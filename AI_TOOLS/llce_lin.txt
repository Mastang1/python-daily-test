# 项目路径: C:\NXP\S32G_LLCE_1_0_10\eclipse\plugins\Lin_43_LLCE_TS_T40D11M10I10R0\lin_packet
# 打包时间: 当前日期: 2025/12/29 周一 
输入新日期: (年月日)
# 共打包 11 个源文件（已自动排除二进制文件）
#================================================================================

===== 文件 [1/11]: include\Lin_43_LLCE.h =====
/**
*   @file    Lin_43_LLCE.h
*   @implements Lin.h_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Lin_43_LLCE - High level header of LIN driver.
*   @details This file contains declarations of the functions defined by AutoSAR.
*
*   @addtogroup LIN_LLCE
*   @{
*/
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2006-2016 Freescale Semiconductor, Inc.
*   Copyright 2020-2025 NXP
*   All Rights Reserved.
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
*   accordance with the applicable license terms.
*   By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
*   the software, you are agreeing that you have read, and that you agree to comply with and are bound
*   by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
*   may not retain, install, activate or otherwise use the software.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/

#ifndef LIN_43_LLCE_H
#define LIN_43_LLCE_H

#ifdef __cplusplus
extern "C"
{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

#include "ComStackTypes.h"
#include "Lin_GeneralTypes.h"
#include "Lin_43_LLCE_Cfg.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

#define LIN_43_LLCE_VENDOR_ID                      43
#if ((LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) || (LIN_43_LLCE_VERSION_INFO_API == STD_ON))
#define LIN_43_LLCE_MODULE_ID                      82
#endif  /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
#define LIN_43_LLCE_AR_RELEASE_MAJOR_VERSION       4
#define LIN_43_LLCE_AR_RELEASE_MINOR_VERSION       4
#define LIN_43_LLCE_AR_RELEASE_REVISION_VERSION    0
#define LIN_43_LLCE_SW_MAJOR_VERSION               1
#define LIN_43_LLCE_SW_MINOR_VERSION               0
#define LIN_43_LLCE_SW_PATCH_VERSION               10
/*==================================================================================================
                                      FILE VERSION CHECKS
==================================================================================================*/
/* Check if current file and Lin_Cfg header file are of the same Autosar version */
#if (LIN_43_LLCE_VENDOR_ID != LIN_43_LLCE_CFG_VENDOR_ID)
    #error "Lin_43_LLCE.h and Lin_43_LLCE_Cfg.h have different vendor ids"
#endif
#if ((LIN_43_LLCE_AR_RELEASE_MAJOR_VERSION    != LIN_43_LLCE_CFG_AR_RELEASE_MAJOR_VERSION) || \
     (LIN_43_LLCE_AR_RELEASE_MINOR_VERSION    != LIN_43_LLCE_CFG_AR_RELEASE_MINOR_VERSION) || \
     (LIN_43_LLCE_AR_RELEASE_REVISION_VERSION != LIN_43_LLCE_CFG_AR_RELEASE_REVISION_VERSION) \
    )
    #error "AutoSar Version Numbers of Lin_43_LLCE.h and Lin_43_LLCE_Cfg.h are different"
#endif
/* Check if current file and Lin_Cfg header file are of the same Software version */
#if ((LIN_43_LLCE_SW_MAJOR_VERSION != LIN_43_LLCE_CFG_SW_MAJOR_VERSION) || \
     (LIN_43_LLCE_SW_MINOR_VERSION != LIN_43_LLCE_CFG_SW_MINOR_VERSION) || \
     (LIN_43_LLCE_SW_PATCH_VERSION != LIN_43_LLCE_CFG_SW_PATCH_VERSION) \
    )
#error "Software Version Numbers of Lin_43_LLCE.h and Lin_43_LLCE_Cfg.h are different"
#endif

#ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
    /* Check if current file and ComStack_Types header file are of the same Autosar version */
    #if ((LIN_43_LLCE_AR_RELEASE_MAJOR_VERSION != COMTYPE_AR_RELEASE_MAJOR_VERSION) || \
         (LIN_43_LLCE_AR_RELEASE_MINOR_VERSION != COMTYPE_AR_RELEASE_MINOR_VERSION) \
        )
        #error "AutoSar Version Numbers of Lin_43_LLCE.h and ComStackTypes.h are different"
    #endif

    /* Check if current file and Mcal.h header file are of the same Autosar version */
    #if ((LIN_43_LLCE_AR_RELEASE_MAJOR_VERSION != MCAL_AR_RELEASE_MAJOR_VERSION) || \
         (LIN_43_LLCE_AR_RELEASE_MINOR_VERSION != MCAL_AR_RELEASE_MINOR_VERSION) \
        )
        #error "AutoSar Version Numbers of Lin_43_LLCE.h and Mcal.h are different"
    #endif
#endif /* DISABLE_MCAL_INTERMODULE_ASR_CHECK */
/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
/**
* @brief            API service used without module initialization
* @details          The LIN Driver module shall report the development error "LIN_43_LLCE_E_UNINIT (0x00)",
*                   when the API Service is used without module initialization.
*
*/
#define LIN_43_LLCE_E_UNINIT            ((uint8)0x00U)

/**
* @brief            API service used with an invalid or inactive channel parameter
* @details          The LIN Driver module shall report the development error
*                   "LIN_43_LLCE_E_INVALID_CHANNEL (0x02)", when API Service used with
*                   an invalid or inactive channel parameter.
*
*/
#define LIN_43_LLCE_E_INVALID_CHANNEL   ((uint8)0x02U)

/**
* @brief            API service called with invalid configuration pointer
* @details          The LIN Driver module shall report the development error
*                   "LIN_43_LLCE_E_INVALID_POINTER (0x03)", when API Service is called
*                   with invalid configuration pointer.
*
*/
#define LIN_43_LLCE_E_INVALID_POINTER   ((uint8)0x03U)

/**
* @brief            Invalid state transition for the current state
* @details          The LIN Driver module shall report the development error
*                   "LIN_43_LLCE_E_STATE_TRANSITION (0x04)", when Invalid state transition
*                   occurs from the current state.
*
*/
#define LIN_43_LLCE_E_STATE_TRANSITION  ((uint8)0x04U)

/**
* @brief            API service called with a NULL pointer
* @details          The LIN Driver module shall report the development error
*                   "LIN_43_LLCE_E_PARAM_POINTER (0x05)", when API Service is called
*                   with a NULL pointer. In case of this error, the API service
*                   shall return immediately without any further action,
*                   beside reporting this development error.
*
*/
#define LIN_43_LLCE_E_PARAM_POINTER  ((uint8)0x05U)


/**
* @brief            Timeout caused by hardware error
* @details          The LIN Driver module shall report the development error
*                   "LIN_43_LLCE_E_TIMEOUT (0x06)", when the error "Timeout caused by hardware error"
*                   has occurred and the reference LinDemEventParameterRefs/LIN_E_TIMEOUT is
*                   not configured.
*
*/
#define LIN_43_LLCE_E_TIMEOUT       ((uint8)0x06U)
#endif  /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

/**
* @brief            LIN driver states
* @details          The state LIN_43_LLCE_UNINIT means that the Lin module has not
*                   been initialized yet and cannot be used.
*
*/
#define LIN_43_LLCE_UNINIT              (0x01U)

/**
* @brief            LIN driver states
* @details          The LIN_43_LLCE_INIT state indicates that the LIN driver has been
*                   initialized, making each available channel ready for service.
*
*/
#define LIN_43_LLCE_INIT                (0x02U)

/*==================================================================================================
                                       DEFINES AND MACROS
==================================================================================================*/

/*==================================================================================================
                                             ENUMS
==================================================================================================*/
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
/* API functions service IDs.*/

/**
* @brief            API service ID for Lin_43_LLCE_GetStatus() function.
* @details          Parameters used when raising an error or exception.
*
*/
#define LIN_43_LLCE_GETSTATUS_ID            ((uint8)0x08U)

#if (LIN_43_LLCE_VERSION_INFO_API == STD_ON)
/**
* @brief            API service ID for Lin_GetVersionInfo() function.
* @details          Parameters used when raising an error or exception.
*
*/
#define LIN_43_LLCE_GETVERSIONINFO_ID       ((uint8)0x01U)
#endif /* (LIN_43_LLCE_VERSION_INFO_API == STD_ON) */

/**
* @brief            API service ID for Lin_43_LLCE_GoToSleep() function.
* @details          Parameters used when raising an error or exception.
*
*/
#define LIN_43_LLCE_GOTOSLEEP_ID            ((uint8)0x06U)
/**
* @brief            API service ID for Lin_43_LLCE_GoToSleepInternal() function.
* @details          Parameters used when raising an error or exception.
*
*/
#define LIN_43_LLCE_GOTOSLEEPINTERNAL_ID    ((uint8)0x09U)
/**
* @brief            API service ID for Lin_43_LLCE_Init() function.
* @details          Parameters used when raising an error or exception.
*
*/
#define LIN_43_LLCE_INIT_ID                 ((uint8)0x00U)
/**
* @brief            API service ID for Lin_43_LLCE_SendFrame() function.
* @details          Parameters used when raising an error or exception.
*
*/
#define LIN_43_LLCE_SENDFRAME_ID            ((uint8)0x04U)
/**
* @brief            API service ID for Lin_43_LLCE_WakeUp() function.
* @details          Parameters used when raising an error or exception.
*
*/
#define LIN_43_LLCE_WAKEUP_ID               ((uint8)0x07U)
/**
* @brief            API service ID for Lin_43_LLCE_WakeupInternal() function.
* @details          Parameters used when raising an error or exception.
*
*/
#define LIN_43_LLCE_WAKEUPINTERNAL_ID       ((uint8)0x0BU)
/**
* @brief            API service ID for Lin_43_LLCE_CheckWakeup() function.
* @details          Parameters used when raising an error or exception.
*
*/
#define LIN_43_LLCE_CHECKWAKEUP_ID          ((uint8)0x0AU)
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
                                 GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/
#define LIN_43_LLCE_START_SEC_CONFIG_DATA_UNSPECIFIED
#include "Lin_43_LLCE_MemMap.h"

#if (LIN_43_LLCE_PRECOMPILE_SUPPORT == STD_OFF)
/* Export Post-Build configurations.*/
LIN_43_LLCE_CONFIG_EXT
#endif /* (LIN_43_LLCE_PRECOMPILE_SUPPORT == STD_OFF) */

#define LIN_43_LLCE_STOP_SEC_CONFIG_DATA_UNSPECIFIED
#include "Lin_43_LLCE_MemMap.h"

/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/
#define LIN_43_LLCE_START_SEC_CODE
#include "Lin_43_LLCE_MemMap.h"

/**
* @brief   Validates for upper layers the wake up of LIN channel.
* @details This function identifies if the addressed LIN channel
*          has been woken up by the LIN bus transceiver.
*          This function calls EcuM and LinIf only the first time
*          ater the wake up event.
*
* @retval E_OK         No error has occurred during execution of the API
* @retval E_NOT_OK     An error has occurred during execution of the API
*
* @note    Autosar Service ID: 0x0A.
*
*/
Std_ReturnType  Lin_43_LLCE_CheckWakeup(uint8 Channel);

/**
* @brief   Initializes the LIN module.
* @details This function performs software initialization of LIN
*          driver:
*          - Clears the shadow buffer of all available Lin channels
*          - Set LIN channel state machine of all available Lin
*            channels to LIN_CH_OPERATIONAL
*          - Set frame operation state machine of all available LIN
*            channels to LIN_CH_READY_STATE
*          - Set driver state machine to LIN_43_LLCE_INIT.
*
* @param[in] Config        Pointer to LIN driver configuration set.
*
* @return  void
*
* @note    Autosar Service ID: 0x00.
* @note    Synchronous, non reentrant function.
*
*/
void            Lin_43_LLCE_Init(const Lin_43_LLCE_ConfigType * Config);

#if (LIN_43_LLCE_MASTER_NODE_USED == STD_ON)
    /**
    * @brief   Gets the status of the LIN driver.
    * @details This function returns the state of the current
    *          transmission, reception or operation status.
    *          If the reception of a Slave response was successful then
    *          this service provides a pointer to the buffer where the
    *          data is stored.
    *
    * @param[in] Channel       LIN channel to be checked.
    *
    * @param[out] Lin_SduPtr   Lin_SduPtr pointer to pointer to a shadow
    *                          buffer or memory mapped LIN Hardware
    *                          receive buffer where the current SDU is
    *                          stored.
    * @return                  Lin_StatusType.
    * @retval LIN_NOT_OK       Development or production error raised
    *                          none of the below conditions.
    * @retval LIN_TX_OK        Successful transmission.
    * @retval LIN_TX_BUSY      Ongoing transmission of header or response.
    * @retval LIN_TX_HEADER_ERROR Error occurred during header
    *                          transmission.
    * @retval LIN_TX_ERROR     Error occurred during response
    *                          transmission.
    * @retval LIN_RX_OK        Reception of correct response.
    * @retval LIN_RX_BUSY      Ongoing reception where at least one byte
    *                          has been received.
    * @retval LIN_RX_ERROR     Error occurred during reception.
    * @retval LIN_RX_NO_RESPONSE No data byte has been received yet.
    * @retval LIN_OPERATIONAL  Channel is ready for next header.
    *                          transmission and no data are available.
    * @retval LIN_CH_SLEEP     Channel is in sleep mode.
    *
    * @note    Autosar Service ID: 0x08.
    * @note    Synchronous, non reentrant function.
    *
    */
    Lin_StatusType  Lin_43_LLCE_GetStatus(uint8 Channel, \
                                                  uint8 ** Lin_SduPtr \
                                                 );

    /**
    * @brief   Sends a LIN frame.
    * @details Sends a LIN header and a LIN response, if necessary. The
    *          direction of the frame response (master response, slave
    *          response, slave-to-slave communication) is provided by
    *          the PduInfoPtr.
    *
    * @param[in] Channel       LIN channel to be addressed.
    * @param[in] PduInfoPtr    pointer to PDU containing the PID,
    *                          Checksum model, Response type, Dl and SDU
    *                          data pointer.
    *
    * @return                  Std_ReturnType.
    * @retval E_NOT_OK         If the LIN Channel is not valid or
    *                          LIN driver is not initialized or
    *                          PduInfoPtr is NULL or
    *                          a timeout occurs or
    *                          LIN Channel is in sleep state.
    * @retval E_OK             Otherwise.
    *
    * @note    Autosar Service ID: 0x04.
    * @note    Synchronous, non reentrant function.
    *
    */
    Std_ReturnType  Lin_43_LLCE_SendFrame(uint8 Channel, \
                                                  const Lin_PduType * PduInfoPtr \
                                                 );

    /**
    * @brief   The service instructs the driver to transmit a
    *          go-to-sleep-command on the addressed LIN channel.
    * @details This function stops any ongoing transmission and initiates
    *          the transmission of the sleep command (master command
    *          frame with ID = 0x3C and data = (0x00, 0xFF, 0xFF, 0xFF,
    *          0xFF, 0xFF, 0xFF, 0xFF). State transition in
    *          LIN_CH_SLEEP_STATE shall be done after the completion of
    *          the sleep command transmission regardless of the success
    *          (therefore the ISR is responsible to put the channel in
    *          LIN_CH_SLEEP_STATE).
    *
    * @param[in] Channel       LIN channel to be checked.
    *
    * @return                  Std_ReturnType.
    * @retval E_NOT_OK         If the LIN Channel is not valid or
    *                          LIN driver is not initialized or
    *                          LIN Channel is in sleep state or
    *                          a timeout occurs.
    * @retval E_OK             Otherwise.
    *
    * @note    Autosar Service ID: 0x06.
    * @note    Synchronous, non reentrant function.
    *
    */
    Std_ReturnType  Lin_43_LLCE_GoToSleep(uint8 Channel);
#endif /* #if LIN_43_LLCE_MASTER_NODE_USED == STD_ON */

/**
* @brief   Put a Lin channel in the internal sleep state.
* @details Stops any ongoing transmission, sets the channel
*          state to LIN_CH_SLEEP and put the LIN
*          hardware unit to a reduced power operation mode.
*
* @param[in] Channel       LIN channel to be addressed.
*
* @return                  Std_ReturnType.
* @retval E_NOT_OK         If the LIN Channel is not valid or
*                          LIN driver is not initialized or
*                          LIN Channel is in sleep state or
*                          a timeout occurs.
* @retval E_OK             Otherwise.
*
* @note    Autosar Service ID: 0x09.
* @note    Synchronous, non reentrant function.
*
*/
Std_ReturnType  Lin_43_LLCE_GoToSleepInternal(uint8 Channel);

/**
* @brief   Generates a wake up pulse.
* @details This function shall sent a wake up signal to the LIN bus
*          and put the LIN channel in LIN_CH_OPERATIONAL state.
*
* @param[in] Channel       LIN channel to be addressed.
*
* @return                  Std_ReturnType.
* @retval E_NOT_OK         If the LIN driver is not in sleep state or
*                          LIN Channel is not valid or
*                          LIN driver is not initialized.
* @retval E_OK             Otherwise.
*
* @note    Autosar Service ID: 0x07.
* @note    Synchronous, non reentrant function.
*
*/
Std_ReturnType  Lin_43_LLCE_Wakeup(uint8 Channel);

/**
* @brief   Wake up the LIN channel.
* @details This function shall put the LIN channel in LIN_CH_OPERATIONAL state without sending a
*          wake up signal to the LIN bus
*
* @param[in] Channel       LIN channel to be addressed.
*
* @return                  Std_ReturnType.
* @retval E_NOT_OK         If the LIN driver is not in sleep state or
*                          LIN Channel is not valid or
*                          LIN driver is not initialized.
* @retval E_OK             Otherwise.
*
* @note    Autosar Service ID: 0x0B.
* @note    Asynchronous, non reentrant function.
*
*/
Std_ReturnType Lin_43_LLCE_WakeupInternal(uint8 Channel);

#if LIN_43_LLCE_VERSION_INFO_API == STD_ON
/**
* @brief   Returns the version information of this module.
* @details The version information includes:
*
*          - Two bytes for the Vendor ID
*          - Two bytes for the Module ID
*          - One byte  for the Instance ID
*          - Three bytes version number. The numbering shall be vendor
*            specific: it consists of:
*
*             - The major, the minor and the patch version number of
*               the module;
*             - The AUTOSAR specification version number shall not
*               be included. The AUTOSAR specification version number is
*               checked during compile time and therefore not required
*               in this API.
*
* @param[in,out] versioninfo   Pointer for storing the version information
*                              of this module.
*
* @return                  void.
*
* @pre            Preconditions as text description. Optional tag.
*
* @note    Autosar Service ID: 0x01.
* @note    Synchronous, non reentrant function.
*
*/
void  Lin_43_LLCE_GetVersionInfo(Std_VersionInfoType * versioninfo);
#endif  /* #if LIN_43_LLCE_VERSION_INFO_API == STD_ON */

#define LIN_43_LLCE_STOP_SEC_CODE
#include "Lin_43_LLCE_MemMap.h"

#ifdef __cplusplus
}
#endif

/** @} */

#endif /* LIN_43_LLCE_H */


===== 文件 [2/11]: include\Lin_43_LLCE_IPW.h =====
/**
*   @file    Lin_43_LLCE_IPW.h
*   @version 1.0.10
*
*   @brief   AUTOSAR Lin_43_LLCE - Isolation level header file for LIN driver.
*   @details Header file for function definition on isolation level between high and low level driver.
*
*   @addtogroup LIN_LLCE
*   @{
*/
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2006-2016 Freescale Semiconductor, Inc.
*   Copyright 2020-2025 NXP
*   All Rights Reserved.
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
*   accordance with the applicable license terms.
*   By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
*   the software, you are agreeing that you have read, and that you agree to comply with and are bound
*   by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
*   may not retain, install, activate or otherwise use the software.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/

#ifndef LIN_43_LLCE_IPW_H
#define LIN_43_LLCE_IPW_H

#ifdef __cplusplus
extern "C"
{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Lin_Llce.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

#define LIN_43_LLCE_IPW_VENDOR_ID                    43
#define LIN_43_LLCE_IPW_AR_RELEASE_MAJOR_VERSION     4
#define LIN_43_LLCE_IPW_AR_RELEASE_MINOR_VERSION     4
#define LIN_43_LLCE_IPW_AR_RELEASE_REVISION_VERSION  0
#define LIN_43_LLCE_IPW_SW_MAJOR_VERSION             1
#define LIN_43_LLCE_IPW_SW_MINOR_VERSION             0
#define LIN_43_LLCE_IPW_SW_PATCH_VERSION             10
/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/
/* Check if current file and Lin_Llce header file are of the same vendor */
#if (LIN_43_LLCE_IPW_VENDOR_ID != LIN_LLCE_VENDOR_ID)
    #error "Lin_43_LLCE_IPW.h and Lin_Llce.h have different vendor ids"
#endif
/* Check if current file and Lin_Llce header file are of the same Autosar version */
#if ((LIN_43_LLCE_IPW_AR_RELEASE_MAJOR_VERSION    != LIN_LLCE_AR_RELEASE_MAJOR_VERSION) || \
     (LIN_43_LLCE_IPW_AR_RELEASE_MINOR_VERSION    != LIN_LLCE_AR_RELEASE_MINOR_VERSION) || \
     (LIN_43_LLCE_IPW_AR_RELEASE_REVISION_VERSION != LIN_LLCE_AR_RELEASE_REVISION_VERSION) \
    )
    #error "AutoSar Version Numbers of Lin_43_LLCE_IPW.h and Lin_Llce.h are different"
#endif
/* Check if current file and Lin_Llce header file are of the same Software version */
#if ((LIN_43_LLCE_IPW_SW_MAJOR_VERSION != LIN_LLCE_SW_MAJOR_VERSION) || \
     (LIN_43_LLCE_IPW_SW_MINOR_VERSION != LIN_LLCE_SW_MINOR_VERSION) || \
     (LIN_43_LLCE_IPW_SW_PATCH_VERSION != LIN_LLCE_SW_PATCH_VERSION) \
    )
    #error "Software Version Numbers of Lin_43_LLCE_IPW.h and Lin_Llce.h are different"
#endif

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
                                       DEFINES AND MACROS
==================================================================================================*/
#define    Lin_43_LLCE_Ipw_CheckWakeup(Controller)                  Lin_Llce_CheckWakeup(Controller)
#define    Lin_43_LLCE_Ipw_Init()                                   Lin_Llce_Init()

#if (LIN_43_LLCE_MASTER_NODE_USED == STD_ON)
    #define    Lin_43_LLCE_Ipw_SendFrame(Controller, PduInfo)           Lin_Llce_SendFrame(Controller, PduInfo)
    #define    Lin_43_LLCE_Ipw_GoToSleep(Controller)                    Lin_Llce_GoToSleep(Controller)
    #define    Lin_43_LLCE_Ipw_HardwareGetStatus(Controller, SduPtr)    Lin_Llce_HardwareGetStatus(Controller, SduPtr)
#endif /* #if LIN_43_LLCE_MASTER_NODE_USED == STD_ON */


#define    Lin_43_LLCE_Ipw_GoToSleepInternal(Controller)            Lin_Llce_GoToSleepInternal(Controller)
#define    Lin_43_LLCE_Ipw_WakeUp(Controller)                       Lin_Llce_WakeUp(Controller)
#define    Lin_43_LLCE_Ipw_WakeUpInternal(Controller)               Lin_Llce_WakeupInternal(Controller)

/*==================================================================================================
                                             ENUMS
==================================================================================================*/

/*==================================================================================================
                                 STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
                                 GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/

/*==================================================================================================
                                     FUNCTION PROTOTYPES
==================================================================================================*/

#ifdef __cplusplus
}
#endif

/** @} */

#endif /* LIN_43_LLCE_IPW_H */


===== 文件 [3/11]: include\Lin_Llce.h =====
/**
*   @internal
*   @file    Lin_Llce.h
*   @version 1.0.10
*
*   @brief   AUTOSAR Lin_llce - LLD module interface.
*   @details Low Level Driver header file for IPV = Llce.
*
*   @addtogroup LIN_LLCE
*   @{
*/
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2006-2016 Freescale Semiconductor, Inc.
*   Copyright 2020-2025 NXP
*   All Rights Reserved.
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
*   accordance with the applicable license terms.
*   By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
*   the software, you are agreeing that you have read, and that you agree to comply with and are bound
*   by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
*   may not retain, install, activate or otherwise use the software.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/

#ifndef LIN_LLCE_H
#define LIN_LLCE_H

#ifdef __cplusplus
extern "C"
{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/**
* @file           Lin_Llce.h
*/
#define LIN_LLCE_VENDOR_ID                    43
#define LIN_LLCE_AR_RELEASE_MAJOR_VERSION     4
#define LIN_LLCE_AR_RELEASE_MINOR_VERSION     4
#define LIN_LLCE_AR_RELEASE_REVISION_VERSION  0
#define LIN_LLCE_SW_MAJOR_VERSION             1
#define LIN_LLCE_SW_MINOR_VERSION             0
#define LIN_LLCE_SW_PATCH_VERSION             10
/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
                                       DEFINES AND MACROS
==================================================================================================*/

/*==================================================================================================
                                             ENUMS
==================================================================================================*/

/*==================================================================================================
                                 STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
                                 GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/

#define LIN_43_LLCE_START_SEC_VAR_INIT_UNSPECIFIED
#include "Lin_43_LLCE_MemMap.h"

extern const Lin_43_LLCE_ConfigType * Lin_43_LLCE_pxConfigPtr;

#define LIN_43_LLCE_STOP_SEC_VAR_INIT_UNSPECIFIED
#include "Lin_43_LLCE_MemMap.h"

#define LIN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "Lin_43_LLCE_MemMap.h"

extern const Lin_43_LLCE_ChannelConfigType * Lin_43_LLCE_pChannelConfigPtr[LIN_43_LLCE_HW_MAX_MODULES];

#define LIN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "Lin_43_LLCE_MemMap.h"

#define LIN_43_LLCE_START_SEC_VAR_INIT_8
#include "Lin_43_LLCE_MemMap.h"

/* LIN driver status variable.*/
extern uint8 Lin_u8LinDrvStatus;

#define LIN_43_LLCE_STOP_SEC_VAR_INIT_8
#include "Lin_43_LLCE_MemMap.h"

/*==================================================================================================
                                     FUNCTION PROTOTYPES
==================================================================================================*/
#define LIN_43_LLCE_START_SEC_CODE
#include "Lin_43_LLCE_MemMap.h"

Std_ReturnType Lin_Llce_CheckWakeup(const uint8 u8Channel);
void Lin_Llce_Init(void);

#if (LIN_43_LLCE_MASTER_NODE_USED == STD_ON)
    Lin_StatusType Lin_Llce_HardwareGetStatus(const uint8 u8Channel, uint8 ** pu8LinSduPtr);
    Std_ReturnType Lin_Llce_SendFrame(const uint8 u8Channel, const Lin_PduType * pPduInfoPtr);
    Std_ReturnType Lin_Llce_GoToSleep(const uint8 u8Channel);
#endif /* #if LIN_43_LLCE_MASTER_NODE_USED == STD_ON */

Std_ReturnType Lin_Llce_GoToSleepInternal(const uint8 u8Channel);
Std_ReturnType Lin_Llce_WakeUp(const uint8 u8Channel);
Std_ReturnType Lin_Llce_WakeupInternal(const uint8 u8Channel);

void Lin_Llce_ProcessCmdFromLlce(const uint8 u8HwCtrl);

#define LIN_43_LLCE_STOP_SEC_CODE
#include "Lin_43_LLCE_MemMap.h"

#ifdef __cplusplus
}
#endif

/** @} */

#endif /* LIN_LLCE_H */


===== 文件 [4/11]: include\Llce_FwVersion.h =====
/**
 *   @file    Llce_FwVersion.h
 *
 *   @brief   LLCE Version module data structures and defines
 *   @details This file contains the LLCE Version data structures, defines and
 *            function declarations to specify the version information included
 *            in the binaries.
 *
 *   @addtogroup LLCE_version LLCE firmware version
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_FW_VERSION_H
#define LLCE_FW_VERSION_H

#ifdef __cplusplus
extern "C" {
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
#include "Llce_RegAccess.h"

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/
#define LLCE_VERSION_MAX_LENGTH 50

/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/
/**
 * @brief Firmware version datatype.
 * It contains the versionString which encodes the 
 * firmware image characteristics, such as: build time,
 * target derivative and the versions of each feature
 **/
typedef struct
{
    /** @brief OUTPUT: LLCE FW version string actual length. */
    uint8 stringLength;
    /** @brief OUTPUT: LLCE FW version string. */
    uint8 versionString[LLCE_VERSION_MAX_LENGTH];
} LLCE__ALIGNED__PACKED Llce_Fw_VersionType;

/*==================================================================================================
 *                                GLOBAL VARIABLE DECLARATIONS
 ==================================================================================================*/

#ifdef __cplusplus
}
#endif

#endif /* LLCE_FW_VERSION_H*/

/** @} */


===== 文件 [5/11]: include\Llce_InterfaceCore2Core.h =====
/**
 *   @file    Llce_InterfaceCore2Core.h
 *
 *   @brief   This file contains defines used for accessing LLCE core2core hw
 *            module
 *   @details This file contains defines used for accessing LLCE core2core hw
 *            module
 *
 *   @addtogroup LLCE_CAN_firmware_interface LLCE CAN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_INTERFACECORE2CORE_H
#define LLCE_INTERFACECORE2CORE_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __DOXYGEN__
/**
 * @page misra_violations MISRA-C:2012 violations
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 4.9, A function should be used in
 * preference to a function-like macro where they are interchangeable. Function
 * like macro are used to reduce code complexity
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 2.5, A project should not contain unused
 * macro declarations Some macros are used either in FW or driver, or provided
 * as API
 *
 */
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
#include "Llce_RegAccess.h"

/*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/
/*==================================================================================================
                  CORE2CORE COMMON DEFINES AND ADDRESS CALCULATION
 MACROS DTE=C0, RXPPE=C1, TXPPE=C2, FR=C3
 =================================================================================================*/
 /** @brief Base address for the CORE2CORE module. */
#define LLCE_CORE2CORE_BASEADDR ((uint32)0x43C26000UL)

#define LLCE_CORE2CORE_HINTC0R ((uint32)LLCE_CORE2CORE_BASEADDR)
#define LLCE_CORE2CORE_HINTC1R ((uint32)LLCE_CORE2CORE_BASEADDR + 0x04U)
#define LLCE_CORE2CORE_HINTC2R ((uint32)LLCE_CORE2CORE_BASEADDR + 0x08U)
#define LLCE_CORE2CORE_HINTC3R ((uint32)LLCE_CORE2CORE_BASEADDR + 0x0CU)

#define LLCE_CORE2CORE_C0INTHR ((uint32)LLCE_CORE2CORE_BASEADDR + 0x20U)
#define LLCE_CORE2CORE_C1INTHR ((uint32)LLCE_CORE2CORE_BASEADDR + 0x24U)
#define LLCE_CORE2CORE_C2INTHR ((uint32)LLCE_CORE2CORE_BASEADDR + 0x28U)
#define LLCE_CORE2CORE_C3INTHR ((uint32)LLCE_CORE2CORE_BASEADDR + 0x2CU)

#define LLCE_CORE2CORE_C0INTCR ((uint32)LLCE_CORE2CORE_BASEADDR + 0x40U)
#define LLCE_CORE2CORE_C1INTCR ((uint32)LLCE_CORE2CORE_BASEADDR + 0x44U)
#define LLCE_CORE2CORE_C2INTCR ((uint32)LLCE_CORE2CORE_BASEADDR + 0x48U)
#define LLCE_CORE2CORE_C3INTCR ((uint32)LLCE_CORE2CORE_BASEADDR + 0x4CU)

#define LLCE_CORE2CORE_HINTC0ER ((uint32)LLCE_CORE2CORE_BASEADDR + 0x60U)
#define LLCE_CORE2CORE_HINTC1ER ((uint32)LLCE_CORE2CORE_BASEADDR + 0x64U)
#define LLCE_CORE2CORE_HINTC2ER ((uint32)LLCE_CORE2CORE_BASEADDR + 0x68U)
#define LLCE_CORE2CORE_HINTC3ER ((uint32)LLCE_CORE2CORE_BASEADDR + 0x6CU)

#define LLCE_CORE2CORE_C0INTHER ((uint32)LLCE_CORE2CORE_BASEADDR + 0x80U)
#define LLCE_CORE2CORE_C1INTHER ((uint32)LLCE_CORE2CORE_BASEADDR + 0x84U)
#define LLCE_CORE2CORE_C2INTHER ((uint32)LLCE_CORE2CORE_BASEADDR + 0x88U)
#define LLCE_CORE2CORE_C3INTHER ((uint32)LLCE_CORE2CORE_BASEADDR + 0x8CU)

#define LLCE_CORE2CORE_C0INTCER ((uint32)LLCE_CORE2CORE_BASEADDR + 0xA0U)
#define LLCE_CORE2CORE_C1INTCER ((uint32)LLCE_CORE2CORE_BASEADDR + 0xA4U)
#define LLCE_CORE2CORE_C2INTCER ((uint32)LLCE_CORE2CORE_BASEADDR + 0xA8U)
#define LLCE_CORE2CORE_C3INTCER ((uint32)LLCE_CORE2CORE_BASEADDR + 0xACU)

#define LLCE_CORE2CORE_C1INTHR_RXLUT_FLAG     ((uint32)0x01U)
#define LLCE_CORE2CORE_HINTC1R_RXLUT_FLAG     ((uint32)0x04U) 

#define LLCE_CORE2DTE_ASSERT_INTERRUPT(u8HwCtrl)                               \
    Reg_Bit_Set32(LLCE_CORE2CORE_C0INTCR,                                      \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2DTE_GET_STATUS_INTERRUPT(u8HwCtrl)                           \
    (Reg_Read32(LLCE_CORE2CORE_C0INTCR) &                                      \
     (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2DTE_CLEAR_INTERRUPT(u8HwCtrl)                                \
    Reg_Write32(LLCE_CORE2CORE_C0INTCR, (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2DTE_ENABLE_INTERRUPT(u8HwCtrl)                               \
    Reg_Bit_Set32(LLCE_CORE2CORE_C0INTCER,                                     \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2DTE_DISABLE_INTERRUPT(u8HwCtrl)                              \
    Reg_Bit_Clear32(LLCE_CORE2CORE_C0INTCER,                                   \
                    (((uint32)0x01U) << ((uint32)u8HwCtrl)))


#define LLCE_CORE2RX_ASSERT_INTERRUPT(u8HwCtrl)                                \
    Reg_Bit_Set32(LLCE_CORE2CORE_C1INTCR,                                      \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2RX_GET_STATUS_INTERRUPT(u8HwCtrl)                            \
    (Reg_Read32(LLCE_CORE2CORE_C1INTCR) &                                      \
     (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2RX_CLEAR_INTERRUPT(u8HwCtrl)                                 \
    Reg_Write32(LLCE_CORE2CORE_C1INTCR, (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2RX_ENABLE_INTERRUPT(u8HwCtrl)                                \
    Reg_Bit_Set32(LLCE_CORE2CORE_C1INTCER,                                     \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2RX_DISABLE_INTERRUPT(u8HwCtrl)                               \
    Reg_Bit_Clear32(LLCE_CORE2CORE_C1INTCER,                                   \
                    (((uint32)0x01U) << ((uint32)u8HwCtrl)))

#define LLCE_CORE2TX_ASSERT_INTERRUPT(u8HwCtrl)                                \
    Reg_Bit_Set32(LLCE_CORE2CORE_C2INTCR,                                      \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2TX_GET_STATUS_INTERRUPT(u8HwCtrl)                            \
    (Reg_Read32(LLCE_CORE2CORE_C2INTCR) &                                      \
     (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2TX_CLEAR_INTERRUPT(u8HwCtrl)                                 \
    Reg_Write32(LLCE_CORE2CORE_C2INTCR, (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2TX_ENABLE_INTERRUPT(u8HwCtrl)                                \
    Reg_Bit_Set32(LLCE_CORE2CORE_C2INTCER,                                     \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2TX_DISABLE_INTERRUPT(u8HwCtrl)                               \
    Reg_Bit_Clear32(LLCE_CORE2CORE_C2INTCER,                                   \
                    (((uint32)0x01U) << ((uint32)u8HwCtrl)))

#define LLCE_CORE2FRPE_ASSERT_INTERRUPT(u8HwCtrl)                              \
    Reg_Bit_Set32(LLCE_CORE2CORE_C3INTCR,                                      \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2FRPE_GET_STATUS_INTERRUPT(u8HwCtrl)                          \
    (Reg_Read32(LLCE_CORE2CORE_C3INTCR) &                                      \
     (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2FRPE_CLEAR_INTERRUPT(u8HwCtrl)                               \
    Reg_Write32(LLCE_CORE2CORE_C3INTCR, (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2FRPE_ENABLE_INTERRUPT(u8HwCtrl)                              \
    Reg_Bit_Set32(LLCE_CORE2CORE_C3INTCER,                                     \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2FRPE_DISABLE_INTERRUPT(u8HwCtrl)                             \
    Reg_Bit_Clear32(LLCE_CORE2CORE_C3INTCER,                                   \
                    (((uint32)0x01U) << ((uint32)u8HwCtrl)))

#define LLCE_HOST2RX_ASSERT_INTERRUPT(u8HwCtrl)                                \
    Reg_Bit_Set32(LLCE_CORE2CORE_C1INTHR,                                      \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_HOST2RX_GET_STATUS_INTERRUPT(u8HwCtrl)                            \
    (Reg_Read32(LLCE_CORE2CORE_C1INTHR) &                                      \
     (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_HOST2RX_CLEAR_INTERRUPT(u8HwCtrl)                                 \
    Reg_Write32(LLCE_CORE2CORE_C1INTHR, (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_HOST2RX_ENABLE_INTERRUPT(u8HwCtrl)                                \
    Reg_Bit_Set32(LLCE_CORE2CORE_C1INTHER,                                     \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_HOST2RX_DISABLE_INTERRUPT(u8HwCtrl)                               \
    Reg_Bit_Clear32(LLCE_CORE2CORE_C1INTHER,                                   \
                    (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_RX2HOST_ASSERT_INTERRUPT(u8HwCtrl)                                \
    Reg_Bit_Set32(LLCE_CORE2CORE_HINTC1R,                                      \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_RX2HOST_GET_STATUS_INTERRUPT(u8HwCtrl)                            \
    (Reg_Read32(LLCE_CORE2CORE_HINTC1R) &                                      \
     (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_RX2HOST_CLEAR_INTERRUPT(u8HwCtrl)                                 \
    Reg_Write32(LLCE_CORE2CORE_HINTC1R, (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_RX2HOST_ENABLE_INTERRUPT(u8HwCtrl)                                \
    Reg_Bit_Set32(LLCE_CORE2CORE_HINTC1ER,                                     \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_RX2HOST_DISABLE_INTERRUPT(u8HwCtrl)                               \
    Reg_Bit_Clear32(LLCE_CORE2CORE_HINTC1ER,                                   \
                    (((uint32)0x01U) << ((uint32)u8HwCtrl)))

#define LLCE_HOST2TX_ASSERT_INTERRUPT(u8HwCtrl)                                \
    Reg_Bit_Set32(LLCE_CORE2CORE_C2INTHR,                                      \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_HOST2TX_GET_STATUS_INTERRUPT(u8HwCtrl)                            \
    (Reg_Read32(LLCE_CORE2CORE_C2INTHR) &                                      \
     (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_HOST2TX_CLEAR_INTERRUPT(u8HwCtrl)                                 \
    Reg_Write32(LLCE_CORE2CORE_C2INTHR, (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_HOST2TX_ENABLE_INTERRUPT(u8HwCtrl)                                \
    Reg_Bit_Set32(LLCE_CORE2CORE_C2INTHER,                                     \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_HOST2TX_DISABLE_INTERRUPT(u8HwCtrl)                               \
    Reg_Bit_Clear32(LLCE_CORE2CORE_C2INTHER,                                   \
                    (((uint32)0x01U) << ((uint32)u8HwCtrl)))

#define LLCE_TX2HOST_ASSERT_INTERRUPT(u8HwCtrl)                                \
    Reg_Bit_Set32(LLCE_CORE2CORE_HINTC2R,                                      \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_TX2HOST_GET_STATUS_INTERRUPT(u8HwCtrl)                            \
    (Reg_Read32(LLCE_CORE2CORE_HINTC2R) &                                      \
     (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_TX2HOST_CLEAR_INTERRUPT(u8HwCtrl)                                 \
    Reg_Write32(LLCE_CORE2CORE_HINTC2R, (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_TX2HOST_ENABLE_INTERRUPT(u8HwCtrl)                                \
    Reg_Bit_Set32(LLCE_CORE2CORE_HINTC2ER,                                     \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_TX2HOST_DISABLE_INTERRUPT(u8HwCtrl)                               \
    Reg_Bit_Clear32(LLCE_CORE2CORE_HINTC2ER,                                   \
                    (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_TX2HOST_GET_ENABLE_STATUS_INTERRUPT(u8HwCtrl)                     \
    (Reg_Read32(LLCE_CORE2CORE_HINTC2ER) &                                     \
     (((uint32)0x01U) << ((uint32)u8HwCtrl)))

#define LLCE_HOST2FRPE_ASSERT_INTERRUPT(u8HwCtrl)                              \
    Reg_Bit_Set32(LLCE_CORE2CORE_C3INTHR,                                      \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_HOST2FRPE_GET_STATUS_INTERRUPT(u8HwCtrl)                          \
    (Reg_Read32(LLCE_CORE2CORE_C3INTHR) &                                      \
     (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_HOST2FRPE_CLEAR_INTERRUPT(u8HwCtrl)                               \
    Reg_Write32(LLCE_CORE2CORE_C3INTHR, (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_HOST2FRPE_ENABLE_INTERRUPT(u8HwCtrl)                              \
    Reg_Bit_Set32(LLCE_CORE2CORE_C3INTHER,                                     \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_HOST2FRPE_DISABLE_INTERRUPT(u8HwCtrl)                             \
    Reg_Bit_Clear32(LLCE_CORE2CORE_C3INTHER,                                   \
                    (((uint32)0x01U) << ((uint32)u8HwCtrl)))

#define LLCE_FRPE2HOST_ASSERT_INTERRUPT(u8HwCtrl)                              \
    Reg_Bit_Set32(LLCE_CORE2CORE_HINTC3R,                                      \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_FRPE2HOST_GET_STATUS_INTERRUPT(u8HwCtrl)                          \
    (Reg_Read32(LLCE_CORE2CORE_HINTC3R) &                                      \
     (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_FRPE2HOST_CLEAR_INTERRUPT(u8HwCtrl)                               \
    Reg_Write32(LLCE_CORE2CORE_HINTC3R, (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_FRPE2HOST_ENABLE_INTERRUPT(u8HwCtrl)                              \
    Reg_Bit_Set32(LLCE_CORE2CORE_HINTC3ER,                                     \
                  (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_FRPE2HOST_DISABLE_INTERRUPT(u8HwCtrl)                             \
    Reg_Bit_Clear32(LLCE_CORE2CORE_HINTC3ER,                                   \
                    (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_FRPE2HOST_GET_ENABLE_STATUS_INTERRUPT(u8HwCtrl)                   \
    (Reg_Read32(LLCE_CORE2CORE_HINTC3ER) &                                     \
     (((uint32)0x01U) << ((uint32)u8HwCtrl)))

#define LLCE_CORE2CORE_ASSERT_INTERRUPT(u32BaseAddr, u8HwCtrl)                 \
    Reg_Bit_Set32(u32BaseAddr, (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2CORE_GET_STATUS_INTERRUPT(u32BaseAddr, u8HwCtrl)             \
    (Reg_Read32(u32BaseAddr) & (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2CORE_CLEAR_INTERRUPT(u32BaseAddr, u8HwCtrl)                  \
    Reg_Write32(u32BaseAddr, (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2CORE_ENABLE_INTERRUPT(u32BaseAddr, u8HwCtrl)                 \
    Reg_Bit_Set32(u32BaseAddr, (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2CORE_DISABLE_INTERRUPT(u32BaseAddr, u8HwCtrl)                \
    Reg_Bit_Clear32(u32BaseAddr, (((uint32)0x01U) << ((uint32)u8HwCtrl)))
#define LLCE_CORE2CORE_GET_ENABLE_STATUS_INTERRUPT(u32BaseAddr, u8HwCtrl)      \
    (Reg_Read32(u32BaseAddr) & (((uint32)0x01U) << ((uint32)u8HwCtrl)))

/*==================================================================================================
 *                                      Interrupts
 ==================================================================================================*/

/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/*==================================================================================================
 *                                STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/

/*==================================================================================================
 *                                GLOBAL VARIABLE DECLARATIONS
 ==================================================================================================*/

/*==================================================================================================
 *                                    FUNCTION PROTOTYPES
 ==================================================================================================*/

#ifdef __cplusplus
}
#endif

#endif /* LLCE_INTERFACECORE2CORE_H */

/** @} */


===== 文件 [6/11]: include\Llce_InterfaceFwMgr.h =====
/**
 *   @file    Llce_InterfaceFwMgr.h
 *
 *   @brief   LLCE defines used to configure the LLCE firmware and interface
 *   @details LLCE defines used to configure the LLCE firmware and interface.
 *            Those configuration parameters are used both by LLCE firmware and
 *            host software.
 *
 *   @addtogroup Llce_configuration LLCE precompile configuration parameters
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_INTERFACEFWMGR_H
#define LLCE_INTERFACEFWMGR_H

#ifdef __cplusplus
extern "C" {
#endif

/**
* @page misra_violations MISRA-C:2012 violations
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.1, Identifiers (internal and external) shall not rely
* on the significance of more than 31 characters.
* The used compilers use more than 31 chars for identifiers.
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.4, Macro identifiers shall be distinct.
* This violation is due to the AUTOSAR requirement [SWS_BSW_00036] (perform inter module checks).
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.2, Identifiers declared in the same scope and name space shall be distinct.
* This rule does not apply if either identifier is a macro identifier, because this case is covered
* by Rule 5.4 and Rule 5.5.
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.5, Identifiers shall be distinct from macro names.
* The identifier clash is between macro identifiers. Therefore, this rule is incorrectly reported by the tool.
*
* @section Llce_InterfaceFwMgr_h_REF_1
* Violates MISRA 2012 Required Rule 21.1, #define and #undef shall not be used on a reserved identifier or
* reserved macro name.
* Certain keywords are not recognized by tools such as PC-LINT and LDRA.
*
* @section Llce_InterfaceFwMgr_h_REF_2
* Violates MISRA 2012 Advisory Rule 4.9, A function should be used in
* preference to a function-like macro where they are interchangeable. Function
* like macro are used to reduce code complexity
*
* @section Llce_InterfaceFwMgr_h_REF_3
* Violates MISRA 2012 Advisory Rule 2.3, A project should not contain unused type declarations.
* False detection by lint tool.
*
*/

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/


#include "Llce_RegAccess.h"

#ifdef CHECK_ABI_COMPATIBILITY
#pragma ABICHECK start
#endif
#include "Llce_FwVersion.h"

/*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/

/*==================================================================================================
 *                                      Interrupts
 ==================================================================================================*/

/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/**
 * @brief CAN firmware notification categories.
 * @details Contains the notification categories of the values returned by the LLCE Firmware.
 * @see Llce_Fw_ReturnType
 **/
typedef enum LLCE__PACKED
{
    LLCE_NOTIFCAT_CAN_PROTOCOL = 1U,
    LLCE_NOTIFCAT_DATA_LOST,
    LLCE_NOTIFCAT_CONFIGURATION,
    LLCE_NOTIFCAT_INTERNAL,
    LLCE_NOTIFCAT_BUSOFF,
    LLCE_NOTIFCAT_FW_STATUS,
    LLCE_NOTIFCAT_CAN_PROTOCOL_CRITICAL_STATE

} Llce_Fw_Notification_Category;

/**
 * @brief CAN firmware error values.
 *
 * CAN error values as they are reported by the LLCE firmware. Some of them are
 * channel related and other are platform related.
 **/
typedef enum LLCE__PACKED
{
    /** @brief CAN firmware error: BOTH SW AND HW TXACK FIFOS are full. */
    LLCE_ERROR_TXACK_FIFO_FULL = 1U,
    /** @brief CAN firmware error: RXOUT SW FIFO is full. */
    LLCE_ERROR_RXOUT_FIFO_FULL,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_0,
    /** @brief CAN firmware error: The system lost indexes or HW FIFO was not cleared and it is full. */
    LLCE_ERROR_HW_FIFO_FULL,
    /** @brief CAN firmware error: There was an attempt to perform a pop operation on an empty SW FIFO. */
    LLCE_ERROR_SW_FIFO_EMPTY,
    /** @brief CAN firmware error: There was an attempt to perform a push operation on a full SW FIFO.*/
    LLCE_ERROR_SW_FIFO_FULL,
    /** @brief CAN firmware error: The maximum hardware object count on the reception side was reached. */
    LLCE_ERROR_MB_NOTAVAILABLE,
    /** @brief CAN firmware error: Short Message buffer is configured but a long frame is received. */
    LLCE_ERROR_SHORT_MB_NOTAVAILABLE,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_BCAN_FRZ_EXIT,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_BCAN_SYNC,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_BCAN_FRZ_ENTER,
    /**
     * @brief CAN firmware error: CAN protocol error due to inability to
     * enter in low-power mode.
     */
    LLCE_ERROR_BCAN_LPM_EXIT,
    /**
     * @brief CAN firmware error: CAN protocol error due to inability to
     * enter in soft reset.
     */
    LLCE_ERROR_BCAN_SRT_ENTER,
    /**
     * @brief CAN firmware error: An error callback was called, but no error code matches : unknown CAN protocol error 
     */
    LLCE_ERROR_BCAN_UNKNOWN_ERROR,
    /**
     * @brief CAN firmware error: ACKERR indicates that an acknowledge error
     * has been detected by the transmitter node.
     */
    LLCE_ERROR_BCAN_ACKERR,
    /**
     * @brief CAN firmware error: CRCERR indicates that a CRC error has been
     * detected by the receiver node in a CAN frame.
     */
    LLCE_ERROR_BCAN_CRCERR,
    /**
     * @brief CAN firmware error: BIT0ERR indicates when an inconsistency
     * occurs between the transmitted and the received bit in a CAN frame.
     */
    LLCE_ERROR_BCAN_BIT0ERR,
    /**
     * @brief CAN firmware error: BIT1ERR indicates when an inconsistency
     * occurs between the transmitted and the received bit in a CAN frame.
     */
    LLCE_ERROR_BCAN_BIT1ERR,
    /**
     * @brief CAN firmware error: DPBIT1ERR indicates when an inconsistency
     * occurs between the transmitted and the received bit in the data phase
     * of a CAN-FD frame.
     */
    LLCE_ERROR_BCAN_DPBIT1ERR,
    /**
     * @brief CAN firmware error: DPBIT0ERR indicates when an inconsistency
     * occurs between the transmitted and the received bit in the data phase
     * of a CAN-FD frame.
     */
    LLCE_ERROR_BCAN_DPBIT0ERR,
    /**
     * @brief CAN firmware error: DPSTFERR indicates that a stuffing error has
     * been detected by the receiver node in the data phase of a CAN-FD frame.
     */
    LLCE_ERROR_BCAN_DPSTFERR,
    /**
     * @brief CAN firmware error: DPFRMERR indicates that a form error has
     * been detected by the receiver node in the data phase of a CAN-FD frame
     * - a fixed-form bit field contains at least one illegal bit.
     */
    LLCE_ERROR_BCAN_DPFRMERR,
    /**
     * @brief CAN firmware error: DPCRCERR indicates that a CRC error has been
     * detected by the receiver node in the data phase of a CAN-FD frame
     */
    LLCE_ERROR_BCAN_DPCRCERR,
    /**
     * @brief CAN firmware error: FRMERR indicates that a form error has
     * been detected by the receiver node in a CAN frame - a fixed-form bit
     * field contains at least one illegal bit.
     */
    LLCE_ERROR_BCAN_FRMERR,
    /**
     * @brief CAN firmware error: STFERR indicates that a stuffing error has
     * been detected by the receiver node in a CAN frame.
     */
    LLCE_ERROR_BCAN_STFERR,
    /**
     * @brief CAN firmware error: TDC mechanism is out of range, 
     * unable to compensate the transceiver's loop delay.
     */
    LLCE_ERROR_BCAN_TDCFAIL,
    /**
     * @brief CAN firmware error: DataLost event caused by BCAN RX Fifo
     * Overrun.
     */
    LLCE_ERROR_BCAN_RXFIFO_OVERRUN,
    /**
     * @brief CAN firmware error: Reports data lost event due to resources
     * exceeded after the frame was received
     */
    LLCE_ERROR_DATA_LOST,
    /** @brief CAN firmware error: The number of Message Buffers available for transmission arbitration was exceeded or the status register indicates that the TXLUT accelerator is full. */
    LLCE_ERROR_TXLUT_FULL,
    /** @brief CAN firmware error: A command with an unknown id was issued or the current host tried to overlap the other host's resources at initialization. */
    LLCE_ERROR_CMD_PROCESSING,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_1,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read or write operation on RXLUT registers. */
    LLCE_ERROR_RXLUT_ACCESS_MODE,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read or write operation on RXLUT registers. */
    LLCE_ERROR_RXLUT_SEARCH_MODE,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read on RXLUT registers and no value was obtained within a configured timeout. */
    LLCE_ERROR_RXLUT_SLOW_OPERATION,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read on the RXLUT status register during search operation and no value was obtained within a configured timeout. */
    LLCE_ERROR_RXLUT_INCOMPLETE_OP,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read on the RXLUT status register during flush operation and no value was obtained within a configured timeout. */
    LLCE_ERROR_RXLUT_OPERATING_MODE,
    /** @brief CAN firmware error: Failed to configure the filter entry address and issue write command. */
    LLCE_ERROR_RXLUT_INIT_SLOW_OP,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_2,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_3,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_4,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_5,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_6,
    /** @brief CAN firmware error: Controller is not started or bus-off event has occured. */
    LLCE_ERROR_CTRL_NOT_READY,
    /** @brief CAN firmware error: A bus off event was triggered.
     * This notification is skipped in case of auto-recovery.
     */
    LLCE_ERROR_BUSOFF,
    /** @brief CAN firmware error: Logging FIFO is full. */
    LLCE_ERROR_FIFO_LOG_FULL,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_7,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_8,
    /**
     * @brief CAN firmware error: Error reported due to the rx core not
     * responding.
     */
    LLCE_ERROR_COMMAND_RXPPE_NORESPONSE,
    /**
     * @brief CAN firmware error: Error reported due to frpe core not
     * responding.
     */
    LLCE_ERROR_COMMAND_AF_NORESPONSE,
    /**
     * @brief CAN firmware error: Error reported because the controller is
     * not stopped.
     */
    LLCE_ERROR_COMMAND_DEINIT_NOTSTOP,
    /**
     * @brief CAN firmware error: Error reported because the host didn't
     * read all the RX tokens (indexes in fifos). LLCE waits for indexes
     * to be read and returned.
     */
    LLCE_ERROR_RXTOKENS_UNRETURNED,
    /**
     * @brief CAN firmware error: Error reported because the host didn't
     * read all the ACKs (indexes in fifos). LLCE waits for indexes to be
     * read.
     */
    LLCE_ERROR_TXACK_NOT_READ,
    /**
     * @brief CAN firmware error: Error reported because the requested
     * command is not in the list of supported commands.
     */
    LLCE_ERROR_COMMAND_NOTSUPPORTED,
    /**
     * @brief CAN firmware error: Error reported because command is not
     * validated by the command flow.
     */
    LLCE_ERROR_COMMAND_NOTVALIDATED,
    /**
     * @brief CAN firmware error: Error reported because the requested
     * command is correct but it not accepted.
     */
    LLCE_ERROR_COMMAND_NOTACCEPTED,
    /**
     * @brief CAN firmware error: Error reported because the requested
     * command parameters are invalid.
     */
    LLCE_ERROR_COMMAND_INVALID_PARAMS,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_9,
    /**
     * @brief CAN firmware error: Reports frame accepted, but not delivered
     * to host because of filters misconfiguration.
     */
    LLCE_ERROR_FRAME_NOT_DELIVERED,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_10,
    /**
     * @brief CAN firmware error: Reports frame accepted, but not delivered
     * to host due to lack of descriptors in software FIFO.
     */
    LLCE_ERROR_FRAME_NOT_DELIVERED_TO_HOST,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_12,
    /**
     * @brief CAN firmware error: Error reported because there are no
     * filters available to be set for a specific controller.
     */
    LLCE_ERROR_FILTERS_FULL,
    /**
     * @brief CAN firmware error: The filter pointed by the related address
     * is not used by the related controller.
     */
    LLCE_ERROR_FILTERS_NOTEXIST,
    /** @brief CAN firmware error: There are no free configuration filters.
     */
    LLCE_ERROR_FILTERS_MASK_EMPTY,
    /** @brief CAN firmware error: There are no free configuration filters.
     */
    LLCE_ERROR_FILTERS_RANGE_EMPTY,
    /** @brief CAN firmware error: There are no free exact match filters. */
    LLCE_ERROR_FILTERS_EM_EMPTY,
    /** @brief CAN firmware error: The index returned by host is not valid, possibly a duplicate index. */
    LLCE_ERROR_IDX_NOT_VALID_HOST,
    /** @brief CAN firmware error: The index returned by logging is not valid, the associated destination didn't match.
     */
    LLCE_ERROR_IDX_NOT_VALID_LOG,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_13,
    /**
     * @brief CAN firmware error: Reserved for future use.
     * to HSE because of full FIFO.
     */
    LLCE_ERROR_CODE_RESERVED_14,
    /**
     * @brief CAN firmware error: Tx frame was dropped because MAC generation failed.
     */
    LLCE_ERROR_TXFRAME_MAC_GEN_ERROR,
    /**
     * @brief CAN firmware error: Rx frame was dropped because it is not
     * authentic.
     */
    LLCE_ERROR_RXFRAME_AUTH_ERROR,
    /**
     * @brief CAN firmware error: Reserved for future use.
     * TX core.
     */
    LLCE_ERROR_CODE_RESERVED_16,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_17,
    /** @brief CAN firmware error: RX Software FIFO is empty. */
    LLCE_ERROR_RX_SW_FIFO_EMPTY,
    /** @brief AF error : error communicating with PFE due to PFE internal error*/
    LLCE_ERROR_PFEIF,
    /** @brief AF error : error communicating with HSE due to HSE internal error*/
    LLCE_ERROR_HSEIF,
    /**
     * @brief Generic firmware code: Command was executed successfully by
     * LLCE Firmware.
     */
    LLCE_FW_SUCCESS,
    /**
     * @brief Generic firmware error: During command execution
     * an error condition was detected.
     */
    LLCE_FW_ERROR,
    /**
     * @brief Generic firmware code: Default value of command return
     * status, set by the host before to send it to LLCE firmware.
     */
    LLCE_FW_NOTRUN,
    /**
     * @brief CAN firmware error: Internal Descriptor was not returned
     * to the source.
     */
    LLCE_ERROR_INTERNALDESC_NOT_RETURNED,
    /**
     * @brief CAN firmware error: Internal Descriptor was not delivered
     * to the destination.
     */
    LLCE_ERROR_INTERNALDESC_NOT_DELIVERED,
    /**
     * @brief CAN firmware error: Internal Descriptor is not available because 
     * the internal LLCE software FIFO is empty.
     */
    LLCE_ERROR_INTERNALDESC_NOTAVAIL,
    /**
     * @brief CAN firmware error: Internal Descriptor software FIFO is full.
     */
    LLCE_ERROR_INTERNALDESC_FIFO_FULL,
    /** @brief CAN firmware error: Message Buffer is not available.
     * the internal message buffer software FIFO is empty.
     */
    LLCE_ERROR_MB_NOTAVAIL,
    /** @brief CAN firmware error: Message Buffer software FIFO is full. */
    LLCE_ERROR_MB_FIFO_FULL,
    /**
     * @brief CAN firmware error: Maximum number of Tx MB per controller for
     * AF is reached.
     */
    LLCE_ERROR_NO_MB_AVAILABLE,
    /** @brief CAN firmware error: The source of the request did not match any of the LLCE cores ids. */
    LLCE_ERROR_UNKNOWN_SRC,
    /** @brief CAN firmware error: Unknown destination of the request : it's neither a CAN or ETHERNET channel, nor the host. */
    LLCE_ERROR_UNKNOWN_DEST,
    /** @brief CAN firmware error: Unknown request in intercore communication. */
    LLCE_ERROR_UNKNOWN_REQUEST,
    /** @brief CAN firmware error: Issued for frames with DLC greater than 8 where destination is not FD . */
    LLCE_ERROR_CONVERSION,
    /**
     * @brief CAN firmware error: AbortMB request failed due to no pending
     * transmission that can be aborted.
     */
    LLCE_ERROR_NO_MB_TO_ABORT,
    /**
     * @brief CAN firmware error: Index not recovered from DTE after Stop
     * or busoff event.
     */
    LLCE_ERROR_INDEX_NOT_RECOVERED,
    /** @brief CAN firmware error: The controller did not exit from freeze mode within a conifgured timeout. */
    LLCE_ERROR_RESET_PENDING,
    /** @brief CAN firmware fatal error: core has entered an error state and is not recoverable. */
    LLCE_ERROR_FATAL,
    /** @brief CAN firmware notification: BCAN is ready to leave bus-off
     * state after the automatic recovery procedure
     */
    LLCE_NOTIF_BUSOFF_DONE,
    /** @brief CAN firmware error: TXWRN is set when the Tx error counter ECR[TEC] reached 96. */
    LLCE_ERROR_BCAN_TXWRN,
    /** @brief CAN firmware error: RXWRN is set when the Rx error counter ECR[REC] reached 96. */
    LLCE_ERROR_BCAN_RXWRN,
    /** @brief CAN firmware error: PASSERR is set when BCAN enters Passive state. */
    LLCE_ERROR_BCAN_PASSERR,
    /** @brief CAN firmware notification: BCAN exits Passive state. */
    LLCE_NOTIF_BCAN_EXIT_PASSIVE_STATE,
    /** @brief CAN firmware notification: There was an attempt to perform routing to a disabled destination. */
    LLCE_ERROR_ROUTINGCHANNEL_DISABLED,
    /** @brief CAN firmware notification: Shutdown request received from host. */
    LLCE_SHUTDOWN_REQUESTED,
    /** @brief CAN firmware notification: Core has entered shutdown state. */
    LLCE_SHUTDOWN_ENTERED,
    /** @brief CAN firmware notification: Core has received an unexpected event during shutdown and
     * is halted but awake */
    LLCE_SHUTDOWN_FAILED,
    /** @brief Number of enum elements. It must be kept as the last member of the list. */
    LLCE_FW_RETURNTYPE_COUNT

} Llce_Fw_ReturnType;

/*==================================================================================================
 *                                STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/
/**
 * @brief Boot sequence data type.
 *
 * Data type used to access shared memory area for managing LLCE boot sequence
 **/

typedef struct
{
    /**
     * @brief OUTPUT: Boot Status of TXPPE. This can be NOTRUN, SUCCESS, or
     * a specific ERROR information
     */
    Llce_Fw_ReturnType eTxBootStatus;
    /**
     * @brief OUTPUT: Boot Status of RXPPE. This can be NOTRUN, SUCCESS, or
     * a specific ERROR information
     */
    Llce_Fw_ReturnType eRxBootStatus;
    /**
     * @brief OUTPUT: Boot Status of RXPPE. This can be NOTRUN, SUCCESS, or
     * a specific ERROR information
     */
    Llce_Fw_ReturnType eDteBootStatus;
    /**
     * @brief OUTPUT: Boot Status of RXPPE. This can be NOTRUN, SUCCESS, or
     * a specific ERROR information
     */
    Llce_Fw_ReturnType eFrpeBootStatus;
    /** @brief OUTPUT: LLCE FW version structure. */
    Llce_Fw_VersionType LlceFwVersion;

} LLCE__ALIGNED__PACKED Llce_Mgr_StatusType;

/**
 * @brief Structure for the timestamps of cores 1, 2, and 3
 * 
 * Structure contains the timestamps for the cores 1, 2, and 3 and shall be 
 * read by host in order to verify if a crash, or high delay has occurred or not.
 **/
typedef struct
{
    /** @brief Timestamp for Core 1. */
    uint32 timeStampCore1;
    /** @brief Timestamp for Core 2. */
    uint32 timeStampCore2;
    /** @brief Timestamp for Core 3. */
    uint32 timeStampCore3;
} LLCE__ALIGNED__PACKED Llce_Mgr_TimeStampCoresType;


#ifdef CHECK_ABI_COMPATIBILITY
#pragma ABICHECK stop
#endif
/*==================================================================================================
 *                                GLOBAL VARIABLE DECLARATIONS
 ==================================================================================================*/

/*==================================================================================================
 *                                    FUNCTION PROTOTYPES
 ==================================================================================================*/

 /** @brief   Helper function that returns the category of a value returned by the LLCE FW.
 *   @details Determines the category of a value returned by the LLCE Firmware.
 *            It can take as input errors, notifications and status values (see Llce_Fw_ReturnType).
 *            It will return the category that value belongs to.
 *   @param[in] eNotificationCode CAN error, notification or status values as they are reported by the LLCE firmware.
 *   @return CAN firmware notification category.
 */
static inline Llce_Fw_Notification_Category Llce_GetNotificationCategory(Llce_Fw_ReturnType eNotificationCode)
{
    Llce_Fw_Notification_Category eNotifCategory;

    switch(eNotificationCode)
    {
        case LLCE_ERROR_BUSOFF:
        case LLCE_NOTIF_BUSOFF_DONE:
            eNotifCategory = LLCE_NOTIFCAT_BUSOFF;
            break;

        /* Treat all the cases leading to DATA_LOST which should be reported to the host */
        case LLCE_ERROR_RXOUT_FIFO_FULL:
        case LLCE_ERROR_MB_NOTAVAILABLE:
        case LLCE_ERROR_BCAN_RXFIFO_OVERRUN:
            eNotifCategory = LLCE_NOTIFCAT_DATA_LOST;
            break;

        /* Can protocol errors */
        case LLCE_ERROR_BCAN_TDCFAIL:
        case LLCE_ERROR_BCAN_ACKERR:
        case LLCE_ERROR_BCAN_CRCERR:
        case LLCE_ERROR_BCAN_BIT0ERR:
        case LLCE_ERROR_BCAN_BIT1ERR:
        case LLCE_ERROR_BCAN_DPBIT0ERR:
        case LLCE_ERROR_BCAN_DPBIT1ERR:
        case LLCE_ERROR_BCAN_STFERR:
        case LLCE_ERROR_BCAN_FRMERR:
        case LLCE_ERROR_BCAN_DPSTFERR:
        case LLCE_ERROR_BCAN_DPFRMERR:
        case LLCE_ERROR_BCAN_DPCRCERR:
        case LLCE_ERROR_BCAN_UNKNOWN_ERROR:
        case LLCE_ERROR_BCAN_FRZ_EXIT:
        case LLCE_ERROR_BCAN_SYNC:
        case LLCE_ERROR_BCAN_FRZ_ENTER:
        case LLCE_ERROR_BCAN_LPM_EXIT:
        case LLCE_ERROR_BCAN_SRT_ENTER:
        case LLCE_NOTIF_BCAN_EXIT_PASSIVE_STATE:
            eNotifCategory = LLCE_NOTIFCAT_CAN_PROTOCOL;
            break;
        case LLCE_ERROR_BCAN_TXWRN:
        case LLCE_ERROR_BCAN_RXWRN:
        case LLCE_ERROR_BCAN_PASSERR:
            eNotifCategory = LLCE_NOTIFCAT_CAN_PROTOCOL_CRITICAL_STATE;
            break;

        /* Initialization errors. This category contains errors caused by bad usage or a
           malicious host (eg initialization errors, bad cmd parameters, invalid indexes etc). */
        case LLCE_ERROR_COMMAND_NOTSUPPORTED:
        case LLCE_ERROR_COMMAND_NOTACCEPTED:
        case LLCE_ERROR_COMMAND_INVALID_PARAMS:
        case LLCE_ERROR_RXTOKENS_UNRETURNED:
        case LLCE_ERROR_FILTERS_NOTEXIST:
        case LLCE_ERROR_FILTERS_FULL:
        case LLCE_ERROR_CMD_PROCESSING:
        case LLCE_ERROR_TXACK_NOT_READ:
        case LLCE_ERROR_COMMAND_DEINIT_NOTSTOP:
            eNotifCategory = LLCE_NOTIFCAT_CONFIGURATION;
            break;

        /* Values that are neither errors nor notifications. */
        case LLCE_FW_SUCCESS:
        case LLCE_FW_ERROR:
        case LLCE_FW_NOTRUN:
            eNotifCategory = LLCE_NOTIFCAT_FW_STATUS;
            break;

        default:
            eNotifCategory = LLCE_NOTIFCAT_INTERNAL;
            break;
    }

    return eNotifCategory;
}


#ifdef __cplusplus
}
#endif

#endif /* LLCE_INTERFACEFWMGR_H */

/** @} */


===== 文件 [7/11]: include\Llce_InterfaceLinTypes.h =====
/**
 *   @file    Llce_InterfaceLinTypes.h
 *
 *   @brief   LLCE data structures used to implement the LLCE interface
 *   @details This file contains data structures used to implement the LLCE
 *            interface
 *
 *   @addtogroup LLCE_LIN_firmware_interface LLCE LIN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_INTERFACELINTYPES_H
#define LLCE_INTERFACELINTYPES_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __DOXYGEN__
/**
 *
 * @page misra_violations MISRA-C:2012 violations
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 2.5, A project should not contain unused
 * macro declarations Some macros are used either in FW or driver, or provided
 * as API
 *
 * @section Llce_InterfaceLinTypes_h_REF_1
 * Violates MISRA 2012 Advisory Rule 4.9, A function should be used in
 * preference to a function-like macro where they are interchangeable. Function
 * like macro are used to reduce code complexity
 *
 */
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
#include "Llce_RegAccess.h"

/*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/

/* LIN defines */
/** @brief Maximum number of hardware LIN controllers usable inside LLCE */
#define LLCE_LIN_MAXCTRL_COUNT              (4U)
/**< @brief   Maximum buffer size used to store the LIN frame payload */
#define LLCE_LIN_CONFIG_PAYLOAD_MAX_SIZE    (8U)                   

/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/**
 * @brief Type of the LIN node.
 *
 * Type of the LIN node. Master or Slave.
 **/
typedef enum LLCE__PACKED
{
    /** @brief This is used for Master node */
    LLCE_LIN_MASTER_NODE = 0x0U,
    /** @brief This is used for Slave node */
    LLCE_LIN_SLAVE_NODE = 0x1U
} Llce_Lin_NodeType;

/**
 * @brief Lin Slave error codes.
 *
 * Lin Slave error codes.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Error in header */
    LLCE_LIN_ERR_HEADER = 0,
    /** @brief Framing error in response */
    LLCE_LIN_ERR_RESP_STOPBIT,
    /** @brief Checksum error */
    LLCE_LIN_ERR_RESP_CHKSUM,
    /** @brief Monitoring error of transmitted data bit in response */
    LLCE_LIN_ERR_RESP_DATABIT,
    /** @brief No response */
    LLCE_LIN_ERR_NO_RESP,
    /** @brief Incomplete response */
    LLCE_LIN_ERR_INC_RESP
} Llce_Lin_SlaveErrorType;

/**
 * @brief Return status codes reported at the end of each command execution.
 *
 * Return status codes reported at the end of each command execution.
 * The meaning of these codes are command dependent.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Default state of the command. */
    LLCE_LIN_NOTRUN = 0x11,
    /** @brief Command was executed successfully. */
    LLCE_LIN_SUCCESS = 0x55,
    /**
     * @brief During command execution it was detected an error
     * condition.
     */
    LLCE_LIN_ERROR = 0x56,
    /** @brief Command was executed, but a timeout was present. */
    LLCE_LIN_ERROR_TIMEOUT = 0x57,
    /** @brief Command was executed, but LIN channel is in wrong state. */
    LLCE_LIN_ERROR_STATE = 0x58,
    /**
     * @brief Command was executed, but LIN channel returned a
     * FALSE response.
     */
    LLCE_LIN_ERROR_FALSE = 0x59
} Llce_Lin_ReturnType;

/**
 * @brief LIN command IDs used to interface with LLCE.
 *
 * Some of these commands are sent by the host to LLCE module and others
 * are sent by LLCE module to the host.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Host initializes LIN channels inside LLCE. */
    LLCE_LIN_CMD_INIT = 0UL,
    /** @brief Host sets LIN channel to sleep state. */
    LLCE_LIN_CMD_GOTOSLEEP,
    /** @brief Host sets LIN channel to internal sleep state. */
    LLCE_LIN_CMD_GOTOSLEEPINTERNAL,
    /** @brief Host sends wakeup command to LIN channel. */
    LLCE_LIN_CMD_WAKEUP,
    /** @brief Host sends internal wakeup command to LIN channel. */
    LLCE_LIN_CMD_WAKEUPINTERNAL,
    /** @brief Host requests the status of LIN channel. */
    LLCE_LIN_CMD_GETSTATUS,
    /** @brief Host sends a frame to a LIN channel. */
    LLCE_LIN_CMD_SENDFRAME,
    /** @brief LLCE notifies host about wakeup event. */
    LLCE_LIN_CMD_WAKEUP_CONFIRMATION,
    /**
     * @brief LLCE notifies host about Reception of a header.
     * Only for Slave nodes.
     */
    LLCE_LIN_CMD_HEADER_INDICATION,
    /**
     * @brief LLCE notifies host about an error occurred.
     * Only for Slave nodes.
     */
    LLCE_LIN_CMD_ERROR_INDICATION,
    /**
     * @brief LLCE notifies host about Reception event.
     * Only for Slave nodes.
     */
    LLCE_LIN_CMD_RX_INDICATION,
    /**
     * @brief LLCE notifies host about Transmission Event.
     * Only for Slave nodes.
     */
    LLCE_LIN_CMD_TX_CONFIRMATION,
    /** @brief Enables interrupt forwarding for all LIN Channels. */
    LLCE_LIN_CMD_ENABLEINTRFORWARD
} Llce_Lin_CommandIdType;

/**
 * @brief Checksum models for the LIN Frame.
 *
 * This type is used to specify the Checksum model to be used
 */
typedef enum LLCE__PACKED
{
    /** @brief Enhanced checksum model.*/
    LLCE_LIN_ENHANCED_CS,
    /** @brief Classic checksum model.*/
    LLCE_LIN_CLASSIC_CS
} Llce_Lin_FrameCsModelType;

/**
 * @brief Frame response types.
 *
 * This type is used to specify whether the frame processor is required to
 * transmit the response part of the LIN frame.
 */
typedef enum LLCE__PACKED
{
    /** @brief Response is generated from this (master) node.*/
    LLCE_LIN_FRAMERESPONSE_TX = 0,
    /** @brief Response is generated from a remote slave node.*/
    LLCE_LIN_FRAMERESPONSE_RX,
    /** @brief Response is generated from one slave to another slave.*/
    LLCE_LIN_FRAMERESPONSE_IGNORE
    /**
     * @brief For the master the response will be anonymous, it does not
     * have to receive the response.
     */
} Llce_Lin_FrameResponseType;

/**
 * @brief LIN Frame and Channel states operation.
 *
 * LIN operation states for a LIN channel or frame
 */

typedef enum LLCE__PACKED
{
    /** @brief Development or production error  occurred.*/
    LLCE_LIN_NOT_OK = 0,
    /** @brief Successful transmission.*/
    LLCE_LIN_TX_OK,
    /** @brief Ongoing transmission (Header or Response).*/
    LLCE_LIN_TX_BUSY,
    /**
     * @brief Erroneous header transmission such as:
     * - Mismatch between sent and read back data
     * - Identifier parity error
     * - Physical bus error.
     */
    LLCE_LIN_TX_HEADER_ERROR,
    /**
     * @brief Erroneous transmission such as:
     * - Mismatch between sent and read back data
     * - Physical bus error.
     */
    LLCE_LIN_TX_ERROR,
    /** @brief Reception of correct response.*/
    LLCE_LIN_RX_OK,
    /**
     * @brief Ongoing reception: at least one response byte has been
     * received, but the checksum byte has not been received.
     */
    LLCE_LIN_RX_BUSY,
    /**
     * @brief Erroneous reception such as:
     * - Framing error
     * - Overrun error
     * - Checksum error
     * - Short response.
     */
    LLCE_LIN_RX_ERROR,
    /**
     * @brief No response byte has been received so far.
     *
     * Frame status is mixed with channel status but it's kept here only
     * because of LIN168.
     */
    LLCE_LIN_RX_NO_RESPONSE,
    /**
     * @brief Normal operation:
     * - The related LIN channel is ready to transmit next header
     * - No data from previous frame available
     *   (e.g. after initialization).
     */
    LLCE_LIN_OPERATIONAL,
    /**
     * @brief Sleep mode operation:
     * - In this mode wake-up detection from slave
     *   nodes is enabled.
     */
    LLCE_LIN_CH_SLEEP,
} Llce_Lin_StatusType;

/*==================================================================================================
 *                                STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/
/**
 * @brief LIN channel configuration type structure.
 *
 * This is the type of the external data structure containing the overall
 * initialization data for one LIN Channel.
 */
typedef struct
{
    /** @brief LIN baud rate value.*/
    uint32 u32LinBaudRateRegValue;
    /** @brief Wakeup enable.*/
    uint8 u8LinChannelWakeupSupport;
    /** @brief Disable frame timeout. */
    uint8 u8LinChannelDisableFrameTimeout;
    /** @brief These bits indicate the Break length in Master mode.*/
    uint8 u8LinChannelBrkLengthMaster;
    /** @brief These bits indicate the Break length in Slave mode.*/
    uint8 u8LinChannelBrkLengthSlave;
    /** @brief Response timeout value LINTOCR[RTO] in bit time.*/
    uint8 u8ResponseTimeout;
    /** @brief Header timeout value LINTOCR[HTO].*/
    uint8 u8HeaderTimeout;
    /** @brief LIN Node Type.*/
    Llce_Lin_NodeType eLinNodeType;
} LLCE__ALIGNED__PACKED Llce_Lin_ChannelConfigType;

/**
 * @brief LIN initialization command.
 *
 * It is sent by the host to LLCE in order to load and configure all
 * needed parameters for the LIN channels inside LLCE.
 **/
typedef struct
{
    /** @brief INPUT: Configuration options for all hardware LIN
     * controllers. */
    Llce_Lin_ChannelConfigType CtrlConfig;
} LLCE__ALIGNED__PACKED Llce_Lin_InitCmdType;

/**
 * @brief Get LIN status command.
 *
 * It is sent by the host to LLCE in order to get the status of a LIN
 * controller.
 **/
typedef struct
{
    /** @brief OUTPUT: LIN channel state. */
    uint8 u8LinChStatus;
    /** @brief OUTPUT: LIN frame state. */
    uint8 u8LinChFrameStatus;
    /** @brief OUTPUT: LIN Frame error status. */
    uint8 u8LinChFrameErrorStatus;
    /** @brief OUTPUT: LIN header command type */
    uint8 Lin_u8TransmitHeaderCommand;
    /** @brief OUTPUT: LIN controller status */
    Llce_Lin_StatusType u8ControllerStatus;
} LLCE__ALIGNED__PACKED Llce_Lin_GetStatusCmdType;

/**
 * @brief LIN sleep/wakeup management commands.
 *
 * It is sent by the host to LLCE in order to manage sleep/wakeup
 * for a specific channel.
 **/
typedef struct
{
    /** @brief INPUT: Wake-up support enabled. */
    uint8 u8LinChannelWakeupSupport;
    /** @brief OUTPUT: LIN channel state. */
    uint8 u8LinChStatus;
} LLCE__ALIGNED__PACKED Llce_Lin_WakeupCmdType;

/**
 * @brief LIN send frame commands.
 *
 * It is sent by the host to LLCE in order to send a frame
 * on a specific channel. This Type is used to provide PID,
 * checksum model, data length and SDU pointer from the LIN Driver
 * to the LIN controllers inside LLCE.
 **/
typedef struct
{
    /** @brief Pointer to Sdu. */
    uint8 Sdu[LLCE_LIN_CONFIG_PAYLOAD_MAX_SIZE];
    /** @brief LIN frame identifier. */
    uint8 Pid;
    /** @brief Data length. */
    uint8 Dl;
    /** @brief Checksum model type. */
    Llce_Lin_FrameCsModelType Cs;
    /** @brief Response type. */
    Llce_Lin_FrameResponseType Drc;
} LLCE__ALIGNED__PACKED Llce_Lin_SendFrameCmdType;

typedef struct
{
    /** @brief LIN frame identifier. */
    uint8 Pid;
    /** @brief Data length. */
    uint8 Dl;
    /** @brief Checksum model type. */
    Llce_Lin_FrameCsModelType Cs;
    /** @brief Response type. */
    Llce_Lin_FrameResponseType Drc;
} LLCE__ALIGNED__PACKED Llce_Lin_HeaderIndicationCmdType;

typedef struct
{
    /** @brief Response type. */
    Llce_Lin_SlaveErrorType eSlaveError;
} LLCE__ALIGNED__PACKED Llce_Lin_ErrorIndicationCmdType;

/**
 * @brief List of commands used by host.
 *
 * It is used in order to use the same memory area for all commands send
 * from host to LLCE.
 **/
union Llce_Lin_CommandListType
{
    /** @brief Init Command. */
    Llce_Lin_InitCmdType Init;
    /** @brief Get Status Command. */
    Llce_Lin_GetStatusCmdType GetStatus;
    /** @brief Wakeup Command. */
    Llce_Lin_WakeupCmdType Wakeup;
    /** @brief Send Frame Command. */
    Llce_Lin_SendFrameCmdType SendFrame;
    /** @brief Header Indication Notification. */
    Llce_Lin_HeaderIndicationCmdType HeaderIndication;
    /** @brief Error Notification. */
    Llce_Lin_ErrorIndicationCmdType ErrorIndication;
};

/**
 * @brief Command used by host.
 *
 * It is used in order to send commands from host to LLCE using shared memory.
 **/
typedef struct
{
    /** @brief INPUT/OUTPUT: Command parameters. */
    union Llce_Lin_CommandListType CmdList;
    /** @brief INPUT: Command ID. */
    Llce_Lin_CommandIdType eCmdId;
    /** @brief OUTPUT: Return status code after command completion.*/
    Llce_Lin_ReturnType eReturnValue;
} LLCE__ALIGNED__PACKED Llce_Lin_CommandType;

/**
 * @brief Shared memory structure
 *
 * Structure that encapsulates all the shared memory with LlCE on the LIN side.
 **/
typedef struct
{
    /**
     * @brief Array used to exchange commands between host and firmware
     * for each LIN channel
     */
    Llce_Lin_CommandType Lin_aCmd[LLCE_LIN_MAXCTRL_COUNT];
    /**
     * @brief Array used to exchange commands between firmware and host
     * for each LIN channel
     */
    Llce_Lin_CommandType Lin_aNotif[LLCE_LIN_MAXCTRL_COUNT];
    /**
     * @brief Reception message buffers located in the shared
     * memory.
     */
    uint8 aLinMb[LLCE_LIN_MAXCTRL_COUNT][LLCE_LIN_CONFIG_PAYLOAD_MAX_SIZE];
} LLCE__ALIGNED__PACKED Llce_Lin_SharedMemoryType;

/*==================================================================================================
 *                                GLOBAL VARIABLE DECLARATIONS
 ==================================================================================================*/

/*==================================================================================================
 *                                    FUNCTION PROTOTYPES
 ==================================================================================================*/

#ifdef __cplusplus
}
#endif

#endif /*LLCE_INTERFACELINTYPES_H*/

/** @} */


===== 文件 [8/11]: include\Llce_RegAccess.h =====
/**
 *   @file    Llce_RegAccess.h
 *
 *   @brief   This file contains functions used for reading and writing
 *            registers
 *   @details This file contains functions used for reading and writing
 *            registers
 *
 *   @addtogroup LLCE_CAN_firmware_interface LLCE CAN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_REGACCESS_H
#define LLCE_REGACCESS_H

#ifdef __cplusplus
extern "C" {
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
/**
 * @file        Llce_RegAccess.h
 * @brief Include platform types
 */
#include "PlatformTypes.h"

/*==================================================================================================
 *                               SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                           CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                       DEFINES AND MACROS
 ==================================================================================================*/
 #if defined(LDRA) || defined(__DOXYGEN__)
     /* Workaround for Doxygen and LDRA tools not to see packed keyword */
      #define LLCE__PACKED
 #else
     #define LLCE__PACKED __attribute__((packed))
 #endif

 #if defined(__DOXYGEN__)
     /* Workaround for Doxygen not to see attribute keyword */
      #define LLCE__ALIGNED__PACKED

     /* Common defines for standard version. Meant to be used by Doxygen*/
     #define S32G2 ON
  
     #define CANETH_ENABLE ON
 
     #define CAN2CAN_ENABLE ON

     #define LIN_ENABLE ON

     #define CANHSE_ENABLE ON

     #define LOGGING_ENABLE ON

     #define AF_ENABLE ON
 #else
     #define LLCE__ALIGNED__PACKED __attribute__((aligned(4), packed))
 #endif
/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/*==================================================================================================
 *                                 STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/

/*==================================================================================================
 *                                 STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/

/*==================================================================================================
 *                                     FUNCTION PROTOTYPES
 ==================================================================================================*/

/**
 * @brief 8 bits memory write function
 */
static inline void Reg_Write8(uint32 address, uint8 value)
{
    *(volatile uint8 *)(address) = value;
}

/**
 * @brief 16 bits memory write function.
 */
static inline void Reg_Write16(uint32 address, uint16 value)
{
    *(volatile uint16 *)(address) = value;
}

/**
 * @brief 32 bits memory write function.
 */
static inline void Reg_Write32(uint32 address, uint32 value)
{
    *(volatile uint32 *)(address) = value;
}

/**
 * @brief 8 bits memory read function.
 */
static inline uint8 Reg_Read8(uint32 address)
{
    return (*(volatile uint8 *)(address));
}

/**
 * @brief 16 bits memory read function.
 */
static inline uint16 Reg_Read16(uint32 address)
{
    return (*(volatile uint16 *)(address));
}

/**
 * @brief 32 bits memory read function.
 */
static inline uint32 Reg_Read32(uint32 address)
{
    return (*(volatile uint32 *)(address));
}

/**
 * @brief 8 bits indexed memory write function.
 * Index i must have the data type uint32.
 */
static inline void Reg_Awrite8(uint32 address, uint32 i, uint8 value)
{
    *(volatile uint8 *)(address + i) = value;
}

/**
 * @brief 16 bits indexed memory write function.
 * Index i must have the data type uint32.
 */
static inline void Reg_Awrite16(uint32 address, uint32 i, uint16 value)
{
    *(volatile uint16 *)(address + i) = value;
}

/**
 * @brief 32 bits indexed memory write function.
 * Index i must have the data type uint32.
 */
static inline void Reg_Awrite32(uint32 address, uint32 i, uint32 value)
{
    *(volatile uint32 *)(address + i) = value;
}

/**
 * @brief 8 bits indexed memory read function.
 * Index i must have the data type uint32.
 */
static inline uint8 Reg_Aread8(uint32 address, uint32 i)
{
    return (*(volatile uint8 *)(address + i));
}

/**
 * @brief 16 bits indexed memory read function.
 * Index i must have the data type uint32.
 */
static inline uint16 Reg_Aread16(uint32 address, uint32 i)
{
    return (*(volatile uint16 *)(address + ((uint32)(i << 1U))));
}

/**
 * @brief 32 bits indexed memory read function.
 * Index i must have the data type uint32.
 */
static inline uint32 Reg_Aread32(uint32 address, uint32 i)
{
    return (*(volatile uint32 *)(address + ((uint32)(i << 2U))));
}

/**
 * @brief 8 bits bits clearing function.
 */
static inline void Reg_Bit_Clear8(uint32 address, uint8 mask)
{
    (*(volatile uint8 *)(address)) &= (~(mask));
}

/**
 * @brief 16 bits bits clearing function.
 */
static inline void Reg_Bit_Clear16(uint32 address, uint16 mask)
{
    (*(volatile uint16 *)(address)) &= (~(mask));
}

/**
 * @brief 32 bits bits clearing function.
 */
static inline void Reg_Bit_Clear32(uint32 address, uint32 mask)
{
    (*(volatile uint32 *)(address)) &= (~(mask));
}

/**
 * @brief 8 bits bits getting function.
 */
static inline uint8 Reg_Bit_Get8(uint32 address, uint8 mask)
{
    return ((*(volatile uint8 *)(address)) & (mask));
}

/**
 * @brief 16 bits bits getting function.
 */
static inline uint16 Reg_Bit_Get16(uint32 address, uint16 mask)
{
    return ((*(volatile uint16 *)(address)) & (mask));
}

/**
 * @brief 32 bits bits getting function.
 */
static inline uint32 Reg_Bit_Get32(uint32 address, uint32 mask)
{
    return ((*(volatile uint32 *)(address)) & (mask));
}

/**
 * @brief 8 bits bits setting function.
 */
static inline void Reg_Bit_Set8(uint32 address, uint8 mask)
{
    *(volatile uint8 *)(address) |= mask;
}

/**
 * @brief 16 bits bits setting function.
 */
static inline void Reg_Bit_Set16(uint32 address, uint16 mask)
{
    *(volatile uint16 *)(address) |= mask;
}

/**
 * @brief 32 bits bits setting function.
 */
static inline void Reg_Bit_Set32(uint32 address, uint32 mask)
{
    *(volatile uint32 *)(address) |= mask;
}

/**
 * @brief 8 bit clear bits and set with new value
 * @note In the current implementation, it is caller's (user's) responsibility
 *       to make sure that value has only "mask" bits set - (value&~mask)==0
 */
static inline void Reg_Rmw8(uint32 address, uint8 mask, uint8 value)
{
    *(volatile uint8 *)(address) =
        (*(volatile uint8 *)(address) & ((uint8) ~(mask))) | value;
}

/**
 * @brief 16 bit clear bits and set with new value
 * @note In the current implementation, it is caller's (user's) responsibility
 *       to make sure that value has only "mask" bits set - (value&~mask)==0
 */
static inline void Reg_Rmw16(uint32 address, uint16 mask, uint16 value)
{
    *(volatile uint16 *)(address) =
        (*(volatile uint16 *)(address) & ((uint16) ~(mask))) | value;
}

/**
 * @brief 32 bit clear bits and set with new value
 * @note In the current implementation, it is caller's (user's) responsibility
 *       to make sure that value has only "mask" bits set - (value&~mask)==0
 */
static inline void Reg_Rmw32(uint32 address, uint32 mask, uint32 value)
{
    *(volatile uint32 *)(address) =
        (*(volatile uint32 *)(address) & ((uint32) ~(mask))) | value;
}

#ifdef __cplusplus
}
#endif

#endif /* #ifndef LLCE_REGACCESS_H */

/** @} */


===== 文件 [9/11]: src\Lin_43_LLCE.c =====
/**
*   @file    Lin.c
*   @implements Lin.c_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Lin_43_LLCE - High level part of LIN driver.
*   @details This file contains the functions defined by AutoSAR.
*
*   @addtogroup LIN_LLCE
*   @{
*/
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2006-2016 Freescale Semiconductor, Inc.
*   Copyright 2020-2025 NXP
*   All Rights Reserved.
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
*   accordance with the applicable license terms.
*   By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
*   the software, you are agreeing that you have read, and that you agree to comply with and are bound
*   by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
*   may not retain, install, activate or otherwise use the software.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/

#ifdef __cplusplus
extern "C"
{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Lin_43_LLCE.h"
#include "Lin_43_LLCE_IPW.h"
#include "EcuM_Externals.h"
#include "LinIf.h"
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
  #include "Det.h"
#endif

#if (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF)
    #include "Dem.h"
#endif
/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
#define LIN_43_LLCE_VENDOR_ID_C                      43
#define LIN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C       4
#define LIN_43_LLCE_AR_RELEASE_MINOR_VERSION_C       4

#define LIN_43_LLCE_AR_RELEASE_REVISION_VERSION_C    0
#define LIN_43_LLCE_SW_MAJOR_VERSION_C               1
#define LIN_43_LLCE_SW_MINOR_VERSION_C               0
#define LIN_43_LLCE_SW_PATCH_VERSION_C               10
/*==================================================================================================
                                      FILE VERSION CHECKS
==================================================================================================*/
/* Check if current file and Lin header file are of the same Autosar version */
#if (LIN_43_LLCE_VENDOR_ID_C != LIN_43_LLCE_VENDOR_ID)
    #error "Lin.c and Lin_43_LLCE.h have different vendor ids"
#endif
#if ((LIN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C    != LIN_43_LLCE_AR_RELEASE_MAJOR_VERSION) || \
     (LIN_43_LLCE_AR_RELEASE_MINOR_VERSION_C    != LIN_43_LLCE_AR_RELEASE_MINOR_VERSION) || \
     (LIN_43_LLCE_AR_RELEASE_REVISION_VERSION_C != LIN_43_LLCE_AR_RELEASE_REVISION_VERSION) \
    )
    #error "AutoSar Version Numbers of Lin.c and Lin_43_LLCE.h are different"
#endif
/* Check if current file and Lin header file are of the same Software version */
#if ((LIN_43_LLCE_SW_MAJOR_VERSION_C != LIN_43_LLCE_SW_MAJOR_VERSION) || \
     (LIN_43_LLCE_SW_MINOR_VERSION_C != LIN_43_LLCE_SW_MINOR_VERSION) || \
     (LIN_43_LLCE_SW_PATCH_VERSION_C != LIN_43_LLCE_SW_PATCH_VERSION) \
    )
    #error "Software Version Numbers of Lin.c and Lin_43_LLCE.h are different"
#endif
/* Check if current file and Lin_IPW header file are of the same Autosar version */
#if (LIN_43_LLCE_VENDOR_ID_C != LIN_43_LLCE_IPW_VENDOR_ID)
    #error "Lin.c and Lin_43_LLCE_IPW.h have different vendor ids"
#endif
#if ((LIN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C    != LIN_43_LLCE_IPW_AR_RELEASE_MAJOR_VERSION) || \
     (LIN_43_LLCE_AR_RELEASE_MINOR_VERSION_C    != LIN_43_LLCE_IPW_AR_RELEASE_MINOR_VERSION) || \
     (LIN_43_LLCE_AR_RELEASE_REVISION_VERSION_C != LIN_43_LLCE_IPW_AR_RELEASE_REVISION_VERSION) \
    )
    #error "AutoSar Version Numbers of Lin.c and Lin_43_LLCE_IPW.h are different"
#endif
/* Check if current file and Lin_IPW header file are of the same Software version */
#if ((LIN_43_LLCE_SW_MAJOR_VERSION_C != LIN_43_LLCE_IPW_SW_MAJOR_VERSION) || \
     (LIN_43_LLCE_SW_MINOR_VERSION_C != LIN_43_LLCE_IPW_SW_MINOR_VERSION) || \
     (LIN_43_LLCE_SW_PATCH_VERSION_C != LIN_43_LLCE_IPW_SW_PATCH_VERSION) \
    )
    #error "Software Version Numbers of Lin.c and Lin_43_LLCE_IPW.h are different"
#endif
#ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
    #if (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF)
        /* Check if the source file and Dem header file are of the same version */
        #if ((LIN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C != DEM_AR_RELEASE_MAJOR_VERSION) || \
             (LIN_43_LLCE_AR_RELEASE_MINOR_VERSION_C != DEM_AR_RELEASE_MINOR_VERSION) \
            )
            #error "AutoSar Version Numbers of Lin.c and Dem.h are different"
        #endif
    #endif

    #if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /* Check if the source file and Det header file are of the same Autosar version */
        #if ((LIN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C != DET_AR_RELEASE_MAJOR_VERSION) || \
             (LIN_43_LLCE_AR_RELEASE_MINOR_VERSION_C != DET_AR_RELEASE_MINOR_VERSION) \
            )
            #error "AutoSar Version Numbers of Lin.c and Det.h are different"
        #endif
    #endif
#endif /* DISABLE_MCAL_INTERMODULE_ASR_CHECK */

/*==================================================================================================
                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/

/*==================================================================================================
                                       LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
                                       LOCAL VARIABLES
==================================================================================================*/

/*==================================================================================================
                                       GLOBAL CONSTANTS
==================================================================================================*/
#define LIN_43_LLCE_START_SEC_CONFIG_DATA_UNSPECIFIED
#include "Lin_43_LLCE_MemMap.h"

#if (LIN_43_LLCE_PRECOMPILE_SUPPORT == STD_ON)
extern const Lin_43_LLCE_ConfigType Lin_43_LLCE_Config;
#endif

#define LIN_43_LLCE_STOP_SEC_CONFIG_DATA_UNSPECIFIED
#include "Lin_43_LLCE_MemMap.h"
/*==================================================================================================
                                       GLOBAL VARIABLES
==================================================================================================*/

#define LIN_43_LLCE_START_SEC_VAR_INIT_UNSPECIFIED
#include "Lin_43_LLCE_MemMap.h"

/**
* @brief          Global configuration pointer.
* @details        Pointer to the configuration structure.
*/
const Lin_43_LLCE_ConfigType * Lin_43_LLCE_pxConfigPtr = NULL_PTR;

#define LIN_43_LLCE_STOP_SEC_VAR_INIT_UNSPECIFIED
#include "Lin_43_LLCE_MemMap.h"

#define LIN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "Lin_43_LLCE_MemMap.h"

/**
* @brief          Global configuration array.
* @details        Array containing channel configurations.
*/
const Lin_43_LLCE_ChannelConfigType * Lin_43_LLCE_pChannelConfigPtr[LIN_43_LLCE_HW_MAX_MODULES];

#define LIN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "Lin_43_LLCE_MemMap.h"

#define LIN_43_LLCE_START_SEC_VAR_INIT_8
#include "Lin_43_LLCE_MemMap.h"

/* LIN driver status variable.*/
uint8 Lin_u8LinDrvStatus = LIN_43_LLCE_UNINIT;

#define LIN_43_LLCE_STOP_SEC_VAR_INIT_8
#include "Lin_43_LLCE_MemMap.h"

/*==================================================================================================
                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/

/*==================================================================================================
                                       LOCAL FUNCTIONS
==================================================================================================*/

/*==================================================================================================
                                       GLOBAL FUNCTIONS
==================================================================================================*/
#define LIN_43_LLCE_START_SEC_CODE
#include "Lin_43_LLCE_MemMap.h"

/**
* @brief   Initializes the LIN module.
* @details This function performs software initialization of LIN
*          driver:
*          - Clears the shadow buffer of all available Lin channels
*          - Set LIN channel state machine of all available Lin
*            channels to LIN_CH_OPERATIONAL
*          - Set frame operation state machine of all available LIN
*            channels to LIN_CH_READY_STATE
*          - Set driver state machine to LIN_43_LLCE_INIT.
*
* @param[in] Config        Pointer to LIN driver configuration set.
*
* @return  void
*
* @note    Autosar Service ID: 0x00.
* @note    Synchronous, non reentrant function.
*
* @implements Lin_Init_Activity
*
*/
void Lin_43_LLCE_Init(const Lin_43_LLCE_ConfigType * Config)
{
    uint8 u8Lin_ChLoop;

    /* Check whether the LIN driver is in LIN_43_LLCE_UNINIT state */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
    if (LIN_43_LLCE_UNINIT != Lin_u8LinDrvStatus)
    {
        /* LIN driver has been already initialized */
        (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                              (uint8)0, \
                              (uint8)LIN_43_LLCE_INIT_ID, \
                              (uint8)LIN_43_LLCE_E_STATE_TRANSITION \
                             );
    }
    else
    {
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
#if (LIN_43_LLCE_PRECOMPILE_SUPPORT != STD_ON)
        /* Check Config for not being a null pointer */
        if (NULL_PTR == Config)
        {
        #if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /* Invalid pointer */
            (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                  (uint8)0, \
                                  (uint8)LIN_43_LLCE_INIT_ID, \
                                  (uint8)LIN_43_LLCE_E_INVALID_POINTER \
                                 );
        #endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        }
        else
        {
            Lin_43_LLCE_pxConfigPtr = Config;
#else /* LIN_43_LLCE_PRECOMPILE_SUPPORT == STD_ON */
        if (NULL_PTR != Config)
        {
        #if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /* Invalid pointer */
            (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                  (uint8)0, \
                                  (uint8)LIN_43_LLCE_INIT_ID, \
                                  (uint8)LIN_43_LLCE_E_INVALID_POINTER \
                                 );
        #endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        }
        else
        {
            Lin_43_LLCE_pxConfigPtr = &Lin_43_LLCE_Config;
#endif /* LIN_43_LLCE_PRECOMPILE_SUPPORT */
            for (u8Lin_ChLoop=(uint8)0U; u8Lin_ChLoop < LIN_43_LLCE_HW_MAX_MODULES; u8Lin_ChLoop++)
            {
                Lin_43_LLCE_pChannelConfigPtr[u8Lin_ChLoop] = Lin_43_LLCE_pxConfigPtr->pLin_Channel[u8Lin_ChLoop];
            }
            Lin_43_LLCE_Ipw_Init();
            /* Update LIN driver status to LIN_43_LLCE_INIT */
            Lin_u8LinDrvStatus = LIN_43_LLCE_INIT;
        }
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
    }
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
    return; /* Exit function with no return */
}

/**
* @brief   Validates for upper layers the wake up of LIN channel.
* @details This function identifies if the addressed LIN channel
*          has been woken up by the LIN bus transceiver.
*          This function calls EcuM and LinIf only the first time
*          ater the wake up event.
*
* @retval E_OK         No error has occurred during execution of the API
* @retval E_NOT_OK     An error has occurred during execution of the API
*
* @note    Autosar Service ID: 0x0A.
*
* @implements Lin_CheckWakeup_Activity
*
*/
Std_ReturnType Lin_43_LLCE_CheckWakeup(uint8 Channel)
{
    Std_ReturnType u8TempReturn = (uint8)E_NOT_OK;

    /* Check whether the LIN driver is in LIN_43_LLCE_INIT state */
    if (LIN_43_LLCE_INIT != Lin_u8LinDrvStatus)
    {
        /* LIN driver has not been initialized yet */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /* Report error to development error tracer */
        (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                              (uint8)0, \
                              (uint8)LIN_43_LLCE_CHECKWAKEUP_ID, \
                              (uint8)LIN_43_LLCE_E_UNINIT \
                             );
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        u8TempReturn = (uint8)E_NOT_OK;
    }
    else
    {
        /* Check for invalid channel */
        if (Channel >= LIN_43_LLCE_HW_MAX_MODULES)
        {
            /* Invalid channel */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /* Report error to development error tracer */
            (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                  (uint8)0, \
                                  (uint8)LIN_43_LLCE_CHECKWAKEUP_ID, \
                                  (uint8)LIN_43_LLCE_E_INVALID_CHANNEL \
                                 );
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
            u8TempReturn = (uint8)E_NOT_OK;
        }
        else
        {
            u8TempReturn = Lin_43_LLCE_Ipw_CheckWakeup(Channel);

            if ((uint8)E_OK == u8TempReturn)
            {
                if ((uint8) STD_ON == Lin_43_LLCE_pxConfigPtr->pLin_Channel[Channel]->pChannelConfigPC->u8LinChannelWakeupSupport)
                {
                    /* Indicates a valid timer wakeup event to ECU State Manager */
                    EcuM_SetWakeupEvent(Lin_43_LLCE_pChannelConfigPtr[Channel]->pChannelConfigPC->LinChannelEcuMWakeupSource);
                    /* Report the wakeup source to the LinInterface after a successful wakeup */
                    LinIf_WakeupConfirmation(Lin_43_LLCE_pChannelConfigPtr[Channel]->pChannelConfigPC->LinChannelEcuMWakeupSource);
                }
            }
            else
            {
                /* Return E_OK, there was no error during the execution */
                u8TempReturn = (uint8)E_OK;
            }
        }
    }
    return u8TempReturn;
}

#if (LIN_43_LLCE_MASTER_NODE_USED == STD_ON)
/**
* @brief   Gets the status of the LIN driver.
* @details This function returns the state of the current
*          transmission, reception or operation status.
*          If the reception of a Slave response was successful then
*          this service provides a pointer to the buffer where the
*          data is stored.
*
* @param[in] Channel       LIN channel to be checked.
*
* @param[out] Lin_SduPtr   Lin_SduPtr pointer to pointer to a shadow
*                          buffer or memory mapped LIN Hardware
*                          receive buffer where the current SDU is
*                          stored.
* @return                  Lin_StatusType.
* @retval LIN_NOT_OK       Development or production error raised
*                          none of the below conditions.
* @retval LIN_TX_OK        Successful transmission.
* @retval LIN_TX_BUSY      Ongoing transmission of header or response.
* @retval LIN_TX_HEADER_ERROR Error occurred during header
*                          transmission.
* @retval LIN_TX_ERROR     Error occurred during response
*                          transmission.
* @retval LIN_RX_OK        Reception of correct response.
* @retval LIN_RX_BUSY      Ongoing reception where at least one byte
*                          has been received.
* @retval LIN_RX_ERROR     Error occurred during reception.
* @retval LIN_RX_NO_RESPONSE No data byte has been received yet.
* @retval LIN_OPERATIONAL  Channel is ready for next header.
*                          transmission and no data are available.
* @retval LIN_CH_SLEEP     Channel is in sleep mode.
*
* @note    Autosar Service ID: 0x08.
* @note    Synchronous, non reentrant function.
*
* @implements Lin_GetStatus_Activity
*
*/
Lin_StatusType Lin_43_LLCE_GetStatus(uint8 Channel, \
                                             uint8 ** Lin_SduPtr \
                                            )
{
    Lin_StatusType u8tempReturn = LIN_NOT_OK;

    /* Check whether the LIN driver is in LIN_43_LLCE_INIT state */
    if(LIN_43_LLCE_INIT != Lin_u8LinDrvStatus)
    {
        /* LIN driver has not been initialized yet */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /* Report error to development error tracer */
        (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID,(uint8)0,(uint8)LIN_43_LLCE_GETSTATUS_ID,(uint8)LIN_43_LLCE_E_UNINIT);
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        u8tempReturn = LIN_NOT_OK;
    }
    else
    {
        /* Check for invalid channel */
        if (Channel >= LIN_43_LLCE_HW_MAX_MODULES)
        {
            /* Invalid channel */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /* Report error to development error tracer */
            (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                  (uint8)0, \
                                  (uint8)LIN_43_LLCE_GETSTATUS_ID, \
                                  (uint8)LIN_43_LLCE_E_INVALID_CHANNEL \
                                 );
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
            u8tempReturn = LIN_NOT_OK;
        }
        else
        {
            /* Check PduInfoPtr for not being a null pointer */
            if (NULL_PTR == Lin_SduPtr)
            {
                /* Invalid pointer */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                /* Report error to development error tracer */
                (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                      (uint8)0, \
                                      (uint8)LIN_43_LLCE_GETSTATUS_ID, \
                                      (uint8)LIN_43_LLCE_E_PARAM_POINTER \
                                     );
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
                u8tempReturn = LIN_NOT_OK;
            }
            else
            {
                u8tempReturn = Lin_43_LLCE_Ipw_HardwareGetStatus(Channel, Lin_SduPtr);
            }
        }
    }
    return u8tempReturn;
}
#endif /* #if LIN_43_LLCE_MASTER_NODE_USED == STD_ON */

#if (LIN_43_LLCE_MASTER_NODE_USED == STD_ON)
/**
* @brief   The service instructs the driver to transmit a
*          go-to-sleep-command on the addressed LIN channel.
* @details This function stops any ongoing transmission and initiates
*          the transmission of the sleep command (master command
*          frame with ID = 0x3C and data = (0x00, 0xFF, 0xFF, 0xFF,
*          0xFF, 0xFF, 0xFF, 0xFF). State transition in
*          LIN_CH_SLEEP_STATE shall be done after the completion of
*          the sleep command transmission regardless of the success
*          (therefore the ISR is responsible to put the channel in
*          LIN_CH_SLEEP_STATE).
*
* @param[in] Channel       LIN channel to be checked.
*
* @return                  Std_ReturnType.
* @retval E_NOT_OK         If the LIN Channel is not valid or
*                          LIN driver is not initialized or
*                          LIN Channel is in sleep state or
*                          a timeout occurs.
* @retval E_OK             Otherwise.
*
* @note    Autosar Service ID: 0x06.
* @note    Synchronous, non reentrant function.
*
* @implements Lin_GoToSleep_Activity
*
*/
Std_ReturnType Lin_43_LLCE_GoToSleep(uint8 Channel)
{
    Std_ReturnType u8TempReturn = (uint8)E_NOT_OK;

    /* Check whether the LIN driver is in LIN_43_LLCE_INIT state */
    if (LIN_43_LLCE_INIT != Lin_u8LinDrvStatus)
    {
        /* LIN driver has not been initialized yet */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /* Report error to development error tracer */
        (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID,(uint8)0,(uint8)LIN_43_LLCE_GOTOSLEEP_ID,(uint8)LIN_43_LLCE_E_UNINIT);
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        u8TempReturn = (uint8)E_NOT_OK;
    }
    else
    {
        /* Check for invalid channel */
        if (Channel >= LIN_43_LLCE_HW_MAX_MODULES)
        {
            /* Invalid channel */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /* Report error to development error tracer */
            (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                  (uint8)0, \
                                  (uint8)LIN_43_LLCE_GOTOSLEEP_ID, \
                                  (uint8)LIN_43_LLCE_E_INVALID_CHANNEL \
                                 );
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
            u8TempReturn = (uint8)E_NOT_OK;
        }
        else
        {
            u8TempReturn = Lin_43_LLCE_Ipw_GoToSleep(Channel);
        }
    }
    return u8TempReturn;
}
#endif /* #if LIN_43_LLCE_MASTER_NODE_USED == STD_ON */

/**
* @brief   Put a Lin channel in the internal sleep state.
* @details Stops any ongoing transmission, sets the channel
*          state to LIN_CH_SLEEP and put the LIN
*          hardware unit to a reduced power operation mode.
*
* @param[in] Channel       LIN channel to be addressed.
*
* @return                  Std_ReturnType.
* @retval E_NOT_OK         If the LIN Channel is not valid or
*                          LIN driver is not initialized or
*                          LIN Channel is in sleep state or
*                          a timeout occurs.
* @retval E_OK             Otherwise.
*
* @note    Autosar Service ID: 0x09.
* @note    Synchronous, non reentrant function.
*
* @implements Lin_GoToSleepInternal_Activity
*
*/
Std_ReturnType Lin_43_LLCE_GoToSleepInternal(uint8 Channel)
{
    Std_ReturnType u8TempReturn = (uint8)E_NOT_OK;

    /* Check whether the LIN driver is in LIN_43_LLCE_INIT state */
    if (LIN_43_LLCE_INIT != Lin_u8LinDrvStatus)
    {
        /* LIN driver has not been initialized yet */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /* Report error to development error tracer */
        (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                              (uint8)0, \
                              (uint8)LIN_43_LLCE_GOTOSLEEPINTERNAL_ID, \
                              (uint8)LIN_43_LLCE_E_UNINIT \
                             );
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        u8TempReturn = (uint8)E_NOT_OK;
    }
    else
    {
        /* Check for invalid channel */
        if (Channel >= LIN_43_LLCE_HW_MAX_MODULES)
        {
            /* Invalid channel */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /* Report error to development error tracer */
            (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                  (uint8)0, \
                                  (uint8)LIN_43_LLCE_GOTOSLEEPINTERNAL_ID, \
                                  (uint8)LIN_43_LLCE_E_INVALID_CHANNEL \
                                 );
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
            u8TempReturn =  (uint8)E_NOT_OK;
        }
        else
        {
            u8TempReturn = Lin_43_LLCE_Ipw_GoToSleepInternal(Channel);
        }
    }
    return u8TempReturn;
}

#if (LIN_43_LLCE_MASTER_NODE_USED == STD_ON)
/**
* @brief   Sends a LIN frame.
* @details Sends a LIN header and a LIN response, if necessary. The
*          direction of the frame response (master response, slave
*          response, slave-to-slave communication) is provided by
*          the PduInfoPtr.
*
* @param[in] Channel       LIN channel to be addressed.
* @param[in] PduInfoPtr    pointer to PDU containing the PID,
*                          Checksum model, Response type, Dl and SDU
*                          data pointer.
*
* @return                  Std_ReturnType.
* @retval E_NOT_OK         If the LIN Channel is not valid or
*                          LIN driver is not initialized or
*                          PduInfoPtr is NULL or
*                          a timeout occurs or
*                          LIN Channel is in sleep state.
* @retval E_OK             Otherwise.
*
* @note    Autosar Service ID: 0x04.
* @note    Synchronous, non reentrant function.
*
* @implements Lin_SendFrame_Activity
*
*/
Std_ReturnType Lin_43_LLCE_SendFrame(uint8 Channel, \
                                             const Lin_PduType * PduInfoPtr \
                                            )
{
    Std_ReturnType u8TempReturn = (uint8)E_NOT_OK;

    /* Check whether the LIN driver is in LIN_43_LLCE_INIT state */
    if (LIN_43_LLCE_INIT != Lin_u8LinDrvStatus)
    {
        /* LIN driver has not been initialized yet */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /* Report error to development error tracer */
        (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                              (uint8)0, \
                              (uint8)LIN_43_LLCE_SENDFRAME_ID, \
                              (uint8)LIN_43_LLCE_E_UNINIT \
                             );
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        u8TempReturn = (uint8)E_NOT_OK;
    }
    else
    {
        /* Check for invalid channel */
        if (Channel >= LIN_43_LLCE_HW_MAX_MODULES)
        {
            /* Invalid channel */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /* Report error to development error tracer */
            (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID,(uint8)0,(uint8)LIN_43_LLCE_SENDFRAME_ID, (uint8)LIN_43_LLCE_E_INVALID_CHANNEL);
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
            u8TempReturn = (uint8)E_NOT_OK;
        }
        else
        {
            /* Check PduInfoPtr for not being a null pointer */
            if (NULL_PTR == PduInfoPtr)
            {
                /* Invalid pointer */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                /* Report error to development error tracer */
                (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                      (uint8)0, \
                                      (uint8)LIN_43_LLCE_SENDFRAME_ID, \
                                      (uint8)LIN_43_LLCE_E_PARAM_POINTER \
                                     );
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
                u8TempReturn = (uint8)E_NOT_OK;
            }
            else
            {
                u8TempReturn = Lin_43_LLCE_Ipw_SendFrame(Channel,PduInfoPtr);
            }
        }
    }
    return u8TempReturn;
}
#endif /* #if LIN_43_LLCE_MASTER_NODE_USED == STD_ON */

/**
* @brief   Generates a wake up pulse.
* @details This function shall sent a wake up signal to the LIN bus
*          and put the LIN channel in LIN_CH_OPERATIONAL state.
*
* @param[in] Channel       LIN channel to be addressed.
*
* @return                  Std_ReturnType.
* @retval E_NOT_OK         If the LIN driver is not in sleep state or
*                          LIN Channel is not valid or
*                          LIN driver is not initialized.
* @retval E_OK             Otherwise.
*
* @note    Autosar Service ID: 0x07.
* @note    Synchronous, non reentrant function.
*
* @implements Lin_Wakeup_Activity
*
*/
Std_ReturnType Lin_43_LLCE_Wakeup(uint8 Channel)
{
    Std_ReturnType u8TempReturn = (uint8)E_NOT_OK;

    /* Check whether the LIN driver is in LIN_43_LLCE_INIT state */
    if (LIN_43_LLCE_INIT != Lin_u8LinDrvStatus)
    {
        /* LIN driver has not been initialized yet */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /* Report error to development error tracer */
        (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID,(uint8)0,(uint8)LIN_43_LLCE_WAKEUP_ID,(uint8)LIN_43_LLCE_E_UNINIT);
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        u8TempReturn = (uint8)E_NOT_OK;
    }
    else
    {
        /* Check for invalid channel */
        if (Channel >= LIN_43_LLCE_HW_MAX_MODULES)
        {
            /* Invalid channel */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /* Report error to development error tracer */
            (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                  (uint8)0, \
                                  (uint8)LIN_43_LLCE_WAKEUP_ID, \
                                  (uint8)LIN_43_LLCE_E_INVALID_CHANNEL \
                                 );
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
            u8TempReturn = (uint8)E_NOT_OK;
        }
        else
        {
            /* Call LLD function */
            u8TempReturn = Lin_43_LLCE_Ipw_WakeUp(Channel);
        }
    }
    return u8TempReturn;
}

/**
* @brief   Wake up the LIN channel.
* @details This function shall put the LIN channel in LIN_CH_OPERATIONAL state without sending a
*          wake up signal to the LIN bus
*
* @param[in] Channel       LIN channel to be addressed.
*
* @return                  Std_ReturnType.
* @retval E_NOT_OK         If the LIN driver is not in sleep state or
*                          LIN Channel is not valid or
*                          LIN driver is not initialized.
* @retval E_OK             Otherwise.
*
* @note    Autosar Service ID: 0x0B.
* @note    Asynchronous, non reentrant function.
*
* @implements Lin_WakeupInternal_Activity
*
*/
Std_ReturnType Lin_43_LLCE_WakeupInternal(uint8 Channel)
{
    Std_ReturnType u8TempReturn = (uint8)E_NOT_OK;

    /* Check whether the LIN driver is in LIN_43_LLCE_INIT state */
    if (LIN_43_LLCE_INIT != Lin_u8LinDrvStatus)
    {
        /* LIN driver has not been initialized yet */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /* Report error to development error tracer */
        (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID,(uint8)0,(uint8)LIN_43_LLCE_WAKEUPINTERNAL_ID,(uint8)LIN_43_LLCE_E_UNINIT);
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        u8TempReturn = (uint8)E_NOT_OK;
    }
    else
    {
        /* Check for invalid channel */
        if (Channel >= LIN_43_LLCE_HW_MAX_MODULES)
        {
            /* Invalid channel */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /* Report error to development error tracer */
            (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                  (uint8)0, \
                                  (uint8)LIN_43_LLCE_WAKEUPINTERNAL_ID, \
                                  (uint8)LIN_43_LLCE_E_INVALID_CHANNEL \
                                 );
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
            u8TempReturn = (uint8)E_NOT_OK;
        }
        else
        {
            /* Call LLD function */
            u8TempReturn = Lin_43_LLCE_Ipw_WakeUpInternal(Channel);
        }
    }
    return u8TempReturn;
}

 #if (LIN_43_LLCE_VERSION_INFO_API == STD_ON)
/**
* @brief   Returns the version information of this module.
* @details The version information includes:
*
*          - Two bytes for the Vendor ID
*          - Two bytes for the Module ID
*          - One byte  for the Instance ID
*          - Three bytes version number. The numbering shall be vendor
*            specific: it consists of:
*
*             - The major, the minor and the patch version number of
*               the module;
*             - The AUTOSAR specification version number shall not
*               be included. The AUTOSAR specification version number is
*               checked during compile time and therefore not required
*               in this API.
*
* @param[in,out] versioninfo   Pointer for storing the version information
*                              of this module.
*
* @return                  void.
*
* @pre            Preconditions as text description. Optional tag.
*
* @note    Autosar Service ID: 0x01.
* @note    Synchronous, non reentrant function.
*
* @implements Lin_GetVersionInfo_Activity
*
*/
void Lin_43_LLCE_GetVersionInfo(Std_VersionInfoType * versioninfo)
{
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
    if (NULL_PTR == versioninfo)
    {
        (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                              (uint8)0, \
                              (uint8)LIN_43_LLCE_GETVERSIONINFO_ID, \
                              (uint8) LIN_43_LLCE_E_PARAM_POINTER \
                             );
    }
    else
    {
#endif /* LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON */
        (versioninfo)->vendorID = (uint16) LIN_43_LLCE_VENDOR_ID;
        (versioninfo)->moduleID = (uint8) LIN_43_LLCE_MODULE_ID;
        (versioninfo)->sw_major_version = (uint8) LIN_43_LLCE_SW_MAJOR_VERSION;
        (versioninfo)->sw_minor_version = (uint8) LIN_43_LLCE_SW_MINOR_VERSION;
        (versioninfo)->sw_patch_version = (uint8) LIN_43_LLCE_SW_PATCH_VERSION;
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
    }
#endif /* LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON */
}
#endif /* LIN_43_LLCE_VERSION_INFO_API == STD_ON */

#define LIN_43_LLCE_STOP_SEC_CODE
 #include "Lin_43_LLCE_MemMap.h"

#ifdef __cplusplus
}
#endif
/** @} */


===== 文件 [10/11]: src\Lin_Llce.c =====
/**
*   @internal
*   @file    Lin_Llce.c
*   @implements Lin_Llce.c_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Lin - LLCE.
*   @details File containing the low level driver of the Llce IP.
*
*   @addtogroup LIN_LLCE
*   @{
*/
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2006-2016 Freescale Semiconductor, Inc.
*   Copyright 2020-2025 NXP
*   All Rights Reserved.
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
*   accordance with the applicable license terms.
*   By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
*   the software, you are agreeing that you have read, and that you agree to comply with and are bound
*   by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
*   may not retain, install, activate or otherwise use the software.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/

#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Lin_43_LLCE.h"
#include "Lin_Llce.h"
#include "Llce_InterfaceLinTypes.h"
#include "Llce_InterfaceCore2Core.h"
#include "Lin_43_LLCE_Cfg.h"
#include "LinIf.h"

#include "OsIf.h"

#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
    #include "Det.h"
#endif

#if(LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF)
    #include "Dem.h"
#endif

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/**
* @file           Lin_Llce.c
*/
#define LIN_LLCE_VENDOR_ID_C                    43
#define LIN_LLCE_AR_RELEASE_MAJOR_VERSION_C     4
#define LIN_LLCE_AR_RELEASE_MINOR_VERSION_C     4

#define LIN_LLCE_AR_RELEASE_REVISION_VERSION_C  0
#define LIN_LLCE_SW_MAJOR_VERSION_C             1
#define LIN_LLCE_SW_MINOR_VERSION_C             0
#define LIN_LLCE_SW_PATCH_VERSION_C             10
/*==================================================================================================
*                                      FILE VERSION CHECKS
==================================================================================================*/
/* Check if current file and Lin header file are of the same vendor */
#if (LIN_LLCE_VENDOR_ID_C != LIN_43_LLCE_VENDOR_ID)
    #error "Lin_Llce.c and Lin_43_LLCE.h have different vendor ids"
#endif
/* Check if current file and Lin_Llce header file are of the same vendor */
#if (LIN_LLCE_VENDOR_ID_C != LIN_LLCE_VENDOR_ID)
    #error "Lin_Llce.c and Lin_Llce.h have different vendor ids"
#endif
/* Check if current file and Lin_43_LLCE.h header file are of the same Autosar version */
#if ((LIN_LLCE_AR_RELEASE_MAJOR_VERSION_C    != LIN_43_LLCE_AR_RELEASE_MAJOR_VERSION) || \
     (LIN_LLCE_AR_RELEASE_MINOR_VERSION_C    != LIN_43_LLCE_AR_RELEASE_MINOR_VERSION) || \
     (LIN_LLCE_AR_RELEASE_REVISION_VERSION_C != LIN_43_LLCE_AR_RELEASE_REVISION_VERSION) \
    )
    #error "AutoSar Version Numbers of Lin_Llce.c and Lin_43_LLCE.h are different"
#endif
/* Check if current file and Lin_43_LLCE.h header file are of the same Software version */
#if ((LIN_LLCE_SW_MAJOR_VERSION_C != LIN_43_LLCE_SW_MAJOR_VERSION) || \
     (LIN_LLCE_SW_MINOR_VERSION_C != LIN_43_LLCE_SW_MINOR_VERSION) || \
     (LIN_LLCE_SW_PATCH_VERSION_C != LIN_43_LLCE_SW_PATCH_VERSION) \
    )
    #error "Software Version Numbers of Lin_Llce.c and Lin_43_LLCE.h are different"
#endif

/* Check if current file and Lin_Llce.h header file are of the same Autosar version */
#if ((LIN_LLCE_AR_RELEASE_MAJOR_VERSION_C    != LIN_LLCE_AR_RELEASE_MAJOR_VERSION) || \
     (LIN_LLCE_AR_RELEASE_MINOR_VERSION_C    != LIN_LLCE_AR_RELEASE_MINOR_VERSION) || \
     (LIN_LLCE_AR_RELEASE_REVISION_VERSION_C != LIN_LLCE_AR_RELEASE_REVISION_VERSION) \
    )
    #error "AutoSar Version Numbers of Lin_Llce.c and Lin_Llce.h are different"
#endif
/* Check if current file and Lin_Llce.h header file are of the same Software version */
#if ((LIN_LLCE_SW_MAJOR_VERSION_C != LIN_LLCE_SW_MAJOR_VERSION) || \
     (LIN_LLCE_SW_MINOR_VERSION_C != LIN_LLCE_SW_MINOR_VERSION) || \
     (LIN_LLCE_SW_PATCH_VERSION_C != LIN_LLCE_SW_PATCH_VERSION) \
    )
    #error "Software Version Numbers of Lin_Llce.c and Lin_Llce.h are different"
#endif

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL VARIABLES
==================================================================================================*/
#define LIN_43_LLCE_START_SEC_VAR_CLEARED_8
#include "Lin_43_LLCE_MemMap.h"

static uint8 Lin_au8Hw2LogicCtrlMap[LLCE_LIN_MAXCTRL_COUNT];

static uint8 au8WakeUpFlag[LLCE_LIN_MAXCTRL_COUNT];

#define LIN_43_LLCE_STOP_SEC_VAR_CLEARED_8
#include "Lin_43_LLCE_MemMap.h"

/*==================================================================================================
*                                       GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL VARIABLES
==================================================================================================*/
#define LIN_43_LLCE_START_SEC_SHAREDMEMORY
#include "Lin_43_LLCE_MemMap.h"

static volatile Llce_Lin_SharedMemoryType Lin_xSharedMemory;

#define LIN_43_LLCE_STOP_SEC_SHAREDMEMORY
#include "Lin_43_LLCE_MemMap.h"
/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/
#define LIN_43_LLCE_START_SEC_CODE
#include "Lin_43_LLCE_MemMap.h"

static Llce_Lin_ReturnType   Lin_Llce_ExecuteIfCommand(uint8 u8HwCtrl);

/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/**
* @internal
* @brief          Send a command to the LLCE in order to be executed
* @details        Send a prepared command to the LLCE in order to be executed and get the status code from LLCE
*                 This routine is called by:
*                 - Every function which does a specific command, from Lin_Llce.c file.
*
* @pre            Command should be put in shared memory
* @post           Get the status code returned by LLCE.
*
*
*/
static Llce_Lin_ReturnType Lin_Llce_ExecuteIfCommand(uint8 u8HwCtrl)
{
    uint32          u32timeStart = 0U;
    /* Timeout counter. */
    uint32          u32timeElapsed = 0U;
    uint32          u32TicksDelayDuration = 0U;
    
    uint32          u32temp = 0U;

    /* Variable for return status. */
    Llce_Lin_ReturnType eReturnValue = LLCE_LIN_ERROR_TIMEOUT;

    /* Trigger an interrupt to the LLCE */
    LLCE_HOST2TX_ASSERT_INTERRUPT(u8HwCtrl);

    /* Check in polling mode if the command was executed by the LLCE */
    u32timeStart = OsIf_GetCounter(LIN_43_LLCE_SERVICE_TIMEOUT_TYPE);
    u32TicksDelayDuration = OsIf_MicrosToTicks(LIN_43_LLCE_TIMEOUT_DURATION, LIN_43_LLCE_SERVICE_TIMEOUT_TYPE);
    
    do
    {
        u32timeElapsed += OsIf_GetElapsed(&u32timeStart, LIN_43_LLCE_SERVICE_TIMEOUT_TYPE);
        u32temp = LLCE_HOST2TX_GET_STATUS_INTERRUPT(u8HwCtrl);
    }
    while ((u32timeElapsed < u32TicksDelayDuration) && ((uint32)0x0U != u32temp));

    MCAL_FAULT_INJECTION_POINT(LIN_LLCE_FIP_4_T_TIME_OUT_4);

    if (u32timeElapsed < u32TicksDelayDuration)
    {
        /* Read the status code returned by the LLCE. */
        eReturnValue = Lin_xSharedMemory.Lin_aCmd[u8HwCtrl].eReturnValue;
    }

    return eReturnValue;
}

/**
* @internal
* @brief   This function processes wakeup notification from Llce.
* @details This function processes wakeup notification from Llce
*          on the addressed channel.
*
* @param[in]   Channel LIN channel to be addressed.
*
* @return       void.
*
* @note         Internal driver function.
*
* @implements Lin_Llce_WakeupConfirmation_Activity
*
*/
static void Lin_Llce_WakeupConfirmation(const uint8 u8HwCtrl)
{
    uint8  u8LogicCtrl;
    /* Calculate logic controller index. */
    u8LogicCtrl = Lin_au8Hw2LogicCtrlMap[u8HwCtrl];

    /* Set the wakeup flag to be checked later by CheckWakeup */
    au8WakeUpFlag[u8LogicCtrl] = (uint8)E_OK;

    /* Indicates a valid timer wakeup event to ECU State Manager */
    if ((uint8) STD_ON == Lin_43_LLCE_pxConfigPtr->pLin_Channel[u8LogicCtrl]->pChannelConfigPC->u8LinChannelWakeupSupport)
    {
        EcuM_CheckWakeup(Lin_43_LLCE_pxConfigPtr->pLin_Channel[u8LogicCtrl]->pChannelConfigPC->LinChannelEcuMWakeupSource);
    }
}

/**
* @internal
* @brief   This function processes error indication from Llce.
* @details This function processes error indication from Llce
*          on the addressed channel.
*
* @param[in]   Channel LIN channel to be addressed.
*
* @return       void.
*
* @note         Internal driver function.
*
* @implements Lin_Llce_ErrorIndication_Activity
*
*/
#if (LIN_43_LLCE_SLAVE_NODE_USED == STD_ON)
static void Lin_Llce_ErrorIndication(const uint8 u8HwCtrl)
{
    uint8  u8LogicCtrl;
    Lin_SlaveErrorType eSlaveError;
    Llce_Lin_ReturnType eErrorFlag;

    /* Calculate logic controller index. */
    u8LogicCtrl = Lin_au8Hw2LogicCtrlMap[u8HwCtrl];

    eErrorFlag = LLCE_LIN_SUCCESS;

    /* Convert the Error reported by FW to ASR types and notify it to LinIf. */
    switch (Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].CmdList.ErrorIndication.eSlaveError)
    {
        case LLCE_LIN_ERR_HEADER:
            eSlaveError = LIN_ERR_HEADER;
            break;
        case LLCE_LIN_ERR_RESP_STOPBIT:
            eSlaveError = LIN_ERR_RESP_STOPBIT;
            break;
        case LLCE_LIN_ERR_RESP_CHKSUM:
            eSlaveError = LIN_ERR_RESP_CHKSUM;
            break;
        case LLCE_LIN_ERR_RESP_DATABIT:
            eSlaveError = LIN_ERR_RESP_DATABIT;
            break;
        case LLCE_LIN_ERR_NO_RESP:
            eSlaveError = LIN_ERR_NO_RESP;
            break;
        case LLCE_LIN_ERR_INC_RESP:
            eSlaveError = LIN_ERR_INC_RESP;
            break;
        default:
            eSlaveError = LIN_ERR_HEADER;
            /* Conversion error. */
            eErrorFlag = LLCE_LIN_ERROR;
            break;
    }
    /* If the conversion was successfully */
    if (LLCE_LIN_SUCCESS == eErrorFlag)
    {
        LinIf_LinErrorIndication((NetworkHandleType)u8LogicCtrl, eSlaveError);
    }
}
#endif /* if (LIN_43_LLCE_SLAVE_NODE_USED == STD_ON) */

/**
* @internal
* @brief   This function processes header indication from Llce.
* @details This function processes header indication from Llce
*          on the addressed channel.
*          This function calls LinIf_HeaderIndication() to get
*          the information about what to do with the received Header.
*
* @param[in]   Channel LIN channel to be addressed.
*
* @return       void.
*
* @note         Internal driver function.
*
* @implements Lin_Llce_HeaderIndication_Activity
*
*/
#if (LIN_43_LLCE_SLAVE_NODE_USED == STD_ON)
static void Lin_Llce_HeaderIndication(const uint8 u8HwCtrl)
{
    uint8  u8LogicCtrl;
    Llce_Lin_ReturnType eErrorFlag;
    Lin_PduType xPduInfo;
    uint8  u8Idx;

    /* Calculate logic controller index. */
    u8LogicCtrl = Lin_au8Hw2LogicCtrlMap[u8HwCtrl];

    eErrorFlag = LLCE_LIN_SUCCESS;

    /* Prepare the xPduInfo */
    xPduInfo.Pid = Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].CmdList.HeaderIndication.Pid;
    xPduInfo.Dl = Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].CmdList.HeaderIndication.Dl;

    switch (Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].CmdList.HeaderIndication.Cs)
    {
        case LLCE_LIN_ENHANCED_CS:
            xPduInfo.Cs = LIN_ENHANCED_CS;
            break;
        case LLCE_LIN_CLASSIC_CS:
            xPduInfo.Cs = LIN_CLASSIC_CS;
            break;
        default:
            /* Conversion error. */
            eErrorFlag = LLCE_LIN_ERROR;
            break;
    }

    switch (Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].CmdList.HeaderIndication.Drc)
    {
        case LLCE_LIN_FRAMERESPONSE_TX:
            xPduInfo.Drc = LIN_FRAMERESPONSE_TX;
            break;
        case LLCE_LIN_FRAMERESPONSE_RX:
            xPduInfo.Drc = LIN_FRAMERESPONSE_RX;
            break;
        case LLCE_LIN_FRAMERESPONSE_IGNORE:
            xPduInfo.Drc = LIN_FRAMERESPONSE_IGNORE;
            break;
        default:
            /* Conversion error. */
            eErrorFlag = LLCE_LIN_ERROR;
            break;
    }

    /* If the conversion was successfully */
    if (LLCE_LIN_SUCCESS == eErrorFlag)
    {
        /* Call LinIf to get the result */
        if ((uint8)E_OK == LinIf_HeaderIndication((NetworkHandleType)u8LogicCtrl, &xPduInfo))
        {
            /* Copy the new xPduInfo modified by LinIf to the FW */
            for (u8Idx = 0 ; u8Idx < xPduInfo.Dl ; u8Idx++)
            {
                Lin_xSharedMemory.aLinMb[u8HwCtrl][u8Idx] = xPduInfo.SduPtr[u8Idx];
            }

            Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].CmdList.HeaderIndication.Dl = xPduInfo.Dl;

            switch (xPduInfo.Cs)
            {
                case LIN_ENHANCED_CS:
                    Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].CmdList.HeaderIndication.Cs = LLCE_LIN_ENHANCED_CS;
                    break;
                case LIN_CLASSIC_CS:
                    Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].CmdList.HeaderIndication.Cs = LLCE_LIN_CLASSIC_CS;
                    break;
                default:
                    /* Conversion error. */
                    eErrorFlag = LLCE_LIN_ERROR;
                    break;
            }

            switch (xPduInfo.Drc)
            {
                case LIN_FRAMERESPONSE_TX:
                    Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].CmdList.HeaderIndication.Drc = LLCE_LIN_FRAMERESPONSE_TX;
                    break;
                case LIN_FRAMERESPONSE_RX:
                    Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].CmdList.HeaderIndication.Drc = LLCE_LIN_FRAMERESPONSE_RX;
                    break;
                case LIN_FRAMERESPONSE_IGNORE:
                    Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].CmdList.HeaderIndication.Drc = LLCE_LIN_FRAMERESPONSE_IGNORE;
                    break;
                default:
                    /* Conversion error. */
                    eErrorFlag = LLCE_LIN_ERROR;
                    break;
            }

            /* If the conversion was successfully */
            if (LLCE_LIN_SUCCESS == eErrorFlag)
            {
                /* Store the status for FW. */
                Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].eReturnValue = LLCE_LIN_SUCCESS;
            }
            else
            {
                /* Store the status for FW. */
                Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].eReturnValue = LLCE_LIN_ERROR;
            }
        }
        else
        {
            /* Store the status for FW. */
            Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].eReturnValue = LLCE_LIN_ERROR;
        }
    }
}
#endif /* #if (LIN_43_LLCE_SLAVE_NODE_USED == STD_ON) */

/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/

/*================================================================================================*/

/**
* @internal
* @brief   Check if a LIN channel has been woken-up.
* @details This function identifies if the addressed LIN channel
*          has been woken up by the LIN bus transceiver.
*          This function returns E_OK only the first time
*          ater the wake up event.
*
* @param[in] Channel LIN channel to be checked.
*
* @return            Std_ReturnType.
* @retval E_OK       If the LIN Channel has been woken-up
* @retval E_NOT_OK   Otherwise.
*
* @implements Lin_Llce_CheckWakeup_Activity
*
*/
Std_ReturnType Lin_Llce_CheckWakeup(const uint8 u8Channel)
{
    Std_ReturnType u8TempReturn = (uint8)E_NOT_OK;

    if ((uint8)E_OK == au8WakeUpFlag[u8Channel])
    {
        u8TempReturn = (uint8)E_OK;

        au8WakeUpFlag[u8Channel] = (uint8)E_NOT_OK;
    }

    return u8TempReturn;
}

/**
* @internal
* @brief   Initialize a LIN channel.
* @details This function initializes all hardware registers needed to
*          start the LIN functionality on the selected channel.
*
* @param[in] Channel LIN channel to be initialized.
*
* @return            void.
*
* @implements Lin_Llce_Init_Activity
*
*/
void Lin_Llce_Init(void)
{
    volatile Llce_Lin_ChannelConfigType * pxHwCtrlConfig = NULL_PTR;
    const Lin_43_LLCE_ChannelConfigType * pxLinChannelConfig = NULL_PTR;

    /* Index LIN channel from configuration. */
    uint8 u8CtrlIndex = 0U;
    /* Controller hardware offset on chip. */
    uint8 u8HwCtrl = 0U;

    /* Initialize all the LIN controllers */
    for (u8CtrlIndex = 0U; u8CtrlIndex < LIN_43_LLCE_HW_MAX_MODULES; u8CtrlIndex++)
    {
        pxLinChannelConfig = Lin_43_LLCE_pxConfigPtr->pLin_Channel[u8CtrlIndex];
        u8HwCtrl = pxLinChannelConfig->pChannelConfigPC->u8LinHwChannel;

        /* Check if the command buffer is not already used by other command request. */
        if (0x0U == LLCE_HOST2TX_GET_STATUS_INTERRUPT(u8HwCtrl))
        {
            /* Configure the command id. */
            Lin_xSharedMemory.Lin_aCmd[u8HwCtrl].eCmdId = LLCE_LIN_CMD_INIT;

            /* Get a pointer to the shared memory. */
            pxHwCtrlConfig = &Lin_xSharedMemory.Lin_aCmd[u8HwCtrl].CmdList.Init.CtrlConfig;

            /* Store the configuration data related to hardware controller. e.g options, etc.*/
            pxHwCtrlConfig->eLinNodeType = pxLinChannelConfig->pChannelConfigPC->eLinNodeType;
            pxHwCtrlConfig->u8LinChannelWakeupSupport = pxLinChannelConfig->pChannelConfigPC->u8LinChannelWakeupSupport;
            pxHwCtrlConfig->u8LinChannelDisableFrameTimeout = pxLinChannelConfig->pChannelConfigPC->u8LinChannelDisableFrameTimeout;
            pxHwCtrlConfig->u32LinBaudRateRegValue = pxLinChannelConfig->u32LinBaudRateRegValue;
            pxHwCtrlConfig->u8LinChannelBrkLengthMaster = pxLinChannelConfig->u8LinChannelBrkLengthMaster;
            pxHwCtrlConfig->u8LinChannelBrkLengthSlave = pxLinChannelConfig->u8LinChannelBrkLengthSlave;
            pxHwCtrlConfig->u8ResponseTimeout = pxLinChannelConfig->u8ResponseTimeout;
            pxHwCtrlConfig->u8HeaderTimeout = pxLinChannelConfig->u8HeaderTimeout;

            /* Create a vector for Hw2Logic mapping */
            Lin_au8Hw2LogicCtrlMap[u8HwCtrl] = u8CtrlIndex;

            /* Initialize wake up status flag */
            au8WakeUpFlag[u8CtrlIndex] = (uint8)E_NOT_OK;

            /* Disable interrupts from rx core to host core for a specific channel.*/
            LLCE_TX2HOST_DISABLE_INTERRUPT(u8HwCtrl);

            /* Clear existing interrupts from rx core for a specific channel.*/
            LLCE_TX2HOST_CLEAR_INTERRUPT(u8HwCtrl);

            /* Enable interrupts from rx core to host core for a specific channel.*/
            LLCE_TX2HOST_ENABLE_INTERRUPT(u8HwCtrl);

            /* Send the command prepared above to the LLCE in order to be executed */
            if (LLCE_LIN_ERROR == Lin_Llce_ExecuteIfCommand(u8HwCtrl))
            {
                /*Report a DEM  error*/
            }

        } else
        {
            /*Report a DEM  error*/
        }
    }

}

#if (LIN_43_LLCE_MASTER_NODE_USED == STD_ON)
/**
* @internal
* @brief   Sends the header part of the LIN frame.
* @details Initiates the transmission of the header
*          part of the LIN frame on Channel using information
*          stored on PduInfoPtr pointer.
*          If response type is MASTER_RESPONSE then nothing is sent over the bus
*          the entire frame (including header) is sent with the Lin_LLCE_LIN_SendResponse
*
* @param[in]   Channel LIN channel to be addressed.
* @param[in]   PduInfoPtr pointer to PDU containing the PID, Checksum model,
*              Response type, Dl and SDU data pointer.
*
* @return            Std_ReturnType.
* @retval E_NOT_OK   In case of a timeout situation only.
* @retval E_OK       Otherwise.
*
* @implements Lin_Llce_SendFrame_Activity
*
*/
Std_ReturnType Lin_Llce_SendFrame(const uint8 u8Channel, \
                                  const Lin_PduType * pPduInfoPtr \
                                 )

{
    /* Variable for return status. */
    Std_ReturnType u8TempReturn = (uint8)E_NOT_OK;
    /* Controller hardware offset on chip. */
    uint8          u8HwCtrl = 0U;
    /* Variable for byte index of the buffer data. */
    uint8          u8MbDataByte = 0U;

    Llce_Lin_ReturnType eLlceReturn = LLCE_LIN_ERROR;
    volatile Llce_Lin_SendFrameCmdType * pxLlceCmd = NULL_PTR;

    /* Get the hardware offset for this controller. */
    u8HwCtrl = Lin_43_LLCE_pChannelConfigPtr[u8Channel]->pChannelConfigPC->u8LinHwChannel;

    /* Check if the command buffer is not already used by other command request */
    if (0x0U == LLCE_HOST2TX_GET_STATUS_INTERRUPT(u8HwCtrl))
    {
        /* Get access to the command buffer. */
        pxLlceCmd = &Lin_xSharedMemory.Lin_aCmd[u8HwCtrl].CmdList.SendFrame;

        /* Configure the command id. */
        Lin_xSharedMemory.Lin_aCmd[u8HwCtrl].eCmdId = LLCE_LIN_CMD_SENDFRAME;
        pxLlceCmd->Pid = pPduInfoPtr->Pid;
        pxLlceCmd->Dl = pPduInfoPtr->Dl;

        switch (pPduInfoPtr->Cs)
        {
            case LIN_ENHANCED_CS:
                pxLlceCmd->Cs = LLCE_LIN_ENHANCED_CS;
                break;
            case LIN_CLASSIC_CS:
                pxLlceCmd->Cs = LLCE_LIN_CLASSIC_CS;
                break;
            default:
                /* Conversion error */
                break;
        }

        switch (pPduInfoPtr->Drc)
        {
            case LIN_FRAMERESPONSE_TX:
                pxLlceCmd->Drc = LLCE_LIN_FRAMERESPONSE_TX;
                break;
            case LIN_FRAMERESPONSE_RX:
                pxLlceCmd->Drc = LLCE_LIN_FRAMERESPONSE_RX;
                break;
            case LIN_FRAMERESPONSE_IGNORE:
                pxLlceCmd->Drc = LLCE_LIN_FRAMERESPONSE_IGNORE;
                break;
            default:
                /* Conversion error */
                break;
        }

        if (LIN_FRAMERESPONSE_TX == pPduInfoPtr->Drc)
        {
            /* Copy the data into the buff memory. The driver will not read from a null pointer SDU. */
            for (u8MbDataByte = (uint8)0U; u8MbDataByte < pPduInfoPtr->Dl; u8MbDataByte++)
            {
                pxLlceCmd->Sdu[u8MbDataByte] = (uint8)((pPduInfoPtr->SduPtr)[u8MbDataByte]);
            }
        }

        MCAL_FAULT_INJECTION_POINT(LIN_LLCE_FIP_1_T_TIME_OUT_1);

        /* Send the command prepared above to the LLCE in order to be executed */
        eLlceReturn = Lin_Llce_ExecuteIfCommand(u8HwCtrl);

        switch (eLlceReturn) {
            case LLCE_LIN_SUCCESS:
#if (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF)
                if ((uint32)STD_ON == Lin_43_LLCE_E_TimeoutCfg.state)
                {
                    (void)Dem_SetEventStatus((Dem_EventIdType)Lin_43_LLCE_E_TimeoutCfg.id, \
                                            DEM_EVENT_STATUS_PASSED \
                                            );
                }
#endif /* (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */
                u8TempReturn = (uint8)E_OK;
                break;
            case LLCE_LIN_ERROR_STATE:
                /* LIN channel is in sleep mode */
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                /* Report error to development error tracer */
                (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                      (uint8)0, \
                                      (uint8)LIN_43_LLCE_SENDFRAME_ID, \
                                      (uint8)LIN_43_LLCE_E_STATE_TRANSITION \
                                     );
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
                u8TempReturn = (uint8)E_NOT_OK;
                break;
            case LLCE_LIN_ERROR_TIMEOUT:
            /* Report Production error */
            #if (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF)
                if ((uint32)STD_ON == Lin_43_LLCE_E_TimeoutCfg.state)
                {
                    (void)Dem_SetEventStatus((Dem_EventIdType)Lin_43_LLCE_E_TimeoutCfg.id, \
                                           DEM_EVENT_STATUS_FAILED \
                                            );
                }
                else
                {
            #endif  /* (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */
                #if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                    /* Report error to development error tracer */
                    (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                          (uint8)0, \
                                          (uint8)LIN_43_LLCE_SENDFRAME_ID, \
                                          (uint8)LIN_43_LLCE_E_TIMEOUT \
                                         );
                #endif  /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
            #if (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF)
                    ; /* Deliberately left here to avoid misra violation. */
                }
            #endif  /* (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */
                u8TempReturn = (uint8)E_NOT_OK;
                break;
            default:
                u8TempReturn = (uint8)E_NOT_OK;
                break;
        }
    }

    return u8TempReturn;
}
#endif /* #if LIN_43_LLCE_MASTER_NODE_USED == STD_ON */

#if (LIN_43_LLCE_MASTER_NODE_USED == STD_ON)
/**
* @internal
* @brief   Prepares and sends a go-to-sleep-command
*          frame on Channel.
* @details This function stops any ongoing transmission and initiates
*          the transmission of the sleep command (master command frame with
*          ID = 0x3C and data = (0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF).
*
* @param[in] Channel LIN channel to be addressed.
*
* @return            Std_ReturnType.
* @retval E_NOT_OK   In case of a timeout situation only.
* @retval E_OK       Otherwise.
*
* @implements Lin_Llce_GoToSleep_Activity
*
*/
Std_ReturnType Lin_Llce_GoToSleep(const uint8 u8Channel)
{
    uint8          u8HwCtrl = 0U;
    Std_ReturnType u8TmpReturn = (uint8)E_NOT_OK;
    Llce_Lin_ReturnType eLlceReturn = LLCE_LIN_ERROR;

    /* Get the hardware offset for this controller. */
    u8HwCtrl = Lin_43_LLCE_pChannelConfigPtr[u8Channel]->pChannelConfigPC->u8LinHwChannel;

    MCAL_FAULT_INJECTION_POINT(LIN_LLCE_FIP_2_T_TIME_OUT_2);

    /* Check if the command buffer is not already used by other command request */
    if (0x0U == LLCE_HOST2TX_GET_STATUS_INTERRUPT(u8HwCtrl))
    {
        /* Configure the command id. */
        Lin_xSharedMemory.Lin_aCmd[u8HwCtrl].eCmdId = LLCE_LIN_CMD_GOTOSLEEP;

         /* Send the command prepared above to the LLCE in order to be executed */
        eLlceReturn = Lin_Llce_ExecuteIfCommand(u8HwCtrl);

        /* Process llce return */
        switch (eLlceReturn)
        {
            case LLCE_LIN_SUCCESS:
                /* Report Production error */
                #if (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF)
                    if ((uint32)STD_ON == Lin_43_LLCE_E_TimeoutCfg.state)
                    {
                        (void)Dem_SetEventStatus((Dem_EventIdType)Lin_43_LLCE_E_TimeoutCfg.id, \
                                                  DEM_EVENT_STATUS_PASSED \
                                                );
                    }
                #endif /* (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */

                /* Clear the wakeup flag */
                au8WakeUpFlag[u8Channel] = (uint8)E_NOT_OK;

                u8TmpReturn = (uint8)E_OK;
                break;
            case LLCE_LIN_ERROR_TIMEOUT:
                /* Report Production error */
                #if (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF)
                    if ((uint32)STD_ON == Lin_43_LLCE_E_TimeoutCfg.state)
                    {
                        (void)Dem_SetEventStatus((Dem_EventIdType)Lin_43_LLCE_E_TimeoutCfg.id, \
                                                  DEM_EVENT_STATUS_FAILED \
                                                );
                    }
                    else
                    {
                #endif  /* (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */
                        #if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                        /* Report error to development error tracer */
                        (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                              (uint8)0x0U, \
                                              (uint8)LIN_43_LLCE_GOTOSLEEP_ID, \
                                              (uint8)LIN_43_LLCE_E_TIMEOUT \
                                             );
                        #endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
                #if (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF)
                        ; /* Deliberately left here to avoid misra violation. */
                    }
                #endif  /* (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */

                u8TmpReturn = (uint8)E_NOT_OK;
                break;
            case LLCE_LIN_ERROR_STATE:
                /* Already into sleep state */
                u8TmpReturn = (uint8)E_OK;
                break;
            default:
                u8TmpReturn = (uint8)E_NOT_OK;
                break;
        }
    }

    return u8TmpReturn;
}
#endif /* #if LIN_43_LLCE_MASTER_NODE_USED == STD_ON */

/**
* @internal
* @brief   Same function as Lin_LLD_GoToSleep() but
*          without sending a go-to-sleep-command on the bus.
* @details This function stops any ongoing transmission and put the
*          Channel in sleep mode (then LIN hardware enters a
*          reduced power operation mode).
*
* @param[in] Channel LIN channel to be addressed.
*
* @return            Std_ReturnType.
* @retval E_NOT_OK   In case of a timeout situation only.
* @retval E_OK       Otherwise.
*
* @implements Lin_Llce_GoToSleepInternal_Activity
*
*/
Std_ReturnType Lin_Llce_GoToSleepInternal(const uint8 u8Channel)
{
    uint8 u8HwCtrl = 0U;
    Std_ReturnType u8TmpReturn = (uint8)E_NOT_OK;
    Llce_Lin_ReturnType eLlceReturn = LLCE_LIN_ERROR;

    /* Get the hardware offset for this controller. */
    u8HwCtrl = Lin_43_LLCE_pChannelConfigPtr[u8Channel]->pChannelConfigPC->u8LinHwChannel;

    MCAL_FAULT_INJECTION_POINT(LIN_LLCE_FIP_3_T_TIME_OUT_3);

    /* Check if the command buffer is not already used by other command request */
    if (0x0U == LLCE_HOST2TX_GET_STATUS_INTERRUPT(u8HwCtrl))
    {
        /* Configure the command id. */
        Lin_xSharedMemory.Lin_aCmd[u8HwCtrl].eCmdId = LLCE_LIN_CMD_GOTOSLEEPINTERNAL;

        /* Send the command prepared above to the LLCE in order to be executed */
        eLlceReturn = Lin_Llce_ExecuteIfCommand(u8HwCtrl);

        /* Process llce return */
        switch (eLlceReturn)
        {
            case LLCE_LIN_SUCCESS:
                /* Report Production error */
                #if (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF)
                    if ((uint32)STD_ON == Lin_43_LLCE_E_TimeoutCfg.state)
                    {
                        (void)Dem_SetEventStatus((Dem_EventIdType)Lin_43_LLCE_E_TimeoutCfg.id, \
                                                  DEM_EVENT_STATUS_PASSED \
                                                );
                    }
                #endif /* (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */

                /* Clear the wakeup flag */
                au8WakeUpFlag[u8Channel] = (uint8)E_NOT_OK;

                u8TmpReturn = (uint8)E_OK;
                break;
            case LLCE_LIN_ERROR_TIMEOUT:
                /* Report Production error */
                #if (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF)
                    if ((uint32)STD_ON == Lin_43_LLCE_E_TimeoutCfg.state)
                    {
                        (void)Dem_SetEventStatus((Dem_EventIdType)Lin_43_LLCE_E_TimeoutCfg.id, \
                                                  DEM_EVENT_STATUS_FAILED \
                                                );
                    }
                    else
                    {
                #endif  /* (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */
                        #if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                        /* Report error to development error tracer */
                        (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                              (uint8)0x0U, \
                                              (uint8)LIN_43_LLCE_GOTOSLEEPINTERNAL_ID, \
                                              (uint8)LIN_43_LLCE_E_TIMEOUT \
                                             );
                        #endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
                #if (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF)
                        ; /* Deliberately left here to avoid misra violation. */
                    }
                #endif  /* (LIN_43_LLCE_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */

                u8TmpReturn = (uint8)E_NOT_OK;
                break;
            case LLCE_LIN_ERROR_STATE:
                /* Already into sleep state */
                u8TmpReturn = (uint8)E_OK;
                break;
            default:
                u8TmpReturn = (uint8)E_NOT_OK;
                break;
        }
    }

    return u8TmpReturn;
}

/**
* @internal
* @brief   Sends a wake up signal to the LIN bus.
* @details This function shall sent a wake up signal to the LIN bus
*          and put the LIN channel in LIN_CH_OPERATIONAL state.
*
* @param[in]   Channel LIN channel to be addressed.
*
* @return            void.
*
* @implements Lin_Llce_WakeUp_Activity
*
*/
Std_ReturnType Lin_Llce_WakeUp(const uint8 u8Channel)
{
    uint8          u8HwCtrl = 0U;
    Std_ReturnType u8TmpReturn = (uint8)E_NOT_OK;
    Llce_Lin_ReturnType eLlceReturn = LLCE_LIN_ERROR;

    /* Get the hardware offset for this controller. */
    u8HwCtrl = Lin_43_LLCE_pChannelConfigPtr[u8Channel]->pChannelConfigPC->u8LinHwChannel;

    /* Check if the command buffer is not already used by other command request */
    if (0x0U == LLCE_HOST2TX_GET_STATUS_INTERRUPT(u8HwCtrl))
    {
        /* Configure the command id. */
       Lin_xSharedMemory.Lin_aCmd[u8HwCtrl].eCmdId = LLCE_LIN_CMD_WAKEUP;

        /* Send the command prepared above to the LLCE in order to be executed */
        eLlceReturn = Lin_Llce_ExecuteIfCommand(u8HwCtrl);

        switch (eLlceReturn)
        {
            case LLCE_LIN_SUCCESS:
                u8TmpReturn = (uint8)E_OK;
                break;
            case LLCE_LIN_ERROR_STATE:
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                /* Report error to development error tracer */
                (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                      (uint8)0x0U, \
                                      (uint8)LIN_43_LLCE_WAKEUP_ID, \
                                      (uint8)LIN_43_LLCE_E_STATE_TRANSITION \
                                     );
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
                u8TmpReturn = (uint8)E_NOT_OK;
                break;
            default:
                u8TmpReturn = (uint8)E_NOT_OK;
                break;
        }
    }

    return u8TmpReturn;
}

/**
* @internal
* @brief   Wake up the LIN channel.
* @details This function shall put the LIN channel in LIN_CH_OPERATIONAL state without
*          sending a wake up signal to the LIN bus
*
* @param[in]   Channel LIN channel to be addressed.
*
* @return            void.
*
* @implements Lin_Llce_WakeupInternal_Activity
*
*/
Std_ReturnType Lin_Llce_WakeupInternal(const uint8 u8Channel)
{
    uint8          u8HwCtrl = 0U;
    Std_ReturnType u8TmpReturn = (uint8)E_NOT_OK;
    Llce_Lin_ReturnType eLlceReturn = LLCE_LIN_ERROR;

    /* Get the hardware offset for this controller. */
    u8HwCtrl = Lin_43_LLCE_pChannelConfigPtr[u8Channel]->pChannelConfigPC->u8LinHwChannel;

    /* Check if the command buffer is not already used by other command request */
    if (0x0U == LLCE_HOST2TX_GET_STATUS_INTERRUPT(u8HwCtrl))
    {
        /* Configure the command id. */
       Lin_xSharedMemory.Lin_aCmd[u8HwCtrl].eCmdId = LLCE_LIN_CMD_WAKEUPINTERNAL;

        /* Send the command prepared above to the LLCE in order to be executed */
        eLlceReturn = Lin_Llce_ExecuteIfCommand(u8HwCtrl);

        switch (eLlceReturn)
        {
            case LLCE_LIN_SUCCESS:
                u8TmpReturn = (uint8)E_OK;
                break;
            case LLCE_LIN_ERROR_STATE:
#if (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                /* Report error to development error tracer */
                (void)Det_ReportError((uint16)LIN_43_LLCE_MODULE_ID, \
                                      (uint8)0x0U, \
                                      (uint8)LIN_43_LLCE_WAKEUPINTERNAL_ID, \
                                      (uint8)LIN_43_LLCE_E_STATE_TRANSITION \
                                     );
#endif /* (LIN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
                u8TmpReturn = (uint8)E_NOT_OK;
                break;
            default:
                u8TmpReturn = (uint8)E_NOT_OK;
                break;
        }
    }

    return u8TmpReturn;
}

#if (LIN_43_LLCE_MASTER_NODE_USED == STD_ON)
/**
* @internal
* @brief   Gets the status of the LIN driver when Channel is operating.
* @details This function returns the state of the current
*          transmission, reception or operation status.
*          If the reception of a Slave response was successful then
*          this service provides a pointer to the buffer where the
*          data is stored.
*
* @param[in]   Channel LIN channel to be addressed
* @param[out]  pu8LinSduPtr pointer to pointer to a shadow buffer or memory
*              mapped LIN Hardware receive buffer where the current SDU is
*              stored
* @return                  Lin_StatusType.
* @retval LIN_NOT_OK       Development or production error raised
*                          none of the below conditions.
* @retval LIN_TX_OK        Successful transmission.
* @retval LIN_TX_BUSY      Ongoing transmission of header or response.
* @retval LIN_TX_HEADER_ERROR Error occurred during header
*                          transmission.
* @retval LIN_TX_ERROR     Error occurred during response
*                          transmission.
* @retval LIN_RX_OK        Reception of correct response.
* @retval LIN_RX_BUSY      Ongoing reception where at least one byte
*                          has been received.
* @retval LIN_RX_ERROR     Error occurred during reception.
* @retval LIN_RX_NO_RESPONSE No data byte has been received yet.
* @retval LIN_OPERATIONAL  Channel is ready for next header.
*                          transmission and no data is available.
* @retval LIN_CH_SLEEP     Channel is in sleep mode.
*
*
* @implements Lin_Llce_HardwareGetStatus_Activity
*
*/
Lin_StatusType Lin_Llce_HardwareGetStatus(const uint8 u8Channel, \
                                          uint8 ** pu8LinSduPtr \
                                         )
{
    uint8 u8HwCtrl = 0x0U;
    Lin_StatusType u8tempReturn = LIN_NOT_OK;
    Llce_Lin_StatusType u8LlceReturn = LLCE_LIN_NOT_OK;

    u8HwCtrl = Lin_43_LLCE_pChannelConfigPtr[u8Channel]->pChannelConfigPC->u8LinHwChannel;

    /* Check if the command buffer is not already used by other command request */
    if (0x0U == LLCE_HOST2TX_GET_STATUS_INTERRUPT(u8HwCtrl))
    {
        /* Configure the command id. */
        Lin_xSharedMemory.Lin_aCmd[u8HwCtrl].eCmdId = LLCE_LIN_CMD_GETSTATUS;

         /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_LIN_SUCCESS == Lin_Llce_ExecuteIfCommand(u8HwCtrl))
        {
            u8LlceReturn = Lin_xSharedMemory.Lin_aCmd[u8HwCtrl].CmdList.GetStatus.u8ControllerStatus;

            switch (u8LlceReturn)
            {
                case LLCE_LIN_NOT_OK:
                    u8tempReturn = LIN_NOT_OK;
                    break;
                case LLCE_LIN_TX_OK:
                    u8tempReturn = LIN_TX_OK;
                    break;
                case LLCE_LIN_TX_BUSY:
                    u8tempReturn = LIN_TX_BUSY;
                    break;
                case LLCE_LIN_TX_HEADER_ERROR:
                    u8tempReturn = LIN_TX_HEADER_ERROR;
                    break;
                case LLCE_LIN_TX_ERROR:
                    u8tempReturn = LIN_TX_ERROR;
                    break;
                case LLCE_LIN_RX_OK:
                    u8tempReturn = LIN_RX_OK;
                    break;
                case LLCE_LIN_RX_BUSY:
                    u8tempReturn = LIN_RX_BUSY;
                    break;
                case LLCE_LIN_RX_ERROR:
                    u8tempReturn = LIN_RX_ERROR;
                    break;
                case LLCE_LIN_RX_NO_RESPONSE:
                    u8tempReturn = LIN_RX_NO_RESPONSE;
                    break;
                case LLCE_LIN_OPERATIONAL:
                    u8tempReturn = LIN_OPERATIONAL;
                    break;
                case LLCE_LIN_CH_SLEEP:
                    u8tempReturn = LIN_CH_SLEEP;
                    break;
                default:
                    u8tempReturn = LIN_NOT_OK;
                    break;
            }

            /* If the message was successfully received send the data to the upper layer. */
            if (LIN_RX_OK == u8tempReturn)
            {
                *pu8LinSduPtr = (uint8 *)Lin_xSharedMemory.aLinMb[u8HwCtrl];
            }
        }
    }

    return u8tempReturn;
}
#endif /* #if LIN_43_LLCE_MASTER_NODE_USED == STD_ON */

/**
* @internal
* @brief   This function processes notifications from Llce.
* @details This function shall manage all the ISRs from LLCE
*          on the addressed channel.
*
* @param[in]   Channel LIN channel to be addressed.
*
* @return       void.
*
* @note         Internal driver function.
*
* @implements Lin_Llce_ProcessCmdFromLlce_Activity
*
*/
void Lin_Llce_ProcessCmdFromLlce(const uint8 u8HwCtrl)
{
#if (LIN_43_LLCE_SLAVE_NODE_USED == STD_ON)
    uint8  u8LogicCtrl;
#endif /* #if (LIN_43_LLCE_SLAVE_NODE_USED == STD_ON) */
    Llce_Lin_CommandIdType eCmdId;

    /* Check if the driver was initialized */
    if (LIN_43_LLCE_INIT == Lin_u8LinDrvStatus)
    {
        /* Read the command id. */
        eCmdId = Lin_xSharedMemory.Lin_aNotif[u8HwCtrl].eCmdId;
        
#if (LIN_43_LLCE_SLAVE_NODE_USED == STD_ON)
        /* Calculate logic controller index. */
        u8LogicCtrl = Lin_au8Hw2LogicCtrlMap[u8HwCtrl];
#endif /* #if (LIN_43_LLCE_SLAVE_NODE_USED == STD_ON) */

        switch (eCmdId)
        {
            /* Notify the wakeup to LinIf */
            case LLCE_LIN_CMD_WAKEUP_CONFIRMATION:
                Lin_Llce_WakeupConfirmation(u8HwCtrl);
                break;
#if (LIN_43_LLCE_SLAVE_NODE_USED == STD_ON)
            /* Convert the Error reported by FW to ASR types and notify it to LinIf. */
            case LLCE_LIN_CMD_ERROR_INDICATION:
                Lin_Llce_ErrorIndication(u8HwCtrl);
                break;
            /* Send the Header to LinIf and the return the result to the FW. FW will wait for the result. */
            case LLCE_LIN_CMD_HEADER_INDICATION:
                Lin_Llce_HeaderIndication(u8HwCtrl);
                break;
            /* Notify the RX event to LinIf. */
            case LLCE_LIN_CMD_RX_INDICATION:
                LinIf_RxIndication((NetworkHandleType)u8LogicCtrl, (uint8*)Lin_xSharedMemory.aLinMb[u8HwCtrl]);
                break;
            /* Notify the TX event to LinIf. */
            case LLCE_LIN_CMD_TX_CONFIRMATION:
                LinIf_TxConfirmation((NetworkHandleType)u8LogicCtrl);
                break;
#endif /* #if (LIN_43_LLCE_SLAVE_NODE_USED == STD_ON) */
            default:
                /* Unknown command. */
                break;
        }
    }
}

#define LIN_43_LLCE_STOP_SEC_CODE
#include "Lin_43_LLCE_MemMap.h"

#ifdef __cplusplus
}
#endif
/** @} */


===== 文件 [11/11]: src\Lin_Llce_Irq.c =====
/**
*   @file    Lin_Llce_Irq.c
*   @implements Lin_Llce_Irq.c_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Lin - File used by LIN that contain the ISRs.
*   @details This file contains the ISR functions used to serve the LIN interrupts.
*
*   @addtogroup LIN_LLCE
*   @{
*/
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2006-2016 Freescale Semiconductor, Inc.
*   Copyright 2020-2025 NXP
*   All Rights Reserved.
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
*   accordance with the applicable license terms.
*   By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
*   the software, you are agreeing that you have read, and that you agree to comply with and are bound
*   by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
*   may not retain, install, activate or otherwise use the software.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/

#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
/**
* @file           Lin_Irq.c
*/
#include "Lin_43_LLCE.h"
#include "Lin_Llce.h"
#include "Llce_InterfaceCore2Core.h"
#include "Llce_InterfaceLinTypes.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/**
* @file           Lin_Irq.c
*/
#define LIN_LLCE_IRQ_VENDOR_ID_C                    43
#define LIN_LLCE_IRQ_AR_RELEASE_MAJOR_VERSION_C     4
#define LIN_LLCE_IRQ_AR_RELEASE_MINOR_VERSION_C     4
#define LIN_LLCE_IRQ_AR_RELEASE_REVISION_VERSION_C  0
#define LIN_LLCE_IRQ_SW_MAJOR_VERSION_C             1
#define LIN_LLCE_IRQ_SW_MINOR_VERSION_C             0
#define LIN_LLCE_IRQ_SW_PATCH_VERSION_C             10

/*==================================================================================================
*                                      FILE VERSION CHECKS
==================================================================================================*/
/* Check if current file and Lin header file are of the same vendor */
#if (LIN_LLCE_IRQ_VENDOR_ID_C != LIN_43_LLCE_VENDOR_ID)
    #error "Lin_Irq.c and Lin_43_LLCE.h have different vendor ids"
#endif
/* Check if current file and Lin_43_LLCE.h header file are of the same Autosar version */
#if (((LIN_LLCE_IRQ_AR_RELEASE_MAJOR_VERSION_C   != LIN_43_LLCE_AR_RELEASE_MAJOR_VERSION) || \
      (LIN_LLCE_IRQ_AR_RELEASE_MINOR_VERSION_C    != LIN_43_LLCE_AR_RELEASE_MINOR_VERSION)) || \
     (LIN_LLCE_IRQ_AR_RELEASE_REVISION_VERSION_C != LIN_43_LLCE_AR_RELEASE_REVISION_VERSION) \
    )
    #error "AutoSar Version Numbers of Lin_Irq.c and Lin_43_LLCE.h are different"
#endif
/* Check if current file and Lin_43_LLCE.h header file are of the same Software version */
#if ((LIN_LLCE_IRQ_SW_MAJOR_VERSION_C != LIN_43_LLCE_SW_MAJOR_VERSION) || \
     (LIN_LLCE_IRQ_SW_MINOR_VERSION_C != LIN_43_LLCE_SW_MINOR_VERSION) || \
     (LIN_LLCE_IRQ_SW_PATCH_VERSION_C != LIN_43_LLCE_SW_PATCH_VERSION) \
    )
    #error "Software Version Numbers of Lin_Irq.c and Lin_43_LLCE.h are different"
#endif
/* Check if current file and Lin_Llce header file are of the same vendor */
#if (LIN_LLCE_IRQ_VENDOR_ID_C != LIN_LLCE_VENDOR_ID)
    #error "Lin_Irq.c and Lin_Llce.h have different vendor ids"
#endif
/* Check if current file and Lin_Llce header file are of the same Autosar version */
#if ((LIN_LLCE_IRQ_AR_RELEASE_MAJOR_VERSION_C    != LIN_LLCE_AR_RELEASE_MAJOR_VERSION) || \
     (LIN_LLCE_IRQ_AR_RELEASE_MINOR_VERSION_C    != LIN_LLCE_AR_RELEASE_MINOR_VERSION) || \
     (LIN_LLCE_IRQ_AR_RELEASE_REVISION_VERSION_C != LIN_LLCE_AR_RELEASE_REVISION_VERSION) \
    )
    #error "AutoSar Version Numbers of Lin_Irq.c and Lin_Llce.h are different"
#endif
/* Check if current file and Lin_Llce header file are of the same Software version */
#if ((LIN_LLCE_IRQ_SW_MAJOR_VERSION_C != LIN_LLCE_SW_MAJOR_VERSION) || \
     (LIN_LLCE_IRQ_SW_MINOR_VERSION_C != LIN_LLCE_SW_MINOR_VERSION) || \
     (LIN_LLCE_IRQ_SW_PATCH_VERSION_C != LIN_LLCE_SW_PATCH_VERSION) \
    )
    #error "Software Version Numbers of Lin_Irq.c and Lin_Llce.h are different"
#endif
/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL VARIABLES
==================================================================================================*/


/*==================================================================================================
*                                       GLOBAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                       GLOBAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
#define LIN_43_LLCE_START_SEC_CODE
#include "Lin_43_LLCE_MemMap.h"

ISR(Lin_CmdFromLlceIsr);

/**
* @brief   This is the interrupt service routine used for notifications from LLCE.
* @details This is the interrupt service routine used for notifications from LLCE.
*
* @implements Lin_CmdFromLlceIsr_Activity
*
*/
ISR(Lin_CmdFromLlceIsr)
{
    uint8  u8HwCtrl;
    uint32 u32TempFlag;
    uint32 u32IntrStatusFlags;
    uint32 u32IntrEnable;

    /*Read contents of interrupt concentrator register.*/
    u32IntrStatusFlags = Reg_Read32(LLCE_CORE2CORE_HINTC2R);

    u32IntrEnable = Reg_Read32(LLCE_CORE2CORE_HINTC2ER);

    /*Check all bit fields from interrupt concentrator register. */
    for (u8HwCtrl=0; u8HwCtrl < LLCE_LIN_MAXCTRL_COUNT; u8HwCtrl++)
    {
        u32TempFlag = (((uint32)0x1U) << ((uint32)u8HwCtrl));

        /* Check if the value of the concentrator status flag. */
        if (u32TempFlag == (u32IntrStatusFlags & u32TempFlag))
        {
            /* Check if it is a spurious interrupt */
            if (u32TempFlag == (u32IntrEnable & u32TempFlag))
            {
                Lin_Llce_ProcessCmdFromLlce(u8HwCtrl);
              
              	/* Clear the interrupt status flag. */
            	LLCE_TX2HOST_CLEAR_INTERRUPT(u8HwCtrl);
            }
        }
    }
}

#define LIN_43_LLCE_STOP_SEC_CODE
#include "Lin_43_LLCE_MemMap.h"

#ifdef __cplusplus
}
#endif

/*! @} */


