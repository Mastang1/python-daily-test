# 项目路径: C:\NXP\S32G_LLCE_1_0_10\eclipse\plugins\Can_43_LLCE_TS_T40D11M10I10R0
# 打包时间: 当前日期: 2025/12/29 周一 
输入新日期: (年月日)
# 共打包 112 个源文件（已自动排除二进制文件）
#================================================================================

===== 文件 [1/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\Project_Settings\Startup_Code\Vector_Table.s =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
*   @file    Vector_Table.s
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - Vector Table.
*   @details Vector Table.
*            This file contains sample code only. It is not part of the production code deliverables
==================================================================================================*/

.section  ".intc_vector","ax"
.align 2
.thumb
.globl undefined_handler
.globl undefined_handler
.globl VTABLE
.globl __Stack_dtcm_start        /* Top of Stack for Initial Stack Pointer */
.globl Reset_Handler             /* Reset Handler */
.globl NMI_Handler               /* NMI Handler */
.globl HardFault_Handler         /* Hard Fault Handler */
.globl MemManage_Handler         /* Reserved */
.globl BusFault_Handler          /* Bus Fault Handler */
.globl UsageFault_Handler        /* Usage Fault Handler */
.globl SVC_Handler               /* SVCall Handler */
.globl DebugMon_Handler          /* Debug Monitor Handler */
.globl PendSV_Handler            /* PendSV Handler */
.globl SysTick_Handler           /* SysTick Handler */ /* 15*/

VTABLE:
.long __Stack_dtcm_start          /* Top of Stack for Initial Stack Pointer */
.long Reset_Handler+1           /* Reset Handler need plus 1 because Reset_Handler is generated with LSB bit =0*/
.long NMI_Handler               /* NMI Handler */
.long HardFault_Handler         /* Hard Fault Handler */
.long MemManage_Handler         /* Reserved */
.long BusFault_Handler          /* Bus Fault Handler */
.long UsageFault_Handler        /* Usage Fault Handler */
.long 0                         /* Reserved */
.long 0                         /* Reserved */
.long 0                         /* Reserved */
.long 0                         /* Reserved */
.long SVC_Handler+1             /* SVCall Handler */
.long DebugMon_Handler          /* Debug Monitor Handler */
.long 0                         /* Reserved */
.long PendSV_Handler            /* PendSV Handler */
.long SysTick_Handler           /* SysTick Handler */ /* 15*/

.long undefined_handler /*0*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*10*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*20*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*30*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler /*40*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler /*50*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*60*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*70*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*80*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*90*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*100*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*110*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*120*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*130*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*140*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*150*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*160*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*170*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*180*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*190*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*200*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*210*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*220*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*230*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*240*/
.long undefined_handler




.size VTABLE, . - VTABLE


===== 文件 [2/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\Project_Settings\Startup_Code\exceptions.c =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
*   @file    exceptions.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - Interrupts table.
*   @details Interrupts table.
*            This file contains sample code only. It is not part of the production code deliverables.
==================================================================================================*/

#ifdef __cplusplus
extern "C" {
#endif

#include "Platform_Types.h"
#include "Mcal.h"

#define PLATFORM_START_SEC_CODE
#include "Platform_MemMap.h"

void NMI_Handler(void)                  __attribute__ ((weak));               /* NMI Handler */
void HardFault_Handler(void)            __attribute__ ((weak));         /* Hard Fault Handler */
void MemManage_Handler(void)            __attribute__ ((weak));         /* Reserved */
void BusFault_Handler(void)             __attribute__ ((weak));          /* Bus Fault Handler */
void UsageFault_Handler(void)           __attribute__ ((weak));        /* Usage Fault Handler */
void DebugMon_Handler(void)             __attribute__ ((weak));          /* Debug Monitor Handler */
void PendSV_Handler(void)               __attribute__ ((weak));            /* PendSV Handler */
void SysTick_Handler(void)              __attribute__ ((weak));           /* SysTick Handler */
void undefined_handler(void);         /* Undefined Handler */
#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
void SVCHandler_main(uint32 * svc_args);
void Suspend_Interrupts(void);
void Resume_Interrupts(void);
#endif

#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
#ifndef __ICCARM__
#ifdef _DIABDATA_C_S32G2XX_
/* Define the SVC handler in assembly, to ensure there is no extra PUSH instruction at the beginning of the C handler.*/
__asm(".section .mcal_text");
__asm(".globl SVC_Handler");
__asm(".weak SVC_Handler");
__asm("SVC_Handler:");
/*Load in R0 the stack pointer (depneding on context from which SVC is called)*/
__asm("tst     lr, #4");
__asm("ite eq");
__asm("mrseq   r0, MSP");
__asm("mrsne   r0, PSP");
/* stack pointer is passed to SVCHandler_main, it will be used to extract the parameter given to svc call*/
__asm("b       SVCHandler_main");
#else
/* Define the SVC handler in assembly, to ensure there is no extra PUSH instruction at the beginning of the C handler.*/
ASM_KEYWORD(".globl SVC_Handler");
ASM_KEYWORD(".weak SVC_Handler");
ASM_KEYWORD("SVC_Handler:");
/*Load in R0 the stack pointer (depneding on context from which SVC is called)*/
ASM_KEYWORD("tst     lr, #4");
ASM_KEYWORD("ite eq");
ASM_KEYWORD("mrseq   r0, MSP");
ASM_KEYWORD("mrsne   r0, PSP");
/* stack pointer is passed to SVCHandler_main, it will be used to extract the parameter given to svc call*/
ASM_KEYWORD("b       SVCHandler_main");
#endif
#else
void SVC_Handler(void) __attribute__((naked, weak));
void SVC_Handler(void)
{
    ASM_KEYWORD("tst lr, #4\n"\
                "ite eq\n" \
                "mrseq   r0, MSP\n" \
                "mrsne   r0, PSP\n");
    /* stack pointer is passed to SVCHandler_main, it will be used to extract the parameter given to svc call*/
    ASM_KEYWORD("b       SVCHandler_main");
}
#endif
#endif


void NMI_Handler(void)
{
    while(TRUE){};
}
void HardFault_Handler(void)
{
    while(TRUE){};
}
void MemManage_Handler(void)
{
    while(TRUE){};
}
void BusFault_Handler(void)
{
    while(TRUE){};
}
void UsageFault_Handler(void)
{
    while(TRUE){};
}

#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
void SVC_Handler(void)  __attribute__ ((weak));               /* SVCall Handler */
void SVC_Handler(void)
{
    while(TRUE){};
}
#else
void SVCHandler_main(uint32 * svc_args)
{
    uint32 svc_number;    /* Stack contains:    * r0, r1, r2, r3, r12, r14, the return address and xPSR   */
                                /* First argument (r0) is svc_args[0]  */
    /* svc_args[6] =  SP + 0x18  PC(r15) */
    /* ((char *)svc_args[6])[-2]; = first two bytes, lsb, of the instruction which caused the SVC */
    /* this will nto work if optimization compiler options are changed*/
    svc_number = ((uint8 *)svc_args[6])[-2];
    switch(svc_number)
    {
        case 1:
            /* Handle SVC 01*/
            ASM_KEYWORD("mov   r0, #0x1");   /* Set User mode for Thread mode */
            ASM_KEYWORD("msr   CONTROL, r0");
            break;
        case 0:
            /* Handle SVC 00*/
            ASM_KEYWORD("mov   r0, #0x0");   /* Set Supervisor mode for Thread mode */
            ASM_KEYWORD("msr   CONTROL, r0");
            break;
        case 2:
            /* Handle SVC 02*/
            Resume_Interrupts(); /* Resume all interrupts */
            
            break;
        case 3:
            /* Handle SVC 03*/
            Suspend_Interrupts(); /* Suspend all interrupts */

            break;
        default:
            /* Unknown SVC*/
            break;
    }
}

void Suspend_Interrupts(void)
{
    ASM_KEYWORD("push {r0}");
    ASM_KEYWORD("mov   r0, #0x10");
    ASM_KEYWORD(" msr BASEPRI, r0");
    ASM_KEYWORD("pop {r0}");
}

void Resume_Interrupts(void)
{
    ASM_KEYWORD("push {r0}");
    ASM_KEYWORD("mov   r0, #0x0");
    ASM_KEYWORD("msr BASEPRI, r0");
    ASM_KEYWORD("pop {r0}");
}
#endif
void DebugMon_Handler(void)
{
    while(TRUE){};
}
void PendSV_Handler(void)
{
    while(TRUE){};
}
void SysTick_Handler(void)
{
    while(TRUE){};
}
void undefined_handler(void)
{
   while(TRUE){};
}

#define PLATFORM_STOP_SEC_CODE
#include "Platform_MemMap.h"

#ifdef __cplusplus
}
#endif


===== 文件 [3/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\Project_Settings\Startup_Code\nvic.c =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
*   @file    nvic.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - nvic driver
*   @details Functions that manage interrupts and exceptions via the NVIC.
*            This file contains sample code only. It is not part of the production code deliverables.
==================================================================================================*/

#include "Std_Types.h"
#include "nvic.h"

#if defined(S32G2XX)
    #include "S32G274A_NVIC.h"
    #include "S32G274A_SCB.h"
#elif defined(S32R45)
    #include "S32R45_SCB.h"
    #include "S32R45_NVIC.h"
#elif defined(S32G3XX)
    #include "S32G399A_SCB.h"
    #include "S32G399A_NVIC.h"
#endif


/*==================================================================================================
*                                        LOCAL MACROS
==================================================================================================*/
/*==================================================================================================
*                                      FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL VARIABLES
==================================================================================================*/
#define FEATURE_NVIC_PRIO_BITS (4U)

/*==================================================================================================
*                                       GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/*================================================================================================*/
#define PLATFORM_START_SEC_CODE
#include "Platform_MemMap.h"
/** 
* @brief Set Priority Grouping
* @details The function sets the priority grouping field using the required unlock sequence.
*  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
*   Only values from 0..7 are used.
*   In case of a conflict between priority grouping and available
*   priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set
*/
/*================================================================================================*/
void NVIC_SetPriorityGrouping(uint32 PriorityGroup)
{
    /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
    S32_SCB->AIRCR = (S32_SCB->AIRCR & (~0x700UL)) | PriorityGroup;
}

/*================================================================================================*/
/** 
* @brief Enable External Interrupt
* @details The function enables a device-specific interrupt in the NVIC interrupt controller.
*/
/*================================================================================================*/ 
void NVIC_EnableIRQ(uint8 IRQn)
{
    S32_NVIC->ISER[(uint32)(IRQn) >> 5U] = (uint32)(1UL << ((uint32)(IRQn) & (uint32)0x1FU));
}

/*================================================================================================*/
/** 
* @brief Disable External Interrupt
* @details The function disables a device-specific interrupt in the NVIC interrupt controller
*/
/*================================================================================================*/  
void NVIC_DisableIRQ(uint8 IRQn)
{
    S32_NVIC->ICER[(uint32)(IRQn) >> 5U] = (uint32)(1UL << ((uint32)(IRQn) & (uint32)0x1FU));
}
 
 
/*================================================================================================*/
/** 
* @brief Set Interrupt Priority
* @details The function sets the priority of an interrupt.
*/
/*================================================================================================*/  
void NVIC_SetPriority(uint8 IRQn, uint8 priority)
{
    uint8 shift = (uint8) (8U - FEATURE_NVIC_PRIO_BITS);
    S32_NVIC->IP[(uint32)(IRQn)] = (uint8)(((((uint32)priority) << shift)) & 0xFFUL);
}
 
 
#define PLATFORM_STOP_SEC_CODE
#include "Platform_MemMap.h"


===== 文件 [4/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\Project_Settings\Startup_Code\startup.c =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/
/**
*   @implements startup.c_Artifact
*/

#include "Std_Types.h"

/*******************************************************************************
 * Definitions
 *******************************************************************************/
#if (CPU_TYPE == CPU_TYPE_64)
    typedef uint64 uintptr;
#elif (CPU_TYPE == CPU_TYPE_32)
    typedef uint32 uintptr;
#elif (CPU_TYPE == CPU_TYPE_16)
    typedef uint16 uintptr;
#else
    typedef uint8 uintptr;
#endif

 /*!
 * @brief Defines the init table layout
 */
typedef struct
{
    uint32 * ram_start; /*!< Start address of section in RAM */
    uint32 * rom_start; /*!< Start address of section in ROM */
    uint32 * rom_end;   /*!< End address of section in ROM */
} Sys_CopyLayoutType;

/*!
 * @brief Defines the zero table layout
 */
typedef struct
{
    uint32 * ram_start; /*!< Start address of section in RAM */
    uint32 * ram_end;   /*!< End address of section in RAM */
} Sys_ZeroLayoutType;

extern uintptr __INIT_TABLE[1U];
extern uintptr __ZERO_TABLE[1U];
extern uintptr __INDEX_COPY_CORE2[];
#if (defined(__ARMCC_VERSION))
    extern uintptr __VECTOR_RAM;
#else
    extern uintptr __VECTOR_RAM[1U];
#endif

/*******************************************************************************
 * Static Variables
 ******************************************************************************/

/*******************************************************************************
 * Code
 ******************************************************************************/
/*FUNCTION**********************************************************************
 *
 * Function Name : init_data_bss
 * Description   : Make necessary initializations for RAM.
 * - Copy the vector table from ROM to RAM.
 * - Copy initialized data from ROM to RAM.
 * - Copy code that should reside in RAM from ROM
 * - Clear the zero-initialized data section.
 *
 * Tool Chains:
 *   __GNUC__           : GNU Compiler Collection
 *   __ghs__            : Green Hills ARM Compiler
 *   __ICCARM__         : IAR ARM Compiler
 *   __DCC__            : Wind River Diab Compiler
 *   __ARMCC_VERSION    : ARMC Compiler
 *
 * Implements    : init_data_bss_Activity
 *END**************************************************************************/
#define PLATFORM_START_SEC_CODE
#include "Platform_MemMap.h"
 
void init_data_bss(void);
void init_data_bss_core2(void);

void init_data_bss(void)
{
    const Sys_CopyLayoutType * copy_layout;
    const Sys_ZeroLayoutType * zero_layout;
    const uint32 * rom;
    const uint8 * rom8;
    uint32 * ram;
    uint8 * ram8;
    uint8 dataPad;
    uint32 len = 0U;
    uintptr size = 0U;
    uint32 i = 0U;
    uint32 j = 0U;

    const uintptr * initTable_Ptr = (uintptr*)__INIT_TABLE;
    const uintptr * zeroTable_Ptr = (uintptr*)__ZERO_TABLE;

    /* Copy initialized table */
    len = *initTable_Ptr;
    initTable_Ptr++;
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
    for(i = 0U; i < len; i++)
    {
        rom = copy_layout[i].rom_start;
        ram = copy_layout[i].ram_start;
        size = (uintptr)copy_layout[i].rom_end - (uintptr)copy_layout[i].rom_start;
        /* Make sure the data area to be copied must be aligned with 4. Then, copy 4 bytes at per one read */
        dataPad = size & 0x3U;
        for(j = 0U; j < ((size - dataPad) >> 2U); j++)
        {
            ram[j] = rom[j];
        }
        /* For the rest of data, copy 1 bytes at per one read */
        rom8 = (uint8 *)&(rom[j]);
        ram8 = (uint8 *)&(ram[j]);
        for (j = 0U; j < dataPad; j++)
        {
            ram8[j] = rom8[j];
        }
    }

    /* Clear zero table */
    len = *zeroTable_Ptr;
    zeroTable_Ptr++;
    zero_layout = (const Sys_ZeroLayoutType *)zeroTable_Ptr;
    for(i = 0U; i < len; i++)
    {
        ram = zero_layout[i].ram_start;
        size = (uintptr)zero_layout[i].ram_end - (uintptr)zero_layout[i].ram_start;
        for(j = 0U; j < (size >> 2U); j++)
        {
            ram[j] = 0U;
        }
        /* Since the size of the section always aligns with 32bits according to the sample file linker. 
           Zeroing the last 4 bytes of the section if the data to be used of program does not align with 4.*/
        if ((size & 0x3U) != 0U)
        {
            ram[j] = 0U;
        }
    }
}

void init_data_bss_core2(void)
{
    const Sys_CopyLayoutType * copy_layout;
    const uint32 * rom;
    const uint8 * rom8;
    uint32 * ram;
    uint8 * ram8;
    uint8 dataPad;
    uint32 len = 0U;
    uintptr size = 0U;
    uint32 i = 0U;
    uint32 j = 0U;

    const uintptr * initTable_Ptr = (uintptr*)__INIT_TABLE;

    /* Copy initialized table */
    len = *initTable_Ptr;
    initTable_Ptr++;
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
    for(i = (uintptr)__INDEX_COPY_CORE2; i < len; i++)
    {
        rom = copy_layout[i].rom_start;
        ram = copy_layout[i].ram_start;
        size = (uintptr)copy_layout[i].rom_end - (uintptr)copy_layout[i].rom_start;
        /* Make sure the data area to be copied must be aligned with 4. Then, copy 4 bytes at per one read */
        dataPad = size & 0x3U;
        for(j = 0U; j < ((size - dataPad) >> 2U); j++)
        {
            ram[j] = rom[j];
        }
        /* For the rest of data, copy 1 bytes at per one read */
        rom8 = (uint8 *)&(rom[j]);
        ram8 = (uint8 *)&(ram[j]);
        for (j = 0U; j < dataPad; j++)
        {
            ram8[j] = rom8[j];
        }
    }
}
#define PLATFORM_STOP_SEC_CODE
#include "Platform_MemMap.h"

/*******************************************************************************
 * EOF
 ******************************************************************************/


===== 文件 [5/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\Project_Settings\Startup_Code\startup_cm7.s =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
*   @file    startup_cm7.s
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - Startup file for ARM.
*   @details Startup file for ARM.
*            This file contains sample code only. It is not part of the production code deliverables
==================================================================================================*/

#define MAIN_CORE 4
#define CM7_ITCMCR 0xE000EF90
#define CM7_DTCMCR 0xE000EF94

#define SBAF_BOOT_MARKER   (0x5AA55AA5)
#define CM7_0_ENABLE_SHIFT (0)
#define CM7_1_ENABLE_SHIFT (1)

#define CM7_0_ENABLE            (1)
#define CM7_1_ENABLE            (0)
#define CM7_0_VTOR_ADDR         (__INIT_INTERRUPT_START)
#define CM7_1_VTOR_ADDR         (0)
#define XRDC_CONFIG_ADDR        (0)
#define LF_CONFIG_ADDR          (0)

    .syntax unified
    .arch armv7-m
/* Table for copying and zeroing */
/* Copy table:
  - Table entries count
    - entry one ram start
    - entry one rom start
    - entry one rom end
    ...
    - entry n ram start
    - entry n rom start
    - entry n rom end
  Zero Table:
    - Table entries count
      - entry one ram start
      - entry one ram end
*/
.section ".init_table", "a"
  .long 6
  .long __RAM_CACHEABLE_START
  .long __ROM_CACHEABLE_START
  .long __ROM_CACHEABLE_END
  .long __RAM_NO_CACHEABLE_START
  .long __ROM_NO_CACHEABLE_START
  .long __ROM_NO_CACHEABLE_END
  .long __RAM_SHAREABLE_START
  .long __ROM_SHAREABLE_START
  .long __ROM_SHAREABLE_END
  .long __HSE_RAM_SHAREABLE_START
  .long __HSE_ROM_SHAREABLE_START
  .long __HSE_ROM_SHAREABLE_END
  .long __RAM_INTERRUPT_START
  .long __INIT_INTERRUPT_START
  .long __INIT_INTERRUPT_END
  .long __RAM_DTCM_START
  .long __ROM_DTCM_START
  .long __ROM_DTCM_END
.section ".zero_table", "a"
  .long 4
  .long __BSS_SRAM_SH_START
  .long __BSS_SRAM_SH_END
  .long __BSS_HSE_SRAM_SH_START
  .long __BSS_HSE_SRAM_SH_END
  .long __BSS_SRAM_NC_START
  .long __BSS_SRAM_NC_END
  .long __BSS_SRAM_START
  .long __BSS_SRAM_END

.globl RESET_CATCH_CORE
.globl _core_loop
.section ".core_loop","ax"
.thumb

_core_loop:
    nop
    nop
    nop
    nop
    b _core_loop

.section ".boot_header","ax"
  .long SBAF_BOOT_MARKER /* IVT marker */
  .long (CM7_0_ENABLE << CM7_0_ENABLE_SHIFT) | (CM7_1_ENABLE << CM7_1_ENABLE_SHIFT) /* Boot configuration word */
  .long 0 /* Reserved */
  .long CM7_0_VTOR_ADDR /* CM7_0 Start address */
  .long 0 /* Reserved */
  .long CM7_1_VTOR_ADDR /* CM7_1 Start address */
  .long 0 /* Reserved */
  .long XRDC_CONFIG_ADDR /* XRDC configuration pointer */
  .long LF_CONFIG_ADDR /* Lifecycle configuration pointer */
  .long 0 /* Reserved */

.globl VTABLE
.section ".startup","ax"
.thumb
/************************************************************************/
/* Autosar synopsis of startup code (See MCU Specification):            */
/*                                                                      */
/*   Before the MCU driver can be initialized, a basic initialization   */
/*   of the MCU has to be executed. This MCU specific initialization is */
/*   typically executed in a start-up code. The start-up code of the    */
/*   MCU shall be executed after power up and any kind of micro-        */
/*   controller reset. It shall perform very basic and microcontroller  */
/*   specific start-up initialization and shall be kept short, because  */
/*   the MCU clock and PLL is not yet initialized. The start-up code    */
/*   shall cover MCU specific initialization, which is not part of      */
/*   other MCU services or other MCAL drivers. The following steps      */
/*   summarizes basic functionality which shall be included in the      */
/*   start-up code. They are listed for guidance, because some          */
/*   functionality might not be supported. No code will be found in     */
/*   case.                                                              */
/************************************************************************/
.set VTOR_REG, 0xE000ED08
.thumb 
.thumb_func
.globl Reset_Handler
.globl _start
_start:
Reset_Handler:
/*****************************************************/
/* Skip normal entry point as nothing is initialized */
/*****************************************************/
 cpsid i
 mov   r0, #0
 mov   r1, #0
 mov   r2, #0
 mov   r3, #0
 mov   r4, #0
 mov   r5, #0
 mov   r6, #0
 mov   r7, #0


/*******************************************************************/
/* NXP Guidance 1 - Init registers to avoid lock-step issues */
/* N/A                                                             */
/*******************************************************************/

/*******************************************************************/
/* NXP Guidance 2 - MMU Initialization for CPU               */
/*  TLB0 - PbridgeB                                                */
/*  TLB1 - Internal Flash                                          */
/*  TLB2 - External SRAM                                           */
/*  TLB3 - Internal SRAM                                           */
/*  TLB4 - PbridgeA                                                */
/*******************************************************************/

/******************************************************************/
/* Autosar Guidance 1 - The start-up code shall initialize the    */
/* base addresses for interrupt and trap vector tables. These base*/
/* addresses are provided as configuration parameters or          */
/* linker/locator setting.                                        */
/******************************************************************/

/* relocate vector table to RAM */
ldr  r0, =VTOR_REG
ldr  r1, =__RAM_INTERRUPT_START
str  r1,[r0]

/******************************************************************/
/* Autosar Guidance 2 - The start-up code shall initialize the    */
/* interrupt stack pointer, if an interrupt stack is              */
/* supported by the MCU. The interrupt stack pointer base address */
/* and the stack size are provided as configuration parameter or  */
/* linker/locator setting.                                        */
/*                                                                */
/******************************************************************/


/******************************************************************/
/* Autosar Guidance 3 - The start-up code shall initialize the    */
/* user stack pointer. The user stack pointer base address and    */
/* the stack size are provided as configuration parameter or      */
/* linker/locator setting.                                        */
/******************************************************************/
/* Enable TCM and Disable RETEN bit */
ldr r1, =CM7_DTCMCR
ldr r0, [r1]
bic r0, r0, #0x4
orr r0, r0, #0x1
str r0, [r1]
/* set up stack; r13 SP*/
ldr  r0, =__Stack_dtcm_start
msr MSP, r0
/*GetCoreID*/
ldr  r0, =0x40198004
ldr  r1,[r0]

ldr  r0, =MAIN_CORE
cmp  r1,r0
beq  DisableSWT0

ldr  r0, =0x5
cmp  r1,r0
beq  DisableSWT1

ldr  r0, =0x6
cmp  r1,r0
beq  DisableSWT2

ldr  r0, =0x7
cmp  r1,r0
beq  DisableSWT7

/******************************************************************/
/* Autosar Guidance 4 - If the MCU supports context save          */
/* operation, the start-up code shall initialize the memory which */
/* is used for context save operation. The maximum amount of      */
/* consecutive context save operations is provided as             */
/* configuration parameter or linker/locator setting.             */
/*                                                                */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 5 - The start-up code shall ensure that the   */
/* MCU internal watchdog shall not be serviced until the watchdog */
/* is initialized from the MCAL watchdog driver. This can be      */
/* done for example by increasing the watchdog service time.      */
/*                                                                */
/******************************************************************/

/* Note from manual: For any operation to be performed on an SWT  */
/* instance, its respective core must be enabled.                 */
DisableSWT0:
  ldr  r0, =0x40100010
  ldr  r1, =0xC520
  str  r1, [r0]
  ldr  r1, =0xD928
  str  r1, [r0]
  ldr  r0, =0x40100000
  ldr  r1, =0xFF000040
  str  r1, [r0]
  b    RamInit

DisableSWT1:
  /* disable SWT1 */
  ldr  r0, =0x40104010
  ldr  r1, =0xC520
  str  r1, [r0]
  ldr  r1, =0xD928
  str  r1, [r0]
  ldr  r0, =0x40104000
  ldr  r1, =0xFF000040
  str  r1, [r0]
  b    RamInit

DisableSWT2:
  /* disable SWT2 */
  ldr  r0, =0x40108010
  ldr  r1, =0xC520
  str  r1, [r0]
  ldr  r1, =0xD928
  str  r1, [r0]
  ldr  r0, =0x40108000
  ldr  r1, =0xFF000040
  str  r1, [r0]
  b    RamInit
  

DisableSWT7:
  /* disable SWT7 */
  ldr  r0, =0x4020C010
  ldr  r1, =0xC520
  str  r1, [r0]
  ldr  r1, =0xD928
  str  r1, [r0]
  ldr  r0, =0x4020C000
  ldr  r1, =0xFF000040
  str  r1, [r0]
  b    RamInit

/******************************************************************/
/* Autosar Guidance 13 - The start-up code shall initialize a     */
/* minimum amount of RAM in order to allow proper execution of    */
/* the MCU driver services and the caller of these services.      */
/******************************************************************/
RamInit:
    /* Initialize SRAM ECC */
    ldr  r0, =__RAM_INIT
    cmp  r0, 0
    /* Skip if __SRAM_INIT is not set */
    beq SRAM_LOOP_END
    ldr r1, =__INT_SRAM_START
    ldr r2, =__INT_SRAM_END
    
    subs    r2, r1
    subs    r2, #1
    ble SRAM_LOOP_END

    movs    r0, 0
    movs    r3, 0
SRAM_LOOP:
    stm r1!, {r0,r3}
    subs r2, 8
    bge SRAM_LOOP
SRAM_LOOP_END:

DTCM_Init:
    /* Initialize DTCM ECC */
    ldr  r0, =__DTCM_INIT
    cmp  r0, 0
    /* Skip if __DTCM_INIT is not set */
    beq DTCM_LOOP_END

    ldr r1, =__INT_DTCM_START
    ldr r2, =__INT_DTCM_END
    
    subs    r2, r1
    subs    r2, #1
    ble DTCM_LOOP_END

    movs    r0, 0
    movs    r3, 0
DTCM_LOOP:
    stm r1!, {r0,r3}
    subs r2, #8
    bge DTCM_LOOP
DTCM_LOOP_END:

ITCM_Init:
    /* Initialize ITCM ECC */
    ldr  r0, =__ITCM_INIT
    cmp  r0, 0
    /* Skip if __TCM_INIT is not set */
    beq ITCM_LOOP_END

    /* Enable TCM */
    LDR r1, =CM7_ITCMCR
    LDR r0, [r1]
    LDR r2, =0x1
    ORR r0, r2
    STR r0, [r1]

    ldr r1, =__INT_ITCM_START
    ldr r2, =__INT_ITCM_END
    
    subs    r2, r1
    subs    r2, #1
    ble ITCM_LOOP_END

    movs    r0, 0
    movs    r3, 0
ITCM_LOOP:
    stm r1!, {r0,r3}
    subs r2, #8
    bge ITCM_LOOP
ITCM_LOOP_END:

DebuggerHeldCoreLoop:
  ldr  r0, =RESET_CATCH_CORE
  ldr  r0, [r0]
  ldr  r1, =0x5A5A5A5A
  cmp  r0, r1
  beq	DebuggerHeldCoreLoop

/************************/
/* Erase ".bss Section" */
/************************/
#ifndef MULTIPLE_IMAGE
_DATA_INIT:
    /* If this is the primary core, initialize data and bss */
    ldr  r0, =0x40198004
    ldr  r1,[r0]

    ldr  r0, =MAIN_CORE
    cmp  r1,r0
    beq	 _INIT_DATA_BSS
    bl   init_data_bss_core2
    b __SYSTEM_INIT
#endif

_INIT_DATA_BSS:
  bl init_data_bss


/******************************************************************/
/* Autosar Guidance 6 - If the MCU supports cache memory for data */
/* and/or code, it shall be initialized and enabled in the        */
/* start-up code.                                                 */
/*                                                                */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 7 - The start-up code shall initialize MCU    */
/* specific features of internal memory like memory protection.   */
/*                                                                */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 8 - If external memory is used, the memory    */
/* shall be initialized in the start-up code. The start-up code   */
/* shall be prepared to support different memory configurations   */
/* depending on code location. Different configuration options    */
/* shall be taken into account for code execution from            */
/* external/internal memory.                                      */
/* N/A - external memory is not used                              */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 9 - The settings of the different memories    */
/* shall be provided to the start-up code as configuration        */
/* parameters.                                                    */
/* N/A - all memories are already configured                      */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 10 - In the start-up code a default           */
/* initialization of the MCU clock system shall be performed      */
/* including global clock prescalers.                             */
/******************************************************************/
__SYSTEM_INIT:
  bl SystemInit

/******************************************************************/
/* Autosar Guidance 5 - The start-up code shall ensure that the   */
/* MCU internal watchdog shall not be serviced until the watchdog */
/* is initialized from the MCAL watchdog driver. This can be      */
/* done for example by increasing the watchdog service time.      */
/*                                                                */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 11 - The start-up code shall enable           */
/* protection mechanisms for special function registers(SFR's),   */
/* if supported by the MCU.                                       */
/* N/A - will be handled by Autosar OS                            */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 12 - The start-up code shall initialize all   */
/* necessary write once registers or registers common to several  */
/* drivers where one write, rather than repeated writes, to the   */
/* register is required or highly desirable.                      */
/******************************************************************/

/*********************************/
/* Set the small ro data pointer */
/*********************************/


/*********************************/
/* Set the small rw data pointer */
/*********************************/

/******************************************************************/
/* Call Main Routine                                              */
/******************************************************************/
_MAIN:
  cpsie i
  bl startup_go_to_user_mode
  bl main

/******************************************************************/
/* Init runtime check data space                                  */
/******************************************************************/
.globl MCAL_LTB_TRACE_OFF
 MCAL_LTB_TRACE_OFF:
    nop

#ifdef CCOV_ENABLE
    /* code coverage is requested */
    bl ccov_main
#endif

    /*BKPT #1 - removed to avoid debug fault being escalated to hardfault when debugger is not attached or on VDK*/ /* last instruction for the debugger to dump results data */
.globl _end_of_eunit_test
_end_of_eunit_test:
    b .

#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
.globl startup_getControlRegisterValue
startup_getControlRegisterValue:
mrs r0, CONTROL
bx r14

.globl startup_getAipsRegisterValue
startup_getAipsRegisterValue:
mrs r0, IPSR
bx r14
#endif

.align 4
.ltorg


===== 文件 [6/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\Project_Settings\Startup_Code\system.c =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*================================================================================================
*   @file    system.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - SYSTEM
*   @details SYSTEM
*            This file contains sample code only. It is not part of the production code deliverables.
==================================================================================================*/

#ifdef __cplusplus
extern "C" {
#endif

/*==================================================================================================
*                                         INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Platform_Types.h"
#include "Mcal.h"
#if defined(S32G2XX)
    #include "S32G274A_MSCM.h"
    #include "S32G274A_FXOSC.h"
    #include "S32G274A_MC_CGM_0.h"
    #include "S32G274A_MC_CGM_1.h"
    #include "S32G274A_MC_CGM_2.h"
    #include "S32G274A_SCB.h"
    #include "S32G274A_MPU.h"
    #include "S32G274A_MC_ME.h"
    #include "S32G274A_MC_RGM.h"
    #include "S32G274A_SECURITY.h"
    #include "S32G274A_MDM_AP.h"
    #include "S32G274A_SIUL2.h"
#elif defined(S32R45)
    #include "S32R45_MSCM.h"
    #include "S32R45_FXOSC.h"
    #include "S32R45_MC_CGM_0.h"
    #include "S32R45_MC_CGM_1.h"
    #include "S32R45_MC_CGM_2.h"
    #include "S32R45_SCB.h"
    #include "S32R45_MPU.h"
    #include "S32R45_MC_ME.h"
    #include "S32R45_MC_RGM.h"
    #include "S32R45_SECURITY.h"
    #include "S32R45_MDM_AP.h"
    #include "S32R45_SIUL2.h"
#elif defined(S32G3XX)
    #include "S32G399A_MSCM.h"
    #include "S32G399A_FXOSC.h"
    #include "S32G399A_MC_CGM_0.h"
    #include "S32G399A_MC_CGM_1.h"
    #include "S32G399A_MC_CGM_2.h"
    #include "S32G399A_SCB.h"
    #include "S32G399A_MPU.h"
    #include "S32G399A_MC_ME.h"
    #include "S32G399A_MC_RGM.h"
    #include "S32G399A_SECURITY.h"
    #include "S32G399A_MDM_AP.h"
    #include "S32G399A_SIUL2.h"
#endif

#if (MCAL_PLATFORM_ARM  == MCAL_ARM_AARCH64)
#include "gic500.h"
#else
#include "nvic.h"
#include "core_specific.h"
#endif
#include "system.h"

/*==================================================================================================
*                                      FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/
#define CA53_0_0 (0UL)
#define CA53_0_1 (1UL)
#define CA53_1_0 (2UL)
#define CA53_1_1 (3UL)
#define CM7_0    (4UL)
#define CM7_1    (5UL)
#define CM7_2    (6UL)
#define CM7_3    (7UL)

#define SIUL2_MINOR_MASK             (0x0FU)
#define SIUL2_MINOR_SHIFT            (0x0U)
#define SIUL2_MAJOR_MASK             (0xF0U)
#define SIUL2_MAJOR_SHIFT            (0x4U)


#if (MCAL_PLATFORM_ARM  == MCAL_ARM_AARCH64)
#define SVC_GoToSupervisor()
#define SVC_GoToUser()
#else
#define SVC_GoToSupervisor()      ASM_KEYWORD("svc 0x0")
#define SVC_GoToUser()            ASM_KEYWORD("svc 0x1")
#endif

#define S32_SCB_CPACR_CPx_SHIFT(CpNum)            (2U*((uint32)CpNum))
#define S32_SCB_CPACR_CPx_MASK(CpNum)             (0x3U << S32_SCB_CPACR_CPx_SHIFT(CpNum))
#define S32_SCB_CPACR_CPx(CpNum, x)               (((uint32)(((uint32)(x))<<S32_SCB_CPACR_CPx_SHIFT((CpNum))))&S32_SCB_CPACR_CPx_MASK((CpNum)))

/*==================================================================================================
*                                       LOCAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL VARIABLES
==================================================================================================*/
#define PLATFORM_START_SEC_VAR_CLEARED_32
#include "Platform_MemMap.h"
/* Allocate a global variable which will be overwritten by the debugger if attached(in CMM), to catch the core after reset. */
uint32 RESET_CATCH_CORE;
#define PLATFORM_STOP_SEC_VAR_CLEARED_32
#include "Platform_MemMap.h"

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/

#define PLATFORM_START_SEC_CODE
#include "Platform_MemMap.h"

/*================================================================================================*/
/*
 * @brief Initializes the caches on the platform based on build options. This requires the MPU areas to be configured and enabled before calling this routine.
 * @param: None
 *
 * @return: None
 */
static INLINE void sys_m7_cache_init(void);
/*
 * @brief Disables any previously configured and initialized cache, please make sure MPU is enabled before calling these apis
 * @param: None
 *
 * @return: None
 */
static INLINE void sys_m7_cache_disable(void);
/*
 * @brief Performs a cache clean operation over the configured caches.
 * @param: None
 *
 * @return: None
 */
static INLINE void sys_m7_cache_clean(void);

#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
LOCAL_INLINE void Direct_GoToUser(void);
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/
/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/
#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
LOCAL_INLINE void Direct_GoToUser(void)
{
    ASM_KEYWORD("push {r0}");
    ASM_KEYWORD("ldr r0, =0x1");
    ASM_KEYWORD("msr CONTROL, r0");
    ASM_KEYWORD("pop {r0}");
}
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/
/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
    extern uint32 startup_getControlRegisterValue(void);
    extern uint32 startup_getAipsRegisterValue(void);
    extern void Suspend_Interrupts(void);
    extern void Resume_Interrupts(void);
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/


/*================================================================================================*/
/**
* @brief    startup_go_to_user_mode
* @details  Function called from startup.s to switch to user mode if MCAL_ENABLE_USER_MODE_SUPPORT
*           is defined
*/
/*================================================================================================*/
void startup_go_to_user_mode(void);
void startup_go_to_user_mode(void)
{
#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
    ASM_KEYWORD("svc 0x1");
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/
}

/*================================================================================================*/
/**
* @brief   Default IRQ handler
* @details Infinite Loop
*/
/*================================================================================================*/
void default_interrupt_routine(void)
{
    while(TRUE){};
}

/*================================================================================================*/
/**
* @brief Sys_GoToSupervisor
* @details function used to enter to supervisor mode.
*           check if it's needed to switch to supervisor mode and make the switch.
*           Return 1 if switch was done
*/
/*================================================================================================*/

#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
uint32 Sys_GoToSupervisor(void)
{
    uint32 u32ControlRegValue;
    uint32 u32AipsRegValue;
    uint32 u32SwitchToSupervisor;

    /* if it's 0 then Thread mode is already in supervisor mode */
    u32ControlRegValue = startup_getControlRegisterValue();
    /* if it's 0 the core is in Thread mode, otherwise in Handler mode */
    u32AipsRegValue = startup_getAipsRegisterValue();

    /* if core is already in supervisor mode for Thread mode, or running form Handler mode, there is no need to make the switch */
    if((0U == (u32ControlRegValue & 1u)) || (0u < (u32AipsRegValue & 0xFFu)))
    {
        u32SwitchToSupervisor = 0U;
    }
    else
    {
        u32SwitchToSupervisor = 1U;
        SVC_GoToSupervisor();
    }

    return u32SwitchToSupervisor;
}

/*================================================================================================*/
/**
* @brief Sys_GoToUser_Return
* @details function used to switch back to user mode for Thread mode, return a uint32 value passed as parameter
*/
/*================================================================================================*/
uint32 Sys_GoToUser_Return(uint32 u32SwitchToSupervisor, uint32 u32returnValue)
{
    if (1UL == u32SwitchToSupervisor)
    {
        Direct_GoToUser();
    }

    return u32returnValue;
}

uint32 Sys_GoToUser(void)
{
    Direct_GoToUser();
    return 0UL;
}

/*================================================================================================*/
/**
* @brief Sys_SuspendInterrupts
* @details Suspend Interrupts
*/
/*================================================================================================*/
void Sys_SuspendInterrupts(void)
{
    uint32 u32ControlRegValue;
    uint32 u32AipsRegValue;

    /* if it's 0 then Thread mode is already in supervisor mode */
    u32ControlRegValue = startup_getControlRegisterValue();
    /* if it's 0 the core is in Thread mode, otherwise in Handler mode */
    u32AipsRegValue = startup_getAipsRegisterValue();

    if((0U == (u32ControlRegValue & 1u)) || (0u < (u32AipsRegValue & 0xFFu)))
    {
        Suspend_Interrupts();
    }
    else
    {
        ASM_KEYWORD(" svc 0x3");
    }
}
/*================================================================================================*/
/**
* @brief Sys_ResumeInterrupts
* @details Resume Interrupts
*/
/*================================================================================================*/
void Sys_ResumeInterrupts(void)
{
    uint32 u32ControlRegValue;
    uint32 u32AipsRegValue;

    /* if it's 0 then Thread mode is already in supervisor mode */
    u32ControlRegValue = startup_getControlRegisterValue();
    /* if it's 0 the core is in Thread mode, otherwise in Handler mode */
    u32AipsRegValue = startup_getAipsRegisterValue();

    if((0U == (u32ControlRegValue & 1u)) || (0u < (u32AipsRegValue & 0xFFu)))
    {
        Resume_Interrupts();
    }
    else
    {
        ASM_KEYWORD(" svc 0x2");
    }
}
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/


/*================================================================================================*/
/**
* @brief Sys_GetCoreID
* @details Function used to get the ID of the currently executing thread
*/
/*================================================================================================*/
#if !defined(USING_OS_AUTOSAROS)
uint8 Sys_GetCoreID(void)
{
    return ((uint8)(IP_MSCM->CPXNUM & MSCM_CPXNUM_CPN_MASK));
}
#endif /*!defined(USING_OS_AUTOSAROS)*/

/*================================================================================================*/
/**
* @brief Sys_StartSecondaryCores
* @details Function used to start the secondary cores
*/
/*================================================================================================*/
#if (defined(CORE0) && defined(MULTIPLE_IMAGE))

static void Sys_StartSecondaryCores(void)
{
#ifdef START_CM7_1
    extern const uint32 __CORE1_START_ADDRESS;

    IP_MC_ME->PRTN0_CORE1_ADDR = (uint32)&__CORE1_START_ADDRESS;
    IP_MC_ME->PRTN0_CORE1_PCONF = 1;
    IP_MC_ME->PRTN0_CORE1_PUPD = 1;
    IP_MC_ME->CTL_KEY = 0x5AF0;
    IP_MC_ME->CTL_KEY = 0xA50F;
    while (!(IP_MC_ME->PRTN0_CORE1_STAT & MC_ME_PRTN0_CORE1_STAT_CCS_MASK)) {};
    IP_MC_RGM->PRST_0[0].PRST_0 &= ~MC_RGM_PRST_0_PERIPH_1_RST(1);
    while(IP_MC_RGM->PSTAT_0[0].PSTAT_0 & MC_RGM_PSTAT_0_PERIPH_1_STAT_MASK);
#endif /*START_CM7_1*/
#ifdef START_CM7_2
    extern const uint32 __CORE2_START_ADDRESS;

    IP_MC_ME->PRTN0_CORE2_ADDR = (uint32)&__CORE2_START_ADDRESS;
    IP_MC_ME->PRTN0_CORE2_PCONF = 1;
    IP_MC_ME->PRTN0_CORE2_PUPD = 1;
    IP_MC_ME->CTL_KEY = 0x5AF0;
    IP_MC_ME->CTL_KEY = 0xA50F;
    while (!(IP_MC_ME->PRTN0_CORE2_STAT & MC_ME_PRTN0_CORE2_STAT_CCS_MASK)) {};
    IP_MC_RGM->PRST_0[0].PRST_0 &= ~MC_RGM_PRST_0_PERIPH_2_RST(1);
    while(IP_MC_RGM->PSTAT_0[0].PSTAT_0 & MC_RGM_PSTAT_0_PERIPH_2_STAT_MASK);
#endif /*START_CM7_2*/
#ifdef START_CM7_3
    extern const uint32_t __CORE3_START_ADDRESS;

    IP_MC_ME->PRTN0_CORE4_ADDR = (uint32)&__CORE3_START_ADDRESS;
    IP_MC_ME->PRTN0_CORE4_PCONF = 1;
    IP_MC_ME->PRTN0_CORE4_PUPD = 1;
    IP_MC_ME->CTL_KEY = 0x5AF0;
    IP_MC_ME->CTL_KEY = 0xA50F;
    while (!(IP_MC_ME->PRTN0_CORE4_STAT & MC_ME_PRTN0_CORE4_STAT_CCS_MASK)) {};
    IP_MC_RGM->PRST_0[0].PRST_0 &= ~MC_RGM_PRST_0_PERIPH_6_RST(1);
    while(IP_MC_RGM->PSTAT_0[0].PSTAT_0 & MC_RGM_PSTAT_0_PERIPH_6_STAT_MASK);
#endif /*START_CM7_3*/
}
#endif /*(defined(CORE0) && defined(MULTIPLE_IMAGE))*/

/*================================================================================================*/
/*
 * system initialization : system clock, interrupt router ...
 */

void SystemInit(void)
{
    uint32 i;
    uint32 coreMask;
#ifdef MPU_ENABLE
    uint8 regionNum = 0U;
#endif

    uint32 coreId = OsIf_GetCoreID();

    switch(coreId)
    {
        case CA53_0_0:
            /* There is only one bitfield for all Cortex A53 interrupt steering. Fall trough */
        case CA53_0_1:
            /* There is only one bitfield for all Cortex A53 interrupt steering. Fall trough */
        case CA53_1_0:
            /* There is only one bitfield for all Cortex A53 interrupt steering. Fall trough */
        case CA53_1_1:
            coreMask = (1UL << MSCM_IRSPRC_GIC500_SHIFT);
            break;
        case CM7_0:
            coreMask = (1UL << MSCM_IRSPRC_M7_0_SHIFT);
            break;
        case CM7_1:
            coreMask = (1UL << MSCM_IRSPRC_M7_1_SHIFT);
            break;
        case CM7_2:
            coreMask = (1UL << MSCM_IRSPRC_M7_2_SHIFT);
            break;
#if defined(S32G3XX)
        case CM7_3:
            coreMask = (1UL << MSCM_IRSPRC_M7_3_SHIFT);
            break;
#endif
        default:
            coreMask = 0UL;
            break;
    }

    /* Configure IP_MSCM to enable/disable interrupts routing to Core processor */
    for (i = 0; i < MSCM_IRSPRC_COUNT; i++)
    {
        IP_MSCM->IRSPRC[i] |= coreMask;
    }

#if (defined(CORE0) && defined(MULTIPLE_IMAGE))
    Sys_StartSecondaryCores();
#endif

#if (MCAL_PLATFORM_ARM  == MCAL_ARM_AARCH64)

    gic500_enableGIC();

    /* fill the interrupts_vector with the default interrupt rutine */
    for (i=0; i<A53_NUM_OF_VECTORS; i++)
    {
        g_INT_vectors[i] = (isr_t)default_interrupt_routine;
    }

#else

  NVIC_SetPriorityGrouping(0); /* 0 means 7 bits for prio, 1 for sub-prio */
  S32_SCB->CCR |=  1;          /* processor can enter Thread mode from any level under the
                                   control of an EXC_RETURN value, PendSV priority set to 0 */
  S32_SCB->SHPR3 = 0;

/**************************************************************************/
                      /* FPU ENABLE*/
/**************************************************************************/
#ifdef ENABLE_FPU
    /* Enable CP10 and CP11 coprocessors */
    S32_SCB->CPACR |= (S32_SCB_CPACR_CPx(10U, 3U) | S32_SCB_CPACR_CPx(11U, 3U));

    MCAL_INSTRUCTION_SYNC_BARRIER();
    MCAL_DATA_SYNC_BARRIER();

#endif /*ENABLE_FPU*/

/**************************************************************************/
                      /* DEFAULT MEMORY ENABLE*/
/**************************************************************************/
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
/**************************************************************************/
                      /* MPU ENABLE*/
/**************************************************************************/
#ifdef MPU_ENABLE
    /*Checking if cache is enable before*/
    if (((((uint32)1U << (uint32)17U) & S32_SCB->CCR) != (uint32)0) || ((((uint32)1U << (uint32)16U) & S32_SCB->CCR) != (uint32)0))
    {
        /* synchronize cache before update mpu */
        sys_m7_cache_disable();
    }
    /* Set default memory regions */
    for (regionNum = 0U; regionNum < CPU_MPU_MEMORY_COUNT; regionNum++)
    {
        S32_MPU->RNR  = regionNum;
        S32_MPU->RBAR = rbar[regionNum];
        S32_MPU->RASR = rasr[regionNum];
    }

    /* Enable MPU */
    S32_MPU->CTRL |= S32_MPU_CTRL_ENABLE_MASK;
    MCAL_INSTRUCTION_SYNC_BARRIER();
    MCAL_DATA_SYNC_BARRIER();
#endif /*MPU_ENABLE*/

/**************************************************************************/
            /* ENABLE CACHE */
/**************************************************************************/
#if defined(D_CACHE_ENABLE) || defined(I_CACHE_ENABLE)
    sys_m7_cache_init();
#endif /*defined(D_CACHE_ENABLE) || defined(I_CACHE_ENABLE)*/
/*
 * SystemWfiConfig : Implement errata ERR051149
 */
#if defined(ERR_CORTEX_M7_E051149) || defined(ERR_CORTEX_M7_E051166)
    SystemWfiConfig();
#endif

#endif /*(MCAL_PLATFORM_ARM  == MCAL_ARM_AARCH64)*/

}
   
static void sys_m7_cache_init(void)
{
#ifdef D_CACHE_ENABLE
    uint32 ccsidr = 0U;
    uint32 sets = 0U;
    uint32 ways = 0U;

    /*init Data caches*/
    S32_SCB->CSSELR = 0U;                       /* select Level 1 data cache */

    MCAL_DATA_SYNC_BARRIER();
    ccsidr = S32_SCB->CCSIDR;
    sets = (uint32)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32)(CCSIDR_WAYS(ccsidr));
      do {
        S32_SCB->DCISW = (((sets << SCB_DCISW_SET_SHIFT) & SCB_DCISW_SET_MASK) |
                      ((ways << SCB_DCISW_WAY_SHIFT) & SCB_DCISW_WAY_MASK)  );

    MCAL_DATA_SYNC_BARRIER();
      } while (ways-- != 0U);
    } while(sets-- != 0U);
    MCAL_DATA_SYNC_BARRIER();
    S32_SCB->CCR |=  (uint32)SCB_CCR_DC_MASK;  /* enable D-Cache */
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
#endif /*D_CACHE_ENABLE*/

#ifdef I_CACHE_ENABLE
    /*init Code caches*/
    S32_SCB->ICIALLU = 0UL;                    /* invalidate I-Cache */
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
    S32_SCB->CCR |=  (uint32)SCB_CCR_IC_MASK;  /* enable I-Cache */
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
#endif /*I_CACHE_ENABLE*/
}

static INLINE void sys_m7_cache_disable(void)
{
    sys_m7_cache_clean();
    S32_SCB->CCR &= ~((uint32)1U << 17U);
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
    S32_SCB->CCR &= ~((uint32)1U << 16U);
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
}

static INLINE void sys_m7_cache_clean(void)
{
#ifdef D_CACHE_ENABLE
    uint32 ccsidr = 0U;
    uint32 sets = 0U;
    uint32 ways = 0U;

    S32_SCB->CSSELR = 0U;                       /* select Level 1 data cache */
    MCAL_DATA_SYNC_BARRIER();
    ccsidr = S32_SCB->CCSIDR;
    sets = (uint32)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32)(CCSIDR_WAYS(ccsidr));
      do {
        S32_SCB->DCCISW = (((sets << SCB_DCCISW_SET_SHIFT) & (uint32)SCB_DCCISW_SET_MASK) |
                      ((ways << SCB_DCCISW_WAY_SHIFT) & (uint32)SCB_DCCISW_WAY_MASK)  );
        MCAL_DATA_SYNC_BARRIER();
      } while (ways-- != 0U);
    } while(sets-- != 0U);
    MCAL_DATA_SYNC_BARRIER();
    S32_SCB->CSSELR = (uint32)((S32_SCB->CSSELR) | 1U);
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
#endif /*D_CACHE_ENABLE*/

#ifdef I_CACHE_ENABLE
    S32_SCB->ICIALLU = 0UL;
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
#endif /*I_CACHE_ENABLE*/
}
/*================================================================================================*/
/*
 * SystemWfiConfig : Implement errata ERR051149
 * SystemWfiConfig : Implement errata ERR051166
 */
#if defined(ERR_CORTEX_M7_E051149) || defined(ERR_CORTEX_M7_E051166)
void SystemWfiConfig(void)
{
    uint32 u32EdbStatus = 0U;
#ifdef S32G3XX
/*  Major Mask Revision
    0000b - Rev 1.x
    0001b - Rev 2.x
    Minor Mask Revision
    0000b - Rev x.0
    0001b - Rev x.1 */
    uint32 U32MajorMinor = (uint32_t)(IP_SIUL2_0->MIDR1);
    uint8 Minor = (uint8)((U32MajorMinor & SIUL2_MINOR_MASK) >> SIUL2_MINOR_SHIFT);
    uint8 Major = (uint8)((U32MajorMinor & SIUL2_MAJOR_MASK) >> SIUL2_MAJOR_SHIFT);
    if (Major == 0U && Minor == 0U)
    {
#endif
        u32EdbStatus = (uint32_t)(IP_SECURITY_CC->EXT_DBGSTAT & SECURITY_EXT_DBGSTAT_EDB_MASK);
        if (u32EdbStatus == 0U)
        {
            IP_MDM_AP->DAP_EN_CTRL &= ~MDM_AP_DAP_EN_CTRL_CSPNIDEN_MASK;
            IP_MDM_AP->DAP_EN_CTRL &= ~MDM_AP_DAP_EN_CTRL_CSPIDEN_MASK;
            IP_MDM_AP->DAP_EN_CTRL &= ~MDM_AP_DAP_EN_CTRL_CNIDEN_MASK;
            IP_MDM_AP->DAP_EN_CTRL &= ~MDM_AP_DAP_EN_CTRL_CDBGEN_MASK;
            IP_MDM_AP->CONTROL |= MDM_AP_CONTROL_CM7_0_EDBGREQ_MASK;
            IP_MDM_AP->CONTROL |= MDM_AP_CONTROL_CM7_1_EDBGREQ_MASK;
            IP_MDM_AP->CONTROL |= MDM_AP_CONTROL_CM7_2_EDBGREQ_MASK;
#ifdef S32G3XX
#if defined(ERR_CORTEX_M7_E051166)
            IP_MDM_AP->CORTEX_A53_A0_IP_DBG |= MDM_AP_CORTEX_A53_A0_IP_DBG_CM7_3_EDBGREQ_MASK;
#endif
#endif
        }
        else
        {
            /* do nothing */
        }
#ifdef S32G3XX
    }
    else
    {
        /* do nothing */
    }
#endif
}
#endif

#define PLATFORM_STOP_SEC_CODE
#include "Platform_MemMap.h"

#ifdef __cplusplus
}
#endif /*__cplusplus */


===== 文件 [7/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\include\Core_Heartbeat.h =====
/*==================================================================================================
*
* Copyright 2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#ifndef CORE_HEARTBEAT
#define CORE_HEARTBEAT

#include "StandardTypes.h"

#define HEARTBEAT_STRUCTURE_ADDRESS   (0x4384FFD0U)
#define HEARTBEAT_MAX_TIME_DIFFERENCE (100u)

void Core_Heartbeat_Init(void);
void Core_Heartbeat_Check(void);

#endif /* CORE_HEARTBEAT */


===== 文件 [8/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\include\Llce_Firmware_Load.h =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#ifndef LLCE_FIRMWARE_LOAD_H
#define LLCE_FIRMWARE_LOAD_H

#include "StandardTypes.h"

Std_ReturnType Llce_Firmware_Load(void);
boolean Llce_Firmware_Load_GetBootStatus(void);

#endif /* LLCE_FIRMWARE_LOAD_H */


===== 文件 [9/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\include\PlatformInit.h =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#ifndef APP_PLATFORM_INIT
#define APP_PLATFORM_INIT

void PlatformInit(void);

#endif /* APP_PLATFORM_INIT */


===== 文件 [10/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\include\can_common.h =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#ifndef CAN_COMMON
#define CAN_COMMON

#ifdef ASR_NOT_USED
    #include "PlatformTypes.h"    
#endif

#define CAN_FD_FRAME_LEN 64U
#define CAN_STD_FRAME_LEN 8U
#define TP_TIMEOUT 800000U
#define CONTROLLER1 1
#define CONTROLLER0 0
#define CONTROLLER2 2
#define CONTROLLER3 3
#define CONTROLLER4 4
#define CONTROLLER5 5
#define CONTROLLER7 7
#define CONTROLLER10 10
#define CONTROLLER11 11
#define CONTROLLER12 12
#define CONTROLLER14 14
#define CONTROLLER15 15
#define ITER_NR 200
#define MAX_BUFFER_FRAME_FD 64
#define CAN_LPDU_FD_U32 ((uint32)0x40000000)
#define MAX_NUM_OF_CORES 8U
#define ON  1
#define OFF 0

/* Sample app specific variable. Possible values: ON, OFF */
extern volatile uint8 fail;

#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    extern volatile uint32 last_RxIndication;
    extern volatile uint32 last_TxConfirmation;
#else
    extern volatile uint32 last_RxIndication[MAX_NUM_OF_CORES];
    extern volatile uint32 last_TxConfirmation[MAX_NUM_OF_CORES];
#endif

void Circular_Permutation(volatile uint8 *Payload, uint8 n);
StatusType Check_Status(Can_PduType *CanMessage);


#endif  /* CAN_COMMON */


===== 文件 [11/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\include\check_example.h =====
/*
*   (c) Copyright 2020 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be used strictly
*   in accordance with the applicable license terms.  By expressly accepting
*   such terms or by downloading, installing, activating and/or otherwise using
*   the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms.  If you do not agree to
*   be bound by the applicable license terms, then you may not retain,
*   install, activate or otherwise use the software.
*
*   This file contains sample code only. It is not part of the production code deliverables.
*/

#ifndef CHECK_EXAMPLE_H
#define CHECK_EXAMPLE_H

#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/


/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/

/**
* @brief        Function used for testing automatically examples
* @details      Writes a pass or fail status in the memory at a given address
* @internal
*/
static inline void Exit_Example(boolean result) 
{
    volatile uint8 * testResultBasePtr;
    
    testResultBasePtr = (volatile uint8 *)VV_RESULT_ADDRESS;
    
    if (TRUE == result)
    {
        *testResultBasePtr = 0x5AU;
    }
    else
    {
        *testResultBasePtr = 0x33U;
    }
}

static inline void EX_ASSERT(boolean result) 
{
    volatile uint8 * testResultBasePtr;
    
    testResultBasePtr = (volatile uint8 *)VV_RESULT_ADDRESS;
    
    if (TRUE == result)
    {
        if(*testResultBasePtr != 0x33U)
        {
            *testResultBasePtr = 0x5AU;
        }
    }
    else
    {
        *testResultBasePtr = 0x33U;
    }
}

#ifdef __cplusplus
}
#endif

#endif 

/** @} */


===== 文件 [12/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\include\stubs.h =====
#ifndef STUBS_H
#define STUBS_H

#include "Can_43_LLCE.h"
#include "can_common.h"
#include "Platform_Types.h"

#define ASSERT(expr) \
    if (!(expr)) \
        fail = ON

/* Stub functions */
void CanIf_RxIndication( const Can_HwType* Mailbox, const PduInfoType* PduInfoPtr );
void CanIf_TxConfirmation( PduIdType CanTxPduId);
void CanIf_ControllerModeIndication( uint8 Controller, Can_ControllerStateType ControllerMode);
void CanIf_ControllerBusOff( uint8 Controller);
void RxTimestampNotification(Can_HwHandleType Hoh, uint32 u32TimestampVal);
void TxTimestampNotification(Can_HwHandleType Hoh, PduIdType CanTxPduId, uint32 u32TimestampVal);
void CanErrorNotification(uint8 u8CanIfCtrlId, Llce_Can_NotificationIdType eNotifId, volatile Llce_Can_ErrorNotifType* ErrorInfo);

void Can_CallBackSetUp(void);

extern volatile uint8   Can_RxData[CAN_FD_FRAME_LEN];
extern volatile uint8  Can_RxHandle;
extern volatile Can_IdType Can_RxId;
extern volatile uint8  Can_RxDlc;
extern volatile uint8  Can_ControllerId;
extern volatile PduIdType Can_TxConfirmation_CanTxPduId;
extern volatile uint8  Can_BusOffConfirmation;
extern volatile uint32   Can_Tx_No[16];
extern volatile uint32 u32CustomCallbackExecutions;
#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    extern volatile uint32 Can_RxIndication;
    extern volatile uint32 Can_TxConfirmation;
#else
    extern volatile uint32 Can_RxIndication[MAX_NUM_OF_CORES];
    extern volatile uint32 Can_TxConfirmation[MAX_NUM_OF_CORES];
#endif

#endif /* STUBS_H */


===== 文件 [13/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\src\Core_Heartbeat.c =====
/*==================================================================================================
*
* Copyright 2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#include "Core_Heartbeat.h"
#include "Llce_RegAccess.h"
#include "Llce_InterfaceFwMgr.h"

/* Macro used for rollover detection of the global counter u32SysTickCounter. (Rollover every ~118h when counting hundreds of microseconds (100us granularity)) */
#define MAX_UINT32_VALUE (uint32)4294967295U
#define MAX_NR_OF_CORE_TIMEOUT   10u

/* Counter increases when a timeout occurs (up to 10) and decreases when it doesn't */
static struct 
{
  uint8 core1TimeoutCounter;
  uint8 core2TimeoutCounter;
  uint8 core3TimeoutCounter;
}timeoutCoreCounter;


static Llce_Mgr_TimeStampCoresType Core_Heartbeat_Time_Elapsed(Llce_Mgr_TimeStampCoresType currentHeartbeatValue, Llce_Mgr_TimeStampCoresType previousHeartbeatValue);
static uint32 Core_Heartbeat_Calculate_Time_Difference(uint32 currentHeartbeatCoreValue, uint32 previousHeartbeatCoreValue);
static void Core_Heartbeat_Update_All_Counters(Llce_Mgr_TimeStampCoresType heartbeatTimeDifference);
static void Core_Heartbeat_Update_Counter(uint32 timestampDifference, uint8 *counter);

void Core_Heartbeat_Init(void)
{
  /* Init already done in Can_Enable_Timestamp() from Platform_Init.c */

}

void Core_Heartbeat_Check(void)
{   
  static volatile Llce_Mgr_TimeStampCoresType previousHeartbeatValue;
  static volatile Llce_Mgr_TimeStampCoresType* pcurrentHeartbeatValue = (Llce_Mgr_TimeStampCoresType*)HEARTBEAT_STRUCTURE_ADDRESS;
  Llce_Mgr_TimeStampCoresType heartbeatTimeDifference;

  heartbeatTimeDifference = Core_Heartbeat_Time_Elapsed(*pcurrentHeartbeatValue, previousHeartbeatValue);

  Core_Heartbeat_Update_All_Counters(heartbeatTimeDifference);

  if(
       (timeoutCoreCounter.core1TimeoutCounter >= MAX_NR_OF_CORE_TIMEOUT) 
    || (timeoutCoreCounter.core2TimeoutCounter >= MAX_NR_OF_CORE_TIMEOUT) 
    || (timeoutCoreCounter.core3TimeoutCounter >= MAX_NR_OF_CORE_TIMEOUT)
    )
  {
    /* Insert reaction here */
  }

  previousHeartbeatValue = *pcurrentHeartbeatValue;
}

/* Increment or decrement a counter based on the time difference between two consecutive timestamps */
static void Core_Heartbeat_Update_Counter(uint32 timestampDifference, uint8 *counter)
{
  if((timestampDifference) > HEARTBEAT_MAX_TIME_DIFFERENCE)
  {
    if(*counter < 255u)
    {
      (*counter)++;
    }
  }
  else
  {
    if(*counter > 0u)
    {
      (*counter)--;
    }
  }
}

/* Update the counter value for every core */
static void Core_Heartbeat_Update_All_Counters(Llce_Mgr_TimeStampCoresType heartbeatTimeDifference)
{
  Core_Heartbeat_Update_Counter(heartbeatTimeDifference.timeStampCore1, &timeoutCoreCounter.core1TimeoutCounter);
  Core_Heartbeat_Update_Counter(heartbeatTimeDifference.timeStampCore2, &timeoutCoreCounter.core2TimeoutCounter);
  Core_Heartbeat_Update_Counter(heartbeatTimeDifference.timeStampCore3, &timeoutCoreCounter.core3TimeoutCounter);
}

/* Update for every core the difference between two consecutive timestamps. */
static Llce_Mgr_TimeStampCoresType Core_Heartbeat_Time_Elapsed(Llce_Mgr_TimeStampCoresType currentHeartbeatValue, Llce_Mgr_TimeStampCoresType previousHeartbeatValue)
{
  Llce_Mgr_TimeStampCoresType heartbeatTimeDifference;

  heartbeatTimeDifference.timeStampCore1 = Core_Heartbeat_Calculate_Time_Difference(currentHeartbeatValue.timeStampCore1, previousHeartbeatValue.timeStampCore1);
  heartbeatTimeDifference.timeStampCore2 = Core_Heartbeat_Calculate_Time_Difference(currentHeartbeatValue.timeStampCore2, previousHeartbeatValue.timeStampCore2);
  heartbeatTimeDifference.timeStampCore3 = Core_Heartbeat_Calculate_Time_Difference(currentHeartbeatValue.timeStampCore3, previousHeartbeatValue.timeStampCore3);

  return heartbeatTimeDifference;
}

/* Calculate the time difference between two consecutive timestamps */
static uint32 Core_Heartbeat_Calculate_Time_Difference(uint32 currentHeartbeatCoreValue, uint32 previousHeartbeatCoreValue)
{
  uint32 timeDifference;
  if(currentHeartbeatCoreValue >= previousHeartbeatCoreValue)
  {
    timeDifference = currentHeartbeatCoreValue - previousHeartbeatCoreValue;
  }
  else
  {
    /* In case of overflow of currentHeartbeatValue */
    timeDifference = MAX_UINT32_VALUE - previousHeartbeatCoreValue + currentHeartbeatCoreValue;
  }
  
  return timeDifference;
}


===== 文件 [14/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\src\Llce_Firmware_Load.c =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#include "Llce_Firmware_Load.h"
#include "Llce_InterfaceFwMgr.h"
#include "Llce_RegAccess.h"


typedef struct {
    uint8* const pu8MemLocation;
    const uint32 u32RAMSize;
    const uint8* const pu8CodeData;
    const uint32* u32CodeSize;
} Llce_CoreProgramType;


#define LLCE_NUM_CORES              4U
#define LLCE_ENABLE_CORE_ADDR       ((uint32)0x43FF8000U)
#define LLCE_DATA_RAM_START_ADDR    0x43800000
#define LLCE_DATA_RAM_LENGTH        0x50000
#define LLCE_FW_STARTUP_DURATION    1000000

#if defined(S32G3) || defined(S32G3XX)
    #define DTE_RAM_SIZE        0x4000
    #define PPE_RX_RAM_SIZE     0x18000
    #define PPE_TX_RAM_SIZE     0x8000
    #define FRPE_RAM_SIZE       0x40000
#else /* S32G2 */
    #define DTE_RAM_SIZE        0x2000
    #define PPE_RX_RAM_SIZE     0x8000
    #define PPE_TX_RAM_SIZE     0x8000
    #define FRPE_RAM_SIZE       0x10000
#endif

/* This variable contains information about fw boot end */
__attribute__((section(".llce_boot_end"))) volatile Llce_Mgr_StatusType Llce_Mgr_Status;

extern const uint8 dte_bin[];
extern const uint32 dte_bin_len;

extern const uint8 ppe_rx_bin[];
extern const uint32 ppe_rx_bin_len;

extern const uint8 ppe_tx_bin[];
extern const uint32 ppe_tx_bin_len;

extern const uint8 frpe_bin[];
extern const uint32 frpe_bin_len;

#ifdef LLCE_USE_HEADLESS
extern const uint8 LLCE_HeadlessConfig_bin[];
#endif

static const Llce_CoreProgramType Llce_CoreData[LLCE_NUM_CORES] = 
{
    { (uint8*)0x43000000, DTE_RAM_SIZE,  dte_bin,    &dte_bin_len },
    { (uint8*)0x43100000, PPE_RX_RAM_SIZE, ppe_rx_bin, &ppe_rx_bin_len},
    { (uint8*)0x43200000, PPE_TX_RAM_SIZE, ppe_tx_bin, &ppe_tx_bin_len},
    { (uint8*)0x43300000, FRPE_RAM_SIZE, frpe_bin,   &frpe_bin_len }
};

/**
* @brief          Service routine used to load the firmware from host memory to LLCE internal memory and enable LLCE cores in order to start running.
* @details        This routine is called by:
*                  - Can_Llce_Init
*
* @param[in]      void
*
* @return
* @retval        E_OK  Timeout was not reached. LLCE internal cores started correctly
* @retval        E_NOT_OK  Timeout was reached. LLCE internal cores not started correctly
*/
Std_ReturnType Llce_Firmware_Load(void)
{   
    uint8 i;
    uint32 crtOffset;
    uint32 byteIndex;
    uint64 *u64MemPointer;
    uint64 *u64MemPointer2;
    const uint64 *u64DataPointer;
	
    /* Put all cores in reset*/
    Reg_Write32(LLCE_ENABLE_CORE_ADDR, 0x0);

    for (i = 0U; i < LLCE_NUM_CORES; i++) 
    {
        /* Move code to core's code section*/
        /* Performance optimisation: write 8 bytes at a time */
        u64MemPointer  = (uint64*)Llce_CoreData[i].pu8MemLocation;
        u64DataPointer = (uint64*)Llce_CoreData[i].pu8CodeData;

        /* Offset is in words (32 bit) */
        for (crtOffset = 0U; crtOffset <  (*(Llce_CoreData[i].u32CodeSize)) / 8; crtOffset++)
        {
            u64MemPointer[crtOffset] = u64DataPointer[crtOffset];
        }
        
        /* Write 2 words at a time before copying bytes */
        u64MemPointer[crtOffset] = (uint64)0;

        /* Back to 1 byte mode */
        for (byteIndex = crtOffset * 8U; byteIndex <  (*(Llce_CoreData[i].u32CodeSize)); byteIndex++)
        {
            Llce_CoreData[i].pu8MemLocation[byteIndex] = Llce_CoreData[i].pu8CodeData[byteIndex];
        }

        crtOffset++;

        /* Fill the rest of the core's RAM in order to enable ECC RAM */
        for ( ; crtOffset < (Llce_CoreData[i].u32RAMSize) / 8 ; crtOffset++)
        {
            u64MemPointer[crtOffset] = (uint64)0;
        }
    }

    /* Pointer to the first half of LLCE Shared RAM */
    u64MemPointer  = (uint64*)LLCE_DATA_RAM_START_ADDR;
    /* Pointer to the second half of LLCE Shared RAM */
    u64MemPointer2  = (uint64*)(LLCE_DATA_RAM_START_ADDR + (LLCE_DATA_RAM_LENGTH/2));

    /* Write all the Shared Memory in order to enable ECC RAM: 8 bytes at a time */
    for (crtOffset = 0U; crtOffset <  LLCE_DATA_RAM_LENGTH / 16; crtOffset++)
    {
        u64MemPointer[crtOffset] = (uint64)0;
        u64MemPointer2[crtOffset] = (uint64)0;
    }

#ifdef LLCE_USE_HEADLESS
    /* Copy magic value from headless config */
    *((uint32*)LLCE_DATA_RAM_START_ADDR) = *((uint32*)LLCE_HeadlessConfig_bin);
    /* Set headless config address */
    *(((uint32*)LLCE_DATA_RAM_START_ADDR) + 1U) = (uint32)&LLCE_HeadlessConfig_bin;
#endif    

    /* Clear memory area where Llce notifies about boot ending */
    Llce_Mgr_Status.eTxBootStatus = LLCE_FW_NOTRUN;
    Llce_Mgr_Status.eRxBootStatus = LLCE_FW_NOTRUN;
    Llce_Mgr_Status.eDteBootStatus = LLCE_FW_NOTRUN;
    Llce_Mgr_Status.eFrpeBootStatus = LLCE_FW_NOTRUN;

    Reg_Write32(LLCE_ENABLE_CORE_ADDR, 0xF);      /*start all cores */

    return Llce_Firmware_Load_GetBootStatus();
}

boolean Llce_Firmware_Load_GetBootStatus(void)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;
    uint32 u32Timeout = LLCE_FW_STARTUP_DURATION;
    Llce_Fw_ReturnType eTxBootStatus   = LLCE_FW_NOTRUN;
    Llce_Fw_ReturnType eRxBootStatus   = LLCE_FW_NOTRUN;
    Llce_Fw_ReturnType eDteBootStatus  = LLCE_FW_NOTRUN;
    Llce_Fw_ReturnType eFrpeBootStatus = LLCE_FW_NOTRUN; 

    /*Wait that the LLCE firmware cores to start running and boot.*/
    while (( (LLCE_FW_SUCCESS != eTxBootStatus) || (LLCE_FW_SUCCESS != eRxBootStatus) || \
			(LLCE_FW_SUCCESS != eDteBootStatus) || (LLCE_FW_SUCCESS != eFrpeBootStatus) ) && (u32Timeout > 0))
    {
        /* Volatile variables should be read separately */
        eTxBootStatus   = Llce_Mgr_Status.eTxBootStatus;
        eRxBootStatus   = Llce_Mgr_Status.eRxBootStatus;
        eDteBootStatus  = Llce_Mgr_Status.eDteBootStatus;
        eFrpeBootStatus = Llce_Mgr_Status.eFrpeBootStatus;
		u32Timeout--;
    }
    
    if (u32Timeout != 0)	
    {
            eReturnValue = E_OK;
    }

    return  eReturnValue;
}


===== 文件 [15/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\src\Platform_Init.c =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#include "Llce_RegAccess.h"
#include "Mcu.h"
#include "OsIf.h"
#include "Platform.h"
#include "CDD_Rm.h"
#ifdef USE_PORT_HLD
    #include "Port.h" /* EB Tresos demo project */
#else
    #include "Siul2_Port_Ip.h" /* S32DS demo project */
#endif

#define MACRO_CONCAT(a,b) a##b
#define MACRO_CONFIG(a,b) MACRO_CONCAT(a, b)
#ifndef CONFIG_VARIANT_USED
 #define MCU_VARIANT    NULL_PTR
 #define PORT_VARIANT   NULL_PTR
#else
 #define MCU_VARIANT    &MACRO_CONFIG(Mcu_Config_, CONFIG_VARIANT_USED)
 #define PORT_VARIANT   &MACRO_CONFIG(Port_Config_, CONFIG_VARIANT_USED)
#endif

/* Bcan Timestamping related defines */
#define TST_CTRL_REG_ADDR   0x4007C0F0  /* TIMESTAMP_CONTROL_REGISTER */
#define TST_SOURCE_SEL_MASK 0x00000001  /* Timestamp 1 counter output is selected as timestamp module output */
#define TST_ENABLE_MASK     0x00000004  /* Timestamp module enable control */
#define STM7_BASE_ADDR      0x40228000  /* STM_7 base address */
#define STM7_ENABLE_MASK    0x00000001  /* STM_7 enable bit */
#define STMTS_REG_ADDR      0x4400C000  /* STM_TS register address */
#define STMTS_SEL_MASK      0x00008501  /* STM_TS mask to set presclarer to 133 */

static void Can_Enable_Timestamp(void);

void PlatformInit(void)
{
    #if (RM_PRECOMPILE_SUPPORT == STD_OFF)
        Rm_Init(&Rm_Config_VS_0);
    #else
        Rm_Init(NULL_PTR);
    #endif

    /* Configure S32G clocks */
    /* Enable LLCE partition */
    Mcu_Init(MCU_VARIANT);
    Mcu_InitClock(McuClockSettingConfig_0);
    while ( MCU_PLL_LOCKED != Mcu_GetPllStatus() )
    {
        /* Busy wait until the System PLL is locked */
    }
    Mcu_DistributePllClock();
    Mcu_SetMode(McuModeSettingConf_0);

#ifdef USE_PORT_HLD
    Port_Init(PORT_VARIANT);
#else
    Siul2_Port_Ip_Init(NUM_OF_CONFIGURED_PINS0, g_pin_mux_InitConfigArr0);
#endif

    OsIf_Init(NULL_PTR); /* enable system timer for timeout detection */

    /* Configurations for IRQ routing, priority and enable through Platform plugin. */
    Platform_Init(NULL_PTR);

    Can_Enable_Timestamp();

}

/*================================================================================================*/
/**
@brief         Enable Bcan timestamping
@details       Select timestamp source and enable timestamping
*/
/*================================================================================================*/
static void Can_Enable_Timestamp(void)
{
	/* Select timestamp source STM_7 and enable timestamp module in TIMESTAMP_CONTROL_REGISTER */
    Reg_Bit_Set32(TST_CTRL_REG_ADDR, TST_SOURCE_SEL_MASK | TST_ENABLE_MASK);

	/*start STM_7*/
	Reg_Bit_Set32(STM7_BASE_ADDR, STM7_ENABLE_MASK);

    /* Set STM Prescaler 133. - This shall offer 1ms ticks */
    Reg_Bit_Set32(STMTS_REG_ADDR, STMTS_SEL_MASK);
}


===== 文件 [16/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\src\can_common.c =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/


#ifndef ASR_NOT_USED
    #include "stubs.h"
    #include "Can_43_LLCE.h"
#endif

#include "can_common.h"


#ifdef __cplusplus
extern "C"
{
#endif

volatile uint8 fail = OFF;

#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    volatile uint32 last_RxIndication;
    volatile uint32 last_TxConfirmation;
#else
    volatile uint32 last_RxIndication[MAX_NUM_OF_CORES];
    volatile uint32 last_TxConfirmation[MAX_NUM_OF_CORES];
#endif

/* Circular permutation on data buffer. The reason of using this function is for checking data sent is the same with data received every time.  */
void Circular_Permutation(volatile uint8 *Payload, uint8 n)
{
    uint8 temp = Payload[0];

    for (uint8 Idx = 0; Idx < n - 1; Idx++)
    {
        Payload[Idx] = Payload[Idx + 1];
    }

    Payload[n - 1] = temp;
}

StatusType Check_Status(Can_PduType *CanMessage)
{
    uint32 can_counter = 0;
    uint8 u8Idx = 0;
    StatusType transmission_status = E_OK;

#if CAN_43_LLCE_MAX_PARTITIONS != 1U    
    uint32 u32CoreId = OsIf_GetCoreID();
#endif

    /* Wait for transmission and reception */
#if CAN_43_LLCE_MAX_PARTITIONS == 1U    
    while ( (( (Can_TxConfirmation - last_TxConfirmation) < 1) || ( (Can_RxIndication - last_RxIndication) < 1))  && (can_counter < TP_TIMEOUT) )
#else
    while ( (( (Can_TxConfirmation[u32CoreId] - last_TxConfirmation[u32CoreId]) < 1) || ( (Can_RxIndication[u32CoreId] - last_RxIndication[u32CoreId]) < 1))  && (can_counter < TP_TIMEOUT) )
#endif
    {
        can_counter++;
    }

    /* Check received Data length */
    if (Can_RxDlc != CanMessage->length)
    {
        transmission_status = E_NOT_OK;
    }

    /* Check integrity of received Data content */
    for (u8Idx = 0; u8Idx < CanMessage->length; u8Idx++)
    {
        if (Can_RxData[u8Idx] != CanMessage->sdu[u8Idx])
        {
            transmission_status = E_NOT_OK;
            break;
        }
    }

#if CAN_43_LLCE_MAX_PARTITIONS == 1U    
    last_RxIndication++;
    last_TxConfirmation++;
#else
    last_RxIndication[u32CoreId]++;
    last_TxConfirmation[u32CoreId]++;
#endif

    /* Shuffle the data in order to check sending/receiving of another frame */
    Circular_Permutation(CanMessage->sdu, CAN_FD_FRAME_LEN);

    return transmission_status;
}


===== 文件 [17/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\src\main.c =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#include "stubs.h"
#include "Can_43_LLCE.h"
#include "PlatformInit.h"
#include "Llce_Firmware_Load.h"
#include "can_common.h"
#include "Core_Heartbeat.h"

#ifdef __cplusplus
extern "C"
{
#endif

#define MACRO_CONCAT(a,b) a##b
 #define CAN_VARIANT(var) MACRO_CONCAT(Can_43_LLCE_Config_, var)
#ifndef CONFIG_VARIANT_USED
 #define CAN_LLCE_VARIANT   NULL_PTR
#else
 #define CAN_LLCE_VARIANT   &CAN_VARIANT(CONFIG_VARIANT_USED)     
#endif


/* Autosar Configuration (see CAN2CAN_Project ) mapping is: idx 2 -> hwCtrl (BCAN) 14; idx 3 -> hwCtrl (BCAN)  15 */
#define LOGICAL_CONTROLLER15 3
#define LOGICAL_CONTROLLER14 2


void Can_Driver_Sample_Test(void)
{
    Can_ErrorStateType ErrorState;
    Std_ReturnType can_retval = E_NOT_OK;
    Can_PduType CanMessage;
    static uint8 can_fd_data[CAN_FD_FRAME_LEN];
    static uint8 can_std_data[CAN_STD_FRAME_LEN];
    uint16 u16MbGlobalIndex = 0U;

    Can_43_LLCE_Init(CAN_LLCE_VARIANT);

    /* Reset global flags and counters. */
    Can_CallBackSetUp();

    /*Initialize transmission data buffer with a standard Can frame.*/
    for (u16MbGlobalIndex = 0; u16MbGlobalIndex < CAN_STD_FRAME_LEN; u16MbGlobalIndex++)
    {
        can_std_data[u16MbGlobalIndex] = u16MbGlobalIndex;
    }

    /*Initialize transmission data buffer with a Can Fd frame.*/
    for (u16MbGlobalIndex = 0; u16MbGlobalIndex < CAN_FD_FRAME_LEN; u16MbGlobalIndex++)
    {
        can_fd_data[u16MbGlobalIndex] = u16MbGlobalIndex;
    }

    (void)can_retval;

/* In headless mode the call of Can_SetBaudrate() would cause a re-initialization of the CAN Controller 
   when it is in STARTED state and will return E_NOT_OK according to (SWS_Can_00256) */

    /* Start CONTROLLER0 */
#ifndef LLCE_USE_HEADLESS
    can_retval = Can_43_LLCE_SetBaudrate(CONTROLLER0, 1); /* Index 1 corresponds to a baudrate configuration of (500 kbps; 2000 kbps).See Tresos configuration*/
    ASSERT(E_OK == can_retval);
#endif
    can_retval = Can_43_LLCE_SetControllerMode(CONTROLLER0, CAN_CS_STARTED);
    ASSERT(E_OK == can_retval);
    can_retval = Can_43_LLCE_GetControllerErrorState(CONTROLLER0, &ErrorState);
    ASSERT(E_OK == can_retval);
    /* Start CONTROLLER1 */
#ifndef LLCE_USE_HEADLESS    
    can_retval = Can_43_LLCE_SetBaudrate(CONTROLLER1, 1); /* Index 1 corresponds to a baudrate configuration of (500 kbps; 2000 kbps).See Tresos configuration*/
    ASSERT(E_OK == can_retval);
#endif
    can_retval = Can_43_LLCE_SetControllerMode(CONTROLLER1, CAN_CS_STARTED);
    ASSERT(E_OK == can_retval);
    can_retval = Can_43_LLCE_GetControllerErrorState(CONTROLLER1, &ErrorState);
    ASSERT(E_OK == can_retval);

    /* Make sure that Tx Message Buffers used for host are less than 16. The difference between 16(max number of tx mb) 
    and tx Mb reserved or host will be used for routing on that channel. In this demo, that's channel 15.
    It has 4 MBs used for standard transmission, and 12 MBs used for routing frames to other channels. */

    /* Start CONTROLLER15 */
#ifndef LLCE_USE_HEADLESS
    can_retval = Can_43_LLCE_SetBaudrate(LOGICAL_CONTROLLER15, 0); /* Index 0 corresponds to a baudrate configuration of (250 kbps; 500 kbps). See Tresos configuration*/
    ASSERT(E_OK == can_retval);
#endif
    can_retval = Can_43_LLCE_SetControllerMode(LOGICAL_CONTROLLER15, CAN_CS_STARTED);
    ASSERT(E_OK == can_retval);
    /* Start CONTROLLER14 */
#ifndef LLCE_USE_HEADLESS
    can_retval = Can_43_LLCE_SetBaudrate(LOGICAL_CONTROLLER14, 0);  /* Index 0 corresponds to a baudrate configuration of (250 kbps; 500 kbps). See Tresos configuration*/
    ASSERT(E_OK == can_retval);
#endif
    can_retval = Can_43_LLCE_SetControllerMode(LOGICAL_CONTROLLER14, CAN_CS_STARTED);
    ASSERT(E_OK == can_retval);

    /* Send data */
    Can_TxConfirmation = 0;
    Can_RxIndication = 0;
    Can_RxDlc = 0;

    last_RxIndication = 0;
    last_TxConfirmation = 0;

    for (u16MbGlobalIndex = 0; u16MbGlobalIndex < ITER_NR; u16MbGlobalIndex++)
    {   
        Core_Heartbeat_Check();

        /* Set-up CAN frame data */
        CanMessage.length = CAN_FD_FRAME_LEN;
        CanMessage.sdu = can_fd_data;
        CanMessage.swPduHandle = u16MbGlobalIndex & 15; //%16

        /* Ctrl1 send frame to Ctrl0. This is an unrouted frame. In configuration, the HRH which receive frame with ID=1 has the routing option OFF */
        CanMessage.id = 1 | CAN_LPDU_FD_U32;
        can_retval = Can_43_LLCE_Write(CanHO_Config1_TX1, &CanMessage);
        ASSERT(E_OK == can_retval);

        /* Check status of transmission and reception */
        can_retval = Check_Status(&CanMessage);
        ASSERT(E_OK == can_retval);
        
        /* Ctrl 1 will send a message to ctrl 0, which does internal routing to channel 15, which will send the frame
        with id=15 to ctrl 14 on the external bus. Now, ctrl 0 will receive the frame on another HRH which receive frame with ID=15 and has the routing option ON,
        and the routing table indicates destination channel = 15 (configurable in Llce plugin)  */
        /* This is a routed frame */
        CanMessage.id = 15 | CAN_LPDU_FD_U32;
        can_retval = Can_43_LLCE_Write(CanHO_Config1_TX1, &CanMessage);
        ASSERT(E_OK == can_retval);
        
        /* Check status of transmission and reception */
        can_retval = Check_Status(&CanMessage);
        ASSERT(E_OK == can_retval);

        /* Now, Ctrl 1 will send a message with ID=888 to ctrl 0, which has a filter that accepts that ID. In the same time, it has an advanced feature reference
        (CanAdvancedFeature_3 in Llce_Af plugin, linked to the HRH CanHOH_Routing_RX0_IdRemap in Can_Llce plugin) which says "change the frame ID to 999 and forward
         it to destination channel 15, and don't deliver it to the host". It's also possible to send the frame also to the host core, to a logging core and to a list
         of multiple channel destinations simultaneously. */
        CanMessage.id = 888 | CAN_LPDU_FD_U32;
        can_retval = Can_43_LLCE_Write(CanHO_Config1_TX1, &CanMessage);
        ASSERT(E_OK == can_retval);
        
        /* Check status of transmission and reception */
        can_retval = Check_Status(&CanMessage);
        ASSERT(E_OK == can_retval);
        
        /* New Id value received */
        ASSERT((Can_RxId & ~CAN_LPDU_FD_U32) == 999);
        
        /* --- Routing with converting frame between CAN and CAN-FD --- */
        /* Set-up CAN frame data */
        CanMessage.length = CAN_STD_FRAME_LEN;
        CanMessage.sdu = can_std_data;

        /* Now, Ctrl 1 will send a message with ID=321 to ctrl 0, which has a filter (named CanHOH_CanFD2Can) which accepts that ID. In the same time, it is linked to an advanced feature 
            reference (CanAdvancedFeature_2) which says "change the frame format from CAN-FD to CAN and forward it to channel 15, and don't deliver it to the host" */
        CanMessage.id = 321 | CAN_LPDU_FD_U32;
        can_retval = Can_43_LLCE_Write(CanHO_Config1_TX1, &CanMessage);
        ASSERT(E_OK == can_retval);
        
        /* Check status of transmission and reception */
        can_retval = Check_Status(&CanMessage);
        ASSERT(E_OK == can_retval);

        /* Check received RxID frame */
        ASSERT(CAN_LPDU_FD_U32 != (Can_RxId & CAN_LPDU_FD_U32));
       
        /* Now, Ctrl 1 will send a message with ID=123 to ctrl 0, which has a filter (named CanHOH_Can2CanFD) which accepts that ID. In the same time, it is linked to an advanced feature 
            reference (CanAdvancedFeature_1) which says "change the frame format from CAN-FD to CAN and forward it to channel 15, and don't deliver it to the host" */
        CanMessage.id = 123;
        can_retval = Can_43_LLCE_Write(CanHO_Config1_TX1, &CanMessage);
        ASSERT(E_OK == can_retval);
        
        /* Check status of transmission and reception */
        can_retval = Check_Status(&CanMessage);
        ASSERT(E_OK == can_retval);

        /* Check received RxID frame */
        ASSERT(CAN_LPDU_FD_U32 == (Can_RxId & CAN_LPDU_FD_U32));
    }

	/* Check eventual errors configured to be reported in polling. This will trigger CanErrorNotification. */
	Can_43_LLCE_MainFunction_ErrorNotification();
    can_retval = Can_43_LLCE_SetControllerMode(CONTROLLER0, CAN_CS_STOPPED);
    ASSERT(E_OK == can_retval);
    can_retval = Can_43_LLCE_SetControllerMode(CONTROLLER1, CAN_CS_STOPPED);
    ASSERT(E_OK == can_retval);
    can_retval = Can_43_LLCE_SetControllerMode(LOGICAL_CONTROLLER14, CAN_CS_STOPPED);
    ASSERT(E_OK == can_retval);
    can_retval = Can_43_LLCE_SetControllerMode(LOGICAL_CONTROLLER15, CAN_CS_STOPPED);
    ASSERT(E_OK == can_retval);

    /* 5 writes was executed per iteration */
    ASSERT(5 * ITER_NR == Can_TxConfirmation);
    ASSERT(5 * ITER_NR == Can_RxIndication);

	Can_43_LLCE_DeInit();

}

int main(void)
{
    PlatformInit();
    
    Llce_Firmware_Load();
    Can_Driver_Sample_Test();

    while (1);
}

#ifdef __cplusplus
}
#endif


===== 文件 [18/112]: examples\S32DS\S32G2\Can_Llce_DS_Can2Can_S32G274A_M7\src\stubs.c =====
#include "stubs.h"

/* RX Specific variables used by stub functions */
volatile uint8 Can_RxData[CAN_FD_FRAME_LEN];
volatile uint8  Can_RxHandle;
volatile Can_IdType Can_RxId;
volatile uint8  Can_RxDlc;
volatile uint8  Can_ControllerId;

/* TX  Ok Transmission Specific variables */
volatile PduIdType Can_TxConfirmation_CanTxPduId;
volatile uint32   Can_Tx_No[16];

/* RX and TX specific counters */
#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    volatile uint32 Can_RxIndication;
    volatile uint32 Can_TxConfirmation;
#else
    volatile uint32 Can_RxIndication[MAX_NUM_OF_CORES];
    volatile uint32 Can_TxConfirmation[MAX_NUM_OF_CORES];
#endif

/* Bus Off Specific variables */
volatile uint8  Can_BusOffConfirmation;
volatile uint32 u32CustomCallbackExecutions = 0;

/*==================================================================================================
*                                      CAN stub functions implementation
==================================================================================================*/

void Can_CallBackSetUp(void)
{

#if CAN_43_LLCE_MAX_PARTITIONS != 1U
    uint8 u8Idx = 0U;
#endif
    
    /* Reset global flags. */
    Can_BusOffConfirmation = 0U;    
    Can_RxDlc = 0U;

#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    Can_TxConfirmation = 0U;
    Can_RxIndication = 0U;
#else
    for (u8Idx = 0U; u8Idx < MAX_NUM_OF_CORES; u8Idx++)
    {
        Can_TxConfirmation[u8Idx] = 0U;
        Can_RxIndication[u8Idx] = 0U; 
    }
#endif

}

void CanIf_RxIndication( const Can_HwType* Mailbox, const PduInfoType* PduInfoPtr )
{   
    /* Local variable */
    uint8 i = 0U;
#if CAN_43_LLCE_MAX_PARTITIONS != 1U
    uint32 u32CoreId = OsIf_GetCoreID();
#endif

    for (i = 0; i < PduInfoPtr->SduLength; i++)
    {
        /* Pointer to received L-SDU (payload) */
        Can_RxData[i] = PduInfoPtr->SduDataPtr[i];
    }

     for (i = PduInfoPtr->SduLength; i < CAN_FD_FRAME_LEN; i++)
    {
        /* Clean the rest of the payload if it's not a CAN FD frame*/
        Can_RxData[i] = 0;
    }

    /* Get the id of the corresponding hardware object: Range is 0 .. (total number of HRH-1) */
    Can_RxHandle = Mailbox->Hoh;
    /* standard/Extended Can ID of L-PDU  that has been successfully received */
    Can_RxId = Mailbox->CanId;
    /* Data length code (length of L0PDU payload) */
    Can_RxDlc = PduInfoPtr->SduLength;
    /*Get the id of Controller*/
    Can_ControllerId = Mailbox->ControllerId;

    /* Increment counter to record reception of a message */
#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    Can_RxIndication++;
#else
    Can_RxIndication[u32CoreId]++;
#endif
}

void CanIf_ControllerBusOff( uint8 Controller)
{   
    /* Increment counter to record bus off events */
    Can_BusOffConfirmation++;
    (void)Controller;
}

void CanIf_ControllerModeIndication( uint8 Controller, Can_ControllerStateType ControllerMode )
{
    (void)ControllerMode;
    (void)Controller;
}

void CanIf_TxConfirmation( PduIdType CanTxPduId)
{
#if CAN_43_LLCE_MAX_PARTITIONS != 1U
    uint32 u32CoreId = OsIf_GetCoreID();
#endif
    /* Increment counter to record transmission of a message */
#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    Can_TxConfirmation++;
#else
    u32CoreId = OsIf_GetCoreID();
    Can_TxConfirmation[u32CoreId]++;
#endif
    /* Store the PDU ID for debug purposes */
    Can_TxConfirmation_CanTxPduId = CanTxPduId;
    Can_Tx_No[CanTxPduId]++;
}

void RxTimestampNotification(Can_HwHandleType Hoh, uint32 u32TimestampVal)
{
	(void)u32TimestampVal; /* timestamp for current received frame identified through Hoh */
	(void)Hoh;
}

void TxTimestampNotification(Can_HwHandleType Hoh, PduIdType CanTxPduId, uint32 u32TimestampVal)
{
	(void)u32TimestampVal; /* timestamp for current frame confirmation identified through Hoh and CanTxPduId (frameTag1 and frameTag2) */
	(void)Hoh;
	(void)CanTxPduId;
}

/* Callback for errors. This is triggered for errors configured in INTERRUPT or by calling MainFunction_Error */
void CanErrorNotification(uint8 u8CanIfCtrlId, Llce_Can_NotificationIdType eNotifId, volatile Llce_Can_ErrorNotifType* ErrorInfo)
{
	(void)u8CanIfCtrlId; 
	(void)eNotifId;
	(void)ErrorInfo;
}

void CanWriteCustomCallback(Can_HwHandleType Hoh, PduIdType CanTxPduId, uint32 u32TxMb)
{
	(void)Hoh; 
	(void)CanTxPduId;
	(void)u32TxMb;
}

void CanTxConfirmationCustomCallback(Can_HwHandleType Hoh, PduIdType CanTxPduId)
{
	(void)Hoh; 
	(void)CanTxPduId;
}


boolean Can_43_LLCE_RxCustomCallback(uint8 Hrh, Can_IdType CanId, uint8 CanDataLength, const uint8* CanSduPtr, uint32 u32RxMb)
{
    /* Suppress warnings for unused arguments */
    (void)Hrh; (void)CanId; (void)CanDataLength; (void)CanSduPtr; (void)u32RxMb;

    u32CustomCallbackExecutions++;

    /* Returns FALSE for even IDs */
    return (CanId & 0x01);
}


===== 文件 [19/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\Project_Settings\Startup_Code\Vector_Table.s =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
*   @file    Vector_Table.s
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - Vector Table.
*   @details Vector Table.
*            This file contains sample code only. It is not part of the production code deliverables
==================================================================================================*/

.section  ".intc_vector","ax"
.align 2
.thumb
.globl undefined_handler
.globl undefined_handler
.globl VTABLE
.globl __Stack_dtcm_start        /* Top of Stack for Initial Stack Pointer */
.globl Reset_Handler             /* Reset Handler */
.globl NMI_Handler               /* NMI Handler */
.globl HardFault_Handler         /* Hard Fault Handler */
.globl MemManage_Handler         /* Reserved */
.globl BusFault_Handler          /* Bus Fault Handler */
.globl UsageFault_Handler        /* Usage Fault Handler */
.globl SVC_Handler               /* SVCall Handler */
.globl DebugMon_Handler          /* Debug Monitor Handler */
.globl PendSV_Handler            /* PendSV Handler */
.globl SysTick_Handler           /* SysTick Handler */ /* 15*/

VTABLE:
.long __Stack_dtcm_start          /* Top of Stack for Initial Stack Pointer */
.long Reset_Handler+1           /* Reset Handler need plus 1 because Reset_Handler is generated with LSB bit =0*/
.long NMI_Handler               /* NMI Handler */
.long HardFault_Handler         /* Hard Fault Handler */
.long MemManage_Handler         /* Reserved */
.long BusFault_Handler          /* Bus Fault Handler */
.long UsageFault_Handler        /* Usage Fault Handler */
.long 0                         /* Reserved */
.long 0                         /* Reserved */
.long 0                         /* Reserved */
.long 0                         /* Reserved */
.long SVC_Handler+1             /* SVCall Handler */
.long DebugMon_Handler          /* Debug Monitor Handler */
.long 0                         /* Reserved */
.long PendSV_Handler            /* PendSV Handler */
.long SysTick_Handler           /* SysTick Handler */ /* 15*/

.long undefined_handler /*0*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*10*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*20*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*30*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler /*40*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler /*50*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*60*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*70*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*80*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*90*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*100*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*110*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*120*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*130*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*140*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*150*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*160*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*170*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*180*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*190*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*200*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*210*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*220*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*230*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*240*/
.long undefined_handler




.size VTABLE, . - VTABLE


===== 文件 [20/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\Project_Settings\Startup_Code\exceptions.c =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
*   @file    exceptions.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - Interrupts table.
*   @details Interrupts table.
*            This file contains sample code only. It is not part of the production code deliverables.
==================================================================================================*/

#ifdef __cplusplus
extern "C" {
#endif

#include "Platform_Types.h"
#include "Mcal.h"

#define PLATFORM_START_SEC_CODE
#include "Platform_MemMap.h"

void NMI_Handler(void)                  __attribute__ ((weak));               /* NMI Handler */
void HardFault_Handler(void)            __attribute__ ((weak));         /* Hard Fault Handler */
void MemManage_Handler(void)            __attribute__ ((weak));         /* Reserved */
void BusFault_Handler(void)             __attribute__ ((weak));          /* Bus Fault Handler */
void UsageFault_Handler(void)           __attribute__ ((weak));        /* Usage Fault Handler */
void DebugMon_Handler(void)             __attribute__ ((weak));          /* Debug Monitor Handler */
void PendSV_Handler(void)               __attribute__ ((weak));            /* PendSV Handler */
void SysTick_Handler(void)              __attribute__ ((weak));           /* SysTick Handler */
void undefined_handler(void);         /* Undefined Handler */
#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
void SVCHandler_main(uint32 * svc_args);
void Suspend_Interrupts(void);
void Resume_Interrupts(void);
#endif

#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
#ifndef __ICCARM__
#ifdef _DIABDATA_C_S32G2XX_
/* Define the SVC handler in assembly, to ensure there is no extra PUSH instruction at the beginning of the C handler.*/
__asm(".section .mcal_text");
__asm(".globl SVC_Handler");
__asm(".weak SVC_Handler");
__asm("SVC_Handler:");
/*Load in R0 the stack pointer (depneding on context from which SVC is called)*/
__asm("tst     lr, #4");
__asm("ite eq");
__asm("mrseq   r0, MSP");
__asm("mrsne   r0, PSP");
/* stack pointer is passed to SVCHandler_main, it will be used to extract the parameter given to svc call*/
__asm("b       SVCHandler_main");
#else
/* Define the SVC handler in assembly, to ensure there is no extra PUSH instruction at the beginning of the C handler.*/
ASM_KEYWORD(".globl SVC_Handler");
ASM_KEYWORD(".weak SVC_Handler");
ASM_KEYWORD("SVC_Handler:");
/*Load in R0 the stack pointer (depneding on context from which SVC is called)*/
ASM_KEYWORD("tst     lr, #4");
ASM_KEYWORD("ite eq");
ASM_KEYWORD("mrseq   r0, MSP");
ASM_KEYWORD("mrsne   r0, PSP");
/* stack pointer is passed to SVCHandler_main, it will be used to extract the parameter given to svc call*/
ASM_KEYWORD("b       SVCHandler_main");
#endif
#else
void SVC_Handler(void) __attribute__((naked, weak));
void SVC_Handler(void)
{
    ASM_KEYWORD("tst lr, #4\n"\
                "ite eq\n" \
                "mrseq   r0, MSP\n" \
                "mrsne   r0, PSP\n");
    /* stack pointer is passed to SVCHandler_main, it will be used to extract the parameter given to svc call*/
    ASM_KEYWORD("b       SVCHandler_main");
}
#endif
#endif


void NMI_Handler(void)
{
    while(TRUE){};
}
void HardFault_Handler(void)
{
    while(TRUE){};
}
void MemManage_Handler(void)
{
    while(TRUE){};
}
void BusFault_Handler(void)
{
    while(TRUE){};
}
void UsageFault_Handler(void)
{
    while(TRUE){};
}

#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
void SVC_Handler(void)  __attribute__ ((weak));               /* SVCall Handler */
void SVC_Handler(void)
{
    while(TRUE){};
}
#else
void SVCHandler_main(uint32 * svc_args)
{
    uint32 svc_number;    /* Stack contains:    * r0, r1, r2, r3, r12, r14, the return address and xPSR   */
                                /* First argument (r0) is svc_args[0]  */
    /* svc_args[6] =  SP + 0x18  PC(r15) */
    /* ((char *)svc_args[6])[-2]; = first two bytes, lsb, of the instruction which caused the SVC */
    /* this will nto work if optimization compiler options are changed*/
    svc_number = ((uint8 *)svc_args[6])[-2];
    switch(svc_number)
    {
        case 1:
            /* Handle SVC 01*/
            ASM_KEYWORD("mov   r0, #0x1");   /* Set User mode for Thread mode */
            ASM_KEYWORD("msr   CONTROL, r0");
            break;
        case 0:
            /* Handle SVC 00*/
            ASM_KEYWORD("mov   r0, #0x0");   /* Set Supervisor mode for Thread mode */
            ASM_KEYWORD("msr   CONTROL, r0");
            break;
        case 2:
            /* Handle SVC 02*/
            Resume_Interrupts(); /* Resume all interrupts */
            
            break;
        case 3:
            /* Handle SVC 03*/
            Suspend_Interrupts(); /* Suspend all interrupts */

            break;
        default:
            /* Unknown SVC*/
            break;
    }
}

void Suspend_Interrupts(void)
{
    ASM_KEYWORD("push {r0}");
    ASM_KEYWORD("mov   r0, #0x10");
    ASM_KEYWORD(" msr BASEPRI, r0");
    ASM_KEYWORD("pop {r0}");
}

void Resume_Interrupts(void)
{
    ASM_KEYWORD("push {r0}");
    ASM_KEYWORD("mov   r0, #0x0");
    ASM_KEYWORD("msr BASEPRI, r0");
    ASM_KEYWORD("pop {r0}");
}
#endif
void DebugMon_Handler(void)
{
    while(TRUE){};
}
void PendSV_Handler(void)
{
    while(TRUE){};
}
void SysTick_Handler(void)
{
    while(TRUE){};
}
void undefined_handler(void)
{
   while(TRUE){};
}

#define PLATFORM_STOP_SEC_CODE
#include "Platform_MemMap.h"

#ifdef __cplusplus
}
#endif


===== 文件 [21/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\Project_Settings\Startup_Code\nvic.c =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
*   @file    nvic.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - nvic driver
*   @details Functions that manage interrupts and exceptions via the NVIC.
*            This file contains sample code only. It is not part of the production code deliverables.
==================================================================================================*/

#include "Std_Types.h"
#include "nvic.h"

#if defined(S32G2XX)
    #include "S32G274A_NVIC.h"
    #include "S32G274A_SCB.h"
#elif defined(S32R45)
    #include "S32R45_SCB.h"
    #include "S32R45_NVIC.h"
#elif defined(S32G3XX)
    #include "S32G399A_SCB.h"
    #include "S32G399A_NVIC.h"
#endif


/*==================================================================================================
*                                        LOCAL MACROS
==================================================================================================*/
/*==================================================================================================
*                                      FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL VARIABLES
==================================================================================================*/
#define FEATURE_NVIC_PRIO_BITS (4U)

/*==================================================================================================
*                                       GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/*================================================================================================*/
#define PLATFORM_START_SEC_CODE
#include "Platform_MemMap.h"
/** 
* @brief Set Priority Grouping
* @details The function sets the priority grouping field using the required unlock sequence.
*  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
*   Only values from 0..7 are used.
*   In case of a conflict between priority grouping and available
*   priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set
*/
/*================================================================================================*/
void NVIC_SetPriorityGrouping(uint32 PriorityGroup)
{
    /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
    S32_SCB->AIRCR = (S32_SCB->AIRCR & (~0x700UL)) | PriorityGroup;
}

/*================================================================================================*/
/** 
* @brief Enable External Interrupt
* @details The function enables a device-specific interrupt in the NVIC interrupt controller.
*/
/*================================================================================================*/ 
void NVIC_EnableIRQ(uint8 IRQn)
{
    S32_NVIC->ISER[(uint32)(IRQn) >> 5U] = (uint32)(1UL << ((uint32)(IRQn) & (uint32)0x1FU));
}

/*================================================================================================*/
/** 
* @brief Disable External Interrupt
* @details The function disables a device-specific interrupt in the NVIC interrupt controller
*/
/*================================================================================================*/  
void NVIC_DisableIRQ(uint8 IRQn)
{
    S32_NVIC->ICER[(uint32)(IRQn) >> 5U] = (uint32)(1UL << ((uint32)(IRQn) & (uint32)0x1FU));
}
 
 
/*================================================================================================*/
/** 
* @brief Set Interrupt Priority
* @details The function sets the priority of an interrupt.
*/
/*================================================================================================*/  
void NVIC_SetPriority(uint8 IRQn, uint8 priority)
{
    uint8 shift = (uint8) (8U - FEATURE_NVIC_PRIO_BITS);
    S32_NVIC->IP[(uint32)(IRQn)] = (uint8)(((((uint32)priority) << shift)) & 0xFFUL);
}
 
 
#define PLATFORM_STOP_SEC_CODE
#include "Platform_MemMap.h"


===== 文件 [22/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\Project_Settings\Startup_Code\startup.c =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/
/**
*   @implements startup.c_Artifact
*/

#include "Std_Types.h"

/*******************************************************************************
 * Definitions
 *******************************************************************************/
#if (CPU_TYPE == CPU_TYPE_64)
    typedef uint64 uintptr;
#elif (CPU_TYPE == CPU_TYPE_32)
    typedef uint32 uintptr;
#elif (CPU_TYPE == CPU_TYPE_16)
    typedef uint16 uintptr;
#else
    typedef uint8 uintptr;
#endif

 /*!
 * @brief Defines the init table layout
 */
typedef struct
{
    uint32 * ram_start; /*!< Start address of section in RAM */
    uint32 * rom_start; /*!< Start address of section in ROM */
    uint32 * rom_end;   /*!< End address of section in ROM */
} Sys_CopyLayoutType;

/*!
 * @brief Defines the zero table layout
 */
typedef struct
{
    uint32 * ram_start; /*!< Start address of section in RAM */
    uint32 * ram_end;   /*!< End address of section in RAM */
} Sys_ZeroLayoutType;

extern uintptr __INIT_TABLE[1U];
extern uintptr __ZERO_TABLE[1U];
extern uintptr __INDEX_COPY_CORE2[];
#if (defined(__ARMCC_VERSION))
    extern uintptr __VECTOR_RAM;
#else
    extern uintptr __VECTOR_RAM[1U];
#endif

/*******************************************************************************
 * Static Variables
 ******************************************************************************/

/*******************************************************************************
 * Code
 ******************************************************************************/
/*FUNCTION**********************************************************************
 *
 * Function Name : init_data_bss
 * Description   : Make necessary initializations for RAM.
 * - Copy the vector table from ROM to RAM.
 * - Copy initialized data from ROM to RAM.
 * - Copy code that should reside in RAM from ROM
 * - Clear the zero-initialized data section.
 *
 * Tool Chains:
 *   __GNUC__           : GNU Compiler Collection
 *   __ghs__            : Green Hills ARM Compiler
 *   __ICCARM__         : IAR ARM Compiler
 *   __DCC__            : Wind River Diab Compiler
 *   __ARMCC_VERSION    : ARMC Compiler
 *
 * Implements    : init_data_bss_Activity
 *END**************************************************************************/
#define PLATFORM_START_SEC_CODE
#include "Platform_MemMap.h"
 
void init_data_bss(void);
void init_data_bss_core2(void);

void init_data_bss(void)
{
    const Sys_CopyLayoutType * copy_layout;
    const Sys_ZeroLayoutType * zero_layout;
    const uint32 * rom;
    const uint8 * rom8;
    uint32 * ram;
    uint8 * ram8;
    uint8 dataPad;
    uint32 len = 0U;
    uintptr size = 0U;
    uint32 i = 0U;
    uint32 j = 0U;

    const uintptr * initTable_Ptr = (uintptr*)__INIT_TABLE;
    const uintptr * zeroTable_Ptr = (uintptr*)__ZERO_TABLE;

    /* Copy initialized table */
    len = *initTable_Ptr;
    initTable_Ptr++;
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
    for(i = 0U; i < len; i++)
    {
        rom = copy_layout[i].rom_start;
        ram = copy_layout[i].ram_start;
        size = (uintptr)copy_layout[i].rom_end - (uintptr)copy_layout[i].rom_start;
        /* Make sure the data area to be copied must be aligned with 4. Then, copy 4 bytes at per one read */
        dataPad = size & 0x3U;
        for(j = 0U; j < ((size - dataPad) >> 2U); j++)
        {
            ram[j] = rom[j];
        }
        /* For the rest of data, copy 1 bytes at per one read */
        rom8 = (uint8 *)&(rom[j]);
        ram8 = (uint8 *)&(ram[j]);
        for (j = 0U; j < dataPad; j++)
        {
            ram8[j] = rom8[j];
        }
    }

    /* Clear zero table */
    len = *zeroTable_Ptr;
    zeroTable_Ptr++;
    zero_layout = (const Sys_ZeroLayoutType *)zeroTable_Ptr;
    for(i = 0U; i < len; i++)
    {
        ram = zero_layout[i].ram_start;
        size = (uintptr)zero_layout[i].ram_end - (uintptr)zero_layout[i].ram_start;
        for(j = 0U; j < (size >> 2U); j++)
        {
            ram[j] = 0U;
        }
        /* Since the size of the section always aligns with 32bits according to the sample file linker. 
           Zeroing the last 4 bytes of the section if the data to be used of program does not align with 4.*/
        if ((size & 0x3U) != 0U)
        {
            ram[j] = 0U;
        }
    }
}

void init_data_bss_core2(void)
{
    const Sys_CopyLayoutType * copy_layout;
    const uint32 * rom;
    const uint8 * rom8;
    uint32 * ram;
    uint8 * ram8;
    uint8 dataPad;
    uint32 len = 0U;
    uintptr size = 0U;
    uint32 i = 0U;
    uint32 j = 0U;

    const uintptr * initTable_Ptr = (uintptr*)__INIT_TABLE;

    /* Copy initialized table */
    len = *initTable_Ptr;
    initTable_Ptr++;
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
    for(i = (uintptr)__INDEX_COPY_CORE2; i < len; i++)
    {
        rom = copy_layout[i].rom_start;
        ram = copy_layout[i].ram_start;
        size = (uintptr)copy_layout[i].rom_end - (uintptr)copy_layout[i].rom_start;
        /* Make sure the data area to be copied must be aligned with 4. Then, copy 4 bytes at per one read */
        dataPad = size & 0x3U;
        for(j = 0U; j < ((size - dataPad) >> 2U); j++)
        {
            ram[j] = rom[j];
        }
        /* For the rest of data, copy 1 bytes at per one read */
        rom8 = (uint8 *)&(rom[j]);
        ram8 = (uint8 *)&(ram[j]);
        for (j = 0U; j < dataPad; j++)
        {
            ram8[j] = rom8[j];
        }
    }
}
#define PLATFORM_STOP_SEC_CODE
#include "Platform_MemMap.h"

/*******************************************************************************
 * EOF
 ******************************************************************************/


===== 文件 [23/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\Project_Settings\Startup_Code\startup_cm7.s =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
*   @file    startup_cm7.s
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - Startup file for ARM.
*   @details Startup file for ARM.
*            This file contains sample code only. It is not part of the production code deliverables
==================================================================================================*/

#define MAIN_CORE 4
#define CM7_ITCMCR 0xE000EF90
#define CM7_DTCMCR 0xE000EF94

#define SBAF_BOOT_MARKER   (0x5AA55AA5)
#define CM7_0_ENABLE_SHIFT (0)
#define CM7_1_ENABLE_SHIFT (1)

#define CM7_0_ENABLE            (1)
#define CM7_1_ENABLE            (0)
#define CM7_0_VTOR_ADDR         (__INIT_INTERRUPT_START)
#define CM7_1_VTOR_ADDR         (0)
#define XRDC_CONFIG_ADDR        (0)
#define LF_CONFIG_ADDR          (0)

    .syntax unified
    .arch armv7-m
/* Table for copying and zeroing */
/* Copy table:
  - Table entries count
    - entry one ram start
    - entry one rom start
    - entry one rom end
    ...
    - entry n ram start
    - entry n rom start
    - entry n rom end
  Zero Table:
    - Table entries count
      - entry one ram start
      - entry one ram end
*/
.section ".init_table", "a"
  .long 6
  .long __RAM_CACHEABLE_START
  .long __ROM_CACHEABLE_START
  .long __ROM_CACHEABLE_END
  .long __RAM_NO_CACHEABLE_START
  .long __ROM_NO_CACHEABLE_START
  .long __ROM_NO_CACHEABLE_END
  .long __RAM_SHAREABLE_START
  .long __ROM_SHAREABLE_START
  .long __ROM_SHAREABLE_END
  .long __HSE_RAM_SHAREABLE_START
  .long __HSE_ROM_SHAREABLE_START
  .long __HSE_ROM_SHAREABLE_END
  .long __RAM_INTERRUPT_START
  .long __INIT_INTERRUPT_START
  .long __INIT_INTERRUPT_END
  .long __RAM_DTCM_START
  .long __ROM_DTCM_START
  .long __ROM_DTCM_END
.section ".zero_table", "a"
  .long 4
  .long __BSS_SRAM_SH_START
  .long __BSS_SRAM_SH_END
  .long __BSS_HSE_SRAM_SH_START
  .long __BSS_HSE_SRAM_SH_END
  .long __BSS_SRAM_NC_START
  .long __BSS_SRAM_NC_END
  .long __BSS_SRAM_START
  .long __BSS_SRAM_END

.globl RESET_CATCH_CORE
.globl _core_loop
.section ".core_loop","ax"
.thumb

_core_loop:
    nop
    nop
    nop
    nop
    b _core_loop

.section ".boot_header","ax"
  .long SBAF_BOOT_MARKER /* IVT marker */
  .long (CM7_0_ENABLE << CM7_0_ENABLE_SHIFT) | (CM7_1_ENABLE << CM7_1_ENABLE_SHIFT) /* Boot configuration word */
  .long 0 /* Reserved */
  .long CM7_0_VTOR_ADDR /* CM7_0 Start address */
  .long 0 /* Reserved */
  .long CM7_1_VTOR_ADDR /* CM7_1 Start address */
  .long 0 /* Reserved */
  .long XRDC_CONFIG_ADDR /* XRDC configuration pointer */
  .long LF_CONFIG_ADDR /* Lifecycle configuration pointer */
  .long 0 /* Reserved */

.globl VTABLE
.section ".startup","ax"
.thumb
/************************************************************************/
/* Autosar synopsis of startup code (See MCU Specification):            */
/*                                                                      */
/*   Before the MCU driver can be initialized, a basic initialization   */
/*   of the MCU has to be executed. This MCU specific initialization is */
/*   typically executed in a start-up code. The start-up code of the    */
/*   MCU shall be executed after power up and any kind of micro-        */
/*   controller reset. It shall perform very basic and microcontroller  */
/*   specific start-up initialization and shall be kept short, because  */
/*   the MCU clock and PLL is not yet initialized. The start-up code    */
/*   shall cover MCU specific initialization, which is not part of      */
/*   other MCU services or other MCAL drivers. The following steps      */
/*   summarizes basic functionality which shall be included in the      */
/*   start-up code. They are listed for guidance, because some          */
/*   functionality might not be supported. No code will be found in     */
/*   case.                                                              */
/************************************************************************/
.set VTOR_REG, 0xE000ED08
.thumb 
.thumb_func
.globl Reset_Handler
.globl _start
_start:
Reset_Handler:
/*****************************************************/
/* Skip normal entry point as nothing is initialized */
/*****************************************************/
 cpsid i
 mov   r0, #0
 mov   r1, #0
 mov   r2, #0
 mov   r3, #0
 mov   r4, #0
 mov   r5, #0
 mov   r6, #0
 mov   r7, #0


/*******************************************************************/
/* NXP Guidance 1 - Init registers to avoid lock-step issues */
/* N/A                                                             */
/*******************************************************************/

/*******************************************************************/
/* NXP Guidance 2 - MMU Initialization for CPU               */
/*  TLB0 - PbridgeB                                                */
/*  TLB1 - Internal Flash                                          */
/*  TLB2 - External SRAM                                           */
/*  TLB3 - Internal SRAM                                           */
/*  TLB4 - PbridgeA                                                */
/*******************************************************************/

/******************************************************************/
/* Autosar Guidance 1 - The start-up code shall initialize the    */
/* base addresses for interrupt and trap vector tables. These base*/
/* addresses are provided as configuration parameters or          */
/* linker/locator setting.                                        */
/******************************************************************/

/* relocate vector table to RAM */
ldr  r0, =VTOR_REG
ldr  r1, =__RAM_INTERRUPT_START
str  r1,[r0]

/******************************************************************/
/* Autosar Guidance 2 - The start-up code shall initialize the    */
/* interrupt stack pointer, if an interrupt stack is              */
/* supported by the MCU. The interrupt stack pointer base address */
/* and the stack size are provided as configuration parameter or  */
/* linker/locator setting.                                        */
/*                                                                */
/******************************************************************/


/******************************************************************/
/* Autosar Guidance 3 - The start-up code shall initialize the    */
/* user stack pointer. The user stack pointer base address and    */
/* the stack size are provided as configuration parameter or      */
/* linker/locator setting.                                        */
/******************************************************************/
/* Enable TCM and Disable RETEN bit */
ldr r1, =CM7_DTCMCR
ldr r0, [r1]
bic r0, r0, #0x4
orr r0, r0, #0x1
str r0, [r1]
/* set up stack; r13 SP*/
ldr  r0, =__Stack_dtcm_start
msr MSP, r0
/*GetCoreID*/
ldr  r0, =0x40198004
ldr  r1,[r0]

ldr  r0, =MAIN_CORE
cmp  r1,r0
beq  DisableSWT0

ldr  r0, =0x5
cmp  r1,r0
beq  DisableSWT1

ldr  r0, =0x6
cmp  r1,r0
beq  DisableSWT2

ldr  r0, =0x7
cmp  r1,r0
beq  DisableSWT7

/******************************************************************/
/* Autosar Guidance 4 - If the MCU supports context save          */
/* operation, the start-up code shall initialize the memory which */
/* is used for context save operation. The maximum amount of      */
/* consecutive context save operations is provided as             */
/* configuration parameter or linker/locator setting.             */
/*                                                                */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 5 - The start-up code shall ensure that the   */
/* MCU internal watchdog shall not be serviced until the watchdog */
/* is initialized from the MCAL watchdog driver. This can be      */
/* done for example by increasing the watchdog service time.      */
/*                                                                */
/******************************************************************/

/* Note from manual: For any operation to be performed on an SWT  */
/* instance, its respective core must be enabled.                 */
DisableSWT0:
  ldr  r0, =0x40100010
  ldr  r1, =0xC520
  str  r1, [r0]
  ldr  r1, =0xD928
  str  r1, [r0]
  ldr  r0, =0x40100000
  ldr  r1, =0xFF000040
  str  r1, [r0]
  b    RamInit

DisableSWT1:
  /* disable SWT1 */
  ldr  r0, =0x40104010
  ldr  r1, =0xC520
  str  r1, [r0]
  ldr  r1, =0xD928
  str  r1, [r0]
  ldr  r0, =0x40104000
  ldr  r1, =0xFF000040
  str  r1, [r0]
  b    RamInit

DisableSWT2:
  /* disable SWT2 */
  ldr  r0, =0x40108010
  ldr  r1, =0xC520
  str  r1, [r0]
  ldr  r1, =0xD928
  str  r1, [r0]
  ldr  r0, =0x40108000
  ldr  r1, =0xFF000040
  str  r1, [r0]
  b    RamInit
  

DisableSWT7:
  /* disable SWT7 */
  ldr  r0, =0x4020C010
  ldr  r1, =0xC520
  str  r1, [r0]
  ldr  r1, =0xD928
  str  r1, [r0]
  ldr  r0, =0x4020C000
  ldr  r1, =0xFF000040
  str  r1, [r0]
  b    RamInit

/******************************************************************/
/* Autosar Guidance 13 - The start-up code shall initialize a     */
/* minimum amount of RAM in order to allow proper execution of    */
/* the MCU driver services and the caller of these services.      */
/******************************************************************/
RamInit:
    /* Initialize SRAM ECC */
    ldr  r0, =__RAM_INIT
    cmp  r0, 0
    /* Skip if __SRAM_INIT is not set */
    beq SRAM_LOOP_END
    ldr r1, =__INT_SRAM_START
    ldr r2, =__INT_SRAM_END
    
    subs    r2, r1
    subs    r2, #1
    ble SRAM_LOOP_END

    movs    r0, 0
    movs    r3, 0
SRAM_LOOP:
    stm r1!, {r0,r3}
    subs r2, 8
    bge SRAM_LOOP
SRAM_LOOP_END:

DTCM_Init:
    /* Initialize DTCM ECC */
    ldr  r0, =__DTCM_INIT
    cmp  r0, 0
    /* Skip if __DTCM_INIT is not set */
    beq DTCM_LOOP_END

    ldr r1, =__INT_DTCM_START
    ldr r2, =__INT_DTCM_END
    
    subs    r2, r1
    subs    r2, #1
    ble DTCM_LOOP_END

    movs    r0, 0
    movs    r3, 0
DTCM_LOOP:
    stm r1!, {r0,r3}
    subs r2, #8
    bge DTCM_LOOP
DTCM_LOOP_END:

ITCM_Init:
    /* Initialize ITCM ECC */
    ldr  r0, =__ITCM_INIT
    cmp  r0, 0
    /* Skip if __TCM_INIT is not set */
    beq ITCM_LOOP_END

    /* Enable TCM */
    LDR r1, =CM7_ITCMCR
    LDR r0, [r1]
    LDR r2, =0x1
    ORR r0, r2
    STR r0, [r1]

    ldr r1, =__INT_ITCM_START
    ldr r2, =__INT_ITCM_END
    
    subs    r2, r1
    subs    r2, #1
    ble ITCM_LOOP_END

    movs    r0, 0
    movs    r3, 0
ITCM_LOOP:
    stm r1!, {r0,r3}
    subs r2, #8
    bge ITCM_LOOP
ITCM_LOOP_END:

DebuggerHeldCoreLoop:
  ldr  r0, =RESET_CATCH_CORE
  ldr  r0, [r0]
  ldr  r1, =0x5A5A5A5A
  cmp  r0, r1
  beq	DebuggerHeldCoreLoop

/************************/
/* Erase ".bss Section" */
/************************/
#ifndef MULTIPLE_IMAGE
_DATA_INIT:
    /* If this is the primary core, initialize data and bss */
    ldr  r0, =0x40198004
    ldr  r1,[r0]

    ldr  r0, =MAIN_CORE
    cmp  r1,r0
    beq	 _INIT_DATA_BSS
    bl   init_data_bss_core2
    b __SYSTEM_INIT
#endif

_INIT_DATA_BSS:
  bl init_data_bss


/******************************************************************/
/* Autosar Guidance 6 - If the MCU supports cache memory for data */
/* and/or code, it shall be initialized and enabled in the        */
/* start-up code.                                                 */
/*                                                                */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 7 - The start-up code shall initialize MCU    */
/* specific features of internal memory like memory protection.   */
/*                                                                */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 8 - If external memory is used, the memory    */
/* shall be initialized in the start-up code. The start-up code   */
/* shall be prepared to support different memory configurations   */
/* depending on code location. Different configuration options    */
/* shall be taken into account for code execution from            */
/* external/internal memory.                                      */
/* N/A - external memory is not used                              */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 9 - The settings of the different memories    */
/* shall be provided to the start-up code as configuration        */
/* parameters.                                                    */
/* N/A - all memories are already configured                      */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 10 - In the start-up code a default           */
/* initialization of the MCU clock system shall be performed      */
/* including global clock prescalers.                             */
/******************************************************************/
__SYSTEM_INIT:
  bl SystemInit

/******************************************************************/
/* Autosar Guidance 5 - The start-up code shall ensure that the   */
/* MCU internal watchdog shall not be serviced until the watchdog */
/* is initialized from the MCAL watchdog driver. This can be      */
/* done for example by increasing the watchdog service time.      */
/*                                                                */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 11 - The start-up code shall enable           */
/* protection mechanisms for special function registers(SFR's),   */
/* if supported by the MCU.                                       */
/* N/A - will be handled by Autosar OS                            */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 12 - The start-up code shall initialize all   */
/* necessary write once registers or registers common to several  */
/* drivers where one write, rather than repeated writes, to the   */
/* register is required or highly desirable.                      */
/******************************************************************/

/*********************************/
/* Set the small ro data pointer */
/*********************************/


/*********************************/
/* Set the small rw data pointer */
/*********************************/

/******************************************************************/
/* Call Main Routine                                              */
/******************************************************************/
_MAIN:
  cpsie i
  bl startup_go_to_user_mode
  bl main

/******************************************************************/
/* Init runtime check data space                                  */
/******************************************************************/
.globl MCAL_LTB_TRACE_OFF
 MCAL_LTB_TRACE_OFF:
    nop

#ifdef CCOV_ENABLE
    /* code coverage is requested */
    bl ccov_main
#endif

    /*BKPT #1 - removed to avoid debug fault being escalated to hardfault when debugger is not attached or on VDK*/ /* last instruction for the debugger to dump results data */
.globl _end_of_eunit_test
_end_of_eunit_test:
    b .

#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
.globl startup_getControlRegisterValue
startup_getControlRegisterValue:
mrs r0, CONTROL
bx r14

.globl startup_getAipsRegisterValue
startup_getAipsRegisterValue:
mrs r0, IPSR
bx r14
#endif

.align 4
.ltorg


===== 文件 [24/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\Project_Settings\Startup_Code\system.c =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*================================================================================================
*   @file    system.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - SYSTEM
*   @details SYSTEM
*            This file contains sample code only. It is not part of the production code deliverables.
==================================================================================================*/

#ifdef __cplusplus
extern "C" {
#endif

/*==================================================================================================
*                                         INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Platform_Types.h"
#include "Mcal.h"
#if defined(S32G2XX)
    #include "S32G274A_MSCM.h"
    #include "S32G274A_FXOSC.h"
    #include "S32G274A_MC_CGM_0.h"
    #include "S32G274A_MC_CGM_1.h"
    #include "S32G274A_MC_CGM_2.h"
    #include "S32G274A_SCB.h"
    #include "S32G274A_MPU.h"
    #include "S32G274A_MC_ME.h"
    #include "S32G274A_MC_RGM.h"
    #include "S32G274A_SECURITY.h"
    #include "S32G274A_MDM_AP.h"
    #include "S32G274A_SIUL2.h"
#elif defined(S32R45)
    #include "S32R45_MSCM.h"
    #include "S32R45_FXOSC.h"
    #include "S32R45_MC_CGM_0.h"
    #include "S32R45_MC_CGM_1.h"
    #include "S32R45_MC_CGM_2.h"
    #include "S32R45_SCB.h"
    #include "S32R45_MPU.h"
    #include "S32R45_MC_ME.h"
    #include "S32R45_MC_RGM.h"
    #include "S32R45_SECURITY.h"
    #include "S32R45_MDM_AP.h"
    #include "S32R45_SIUL2.h"
#elif defined(S32G3XX)
    #include "S32G399A_MSCM.h"
    #include "S32G399A_FXOSC.h"
    #include "S32G399A_MC_CGM_0.h"
    #include "S32G399A_MC_CGM_1.h"
    #include "S32G399A_MC_CGM_2.h"
    #include "S32G399A_SCB.h"
    #include "S32G399A_MPU.h"
    #include "S32G399A_MC_ME.h"
    #include "S32G399A_MC_RGM.h"
    #include "S32G399A_SECURITY.h"
    #include "S32G399A_MDM_AP.h"
    #include "S32G399A_SIUL2.h"
#endif

#if (MCAL_PLATFORM_ARM  == MCAL_ARM_AARCH64)
#include "gic500.h"
#else
#include "nvic.h"
#include "core_specific.h"
#endif
#include "system.h"

/*==================================================================================================
*                                      FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/
#define CA53_0_0 (0UL)
#define CA53_0_1 (1UL)
#define CA53_1_0 (2UL)
#define CA53_1_1 (3UL)
#define CM7_0    (4UL)
#define CM7_1    (5UL)
#define CM7_2    (6UL)
#define CM7_3    (7UL)

#define SIUL2_MINOR_MASK             (0x0FU)
#define SIUL2_MINOR_SHIFT            (0x0U)
#define SIUL2_MAJOR_MASK             (0xF0U)
#define SIUL2_MAJOR_SHIFT            (0x4U)


#if (MCAL_PLATFORM_ARM  == MCAL_ARM_AARCH64)
#define SVC_GoToSupervisor()
#define SVC_GoToUser()
#else
#define SVC_GoToSupervisor()      ASM_KEYWORD("svc 0x0")
#define SVC_GoToUser()            ASM_KEYWORD("svc 0x1")
#endif

#define S32_SCB_CPACR_CPx_SHIFT(CpNum)            (2U*((uint32)CpNum))
#define S32_SCB_CPACR_CPx_MASK(CpNum)             (0x3U << S32_SCB_CPACR_CPx_SHIFT(CpNum))
#define S32_SCB_CPACR_CPx(CpNum, x)               (((uint32)(((uint32)(x))<<S32_SCB_CPACR_CPx_SHIFT((CpNum))))&S32_SCB_CPACR_CPx_MASK((CpNum)))

/*==================================================================================================
*                                       LOCAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL VARIABLES
==================================================================================================*/
#define PLATFORM_START_SEC_VAR_CLEARED_32
#include "Platform_MemMap.h"
/* Allocate a global variable which will be overwritten by the debugger if attached(in CMM), to catch the core after reset. */
uint32 RESET_CATCH_CORE;
#define PLATFORM_STOP_SEC_VAR_CLEARED_32
#include "Platform_MemMap.h"

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/

#define PLATFORM_START_SEC_CODE
#include "Platform_MemMap.h"

/*================================================================================================*/
/*
 * @brief Initializes the caches on the platform based on build options. This requires the MPU areas to be configured and enabled before calling this routine.
 * @param: None
 *
 * @return: None
 */
static INLINE void sys_m7_cache_init(void);
/*
 * @brief Disables any previously configured and initialized cache, please make sure MPU is enabled before calling these apis
 * @param: None
 *
 * @return: None
 */
static INLINE void sys_m7_cache_disable(void);
/*
 * @brief Performs a cache clean operation over the configured caches.
 * @param: None
 *
 * @return: None
 */
static INLINE void sys_m7_cache_clean(void);

#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
LOCAL_INLINE void Direct_GoToUser(void);
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/
/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/
#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
LOCAL_INLINE void Direct_GoToUser(void)
{
    ASM_KEYWORD("push {r0}");
    ASM_KEYWORD("ldr r0, =0x1");
    ASM_KEYWORD("msr CONTROL, r0");
    ASM_KEYWORD("pop {r0}");
}
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/
/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
    extern uint32 startup_getControlRegisterValue(void);
    extern uint32 startup_getAipsRegisterValue(void);
    extern void Suspend_Interrupts(void);
    extern void Resume_Interrupts(void);
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/


/*================================================================================================*/
/**
* @brief    startup_go_to_user_mode
* @details  Function called from startup.s to switch to user mode if MCAL_ENABLE_USER_MODE_SUPPORT
*           is defined
*/
/*================================================================================================*/
void startup_go_to_user_mode(void);
void startup_go_to_user_mode(void)
{
#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
    ASM_KEYWORD("svc 0x1");
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/
}

/*================================================================================================*/
/**
* @brief   Default IRQ handler
* @details Infinite Loop
*/
/*================================================================================================*/
void default_interrupt_routine(void)
{
    while(TRUE){};
}

/*================================================================================================*/
/**
* @brief Sys_GoToSupervisor
* @details function used to enter to supervisor mode.
*           check if it's needed to switch to supervisor mode and make the switch.
*           Return 1 if switch was done
*/
/*================================================================================================*/

#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
uint32 Sys_GoToSupervisor(void)
{
    uint32 u32ControlRegValue;
    uint32 u32AipsRegValue;
    uint32 u32SwitchToSupervisor;

    /* if it's 0 then Thread mode is already in supervisor mode */
    u32ControlRegValue = startup_getControlRegisterValue();
    /* if it's 0 the core is in Thread mode, otherwise in Handler mode */
    u32AipsRegValue = startup_getAipsRegisterValue();

    /* if core is already in supervisor mode for Thread mode, or running form Handler mode, there is no need to make the switch */
    if((0U == (u32ControlRegValue & 1u)) || (0u < (u32AipsRegValue & 0xFFu)))
    {
        u32SwitchToSupervisor = 0U;
    }
    else
    {
        u32SwitchToSupervisor = 1U;
        SVC_GoToSupervisor();
    }

    return u32SwitchToSupervisor;
}

/*================================================================================================*/
/**
* @brief Sys_GoToUser_Return
* @details function used to switch back to user mode for Thread mode, return a uint32 value passed as parameter
*/
/*================================================================================================*/
uint32 Sys_GoToUser_Return(uint32 u32SwitchToSupervisor, uint32 u32returnValue)
{
    if (1UL == u32SwitchToSupervisor)
    {
        Direct_GoToUser();
    }

    return u32returnValue;
}

uint32 Sys_GoToUser(void)
{
    Direct_GoToUser();
    return 0UL;
}

/*================================================================================================*/
/**
* @brief Sys_SuspendInterrupts
* @details Suspend Interrupts
*/
/*================================================================================================*/
void Sys_SuspendInterrupts(void)
{
    uint32 u32ControlRegValue;
    uint32 u32AipsRegValue;

    /* if it's 0 then Thread mode is already in supervisor mode */
    u32ControlRegValue = startup_getControlRegisterValue();
    /* if it's 0 the core is in Thread mode, otherwise in Handler mode */
    u32AipsRegValue = startup_getAipsRegisterValue();

    if((0U == (u32ControlRegValue & 1u)) || (0u < (u32AipsRegValue & 0xFFu)))
    {
        Suspend_Interrupts();
    }
    else
    {
        ASM_KEYWORD(" svc 0x3");
    }
}
/*================================================================================================*/
/**
* @brief Sys_ResumeInterrupts
* @details Resume Interrupts
*/
/*================================================================================================*/
void Sys_ResumeInterrupts(void)
{
    uint32 u32ControlRegValue;
    uint32 u32AipsRegValue;

    /* if it's 0 then Thread mode is already in supervisor mode */
    u32ControlRegValue = startup_getControlRegisterValue();
    /* if it's 0 the core is in Thread mode, otherwise in Handler mode */
    u32AipsRegValue = startup_getAipsRegisterValue();

    if((0U == (u32ControlRegValue & 1u)) || (0u < (u32AipsRegValue & 0xFFu)))
    {
        Resume_Interrupts();
    }
    else
    {
        ASM_KEYWORD(" svc 0x2");
    }
}
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/


/*================================================================================================*/
/**
* @brief Sys_GetCoreID
* @details Function used to get the ID of the currently executing thread
*/
/*================================================================================================*/
#if !defined(USING_OS_AUTOSAROS)
uint8 Sys_GetCoreID(void)
{
    return ((uint8)(IP_MSCM->CPXNUM & MSCM_CPXNUM_CPN_MASK));
}
#endif /*!defined(USING_OS_AUTOSAROS)*/

/*================================================================================================*/
/**
* @brief Sys_StartSecondaryCores
* @details Function used to start the secondary cores
*/
/*================================================================================================*/
#if (defined(CORE0) && defined(MULTIPLE_IMAGE))

static void Sys_StartSecondaryCores(void)
{
#ifdef START_CM7_1
    extern const uint32 __CORE1_START_ADDRESS;

    IP_MC_ME->PRTN0_CORE1_ADDR = (uint32)&__CORE1_START_ADDRESS;
    IP_MC_ME->PRTN0_CORE1_PCONF = 1;
    IP_MC_ME->PRTN0_CORE1_PUPD = 1;
    IP_MC_ME->CTL_KEY = 0x5AF0;
    IP_MC_ME->CTL_KEY = 0xA50F;
    while (!(IP_MC_ME->PRTN0_CORE1_STAT & MC_ME_PRTN0_CORE1_STAT_CCS_MASK)) {};
    IP_MC_RGM->PRST_0[0].PRST_0 &= ~MC_RGM_PRST_0_PERIPH_1_RST(1);
    while(IP_MC_RGM->PSTAT_0[0].PSTAT_0 & MC_RGM_PSTAT_0_PERIPH_1_STAT_MASK);
#endif /*START_CM7_1*/
#ifdef START_CM7_2
    extern const uint32 __CORE2_START_ADDRESS;

    IP_MC_ME->PRTN0_CORE2_ADDR = (uint32)&__CORE2_START_ADDRESS;
    IP_MC_ME->PRTN0_CORE2_PCONF = 1;
    IP_MC_ME->PRTN0_CORE2_PUPD = 1;
    IP_MC_ME->CTL_KEY = 0x5AF0;
    IP_MC_ME->CTL_KEY = 0xA50F;
    while (!(IP_MC_ME->PRTN0_CORE2_STAT & MC_ME_PRTN0_CORE2_STAT_CCS_MASK)) {};
    IP_MC_RGM->PRST_0[0].PRST_0 &= ~MC_RGM_PRST_0_PERIPH_2_RST(1);
    while(IP_MC_RGM->PSTAT_0[0].PSTAT_0 & MC_RGM_PSTAT_0_PERIPH_2_STAT_MASK);
#endif /*START_CM7_2*/
#ifdef START_CM7_3
    extern const uint32_t __CORE3_START_ADDRESS;

    IP_MC_ME->PRTN0_CORE4_ADDR = (uint32)&__CORE3_START_ADDRESS;
    IP_MC_ME->PRTN0_CORE4_PCONF = 1;
    IP_MC_ME->PRTN0_CORE4_PUPD = 1;
    IP_MC_ME->CTL_KEY = 0x5AF0;
    IP_MC_ME->CTL_KEY = 0xA50F;
    while (!(IP_MC_ME->PRTN0_CORE4_STAT & MC_ME_PRTN0_CORE4_STAT_CCS_MASK)) {};
    IP_MC_RGM->PRST_0[0].PRST_0 &= ~MC_RGM_PRST_0_PERIPH_6_RST(1);
    while(IP_MC_RGM->PSTAT_0[0].PSTAT_0 & MC_RGM_PSTAT_0_PERIPH_6_STAT_MASK);
#endif /*START_CM7_3*/
}
#endif /*(defined(CORE0) && defined(MULTIPLE_IMAGE))*/

/*================================================================================================*/
/*
 * system initialization : system clock, interrupt router ...
 */

void SystemInit(void)
{
    uint32 i;
    uint32 coreMask;
#ifdef MPU_ENABLE
    uint8 regionNum = 0U;
#endif

    uint32 coreId = OsIf_GetCoreID();

    switch(coreId)
    {
        case CA53_0_0:
            /* There is only one bitfield for all Cortex A53 interrupt steering. Fall trough */
        case CA53_0_1:
            /* There is only one bitfield for all Cortex A53 interrupt steering. Fall trough */
        case CA53_1_0:
            /* There is only one bitfield for all Cortex A53 interrupt steering. Fall trough */
        case CA53_1_1:
            coreMask = (1UL << MSCM_IRSPRC_GIC500_SHIFT);
            break;
        case CM7_0:
            coreMask = (1UL << MSCM_IRSPRC_M7_0_SHIFT);
            break;
        case CM7_1:
            coreMask = (1UL << MSCM_IRSPRC_M7_1_SHIFT);
            break;
        case CM7_2:
            coreMask = (1UL << MSCM_IRSPRC_M7_2_SHIFT);
            break;
#if defined(S32G3XX)
        case CM7_3:
            coreMask = (1UL << MSCM_IRSPRC_M7_3_SHIFT);
            break;
#endif
        default:
            coreMask = 0UL;
            break;
    }

    /* Configure IP_MSCM to enable/disable interrupts routing to Core processor */
    for (i = 0; i < MSCM_IRSPRC_COUNT; i++)
    {
        IP_MSCM->IRSPRC[i] |= coreMask;
    }

#if (defined(CORE0) && defined(MULTIPLE_IMAGE))
    Sys_StartSecondaryCores();
#endif

#if (MCAL_PLATFORM_ARM  == MCAL_ARM_AARCH64)

    gic500_enableGIC();

    /* fill the interrupts_vector with the default interrupt rutine */
    for (i=0; i<A53_NUM_OF_VECTORS; i++)
    {
        g_INT_vectors[i] = (isr_t)default_interrupt_routine;
    }

#else

  NVIC_SetPriorityGrouping(0); /* 0 means 7 bits for prio, 1 for sub-prio */
  S32_SCB->CCR |=  1;          /* processor can enter Thread mode from any level under the
                                   control of an EXC_RETURN value, PendSV priority set to 0 */
  S32_SCB->SHPR3 = 0;

/**************************************************************************/
                      /* FPU ENABLE*/
/**************************************************************************/
#ifdef ENABLE_FPU
    /* Enable CP10 and CP11 coprocessors */
    S32_SCB->CPACR |= (S32_SCB_CPACR_CPx(10U, 3U) | S32_SCB_CPACR_CPx(11U, 3U));

    MCAL_INSTRUCTION_SYNC_BARRIER();
    MCAL_DATA_SYNC_BARRIER();

#endif /*ENABLE_FPU*/

/**************************************************************************/
                      /* DEFAULT MEMORY ENABLE*/
/**************************************************************************/
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
/**************************************************************************/
                      /* MPU ENABLE*/
/**************************************************************************/
#ifdef MPU_ENABLE
    /*Checking if cache is enable before*/
    if (((((uint32)1U << (uint32)17U) & S32_SCB->CCR) != (uint32)0) || ((((uint32)1U << (uint32)16U) & S32_SCB->CCR) != (uint32)0))
    {
        /* synchronize cache before update mpu */
        sys_m7_cache_disable();
    }
    /* Set default memory regions */
    for (regionNum = 0U; regionNum < CPU_MPU_MEMORY_COUNT; regionNum++)
    {
        S32_MPU->RNR  = regionNum;
        S32_MPU->RBAR = rbar[regionNum];
        S32_MPU->RASR = rasr[regionNum];
    }

    /* Enable MPU */
    S32_MPU->CTRL |= S32_MPU_CTRL_ENABLE_MASK;
    MCAL_INSTRUCTION_SYNC_BARRIER();
    MCAL_DATA_SYNC_BARRIER();
#endif /*MPU_ENABLE*/

/**************************************************************************/
            /* ENABLE CACHE */
/**************************************************************************/
#if defined(D_CACHE_ENABLE) || defined(I_CACHE_ENABLE)
    sys_m7_cache_init();
#endif /*defined(D_CACHE_ENABLE) || defined(I_CACHE_ENABLE)*/
/*
 * SystemWfiConfig : Implement errata ERR051149
 */
#if defined(ERR_CORTEX_M7_E051149) || defined(ERR_CORTEX_M7_E051166)
    SystemWfiConfig();
#endif

#endif /*(MCAL_PLATFORM_ARM  == MCAL_ARM_AARCH64)*/

}
   
static void sys_m7_cache_init(void)
{
#ifdef D_CACHE_ENABLE
    uint32 ccsidr = 0U;
    uint32 sets = 0U;
    uint32 ways = 0U;

    /*init Data caches*/
    S32_SCB->CSSELR = 0U;                       /* select Level 1 data cache */

    MCAL_DATA_SYNC_BARRIER();
    ccsidr = S32_SCB->CCSIDR;
    sets = (uint32)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32)(CCSIDR_WAYS(ccsidr));
      do {
        S32_SCB->DCISW = (((sets << SCB_DCISW_SET_SHIFT) & SCB_DCISW_SET_MASK) |
                      ((ways << SCB_DCISW_WAY_SHIFT) & SCB_DCISW_WAY_MASK)  );

    MCAL_DATA_SYNC_BARRIER();
      } while (ways-- != 0U);
    } while(sets-- != 0U);
    MCAL_DATA_SYNC_BARRIER();
    S32_SCB->CCR |=  (uint32)SCB_CCR_DC_MASK;  /* enable D-Cache */
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
#endif /*D_CACHE_ENABLE*/

#ifdef I_CACHE_ENABLE
    /*init Code caches*/
    S32_SCB->ICIALLU = 0UL;                    /* invalidate I-Cache */
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
    S32_SCB->CCR |=  (uint32)SCB_CCR_IC_MASK;  /* enable I-Cache */
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
#endif /*I_CACHE_ENABLE*/
}

static INLINE void sys_m7_cache_disable(void)
{
    sys_m7_cache_clean();
    S32_SCB->CCR &= ~((uint32)1U << 17U);
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
    S32_SCB->CCR &= ~((uint32)1U << 16U);
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
}

static INLINE void sys_m7_cache_clean(void)
{
#ifdef D_CACHE_ENABLE
    uint32 ccsidr = 0U;
    uint32 sets = 0U;
    uint32 ways = 0U;

    S32_SCB->CSSELR = 0U;                       /* select Level 1 data cache */
    MCAL_DATA_SYNC_BARRIER();
    ccsidr = S32_SCB->CCSIDR;
    sets = (uint32)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32)(CCSIDR_WAYS(ccsidr));
      do {
        S32_SCB->DCCISW = (((sets << SCB_DCCISW_SET_SHIFT) & (uint32)SCB_DCCISW_SET_MASK) |
                      ((ways << SCB_DCCISW_WAY_SHIFT) & (uint32)SCB_DCCISW_WAY_MASK)  );
        MCAL_DATA_SYNC_BARRIER();
      } while (ways-- != 0U);
    } while(sets-- != 0U);
    MCAL_DATA_SYNC_BARRIER();
    S32_SCB->CSSELR = (uint32)((S32_SCB->CSSELR) | 1U);
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
#endif /*D_CACHE_ENABLE*/

#ifdef I_CACHE_ENABLE
    S32_SCB->ICIALLU = 0UL;
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
#endif /*I_CACHE_ENABLE*/
}
/*================================================================================================*/
/*
 * SystemWfiConfig : Implement errata ERR051149
 * SystemWfiConfig : Implement errata ERR051166
 */
#if defined(ERR_CORTEX_M7_E051149) || defined(ERR_CORTEX_M7_E051166)
void SystemWfiConfig(void)
{
    uint32 u32EdbStatus = 0U;
#ifdef S32G3XX
/*  Major Mask Revision
    0000b - Rev 1.x
    0001b - Rev 2.x
    Minor Mask Revision
    0000b - Rev x.0
    0001b - Rev x.1 */
    uint32 U32MajorMinor = (uint32_t)(IP_SIUL2_0->MIDR1);
    uint8 Minor = (uint8)((U32MajorMinor & SIUL2_MINOR_MASK) >> SIUL2_MINOR_SHIFT);
    uint8 Major = (uint8)((U32MajorMinor & SIUL2_MAJOR_MASK) >> SIUL2_MAJOR_SHIFT);
    if (Major == 0U && Minor == 0U)
    {
#endif
        u32EdbStatus = (uint32_t)(IP_SECURITY_CC->EXT_DBGSTAT & SECURITY_EXT_DBGSTAT_EDB_MASK);
        if (u32EdbStatus == 0U)
        {
            IP_MDM_AP->DAP_EN_CTRL &= ~MDM_AP_DAP_EN_CTRL_CSPNIDEN_MASK;
            IP_MDM_AP->DAP_EN_CTRL &= ~MDM_AP_DAP_EN_CTRL_CSPIDEN_MASK;
            IP_MDM_AP->DAP_EN_CTRL &= ~MDM_AP_DAP_EN_CTRL_CNIDEN_MASK;
            IP_MDM_AP->DAP_EN_CTRL &= ~MDM_AP_DAP_EN_CTRL_CDBGEN_MASK;
            IP_MDM_AP->CONTROL |= MDM_AP_CONTROL_CM7_0_EDBGREQ_MASK;
            IP_MDM_AP->CONTROL |= MDM_AP_CONTROL_CM7_1_EDBGREQ_MASK;
            IP_MDM_AP->CONTROL |= MDM_AP_CONTROL_CM7_2_EDBGREQ_MASK;
#ifdef S32G3XX
#if defined(ERR_CORTEX_M7_E051166)
            IP_MDM_AP->CORTEX_A53_A0_IP_DBG |= MDM_AP_CORTEX_A53_A0_IP_DBG_CM7_3_EDBGREQ_MASK;
#endif
#endif
        }
        else
        {
            /* do nothing */
        }
#ifdef S32G3XX
    }
    else
    {
        /* do nothing */
    }
#endif
}
#endif

#define PLATFORM_STOP_SEC_CODE
#include "Platform_MemMap.h"

#ifdef __cplusplus
}
#endif /*__cplusplus */


===== 文件 [25/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\include\Core_Heartbeat.h =====
/*==================================================================================================
*
* Copyright 2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#ifndef CORE_HEARTBEAT
#define CORE_HEARTBEAT

#include "StandardTypes.h"

#define HEARTBEAT_STRUCTURE_ADDRESS   (0x4384FFD0U)
#define HEARTBEAT_MAX_TIME_DIFFERENCE (100u)

void Core_Heartbeat_Init(void);
void Core_Heartbeat_Check(void);

#endif /* CORE_HEARTBEAT */


===== 文件 [26/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\include\Llce_Firmware_Load.h =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#ifndef LLCE_FIRMWARE_LOAD_H
#define LLCE_FIRMWARE_LOAD_H

#include "StandardTypes.h"

Std_ReturnType Llce_Firmware_Load(void);
boolean Llce_Firmware_Load_GetBootStatus(void);

#endif /* LLCE_FIRMWARE_LOAD_H */


===== 文件 [27/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\include\PlatformInit.h =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#ifndef APP_PLATFORM_INIT
#define APP_PLATFORM_INIT

void PlatformInit(void);

#endif /* APP_PLATFORM_INIT */


===== 文件 [28/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\include\can_common.h =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#ifndef CAN_COMMON
#define CAN_COMMON

#ifdef ASR_NOT_USED
    #include "PlatformTypes.h"    
#endif

#define CAN_FD_FRAME_LEN 64U
#define CAN_STD_FRAME_LEN 8U
#define TP_TIMEOUT 800000U
#define CONTROLLER1 1
#define CONTROLLER0 0
#define CONTROLLER2 2
#define CONTROLLER3 3
#define CONTROLLER4 4
#define CONTROLLER5 5
#define CONTROLLER7 7
#define CONTROLLER10 10
#define CONTROLLER11 11
#define CONTROLLER12 12
#define CONTROLLER14 14
#define CONTROLLER15 15
#define ITER_NR 200
#define MAX_BUFFER_FRAME_FD 64
#define CAN_LPDU_FD_U32 ((uint32)0x40000000)
#define MAX_NUM_OF_CORES 8U
#define ON  1
#define OFF 0

/* Sample app specific variable. Possible values: ON, OFF */
extern volatile uint8 fail;

#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    extern volatile uint32 last_RxIndication;
    extern volatile uint32 last_TxConfirmation;
#else
    extern volatile uint32 last_RxIndication[MAX_NUM_OF_CORES];
    extern volatile uint32 last_TxConfirmation[MAX_NUM_OF_CORES];
#endif

void Circular_Permutation(volatile uint8 *Payload, uint8 n);
StatusType Check_Status(Can_PduType *CanMessage);


#endif  /* CAN_COMMON */


===== 文件 [29/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\include\check_example.h =====
/*
*   (c) Copyright 2020 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be used strictly
*   in accordance with the applicable license terms.  By expressly accepting
*   such terms or by downloading, installing, activating and/or otherwise using
*   the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms.  If you do not agree to
*   be bound by the applicable license terms, then you may not retain,
*   install, activate or otherwise use the software.
*
*   This file contains sample code only. It is not part of the production code deliverables.
*/

#ifndef CHECK_EXAMPLE_H
#define CHECK_EXAMPLE_H

#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/


/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/

/**
* @brief        Function used for testing automatically examples
* @details      Writes a pass or fail status in the memory at a given address
* @internal
*/
static inline void Exit_Example(boolean result) 
{
    volatile uint8 * testResultBasePtr;
    
    testResultBasePtr = (volatile uint8 *)VV_RESULT_ADDRESS;
    
    if (TRUE == result)
    {
        *testResultBasePtr = 0x5AU;
    }
    else
    {
        *testResultBasePtr = 0x33U;
    }
}

static inline void EX_ASSERT(boolean result) 
{
    volatile uint8 * testResultBasePtr;
    
    testResultBasePtr = (volatile uint8 *)VV_RESULT_ADDRESS;
    
    if (TRUE == result)
    {
        if(*testResultBasePtr != 0x33U)
        {
            *testResultBasePtr = 0x5AU;
        }
    }
    else
    {
        *testResultBasePtr = 0x33U;
    }
}

#ifdef __cplusplus
}
#endif

#endif 

/** @} */


===== 文件 [30/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\include\stubs.h =====
#ifndef STUBS_H
#define STUBS_H

#include "Can_43_LLCE.h"
#include "can_common.h"
#include "Platform_Types.h"

#define ASSERT(expr) \
    if (!(expr)) \
        fail = ON

/* Stub functions */
void CanIf_RxIndication( const Can_HwType* Mailbox, const PduInfoType* PduInfoPtr );
void CanIf_TxConfirmation( PduIdType CanTxPduId);
void CanIf_ControllerModeIndication( uint8 Controller, Can_ControllerStateType ControllerMode);
void CanIf_ControllerBusOff( uint8 Controller);
void RxTimestampNotification(Can_HwHandleType Hoh, uint32 u32TimestampVal);
void TxTimestampNotification(Can_HwHandleType Hoh, PduIdType CanTxPduId, uint32 u32TimestampVal);
void CanErrorNotification(uint8 u8CanIfCtrlId, Llce_Can_NotificationIdType eNotifId, volatile Llce_Can_ErrorNotifType* ErrorInfo);

void Can_CallBackSetUp(void);

extern volatile uint8   Can_RxData[CAN_FD_FRAME_LEN];
extern volatile uint8  Can_RxHandle;
extern volatile Can_IdType Can_RxId;
extern volatile uint8  Can_RxDlc;
extern volatile uint8  Can_ControllerId;
extern volatile PduIdType Can_TxConfirmation_CanTxPduId;
extern volatile uint8  Can_BusOffConfirmation;
extern volatile uint32   Can_Tx_No[16];
extern volatile uint32 u32CustomCallbackExecutions;
#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    extern volatile uint32 Can_RxIndication;
    extern volatile uint32 Can_TxConfirmation;
#else
    extern volatile uint32 Can_RxIndication[MAX_NUM_OF_CORES];
    extern volatile uint32 Can_TxConfirmation[MAX_NUM_OF_CORES];
#endif

#endif /* STUBS_H */


===== 文件 [31/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\src\Core_Heartbeat.c =====
/*==================================================================================================
*
* Copyright 2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#include "Core_Heartbeat.h"
#include "Llce_RegAccess.h"
#include "Llce_InterfaceFwMgr.h"

/* Macro used for rollover detection of the global counter u32SysTickCounter. (Rollover every ~118h when counting hundreds of microseconds (100us granularity)) */
#define MAX_UINT32_VALUE (uint32)4294967295U
#define MAX_NR_OF_CORE_TIMEOUT   10u

/* Counter increases when a timeout occurs (up to 10) and decreases when it doesn't */
static struct 
{
  uint8 core1TimeoutCounter;
  uint8 core2TimeoutCounter;
  uint8 core3TimeoutCounter;
}timeoutCoreCounter;


static Llce_Mgr_TimeStampCoresType Core_Heartbeat_Time_Elapsed(Llce_Mgr_TimeStampCoresType currentHeartbeatValue, Llce_Mgr_TimeStampCoresType previousHeartbeatValue);
static uint32 Core_Heartbeat_Calculate_Time_Difference(uint32 currentHeartbeatCoreValue, uint32 previousHeartbeatCoreValue);
static void Core_Heartbeat_Update_All_Counters(Llce_Mgr_TimeStampCoresType heartbeatTimeDifference);
static void Core_Heartbeat_Update_Counter(uint32 timestampDifference, uint8 *counter);

void Core_Heartbeat_Init(void)
{
  /* Init already done in Can_Enable_Timestamp() from Platform_Init.c */

}

void Core_Heartbeat_Check(void)
{   
  static volatile Llce_Mgr_TimeStampCoresType previousHeartbeatValue;
  static volatile Llce_Mgr_TimeStampCoresType* pcurrentHeartbeatValue = (Llce_Mgr_TimeStampCoresType*)HEARTBEAT_STRUCTURE_ADDRESS;
  Llce_Mgr_TimeStampCoresType heartbeatTimeDifference;

  heartbeatTimeDifference = Core_Heartbeat_Time_Elapsed(*pcurrentHeartbeatValue, previousHeartbeatValue);

  Core_Heartbeat_Update_All_Counters(heartbeatTimeDifference);

  if(
       (timeoutCoreCounter.core1TimeoutCounter >= MAX_NR_OF_CORE_TIMEOUT) 
    || (timeoutCoreCounter.core2TimeoutCounter >= MAX_NR_OF_CORE_TIMEOUT) 
    || (timeoutCoreCounter.core3TimeoutCounter >= MAX_NR_OF_CORE_TIMEOUT)
    )
  {
    /* Insert reaction here */
  }

  previousHeartbeatValue = *pcurrentHeartbeatValue;
}

/* Increment or decrement a counter based on the time difference between two consecutive timestamps */
static void Core_Heartbeat_Update_Counter(uint32 timestampDifference, uint8 *counter)
{
  if((timestampDifference) > HEARTBEAT_MAX_TIME_DIFFERENCE)
  {
    if(*counter < 255u)
    {
      (*counter)++;
    }
  }
  else
  {
    if(*counter > 0u)
    {
      (*counter)--;
    }
  }
}

/* Update the counter value for every core */
static void Core_Heartbeat_Update_All_Counters(Llce_Mgr_TimeStampCoresType heartbeatTimeDifference)
{
  Core_Heartbeat_Update_Counter(heartbeatTimeDifference.timeStampCore1, &timeoutCoreCounter.core1TimeoutCounter);
  Core_Heartbeat_Update_Counter(heartbeatTimeDifference.timeStampCore2, &timeoutCoreCounter.core2TimeoutCounter);
  Core_Heartbeat_Update_Counter(heartbeatTimeDifference.timeStampCore3, &timeoutCoreCounter.core3TimeoutCounter);
}

/* Update for every core the difference between two consecutive timestamps. */
static Llce_Mgr_TimeStampCoresType Core_Heartbeat_Time_Elapsed(Llce_Mgr_TimeStampCoresType currentHeartbeatValue, Llce_Mgr_TimeStampCoresType previousHeartbeatValue)
{
  Llce_Mgr_TimeStampCoresType heartbeatTimeDifference;

  heartbeatTimeDifference.timeStampCore1 = Core_Heartbeat_Calculate_Time_Difference(currentHeartbeatValue.timeStampCore1, previousHeartbeatValue.timeStampCore1);
  heartbeatTimeDifference.timeStampCore2 = Core_Heartbeat_Calculate_Time_Difference(currentHeartbeatValue.timeStampCore2, previousHeartbeatValue.timeStampCore2);
  heartbeatTimeDifference.timeStampCore3 = Core_Heartbeat_Calculate_Time_Difference(currentHeartbeatValue.timeStampCore3, previousHeartbeatValue.timeStampCore3);

  return heartbeatTimeDifference;
}

/* Calculate the time difference between two consecutive timestamps */
static uint32 Core_Heartbeat_Calculate_Time_Difference(uint32 currentHeartbeatCoreValue, uint32 previousHeartbeatCoreValue)
{
  uint32 timeDifference;
  if(currentHeartbeatCoreValue >= previousHeartbeatCoreValue)
  {
    timeDifference = currentHeartbeatCoreValue - previousHeartbeatCoreValue;
  }
  else
  {
    /* In case of overflow of currentHeartbeatValue */
    timeDifference = MAX_UINT32_VALUE - previousHeartbeatCoreValue + currentHeartbeatCoreValue;
  }
  
  return timeDifference;
}


===== 文件 [32/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\src\Llce_Firmware_Load.c =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#include "Llce_Firmware_Load.h"
#include "Llce_InterfaceFwMgr.h"
#include "Llce_RegAccess.h"


typedef struct {
    uint8* const pu8MemLocation;
    const uint32 u32RAMSize;
    const uint8* const pu8CodeData;
    const uint32* u32CodeSize;
} Llce_CoreProgramType;


#define LLCE_NUM_CORES              4U
#define LLCE_ENABLE_CORE_ADDR       ((uint32)0x43FF8000U)
#define LLCE_DATA_RAM_START_ADDR    0x43800000
#define LLCE_DATA_RAM_LENGTH        0x50000
#define LLCE_FW_STARTUP_DURATION    1000000

#if defined(S32G3) || defined(S32G3XX)
    #define DTE_RAM_SIZE        0x4000
    #define PPE_RX_RAM_SIZE     0x18000
    #define PPE_TX_RAM_SIZE     0x8000
    #define FRPE_RAM_SIZE       0x40000
#else /* S32G2 */
    #define DTE_RAM_SIZE        0x2000
    #define PPE_RX_RAM_SIZE     0x8000
    #define PPE_TX_RAM_SIZE     0x8000
    #define FRPE_RAM_SIZE       0x10000
#endif

/* This variable contains information about fw boot end */
__attribute__((section(".llce_boot_end"))) volatile Llce_Mgr_StatusType Llce_Mgr_Status;

extern const uint8 dte_bin[];
extern const uint32 dte_bin_len;

extern const uint8 ppe_rx_bin[];
extern const uint32 ppe_rx_bin_len;

extern const uint8 ppe_tx_bin[];
extern const uint32 ppe_tx_bin_len;

extern const uint8 frpe_bin[];
extern const uint32 frpe_bin_len;

#ifdef LLCE_USE_HEADLESS
extern const uint8 LLCE_HeadlessConfig_bin[];
#endif

static const Llce_CoreProgramType Llce_CoreData[LLCE_NUM_CORES] = 
{
    { (uint8*)0x43000000, DTE_RAM_SIZE,  dte_bin,    &dte_bin_len },
    { (uint8*)0x43100000, PPE_RX_RAM_SIZE, ppe_rx_bin, &ppe_rx_bin_len},
    { (uint8*)0x43200000, PPE_TX_RAM_SIZE, ppe_tx_bin, &ppe_tx_bin_len},
    { (uint8*)0x43300000, FRPE_RAM_SIZE, frpe_bin,   &frpe_bin_len }
};

/**
* @brief          Service routine used to load the firmware from host memory to LLCE internal memory and enable LLCE cores in order to start running.
* @details        This routine is called by:
*                  - Can_Llce_Init
*
* @param[in]      void
*
* @return
* @retval        E_OK  Timeout was not reached. LLCE internal cores started correctly
* @retval        E_NOT_OK  Timeout was reached. LLCE internal cores not started correctly
*/
Std_ReturnType Llce_Firmware_Load(void)
{   
    uint8 i;
    uint32 crtOffset;
    uint32 byteIndex;
    uint64 *u64MemPointer;
    uint64 *u64MemPointer2;
    const uint64 *u64DataPointer;
	
    /* Put all cores in reset*/
    Reg_Write32(LLCE_ENABLE_CORE_ADDR, 0x0);

    for (i = 0U; i < LLCE_NUM_CORES; i++) 
    {
        /* Move code to core's code section*/
        /* Performance optimisation: write 8 bytes at a time */
        u64MemPointer  = (uint64*)Llce_CoreData[i].pu8MemLocation;
        u64DataPointer = (uint64*)Llce_CoreData[i].pu8CodeData;

        /* Offset is in words (32 bit) */
        for (crtOffset = 0U; crtOffset <  (*(Llce_CoreData[i].u32CodeSize)) / 8; crtOffset++)
        {
            u64MemPointer[crtOffset] = u64DataPointer[crtOffset];
        }
        
        /* Write 2 words at a time before copying bytes */
        u64MemPointer[crtOffset] = (uint64)0;

        /* Back to 1 byte mode */
        for (byteIndex = crtOffset * 8U; byteIndex <  (*(Llce_CoreData[i].u32CodeSize)); byteIndex++)
        {
            Llce_CoreData[i].pu8MemLocation[byteIndex] = Llce_CoreData[i].pu8CodeData[byteIndex];
        }

        crtOffset++;

        /* Fill the rest of the core's RAM in order to enable ECC RAM */
        for ( ; crtOffset < (Llce_CoreData[i].u32RAMSize) / 8 ; crtOffset++)
        {
            u64MemPointer[crtOffset] = (uint64)0;
        }
    }

    /* Pointer to the first half of LLCE Shared RAM */
    u64MemPointer  = (uint64*)LLCE_DATA_RAM_START_ADDR;
    /* Pointer to the second half of LLCE Shared RAM */
    u64MemPointer2  = (uint64*)(LLCE_DATA_RAM_START_ADDR + (LLCE_DATA_RAM_LENGTH/2));

    /* Write all the Shared Memory in order to enable ECC RAM: 8 bytes at a time */
    for (crtOffset = 0U; crtOffset <  LLCE_DATA_RAM_LENGTH / 16; crtOffset++)
    {
        u64MemPointer[crtOffset] = (uint64)0;
        u64MemPointer2[crtOffset] = (uint64)0;
    }

#ifdef LLCE_USE_HEADLESS
    /* Copy magic value from headless config */
    *((uint32*)LLCE_DATA_RAM_START_ADDR) = *((uint32*)LLCE_HeadlessConfig_bin);
    /* Set headless config address */
    *(((uint32*)LLCE_DATA_RAM_START_ADDR) + 1U) = (uint32)&LLCE_HeadlessConfig_bin;
#endif    

    /* Clear memory area where Llce notifies about boot ending */
    Llce_Mgr_Status.eTxBootStatus = LLCE_FW_NOTRUN;
    Llce_Mgr_Status.eRxBootStatus = LLCE_FW_NOTRUN;
    Llce_Mgr_Status.eDteBootStatus = LLCE_FW_NOTRUN;
    Llce_Mgr_Status.eFrpeBootStatus = LLCE_FW_NOTRUN;

    Reg_Write32(LLCE_ENABLE_CORE_ADDR, 0xF);      /*start all cores */

    return Llce_Firmware_Load_GetBootStatus();
}

boolean Llce_Firmware_Load_GetBootStatus(void)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;
    uint32 u32Timeout = LLCE_FW_STARTUP_DURATION;
    Llce_Fw_ReturnType eTxBootStatus   = LLCE_FW_NOTRUN;
    Llce_Fw_ReturnType eRxBootStatus   = LLCE_FW_NOTRUN;
    Llce_Fw_ReturnType eDteBootStatus  = LLCE_FW_NOTRUN;
    Llce_Fw_ReturnType eFrpeBootStatus = LLCE_FW_NOTRUN; 

    /*Wait that the LLCE firmware cores to start running and boot.*/
    while (( (LLCE_FW_SUCCESS != eTxBootStatus) || (LLCE_FW_SUCCESS != eRxBootStatus) || \
			(LLCE_FW_SUCCESS != eDteBootStatus) || (LLCE_FW_SUCCESS != eFrpeBootStatus) ) && (u32Timeout > 0))
    {
        /* Volatile variables should be read separately */
        eTxBootStatus   = Llce_Mgr_Status.eTxBootStatus;
        eRxBootStatus   = Llce_Mgr_Status.eRxBootStatus;
        eDteBootStatus  = Llce_Mgr_Status.eDteBootStatus;
        eFrpeBootStatus = Llce_Mgr_Status.eFrpeBootStatus;
		u32Timeout--;
    }
    
    if (u32Timeout != 0)	
    {
            eReturnValue = E_OK;
    }

    return  eReturnValue;
}


===== 文件 [33/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\src\Platform_Init.c =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#include "Llce_RegAccess.h"
#include "Mcu.h"
#include "OsIf.h"
#include "Platform.h"
#include "CDD_Rm.h"
#ifdef USE_PORT_HLD
    #include "Port.h" /* EB Tresos demo project */
#else
    #include "Siul2_Port_Ip.h" /* S32DS demo project */
#endif

#define MACRO_CONCAT(a,b) a##b
#define MACRO_CONFIG(a,b) MACRO_CONCAT(a, b)
#ifndef CONFIG_VARIANT_USED
 #define MCU_VARIANT    NULL_PTR
 #define PORT_VARIANT   NULL_PTR
#else
 #define MCU_VARIANT    &MACRO_CONFIG(Mcu_Config_, CONFIG_VARIANT_USED)
 #define PORT_VARIANT   &MACRO_CONFIG(Port_Config_, CONFIG_VARIANT_USED)
#endif

/* Bcan Timestamping related defines */
#define TST_CTRL_REG_ADDR   0x4007C0F0  /* TIMESTAMP_CONTROL_REGISTER */
#define TST_SOURCE_SEL_MASK 0x00000001  /* Timestamp 1 counter output is selected as timestamp module output */
#define TST_ENABLE_MASK     0x00000004  /* Timestamp module enable control */
#define STM7_BASE_ADDR      0x40228000  /* STM_7 base address */
#define STM7_ENABLE_MASK    0x00000001  /* STM_7 enable bit */
#define STMTS_REG_ADDR      0x4400C000  /* STM_TS register address */
#define STMTS_SEL_MASK      0x00008501  /* STM_TS mask to set presclarer to 133 */

static void Can_Enable_Timestamp(void);

void PlatformInit(void)
{
    #if (RM_PRECOMPILE_SUPPORT == STD_OFF)
        Rm_Init(&Rm_Config_VS_0);
    #else
        Rm_Init(NULL_PTR);
    #endif

    /* Configure S32G clocks */
    /* Enable LLCE partition */
    Mcu_Init(MCU_VARIANT);
    Mcu_InitClock(McuClockSettingConfig_0);
    while ( MCU_PLL_LOCKED != Mcu_GetPllStatus() )
    {
        /* Busy wait until the System PLL is locked */
    }
    Mcu_DistributePllClock();
    Mcu_SetMode(McuModeSettingConf_0);

#ifdef USE_PORT_HLD
    Port_Init(PORT_VARIANT);
#else
    Siul2_Port_Ip_Init(NUM_OF_CONFIGURED_PINS0, g_pin_mux_InitConfigArr0);
#endif

    OsIf_Init(NULL_PTR); /* enable system timer for timeout detection */

    /* Configurations for IRQ routing, priority and enable through Platform plugin. */
    Platform_Init(NULL_PTR);

    Can_Enable_Timestamp();

}

/*================================================================================================*/
/**
@brief         Enable Bcan timestamping
@details       Select timestamp source and enable timestamping
*/
/*================================================================================================*/
static void Can_Enable_Timestamp(void)
{
	/* Select timestamp source STM_7 and enable timestamp module in TIMESTAMP_CONTROL_REGISTER */
    Reg_Bit_Set32(TST_CTRL_REG_ADDR, TST_SOURCE_SEL_MASK | TST_ENABLE_MASK);

	/*start STM_7*/
	Reg_Bit_Set32(STM7_BASE_ADDR, STM7_ENABLE_MASK);

    /* Set STM Prescaler 133. - This shall offer 1ms ticks */
    Reg_Bit_Set32(STMTS_REG_ADDR, STMTS_SEL_MASK);
}


===== 文件 [34/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\src\can_common.c =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/


#ifndef ASR_NOT_USED
    #include "stubs.h"
    #include "Can_43_LLCE.h"
#endif

#include "can_common.h"


#ifdef __cplusplus
extern "C"
{
#endif

volatile uint8 fail = OFF;

#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    volatile uint32 last_RxIndication;
    volatile uint32 last_TxConfirmation;
#else
    volatile uint32 last_RxIndication[MAX_NUM_OF_CORES];
    volatile uint32 last_TxConfirmation[MAX_NUM_OF_CORES];
#endif

/* Circular permutation on data buffer. The reason of using this function is for checking data sent is the same with data received every time.  */
void Circular_Permutation(volatile uint8 *Payload, uint8 n)
{
    uint8 temp = Payload[0];

    for (uint8 Idx = 0; Idx < n - 1; Idx++)
    {
        Payload[Idx] = Payload[Idx + 1];
    }

    Payload[n - 1] = temp;
}

StatusType Check_Status(Can_PduType *CanMessage)
{
    uint32 can_counter = 0;
    uint8 u8Idx = 0;
    StatusType transmission_status = E_OK;

#if CAN_43_LLCE_MAX_PARTITIONS != 1U    
    uint32 u32CoreId = OsIf_GetCoreID();
#endif

    /* Wait for transmission and reception */
#if CAN_43_LLCE_MAX_PARTITIONS == 1U    
    while ( (( (Can_TxConfirmation - last_TxConfirmation) < 1) || ( (Can_RxIndication - last_RxIndication) < 1))  && (can_counter < TP_TIMEOUT) )
#else
    while ( (( (Can_TxConfirmation[u32CoreId] - last_TxConfirmation[u32CoreId]) < 1) || ( (Can_RxIndication[u32CoreId] - last_RxIndication[u32CoreId]) < 1))  && (can_counter < TP_TIMEOUT) )
#endif
    {
        can_counter++;
    }

    /* Check received Data length */
    if (Can_RxDlc != CanMessage->length)
    {
        transmission_status = E_NOT_OK;
    }

    /* Check integrity of received Data content */
    for (u8Idx = 0; u8Idx < CanMessage->length; u8Idx++)
    {
        if (Can_RxData[u8Idx] != CanMessage->sdu[u8Idx])
        {
            transmission_status = E_NOT_OK;
            break;
        }
    }

#if CAN_43_LLCE_MAX_PARTITIONS == 1U    
    last_RxIndication++;
    last_TxConfirmation++;
#else
    last_RxIndication[u32CoreId]++;
    last_TxConfirmation[u32CoreId]++;
#endif

    /* Shuffle the data in order to check sending/receiving of another frame */
    Circular_Permutation(CanMessage->sdu, CAN_FD_FRAME_LEN);

    return transmission_status;
}


===== 文件 [35/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\src\main.c =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#include "stubs.h"
#include "Can_43_LLCE.h"
#include "PlatformInit.h"
#include "Llce_Firmware_Load.h"
#include "can_common.h"
#include "Core_Heartbeat.h"

#define CHANNELS_TO_TEST    16 /* RDB_V2 and EVB */

#define FRAMES_TO_SEND      100

void Can_Driver_Sample_Test(void)
{
    Can_ErrorStateType ErrorState;
    Std_ReturnType can_retval = E_NOT_OK;
    static uint8 can_fd_data[CAN_FD_FRAME_LEN];
    Can_PduType CanMessage[CHANNELS_TO_TEST];
    uint16 u16FrameCount[CHANNELS_TO_TEST];
    uint8 u8StopFlag = 0U;

    uint16 u16MbGlobalIndex = 0U;
    uint8 u8CtrlIdx = 0U;

    const Can_43_LLCE_ConfigType *Can_Cfg1 = &Can_43_LLCE_Config_VS_0;

    Can_43_LLCE_Init(Can_Cfg1);

    /* Reset global flags and counters. */
    Can_CallBackSetUp();

    /*Initialize transmission data buffer with a Can Fd frame.*/
    for (u16MbGlobalIndex = 0; u16MbGlobalIndex < CAN_FD_FRAME_LEN; u16MbGlobalIndex++)
    {
        can_fd_data[u16MbGlobalIndex] = u16MbGlobalIndex;
    }

     /* Set-up CAN frame data with different CAN IDs */
    for (u8CtrlIdx = 0; u8CtrlIdx < CHANNELS_TO_TEST; u8CtrlIdx++)
    {
        u16FrameCount[u8CtrlIdx] = 0;

        CanMessage[u8CtrlIdx].length = CAN_FD_FRAME_LEN;
        CanMessage[u8CtrlIdx].swPduHandle = u8CtrlIdx;
        CanMessage[u8CtrlIdx].sdu = can_fd_data;
        CanMessage[u8CtrlIdx].id = u8CtrlIdx;
        CanMessage[u8CtrlIdx].id |=CAN_LPDU_FD_U32; /*This is a CAN FD frame*/

        Can_Tx_No[u8CtrlIdx] = 0;
    }

    /* Start controllers */
    for (u8CtrlIdx = 0; u8CtrlIdx < CHANNELS_TO_TEST; u8CtrlIdx++)
    {
        can_retval = Can_43_LLCE_SetBaudrate(u8CtrlIdx, 1);
        ASSERT(E_OK == can_retval);
        can_retval = Can_43_LLCE_SetControllerMode(u8CtrlIdx, CAN_CS_STARTED);
        ASSERT(E_OK == can_retval);
        can_retval = Can_43_LLCE_GetControllerErrorState(u8CtrlIdx, &ErrorState);
        ASSERT(E_OK == can_retval);
    }
    
    (void)can_retval;

    while (!u8StopFlag)
    {
        u8StopFlag = 1;
        for (u8CtrlIdx = 0; u8CtrlIdx < CHANNELS_TO_TEST; u8CtrlIdx++)
        {   
            if ((u16FrameCount[u8CtrlIdx] - Can_Tx_No[u8CtrlIdx] < 16) && (u16FrameCount[u8CtrlIdx] < FRAMES_TO_SEND))
            {
                u16FrameCount[u8CtrlIdx]++;
                
                switch (u8CtrlIdx) {
                        case 0: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX0, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 1: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX1, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 2: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX2, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 3: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX3, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 4: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX4, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 5: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX5, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 6: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX6, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 7: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX7, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 8: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX8, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 9: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX9, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 10: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX10, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 11: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX11, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 12: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX12, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 13: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX13, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 14: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX14, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        case 15: can_retval = Can_43_LLCE_Write( CanHO_Config1_TX15, &CanMessage[u8CtrlIdx]);
                                ASSERT(E_OK == can_retval);
                                break;
                        default:
                                break;
                }
            }

            Core_Heartbeat_Check();
        }

        for (u8CtrlIdx = 0; u8CtrlIdx < CHANNELS_TO_TEST; u8CtrlIdx++)
        {   
            u8StopFlag &= (Can_Tx_No[u8CtrlIdx] == FRAMES_TO_SEND);
        }
   
    }

    while ((Can_RxIndication < FRAMES_TO_SEND*CHANNELS_TO_TEST))
    {
    }

    /* Check eventual errors configured to be reported in polling. This will trigger CanErrorNotification. */
    Can_43_LLCE_MainFunction_ErrorNotification();

    /* Stop controllers */
    for (u8CtrlIdx = 0; u8CtrlIdx < CHANNELS_TO_TEST; u8CtrlIdx++)
    {
        can_retval = Can_43_LLCE_SetControllerMode(u8CtrlIdx, CAN_CS_STOPPED);
        ASSERT(E_OK == can_retval);
    }

    ASSERT(CHANNELS_TO_TEST * FRAMES_TO_SEND == Can_RxIndication);
    ASSERT(CHANNELS_TO_TEST * FRAMES_TO_SEND == Can_TxConfirmation);

    Can_43_LLCE_DeInit();
}

int main(void)
{
    PlatformInit();
    
    Llce_Firmware_Load();
    Can_Driver_Sample_Test();

    while (1);
}


===== 文件 [36/112]: examples\S32DS\S32G2\Can_Llce_DS_Loopback_S32G274A_M7\src\stubs.c =====
#include "stubs.h"

/* RX Specific variables used by stub functions */
volatile uint8 Can_RxData[CAN_FD_FRAME_LEN];
volatile uint8  Can_RxHandle;
volatile Can_IdType Can_RxId;
volatile uint8  Can_RxDlc;
volatile uint8  Can_ControllerId;

/* TX  Ok Transmission Specific variables */
volatile PduIdType Can_TxConfirmation_CanTxPduId;
volatile uint32   Can_Tx_No[16];

/* RX and TX specific counters */
#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    volatile uint32 Can_RxIndication;
    volatile uint32 Can_TxConfirmation;
#else
    volatile uint32 Can_RxIndication[MAX_NUM_OF_CORES];
    volatile uint32 Can_TxConfirmation[MAX_NUM_OF_CORES];
#endif

/* Bus Off Specific variables */
volatile uint8  Can_BusOffConfirmation;
volatile uint32 u32CustomCallbackExecutions = 0;

/*==================================================================================================
*                                      CAN stub functions implementation
==================================================================================================*/

void Can_CallBackSetUp(void)
{

#if CAN_43_LLCE_MAX_PARTITIONS != 1U
    uint8 u8Idx = 0U;
#endif
    
    /* Reset global flags. */
    Can_BusOffConfirmation = 0U;    
    Can_RxDlc = 0U;

#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    Can_TxConfirmation = 0U;
    Can_RxIndication = 0U;
#else
    for (u8Idx = 0U; u8Idx < MAX_NUM_OF_CORES; u8Idx++)
    {
        Can_TxConfirmation[u8Idx] = 0U;
        Can_RxIndication[u8Idx] = 0U; 
    }
#endif

}

void CanIf_RxIndication( const Can_HwType* Mailbox, const PduInfoType* PduInfoPtr )
{   
    /* Local variable */
    uint8 i = 0U;
#if CAN_43_LLCE_MAX_PARTITIONS != 1U
    uint32 u32CoreId = OsIf_GetCoreID();
#endif

    for (i = 0; i < PduInfoPtr->SduLength; i++)
    {
        /* Pointer to received L-SDU (payload) */
        Can_RxData[i] = PduInfoPtr->SduDataPtr[i];
    }

     for (i = PduInfoPtr->SduLength; i < CAN_FD_FRAME_LEN; i++)
    {
        /* Clean the rest of the payload if it's not a CAN FD frame*/
        Can_RxData[i] = 0;
    }

    /* Get the id of the corresponding hardware object: Range is 0 .. (total number of HRH-1) */
    Can_RxHandle = Mailbox->Hoh;
    /* standard/Extended Can ID of L-PDU  that has been successfully received */
    Can_RxId = Mailbox->CanId;
    /* Data length code (length of L0PDU payload) */
    Can_RxDlc = PduInfoPtr->SduLength;
    /*Get the id of Controller*/
    Can_ControllerId = Mailbox->ControllerId;

    /* Increment counter to record reception of a message */
#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    Can_RxIndication++;
#else
    Can_RxIndication[u32CoreId]++;
#endif
}

void CanIf_ControllerBusOff( uint8 Controller)
{   
    /* Increment counter to record bus off events */
    Can_BusOffConfirmation++;
    (void)Controller;
}

void CanIf_ControllerModeIndication( uint8 Controller, Can_ControllerStateType ControllerMode )
{
    (void)ControllerMode;
    (void)Controller;
}

void CanIf_TxConfirmation( PduIdType CanTxPduId)
{
#if CAN_43_LLCE_MAX_PARTITIONS != 1U
    uint32 u32CoreId = OsIf_GetCoreID();
#endif
    /* Increment counter to record transmission of a message */
#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    Can_TxConfirmation++;
#else
    u32CoreId = OsIf_GetCoreID();
    Can_TxConfirmation[u32CoreId]++;
#endif
    /* Store the PDU ID for debug purposes */
    Can_TxConfirmation_CanTxPduId = CanTxPduId;
    Can_Tx_No[CanTxPduId]++;
}

void RxTimestampNotification(Can_HwHandleType Hoh, uint32 u32TimestampVal)
{
	(void)u32TimestampVal; /* timestamp for current received frame identified through Hoh */
	(void)Hoh;
}

void TxTimestampNotification(Can_HwHandleType Hoh, PduIdType CanTxPduId, uint32 u32TimestampVal)
{
	(void)u32TimestampVal; /* timestamp for current frame confirmation identified through Hoh and CanTxPduId (frameTag1 and frameTag2) */
	(void)Hoh;
	(void)CanTxPduId;
}

/* Callback for errors. This is triggered for errors configured in INTERRUPT or by calling MainFunction_Error */
void CanErrorNotification(uint8 u8CanIfCtrlId, Llce_Can_NotificationIdType eNotifId, volatile Llce_Can_ErrorNotifType* ErrorInfo)
{
	(void)u8CanIfCtrlId; 
	(void)eNotifId;
	(void)ErrorInfo;
}

void CanWriteCustomCallback(Can_HwHandleType Hoh, PduIdType CanTxPduId, uint32 u32TxMb)
{
	(void)Hoh; 
	(void)CanTxPduId;
	(void)u32TxMb;
}

void CanTxConfirmationCustomCallback(Can_HwHandleType Hoh, PduIdType CanTxPduId)
{
	(void)Hoh; 
	(void)CanTxPduId;
}


boolean Can_43_LLCE_RxCustomCallback(uint8 Hrh, Can_IdType CanId, uint8 CanDataLength, const uint8* CanSduPtr, uint32 u32RxMb)
{
    /* Suppress warnings for unused arguments */
    (void)Hrh; (void)CanId; (void)CanDataLength; (void)CanSduPtr; (void)u32RxMb;

    u32CustomCallbackExecutions++;

    /* Returns FALSE for even IDs */
    return (CanId & 0x01);
}


===== 文件 [37/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\Project_Settings\Startup_Code\Vector_Table.s =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
*   @file    Vector_Table.s
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - Vector Table.
*   @details Vector Table.
*            This file contains sample code only. It is not part of the production code deliverables
==================================================================================================*/

.section  ".intc_vector","ax"
.align 2
.thumb
.globl undefined_handler
.globl undefined_handler
.globl VTABLE
.globl __Stack_dtcm_start        /* Top of Stack for Initial Stack Pointer */
.globl Reset_Handler             /* Reset Handler */
.globl NMI_Handler               /* NMI Handler */
.globl HardFault_Handler         /* Hard Fault Handler */
.globl MemManage_Handler         /* Reserved */
.globl BusFault_Handler          /* Bus Fault Handler */
.globl UsageFault_Handler        /* Usage Fault Handler */
.globl SVC_Handler               /* SVCall Handler */
.globl DebugMon_Handler          /* Debug Monitor Handler */
.globl PendSV_Handler            /* PendSV Handler */
.globl SysTick_Handler           /* SysTick Handler */ /* 15*/

VTABLE:
.long __Stack_dtcm_start          /* Top of Stack for Initial Stack Pointer */
.long Reset_Handler+1           /* Reset Handler need plus 1 because Reset_Handler is generated with LSB bit =0*/
.long NMI_Handler               /* NMI Handler */
.long HardFault_Handler         /* Hard Fault Handler */
.long MemManage_Handler         /* Reserved */
.long BusFault_Handler          /* Bus Fault Handler */
.long UsageFault_Handler        /* Usage Fault Handler */
.long 0                         /* Reserved */
.long 0                         /* Reserved */
.long 0                         /* Reserved */
.long 0                         /* Reserved */
.long SVC_Handler+1             /* SVCall Handler */
.long DebugMon_Handler          /* Debug Monitor Handler */
.long 0                         /* Reserved */
.long PendSV_Handler            /* PendSV Handler */
.long SysTick_Handler           /* SysTick Handler */ /* 15*/

.long undefined_handler /*0*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*10*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*20*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*30*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler /*40*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler /*50*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*60*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*70*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*80*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*90*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler 
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*100*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*110*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*120*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*130*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*140*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*150*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*160*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*170*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*180*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*190*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*200*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*210*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*220*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*230*/
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler
.long undefined_handler /*240*/
.long undefined_handler




.size VTABLE, . - VTABLE


===== 文件 [38/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\Project_Settings\Startup_Code\exceptions.c =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
*   @file    exceptions.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - Interrupts table.
*   @details Interrupts table.
*            This file contains sample code only. It is not part of the production code deliverables.
==================================================================================================*/

#ifdef __cplusplus
extern "C" {
#endif

#include "Platform_Types.h"
#include "Mcal.h"

#define PLATFORM_START_SEC_CODE
#include "Platform_MemMap.h"

void NMI_Handler(void)                  __attribute__ ((weak));               /* NMI Handler */
void HardFault_Handler(void)            __attribute__ ((weak));         /* Hard Fault Handler */
void MemManage_Handler(void)            __attribute__ ((weak));         /* Reserved */
void BusFault_Handler(void)             __attribute__ ((weak));          /* Bus Fault Handler */
void UsageFault_Handler(void)           __attribute__ ((weak));        /* Usage Fault Handler */
void DebugMon_Handler(void)             __attribute__ ((weak));          /* Debug Monitor Handler */
void PendSV_Handler(void)               __attribute__ ((weak));            /* PendSV Handler */
void SysTick_Handler(void)              __attribute__ ((weak));           /* SysTick Handler */
void undefined_handler(void);         /* Undefined Handler */
#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
void SVCHandler_main(uint32 * svc_args);
void Suspend_Interrupts(void);
void Resume_Interrupts(void);
#endif

#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
#ifndef __ICCARM__
#ifdef _DIABDATA_C_S32G2XX_
/* Define the SVC handler in assembly, to ensure there is no extra PUSH instruction at the beginning of the C handler.*/
__asm(".section .mcal_text");
__asm(".globl SVC_Handler");
__asm(".weak SVC_Handler");
__asm("SVC_Handler:");
/*Load in R0 the stack pointer (depneding on context from which SVC is called)*/
__asm("tst     lr, #4");
__asm("ite eq");
__asm("mrseq   r0, MSP");
__asm("mrsne   r0, PSP");
/* stack pointer is passed to SVCHandler_main, it will be used to extract the parameter given to svc call*/
__asm("b       SVCHandler_main");
#else
/* Define the SVC handler in assembly, to ensure there is no extra PUSH instruction at the beginning of the C handler.*/
ASM_KEYWORD(".globl SVC_Handler");
ASM_KEYWORD(".weak SVC_Handler");
ASM_KEYWORD("SVC_Handler:");
/*Load in R0 the stack pointer (depneding on context from which SVC is called)*/
ASM_KEYWORD("tst     lr, #4");
ASM_KEYWORD("ite eq");
ASM_KEYWORD("mrseq   r0, MSP");
ASM_KEYWORD("mrsne   r0, PSP");
/* stack pointer is passed to SVCHandler_main, it will be used to extract the parameter given to svc call*/
ASM_KEYWORD("b       SVCHandler_main");
#endif
#else
void SVC_Handler(void) __attribute__((naked, weak));
void SVC_Handler(void)
{
    ASM_KEYWORD("tst lr, #4\n"\
                "ite eq\n" \
                "mrseq   r0, MSP\n" \
                "mrsne   r0, PSP\n");
    /* stack pointer is passed to SVCHandler_main, it will be used to extract the parameter given to svc call*/
    ASM_KEYWORD("b       SVCHandler_main");
}
#endif
#endif


void NMI_Handler(void)
{
    while(TRUE){};
}
void HardFault_Handler(void)
{
    while(TRUE){};
}
void MemManage_Handler(void)
{
    while(TRUE){};
}
void BusFault_Handler(void)
{
    while(TRUE){};
}
void UsageFault_Handler(void)
{
    while(TRUE){};
}

#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
void SVC_Handler(void)  __attribute__ ((weak));               /* SVCall Handler */
void SVC_Handler(void)
{
    while(TRUE){};
}
#else
void SVCHandler_main(uint32 * svc_args)
{
    uint32 svc_number;    /* Stack contains:    * r0, r1, r2, r3, r12, r14, the return address and xPSR   */
                                /* First argument (r0) is svc_args[0]  */
    /* svc_args[6] =  SP + 0x18  PC(r15) */
    /* ((char *)svc_args[6])[-2]; = first two bytes, lsb, of the instruction which caused the SVC */
    /* this will nto work if optimization compiler options are changed*/
    svc_number = ((uint8 *)svc_args[6])[-2];
    switch(svc_number)
    {
        case 1:
            /* Handle SVC 01*/
            ASM_KEYWORD("mov   r0, #0x1");   /* Set User mode for Thread mode */
            ASM_KEYWORD("msr   CONTROL, r0");
            break;
        case 0:
            /* Handle SVC 00*/
            ASM_KEYWORD("mov   r0, #0x0");   /* Set Supervisor mode for Thread mode */
            ASM_KEYWORD("msr   CONTROL, r0");
            break;
        case 2:
            /* Handle SVC 02*/
            Resume_Interrupts(); /* Resume all interrupts */
            
            break;
        case 3:
            /* Handle SVC 03*/
            Suspend_Interrupts(); /* Suspend all interrupts */

            break;
        default:
            /* Unknown SVC*/
            break;
    }
}

void Suspend_Interrupts(void)
{
    ASM_KEYWORD("push {r0}");
    ASM_KEYWORD("mov   r0, #0x10");
    ASM_KEYWORD(" msr BASEPRI, r0");
    ASM_KEYWORD("pop {r0}");
}

void Resume_Interrupts(void)
{
    ASM_KEYWORD("push {r0}");
    ASM_KEYWORD("mov   r0, #0x0");
    ASM_KEYWORD("msr BASEPRI, r0");
    ASM_KEYWORD("pop {r0}");
}
#endif
void DebugMon_Handler(void)
{
    while(TRUE){};
}
void PendSV_Handler(void)
{
    while(TRUE){};
}
void SysTick_Handler(void)
{
    while(TRUE){};
}
void undefined_handler(void)
{
   while(TRUE){};
}

#define PLATFORM_STOP_SEC_CODE
#include "Platform_MemMap.h"

#ifdef __cplusplus
}
#endif


===== 文件 [39/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\Project_Settings\Startup_Code\nvic.c =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
*   @file    nvic.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - nvic driver
*   @details Functions that manage interrupts and exceptions via the NVIC.
*            This file contains sample code only. It is not part of the production code deliverables.
==================================================================================================*/

#include "Std_Types.h"
#include "nvic.h"

#if defined(S32G2XX)
    #include "S32G274A_NVIC.h"
    #include "S32G274A_SCB.h"
#elif defined(S32R45)
    #include "S32R45_SCB.h"
    #include "S32R45_NVIC.h"
#elif defined(S32G3XX)
    #include "S32G399A_SCB.h"
    #include "S32G399A_NVIC.h"
#endif


/*==================================================================================================
*                                        LOCAL MACROS
==================================================================================================*/
/*==================================================================================================
*                                      FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL VARIABLES
==================================================================================================*/
#define FEATURE_NVIC_PRIO_BITS (4U)

/*==================================================================================================
*                                       GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/*================================================================================================*/
#define PLATFORM_START_SEC_CODE
#include "Platform_MemMap.h"
/** 
* @brief Set Priority Grouping
* @details The function sets the priority grouping field using the required unlock sequence.
*  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
*   Only values from 0..7 are used.
*   In case of a conflict between priority grouping and available
*   priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set
*/
/*================================================================================================*/
void NVIC_SetPriorityGrouping(uint32 PriorityGroup)
{
    /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
    S32_SCB->AIRCR = (S32_SCB->AIRCR & (~0x700UL)) | PriorityGroup;
}

/*================================================================================================*/
/** 
* @brief Enable External Interrupt
* @details The function enables a device-specific interrupt in the NVIC interrupt controller.
*/
/*================================================================================================*/ 
void NVIC_EnableIRQ(uint8 IRQn)
{
    S32_NVIC->ISER[(uint32)(IRQn) >> 5U] = (uint32)(1UL << ((uint32)(IRQn) & (uint32)0x1FU));
}

/*================================================================================================*/
/** 
* @brief Disable External Interrupt
* @details The function disables a device-specific interrupt in the NVIC interrupt controller
*/
/*================================================================================================*/  
void NVIC_DisableIRQ(uint8 IRQn)
{
    S32_NVIC->ICER[(uint32)(IRQn) >> 5U] = (uint32)(1UL << ((uint32)(IRQn) & (uint32)0x1FU));
}
 
 
/*================================================================================================*/
/** 
* @brief Set Interrupt Priority
* @details The function sets the priority of an interrupt.
*/
/*================================================================================================*/  
void NVIC_SetPriority(uint8 IRQn, uint8 priority)
{
    uint8 shift = (uint8) (8U - FEATURE_NVIC_PRIO_BITS);
    S32_NVIC->IP[(uint32)(IRQn)] = (uint8)(((((uint32)priority) << shift)) & 0xFFUL);
}
 
 
#define PLATFORM_STOP_SEC_CODE
#include "Platform_MemMap.h"


===== 文件 [40/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\Project_Settings\Startup_Code\startup.c =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/
/**
*   @implements startup.c_Artifact
*/

#include "Std_Types.h"

/*******************************************************************************
 * Definitions
 *******************************************************************************/
#if (CPU_TYPE == CPU_TYPE_64)
    typedef uint64 uintptr;
#elif (CPU_TYPE == CPU_TYPE_32)
    typedef uint32 uintptr;
#elif (CPU_TYPE == CPU_TYPE_16)
    typedef uint16 uintptr;
#else
    typedef uint8 uintptr;
#endif

 /*!
 * @brief Defines the init table layout
 */
typedef struct
{
    uint32 * ram_start; /*!< Start address of section in RAM */
    uint32 * rom_start; /*!< Start address of section in ROM */
    uint32 * rom_end;   /*!< End address of section in ROM */
} Sys_CopyLayoutType;

/*!
 * @brief Defines the zero table layout
 */
typedef struct
{
    uint32 * ram_start; /*!< Start address of section in RAM */
    uint32 * ram_end;   /*!< End address of section in RAM */
} Sys_ZeroLayoutType;

extern uintptr __INIT_TABLE[1U];
extern uintptr __ZERO_TABLE[1U];
extern uintptr __INDEX_COPY_CORE2[];
#if (defined(__ARMCC_VERSION))
    extern uintptr __VECTOR_RAM;
#else
    extern uintptr __VECTOR_RAM[1U];
#endif

/*******************************************************************************
 * Static Variables
 ******************************************************************************/

/*******************************************************************************
 * Code
 ******************************************************************************/
/*FUNCTION**********************************************************************
 *
 * Function Name : init_data_bss
 * Description   : Make necessary initializations for RAM.
 * - Copy the vector table from ROM to RAM.
 * - Copy initialized data from ROM to RAM.
 * - Copy code that should reside in RAM from ROM
 * - Clear the zero-initialized data section.
 *
 * Tool Chains:
 *   __GNUC__           : GNU Compiler Collection
 *   __ghs__            : Green Hills ARM Compiler
 *   __ICCARM__         : IAR ARM Compiler
 *   __DCC__            : Wind River Diab Compiler
 *   __ARMCC_VERSION    : ARMC Compiler
 *
 * Implements    : init_data_bss_Activity
 *END**************************************************************************/
#define PLATFORM_START_SEC_CODE
#include "Platform_MemMap.h"
 
void init_data_bss(void);
void init_data_bss_core2(void);

void init_data_bss(void)
{
    const Sys_CopyLayoutType * copy_layout;
    const Sys_ZeroLayoutType * zero_layout;
    const uint32 * rom;
    const uint8 * rom8;
    uint32 * ram;
    uint8 * ram8;
    uint8 dataPad;
    uint32 len = 0U;
    uintptr size = 0U;
    uint32 i = 0U;
    uint32 j = 0U;

    const uintptr * initTable_Ptr = (uintptr*)__INIT_TABLE;
    const uintptr * zeroTable_Ptr = (uintptr*)__ZERO_TABLE;

    /* Copy initialized table */
    len = *initTable_Ptr;
    initTable_Ptr++;
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
    for(i = 0U; i < len; i++)
    {
        rom = copy_layout[i].rom_start;
        ram = copy_layout[i].ram_start;
        size = (uintptr)copy_layout[i].rom_end - (uintptr)copy_layout[i].rom_start;
        /* Make sure the data area to be copied must be aligned with 4. Then, copy 4 bytes at per one read */
        dataPad = size & 0x3U;
        for(j = 0U; j < ((size - dataPad) >> 2U); j++)
        {
            ram[j] = rom[j];
        }
        /* For the rest of data, copy 1 bytes at per one read */
        rom8 = (uint8 *)&(rom[j]);
        ram8 = (uint8 *)&(ram[j]);
        for (j = 0U; j < dataPad; j++)
        {
            ram8[j] = rom8[j];
        }
    }

    /* Clear zero table */
    len = *zeroTable_Ptr;
    zeroTable_Ptr++;
    zero_layout = (const Sys_ZeroLayoutType *)zeroTable_Ptr;
    for(i = 0U; i < len; i++)
    {
        ram = zero_layout[i].ram_start;
        size = (uintptr)zero_layout[i].ram_end - (uintptr)zero_layout[i].ram_start;
        for(j = 0U; j < (size >> 2U); j++)
        {
            ram[j] = 0U;
        }
        /* Since the size of the section always aligns with 32bits according to the sample file linker. 
           Zeroing the last 4 bytes of the section if the data to be used of program does not align with 4.*/
        if ((size & 0x3U) != 0U)
        {
            ram[j] = 0U;
        }
    }
}

void init_data_bss_core2(void)
{
    const Sys_CopyLayoutType * copy_layout;
    const uint32 * rom;
    const uint8 * rom8;
    uint32 * ram;
    uint8 * ram8;
    uint8 dataPad;
    uint32 len = 0U;
    uintptr size = 0U;
    uint32 i = 0U;
    uint32 j = 0U;

    const uintptr * initTable_Ptr = (uintptr*)__INIT_TABLE;

    /* Copy initialized table */
    len = *initTable_Ptr;
    initTable_Ptr++;
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
    for(i = (uintptr)__INDEX_COPY_CORE2; i < len; i++)
    {
        rom = copy_layout[i].rom_start;
        ram = copy_layout[i].ram_start;
        size = (uintptr)copy_layout[i].rom_end - (uintptr)copy_layout[i].rom_start;
        /* Make sure the data area to be copied must be aligned with 4. Then, copy 4 bytes at per one read */
        dataPad = size & 0x3U;
        for(j = 0U; j < ((size - dataPad) >> 2U); j++)
        {
            ram[j] = rom[j];
        }
        /* For the rest of data, copy 1 bytes at per one read */
        rom8 = (uint8 *)&(rom[j]);
        ram8 = (uint8 *)&(ram[j]);
        for (j = 0U; j < dataPad; j++)
        {
            ram8[j] = rom8[j];
        }
    }
}
#define PLATFORM_STOP_SEC_CODE
#include "Platform_MemMap.h"

/*******************************************************************************
 * EOF
 ******************************************************************************/


===== 文件 [41/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\Project_Settings\Startup_Code\startup_cm7.s =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
*   @file    startup_cm7.s
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - Startup file for ARM.
*   @details Startup file for ARM.
*            This file contains sample code only. It is not part of the production code deliverables
==================================================================================================*/

#define MAIN_CORE 4
#define CM7_ITCMCR 0xE000EF90
#define CM7_DTCMCR 0xE000EF94

#define SBAF_BOOT_MARKER   (0x5AA55AA5)
#define CM7_0_ENABLE_SHIFT (0)
#define CM7_1_ENABLE_SHIFT (1)

#define CM7_0_ENABLE            (1)
#define CM7_1_ENABLE            (0)
#define CM7_0_VTOR_ADDR         (__INIT_INTERRUPT_START)
#define CM7_1_VTOR_ADDR         (0)
#define XRDC_CONFIG_ADDR        (0)
#define LF_CONFIG_ADDR          (0)

    .syntax unified
    .arch armv7-m
/* Table for copying and zeroing */
/* Copy table:
  - Table entries count
    - entry one ram start
    - entry one rom start
    - entry one rom end
    ...
    - entry n ram start
    - entry n rom start
    - entry n rom end
  Zero Table:
    - Table entries count
      - entry one ram start
      - entry one ram end
*/
.section ".init_table", "a"
  .long 6
  .long __RAM_CACHEABLE_START
  .long __ROM_CACHEABLE_START
  .long __ROM_CACHEABLE_END
  .long __RAM_NO_CACHEABLE_START
  .long __ROM_NO_CACHEABLE_START
  .long __ROM_NO_CACHEABLE_END
  .long __RAM_SHAREABLE_START
  .long __ROM_SHAREABLE_START
  .long __ROM_SHAREABLE_END
  .long __HSE_RAM_SHAREABLE_START
  .long __HSE_ROM_SHAREABLE_START
  .long __HSE_ROM_SHAREABLE_END
  .long __RAM_INTERRUPT_START
  .long __INIT_INTERRUPT_START
  .long __INIT_INTERRUPT_END
  .long __RAM_DTCM_START
  .long __ROM_DTCM_START
  .long __ROM_DTCM_END
.section ".zero_table", "a"
  .long 4
  .long __BSS_SRAM_SH_START
  .long __BSS_SRAM_SH_END
  .long __BSS_HSE_SRAM_SH_START
  .long __BSS_HSE_SRAM_SH_END
  .long __BSS_SRAM_NC_START
  .long __BSS_SRAM_NC_END
  .long __BSS_SRAM_START
  .long __BSS_SRAM_END

.globl RESET_CATCH_CORE
.globl _core_loop
.section ".core_loop","ax"
.thumb

_core_loop:
    nop
    nop
    nop
    nop
    b _core_loop

.section ".boot_header","ax"
  .long SBAF_BOOT_MARKER /* IVT marker */
  .long (CM7_0_ENABLE << CM7_0_ENABLE_SHIFT) | (CM7_1_ENABLE << CM7_1_ENABLE_SHIFT) /* Boot configuration word */
  .long 0 /* Reserved */
  .long CM7_0_VTOR_ADDR /* CM7_0 Start address */
  .long 0 /* Reserved */
  .long CM7_1_VTOR_ADDR /* CM7_1 Start address */
  .long 0 /* Reserved */
  .long XRDC_CONFIG_ADDR /* XRDC configuration pointer */
  .long LF_CONFIG_ADDR /* Lifecycle configuration pointer */
  .long 0 /* Reserved */

.globl VTABLE
.section ".startup","ax"
.thumb
/************************************************************************/
/* Autosar synopsis of startup code (See MCU Specification):            */
/*                                                                      */
/*   Before the MCU driver can be initialized, a basic initialization   */
/*   of the MCU has to be executed. This MCU specific initialization is */
/*   typically executed in a start-up code. The start-up code of the    */
/*   MCU shall be executed after power up and any kind of micro-        */
/*   controller reset. It shall perform very basic and microcontroller  */
/*   specific start-up initialization and shall be kept short, because  */
/*   the MCU clock and PLL is not yet initialized. The start-up code    */
/*   shall cover MCU specific initialization, which is not part of      */
/*   other MCU services or other MCAL drivers. The following steps      */
/*   summarizes basic functionality which shall be included in the      */
/*   start-up code. They are listed for guidance, because some          */
/*   functionality might not be supported. No code will be found in     */
/*   case.                                                              */
/************************************************************************/
.set VTOR_REG, 0xE000ED08
.thumb 
.thumb_func
.globl Reset_Handler
.globl _start
_start:
Reset_Handler:
/*****************************************************/
/* Skip normal entry point as nothing is initialized */
/*****************************************************/
 cpsid i
 mov   r0, #0
 mov   r1, #0
 mov   r2, #0
 mov   r3, #0
 mov   r4, #0
 mov   r5, #0
 mov   r6, #0
 mov   r7, #0


/*******************************************************************/
/* NXP Guidance 1 - Init registers to avoid lock-step issues */
/* N/A                                                             */
/*******************************************************************/

/*******************************************************************/
/* NXP Guidance 2 - MMU Initialization for CPU               */
/*  TLB0 - PbridgeB                                                */
/*  TLB1 - Internal Flash                                          */
/*  TLB2 - External SRAM                                           */
/*  TLB3 - Internal SRAM                                           */
/*  TLB4 - PbridgeA                                                */
/*******************************************************************/

/******************************************************************/
/* Autosar Guidance 1 - The start-up code shall initialize the    */
/* base addresses for interrupt and trap vector tables. These base*/
/* addresses are provided as configuration parameters or          */
/* linker/locator setting.                                        */
/******************************************************************/

/* relocate vector table to RAM */
ldr  r0, =VTOR_REG
ldr  r1, =__RAM_INTERRUPT_START
str  r1,[r0]

/******************************************************************/
/* Autosar Guidance 2 - The start-up code shall initialize the    */
/* interrupt stack pointer, if an interrupt stack is              */
/* supported by the MCU. The interrupt stack pointer base address */
/* and the stack size are provided as configuration parameter or  */
/* linker/locator setting.                                        */
/*                                                                */
/******************************************************************/


/******************************************************************/
/* Autosar Guidance 3 - The start-up code shall initialize the    */
/* user stack pointer. The user stack pointer base address and    */
/* the stack size are provided as configuration parameter or      */
/* linker/locator setting.                                        */
/******************************************************************/
/* Enable TCM and Disable RETEN bit */
ldr r1, =CM7_DTCMCR
ldr r0, [r1]
bic r0, r0, #0x4
orr r0, r0, #0x1
str r0, [r1]
/* set up stack; r13 SP*/
ldr  r0, =__Stack_dtcm_start
msr MSP, r0
/*GetCoreID*/
ldr  r0, =0x40198004
ldr  r1,[r0]

ldr  r0, =MAIN_CORE
cmp  r1,r0
beq  DisableSWT0

ldr  r0, =0x5
cmp  r1,r0
beq  DisableSWT1

ldr  r0, =0x6
cmp  r1,r0
beq  DisableSWT2

ldr  r0, =0x7
cmp  r1,r0
beq  DisableSWT7

/******************************************************************/
/* Autosar Guidance 4 - If the MCU supports context save          */
/* operation, the start-up code shall initialize the memory which */
/* is used for context save operation. The maximum amount of      */
/* consecutive context save operations is provided as             */
/* configuration parameter or linker/locator setting.             */
/*                                                                */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 5 - The start-up code shall ensure that the   */
/* MCU internal watchdog shall not be serviced until the watchdog */
/* is initialized from the MCAL watchdog driver. This can be      */
/* done for example by increasing the watchdog service time.      */
/*                                                                */
/******************************************************************/

/* Note from manual: For any operation to be performed on an SWT  */
/* instance, its respective core must be enabled.                 */
DisableSWT0:
  ldr  r0, =0x40100010
  ldr  r1, =0xC520
  str  r1, [r0]
  ldr  r1, =0xD928
  str  r1, [r0]
  ldr  r0, =0x40100000
  ldr  r1, =0xFF000040
  str  r1, [r0]
  b    RamInit

DisableSWT1:
  /* disable SWT1 */
  ldr  r0, =0x40104010
  ldr  r1, =0xC520
  str  r1, [r0]
  ldr  r1, =0xD928
  str  r1, [r0]
  ldr  r0, =0x40104000
  ldr  r1, =0xFF000040
  str  r1, [r0]
  b    RamInit

DisableSWT2:
  /* disable SWT2 */
  ldr  r0, =0x40108010
  ldr  r1, =0xC520
  str  r1, [r0]
  ldr  r1, =0xD928
  str  r1, [r0]
  ldr  r0, =0x40108000
  ldr  r1, =0xFF000040
  str  r1, [r0]
  b    RamInit
  

DisableSWT7:
  /* disable SWT7 */
  ldr  r0, =0x4020C010
  ldr  r1, =0xC520
  str  r1, [r0]
  ldr  r1, =0xD928
  str  r1, [r0]
  ldr  r0, =0x4020C000
  ldr  r1, =0xFF000040
  str  r1, [r0]
  b    RamInit

/******************************************************************/
/* Autosar Guidance 13 - The start-up code shall initialize a     */
/* minimum amount of RAM in order to allow proper execution of    */
/* the MCU driver services and the caller of these services.      */
/******************************************************************/
RamInit:
    /* Initialize SRAM ECC */
    ldr  r0, =__RAM_INIT
    cmp  r0, 0
    /* Skip if __SRAM_INIT is not set */
    beq SRAM_LOOP_END
    ldr r1, =__INT_SRAM_START
    ldr r2, =__INT_SRAM_END
    
    subs    r2, r1
    subs    r2, #1
    ble SRAM_LOOP_END

    movs    r0, 0
    movs    r3, 0
SRAM_LOOP:
    stm r1!, {r0,r3}
    subs r2, 8
    bge SRAM_LOOP
SRAM_LOOP_END:

DTCM_Init:
    /* Initialize DTCM ECC */
    ldr  r0, =__DTCM_INIT
    cmp  r0, 0
    /* Skip if __DTCM_INIT is not set */
    beq DTCM_LOOP_END

    ldr r1, =__INT_DTCM_START
    ldr r2, =__INT_DTCM_END
    
    subs    r2, r1
    subs    r2, #1
    ble DTCM_LOOP_END

    movs    r0, 0
    movs    r3, 0
DTCM_LOOP:
    stm r1!, {r0,r3}
    subs r2, #8
    bge DTCM_LOOP
DTCM_LOOP_END:

ITCM_Init:
    /* Initialize ITCM ECC */
    ldr  r0, =__ITCM_INIT
    cmp  r0, 0
    /* Skip if __TCM_INIT is not set */
    beq ITCM_LOOP_END

    /* Enable TCM */
    LDR r1, =CM7_ITCMCR
    LDR r0, [r1]
    LDR r2, =0x1
    ORR r0, r2
    STR r0, [r1]

    ldr r1, =__INT_ITCM_START
    ldr r2, =__INT_ITCM_END
    
    subs    r2, r1
    subs    r2, #1
    ble ITCM_LOOP_END

    movs    r0, 0
    movs    r3, 0
ITCM_LOOP:
    stm r1!, {r0,r3}
    subs r2, #8
    bge ITCM_LOOP
ITCM_LOOP_END:

DebuggerHeldCoreLoop:
  ldr  r0, =RESET_CATCH_CORE
  ldr  r0, [r0]
  ldr  r1, =0x5A5A5A5A
  cmp  r0, r1
  beq	DebuggerHeldCoreLoop

/************************/
/* Erase ".bss Section" */
/************************/
#ifndef MULTIPLE_IMAGE
_DATA_INIT:
    /* If this is the primary core, initialize data and bss */
    ldr  r0, =0x40198004
    ldr  r1,[r0]

    ldr  r0, =MAIN_CORE
    cmp  r1,r0
    beq	 _INIT_DATA_BSS
    bl   init_data_bss_core2
    b __SYSTEM_INIT
#endif

_INIT_DATA_BSS:
  bl init_data_bss


/******************************************************************/
/* Autosar Guidance 6 - If the MCU supports cache memory for data */
/* and/or code, it shall be initialized and enabled in the        */
/* start-up code.                                                 */
/*                                                                */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 7 - The start-up code shall initialize MCU    */
/* specific features of internal memory like memory protection.   */
/*                                                                */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 8 - If external memory is used, the memory    */
/* shall be initialized in the start-up code. The start-up code   */
/* shall be prepared to support different memory configurations   */
/* depending on code location. Different configuration options    */
/* shall be taken into account for code execution from            */
/* external/internal memory.                                      */
/* N/A - external memory is not used                              */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 9 - The settings of the different memories    */
/* shall be provided to the start-up code as configuration        */
/* parameters.                                                    */
/* N/A - all memories are already configured                      */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 10 - In the start-up code a default           */
/* initialization of the MCU clock system shall be performed      */
/* including global clock prescalers.                             */
/******************************************************************/
__SYSTEM_INIT:
  bl SystemInit

/******************************************************************/
/* Autosar Guidance 5 - The start-up code shall ensure that the   */
/* MCU internal watchdog shall not be serviced until the watchdog */
/* is initialized from the MCAL watchdog driver. This can be      */
/* done for example by increasing the watchdog service time.      */
/*                                                                */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 11 - The start-up code shall enable           */
/* protection mechanisms for special function registers(SFR's),   */
/* if supported by the MCU.                                       */
/* N/A - will be handled by Autosar OS                            */
/******************************************************************/

/******************************************************************/
/* Autosar Guidance 12 - The start-up code shall initialize all   */
/* necessary write once registers or registers common to several  */
/* drivers where one write, rather than repeated writes, to the   */
/* register is required or highly desirable.                      */
/******************************************************************/

/*********************************/
/* Set the small ro data pointer */
/*********************************/


/*********************************/
/* Set the small rw data pointer */
/*********************************/

/******************************************************************/
/* Call Main Routine                                              */
/******************************************************************/
_MAIN:
  cpsie i
  bl startup_go_to_user_mode
  bl main

/******************************************************************/
/* Init runtime check data space                                  */
/******************************************************************/
.globl MCAL_LTB_TRACE_OFF
 MCAL_LTB_TRACE_OFF:
    nop

#ifdef CCOV_ENABLE
    /* code coverage is requested */
    bl ccov_main
#endif

    /*BKPT #1 - removed to avoid debug fault being escalated to hardfault when debugger is not attached or on VDK*/ /* last instruction for the debugger to dump results data */
.globl _end_of_eunit_test
_end_of_eunit_test:
    b .

#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
.globl startup_getControlRegisterValue
startup_getControlRegisterValue:
mrs r0, CONTROL
bx r14

.globl startup_getAipsRegisterValue
startup_getAipsRegisterValue:
mrs r0, IPSR
bx r14
#endif

.align 4
.ltorg


===== 文件 [42/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\Project_Settings\Startup_Code\system.c =====
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : 
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be 
*   used strictly in accordance with the applicable license terms.  By expressly 
*   accepting such terms or by downloading, installing, activating and/or otherwise 
*   using the software, you are agreeing that you have read, and that you agree to 
*   comply with and are bound by, such license terms.  If you do not agree to be 
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*================================================================================================
*   @file    system.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Platform - SYSTEM
*   @details SYSTEM
*            This file contains sample code only. It is not part of the production code deliverables.
==================================================================================================*/

#ifdef __cplusplus
extern "C" {
#endif

/*==================================================================================================
*                                         INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Platform_Types.h"
#include "Mcal.h"
#if defined(S32G2XX)
    #include "S32G274A_MSCM.h"
    #include "S32G274A_FXOSC.h"
    #include "S32G274A_MC_CGM_0.h"
    #include "S32G274A_MC_CGM_1.h"
    #include "S32G274A_MC_CGM_2.h"
    #include "S32G274A_SCB.h"
    #include "S32G274A_MPU.h"
    #include "S32G274A_MC_ME.h"
    #include "S32G274A_MC_RGM.h"
    #include "S32G274A_SECURITY.h"
    #include "S32G274A_MDM_AP.h"
    #include "S32G274A_SIUL2.h"
#elif defined(S32R45)
    #include "S32R45_MSCM.h"
    #include "S32R45_FXOSC.h"
    #include "S32R45_MC_CGM_0.h"
    #include "S32R45_MC_CGM_1.h"
    #include "S32R45_MC_CGM_2.h"
    #include "S32R45_SCB.h"
    #include "S32R45_MPU.h"
    #include "S32R45_MC_ME.h"
    #include "S32R45_MC_RGM.h"
    #include "S32R45_SECURITY.h"
    #include "S32R45_MDM_AP.h"
    #include "S32R45_SIUL2.h"
#elif defined(S32G3XX)
    #include "S32G399A_MSCM.h"
    #include "S32G399A_FXOSC.h"
    #include "S32G399A_MC_CGM_0.h"
    #include "S32G399A_MC_CGM_1.h"
    #include "S32G399A_MC_CGM_2.h"
    #include "S32G399A_SCB.h"
    #include "S32G399A_MPU.h"
    #include "S32G399A_MC_ME.h"
    #include "S32G399A_MC_RGM.h"
    #include "S32G399A_SECURITY.h"
    #include "S32G399A_MDM_AP.h"
    #include "S32G399A_SIUL2.h"
#endif

#if (MCAL_PLATFORM_ARM  == MCAL_ARM_AARCH64)
#include "gic500.h"
#else
#include "nvic.h"
#include "core_specific.h"
#endif
#include "system.h"

/*==================================================================================================
*                                      FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/
#define CA53_0_0 (0UL)
#define CA53_0_1 (1UL)
#define CA53_1_0 (2UL)
#define CA53_1_1 (3UL)
#define CM7_0    (4UL)
#define CM7_1    (5UL)
#define CM7_2    (6UL)
#define CM7_3    (7UL)

#define SIUL2_MINOR_MASK             (0x0FU)
#define SIUL2_MINOR_SHIFT            (0x0U)
#define SIUL2_MAJOR_MASK             (0xF0U)
#define SIUL2_MAJOR_SHIFT            (0x4U)


#if (MCAL_PLATFORM_ARM  == MCAL_ARM_AARCH64)
#define SVC_GoToSupervisor()
#define SVC_GoToUser()
#else
#define SVC_GoToSupervisor()      ASM_KEYWORD("svc 0x0")
#define SVC_GoToUser()            ASM_KEYWORD("svc 0x1")
#endif

#define S32_SCB_CPACR_CPx_SHIFT(CpNum)            (2U*((uint32)CpNum))
#define S32_SCB_CPACR_CPx_MASK(CpNum)             (0x3U << S32_SCB_CPACR_CPx_SHIFT(CpNum))
#define S32_SCB_CPACR_CPx(CpNum, x)               (((uint32)(((uint32)(x))<<S32_SCB_CPACR_CPx_SHIFT((CpNum))))&S32_SCB_CPACR_CPx_MASK((CpNum)))

/*==================================================================================================
*                                       LOCAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL VARIABLES
==================================================================================================*/
#define PLATFORM_START_SEC_VAR_CLEARED_32
#include "Platform_MemMap.h"
/* Allocate a global variable which will be overwritten by the debugger if attached(in CMM), to catch the core after reset. */
uint32 RESET_CATCH_CORE;
#define PLATFORM_STOP_SEC_VAR_CLEARED_32
#include "Platform_MemMap.h"

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/

#define PLATFORM_START_SEC_CODE
#include "Platform_MemMap.h"

/*================================================================================================*/
/*
 * @brief Initializes the caches on the platform based on build options. This requires the MPU areas to be configured and enabled before calling this routine.
 * @param: None
 *
 * @return: None
 */
static INLINE void sys_m7_cache_init(void);
/*
 * @brief Disables any previously configured and initialized cache, please make sure MPU is enabled before calling these apis
 * @param: None
 *
 * @return: None
 */
static INLINE void sys_m7_cache_disable(void);
/*
 * @brief Performs a cache clean operation over the configured caches.
 * @param: None
 *
 * @return: None
 */
static INLINE void sys_m7_cache_clean(void);

#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
LOCAL_INLINE void Direct_GoToUser(void);
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/
/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/
#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
LOCAL_INLINE void Direct_GoToUser(void)
{
    ASM_KEYWORD("push {r0}");
    ASM_KEYWORD("ldr r0, =0x1");
    ASM_KEYWORD("msr CONTROL, r0");
    ASM_KEYWORD("pop {r0}");
}
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/
/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
    extern uint32 startup_getControlRegisterValue(void);
    extern uint32 startup_getAipsRegisterValue(void);
    extern void Suspend_Interrupts(void);
    extern void Resume_Interrupts(void);
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/


/*================================================================================================*/
/**
* @brief    startup_go_to_user_mode
* @details  Function called from startup.s to switch to user mode if MCAL_ENABLE_USER_MODE_SUPPORT
*           is defined
*/
/*================================================================================================*/
void startup_go_to_user_mode(void);
void startup_go_to_user_mode(void)
{
#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
    ASM_KEYWORD("svc 0x1");
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/
}

/*================================================================================================*/
/**
* @brief   Default IRQ handler
* @details Infinite Loop
*/
/*================================================================================================*/
void default_interrupt_routine(void)
{
    while(TRUE){};
}

/*================================================================================================*/
/**
* @brief Sys_GoToSupervisor
* @details function used to enter to supervisor mode.
*           check if it's needed to switch to supervisor mode and make the switch.
*           Return 1 if switch was done
*/
/*================================================================================================*/

#ifdef MCAL_ENABLE_USER_MODE_SUPPORT
uint32 Sys_GoToSupervisor(void)
{
    uint32 u32ControlRegValue;
    uint32 u32AipsRegValue;
    uint32 u32SwitchToSupervisor;

    /* if it's 0 then Thread mode is already in supervisor mode */
    u32ControlRegValue = startup_getControlRegisterValue();
    /* if it's 0 the core is in Thread mode, otherwise in Handler mode */
    u32AipsRegValue = startup_getAipsRegisterValue();

    /* if core is already in supervisor mode for Thread mode, or running form Handler mode, there is no need to make the switch */
    if((0U == (u32ControlRegValue & 1u)) || (0u < (u32AipsRegValue & 0xFFu)))
    {
        u32SwitchToSupervisor = 0U;
    }
    else
    {
        u32SwitchToSupervisor = 1U;
        SVC_GoToSupervisor();
    }

    return u32SwitchToSupervisor;
}

/*================================================================================================*/
/**
* @brief Sys_GoToUser_Return
* @details function used to switch back to user mode for Thread mode, return a uint32 value passed as parameter
*/
/*================================================================================================*/
uint32 Sys_GoToUser_Return(uint32 u32SwitchToSupervisor, uint32 u32returnValue)
{
    if (1UL == u32SwitchToSupervisor)
    {
        Direct_GoToUser();
    }

    return u32returnValue;
}

uint32 Sys_GoToUser(void)
{
    Direct_GoToUser();
    return 0UL;
}

/*================================================================================================*/
/**
* @brief Sys_SuspendInterrupts
* @details Suspend Interrupts
*/
/*================================================================================================*/
void Sys_SuspendInterrupts(void)
{
    uint32 u32ControlRegValue;
    uint32 u32AipsRegValue;

    /* if it's 0 then Thread mode is already in supervisor mode */
    u32ControlRegValue = startup_getControlRegisterValue();
    /* if it's 0 the core is in Thread mode, otherwise in Handler mode */
    u32AipsRegValue = startup_getAipsRegisterValue();

    if((0U == (u32ControlRegValue & 1u)) || (0u < (u32AipsRegValue & 0xFFu)))
    {
        Suspend_Interrupts();
    }
    else
    {
        ASM_KEYWORD(" svc 0x3");
    }
}
/*================================================================================================*/
/**
* @brief Sys_ResumeInterrupts
* @details Resume Interrupts
*/
/*================================================================================================*/
void Sys_ResumeInterrupts(void)
{
    uint32 u32ControlRegValue;
    uint32 u32AipsRegValue;

    /* if it's 0 then Thread mode is already in supervisor mode */
    u32ControlRegValue = startup_getControlRegisterValue();
    /* if it's 0 the core is in Thread mode, otherwise in Handler mode */
    u32AipsRegValue = startup_getAipsRegisterValue();

    if((0U == (u32ControlRegValue & 1u)) || (0u < (u32AipsRegValue & 0xFFu)))
    {
        Resume_Interrupts();
    }
    else
    {
        ASM_KEYWORD(" svc 0x2");
    }
}
#endif /*MCAL_ENABLE_USER_MODE_SUPPORT*/


/*================================================================================================*/
/**
* @brief Sys_GetCoreID
* @details Function used to get the ID of the currently executing thread
*/
/*================================================================================================*/
#if !defined(USING_OS_AUTOSAROS)
uint8 Sys_GetCoreID(void)
{
    return ((uint8)(IP_MSCM->CPXNUM & MSCM_CPXNUM_CPN_MASK));
}
#endif /*!defined(USING_OS_AUTOSAROS)*/

/*================================================================================================*/
/**
* @brief Sys_StartSecondaryCores
* @details Function used to start the secondary cores
*/
/*================================================================================================*/
#if (defined(CORE0) && defined(MULTIPLE_IMAGE))

static void Sys_StartSecondaryCores(void)
{
#ifdef START_CM7_1
    extern const uint32 __CORE1_START_ADDRESS;

    IP_MC_ME->PRTN0_CORE1_ADDR = (uint32)&__CORE1_START_ADDRESS;
    IP_MC_ME->PRTN0_CORE1_PCONF = 1;
    IP_MC_ME->PRTN0_CORE1_PUPD = 1;
    IP_MC_ME->CTL_KEY = 0x5AF0;
    IP_MC_ME->CTL_KEY = 0xA50F;
    while (!(IP_MC_ME->PRTN0_CORE1_STAT & MC_ME_PRTN0_CORE1_STAT_CCS_MASK)) {};
    IP_MC_RGM->PRST_0[0].PRST_0 &= ~MC_RGM_PRST_0_PERIPH_1_RST(1);
    while(IP_MC_RGM->PSTAT_0[0].PSTAT_0 & MC_RGM_PSTAT_0_PERIPH_1_STAT_MASK);
#endif /*START_CM7_1*/
#ifdef START_CM7_2
    extern const uint32 __CORE2_START_ADDRESS;

    IP_MC_ME->PRTN0_CORE2_ADDR = (uint32)&__CORE2_START_ADDRESS;
    IP_MC_ME->PRTN0_CORE2_PCONF = 1;
    IP_MC_ME->PRTN0_CORE2_PUPD = 1;
    IP_MC_ME->CTL_KEY = 0x5AF0;
    IP_MC_ME->CTL_KEY = 0xA50F;
    while (!(IP_MC_ME->PRTN0_CORE2_STAT & MC_ME_PRTN0_CORE2_STAT_CCS_MASK)) {};
    IP_MC_RGM->PRST_0[0].PRST_0 &= ~MC_RGM_PRST_0_PERIPH_2_RST(1);
    while(IP_MC_RGM->PSTAT_0[0].PSTAT_0 & MC_RGM_PSTAT_0_PERIPH_2_STAT_MASK);
#endif /*START_CM7_2*/
#ifdef START_CM7_3
    extern const uint32_t __CORE3_START_ADDRESS;

    IP_MC_ME->PRTN0_CORE4_ADDR = (uint32)&__CORE3_START_ADDRESS;
    IP_MC_ME->PRTN0_CORE4_PCONF = 1;
    IP_MC_ME->PRTN0_CORE4_PUPD = 1;
    IP_MC_ME->CTL_KEY = 0x5AF0;
    IP_MC_ME->CTL_KEY = 0xA50F;
    while (!(IP_MC_ME->PRTN0_CORE4_STAT & MC_ME_PRTN0_CORE4_STAT_CCS_MASK)) {};
    IP_MC_RGM->PRST_0[0].PRST_0 &= ~MC_RGM_PRST_0_PERIPH_6_RST(1);
    while(IP_MC_RGM->PSTAT_0[0].PSTAT_0 & MC_RGM_PSTAT_0_PERIPH_6_STAT_MASK);
#endif /*START_CM7_3*/
}
#endif /*(defined(CORE0) && defined(MULTIPLE_IMAGE))*/

/*================================================================================================*/
/*
 * system initialization : system clock, interrupt router ...
 */

void SystemInit(void)
{
    uint32 i;
    uint32 coreMask;
#ifdef MPU_ENABLE
    uint8 regionNum = 0U;
#endif

    uint32 coreId = OsIf_GetCoreID();

    switch(coreId)
    {
        case CA53_0_0:
            /* There is only one bitfield for all Cortex A53 interrupt steering. Fall trough */
        case CA53_0_1:
            /* There is only one bitfield for all Cortex A53 interrupt steering. Fall trough */
        case CA53_1_0:
            /* There is only one bitfield for all Cortex A53 interrupt steering. Fall trough */
        case CA53_1_1:
            coreMask = (1UL << MSCM_IRSPRC_GIC500_SHIFT);
            break;
        case CM7_0:
            coreMask = (1UL << MSCM_IRSPRC_M7_0_SHIFT);
            break;
        case CM7_1:
            coreMask = (1UL << MSCM_IRSPRC_M7_1_SHIFT);
            break;
        case CM7_2:
            coreMask = (1UL << MSCM_IRSPRC_M7_2_SHIFT);
            break;
#if defined(S32G3XX)
        case CM7_3:
            coreMask = (1UL << MSCM_IRSPRC_M7_3_SHIFT);
            break;
#endif
        default:
            coreMask = 0UL;
            break;
    }

    /* Configure IP_MSCM to enable/disable interrupts routing to Core processor */
    for (i = 0; i < MSCM_IRSPRC_COUNT; i++)
    {
        IP_MSCM->IRSPRC[i] |= coreMask;
    }

#if (defined(CORE0) && defined(MULTIPLE_IMAGE))
    Sys_StartSecondaryCores();
#endif

#if (MCAL_PLATFORM_ARM  == MCAL_ARM_AARCH64)

    gic500_enableGIC();

    /* fill the interrupts_vector with the default interrupt rutine */
    for (i=0; i<A53_NUM_OF_VECTORS; i++)
    {
        g_INT_vectors[i] = (isr_t)default_interrupt_routine;
    }

#else

  NVIC_SetPriorityGrouping(0); /* 0 means 7 bits for prio, 1 for sub-prio */
  S32_SCB->CCR |=  1;          /* processor can enter Thread mode from any level under the
                                   control of an EXC_RETURN value, PendSV priority set to 0 */
  S32_SCB->SHPR3 = 0;

/**************************************************************************/
                      /* FPU ENABLE*/
/**************************************************************************/
#ifdef ENABLE_FPU
    /* Enable CP10 and CP11 coprocessors */
    S32_SCB->CPACR |= (S32_SCB_CPACR_CPx(10U, 3U) | S32_SCB_CPACR_CPx(11U, 3U));

    MCAL_INSTRUCTION_SYNC_BARRIER();
    MCAL_DATA_SYNC_BARRIER();

#endif /*ENABLE_FPU*/

/**************************************************************************/
                      /* DEFAULT MEMORY ENABLE*/
/**************************************************************************/
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
/**************************************************************************/
                      /* MPU ENABLE*/
/**************************************************************************/
#ifdef MPU_ENABLE
    /*Checking if cache is enable before*/
    if (((((uint32)1U << (uint32)17U) & S32_SCB->CCR) != (uint32)0) || ((((uint32)1U << (uint32)16U) & S32_SCB->CCR) != (uint32)0))
    {
        /* synchronize cache before update mpu */
        sys_m7_cache_disable();
    }
    /* Set default memory regions */
    for (regionNum = 0U; regionNum < CPU_MPU_MEMORY_COUNT; regionNum++)
    {
        S32_MPU->RNR  = regionNum;
        S32_MPU->RBAR = rbar[regionNum];
        S32_MPU->RASR = rasr[regionNum];
    }

    /* Enable MPU */
    S32_MPU->CTRL |= S32_MPU_CTRL_ENABLE_MASK;
    MCAL_INSTRUCTION_SYNC_BARRIER();
    MCAL_DATA_SYNC_BARRIER();
#endif /*MPU_ENABLE*/

/**************************************************************************/
            /* ENABLE CACHE */
/**************************************************************************/
#if defined(D_CACHE_ENABLE) || defined(I_CACHE_ENABLE)
    sys_m7_cache_init();
#endif /*defined(D_CACHE_ENABLE) || defined(I_CACHE_ENABLE)*/
/*
 * SystemWfiConfig : Implement errata ERR051149
 */
#if defined(ERR_CORTEX_M7_E051149) || defined(ERR_CORTEX_M7_E051166)
    SystemWfiConfig();
#endif

#endif /*(MCAL_PLATFORM_ARM  == MCAL_ARM_AARCH64)*/

}
   
static void sys_m7_cache_init(void)
{
#ifdef D_CACHE_ENABLE
    uint32 ccsidr = 0U;
    uint32 sets = 0U;
    uint32 ways = 0U;

    /*init Data caches*/
    S32_SCB->CSSELR = 0U;                       /* select Level 1 data cache */

    MCAL_DATA_SYNC_BARRIER();
    ccsidr = S32_SCB->CCSIDR;
    sets = (uint32)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32)(CCSIDR_WAYS(ccsidr));
      do {
        S32_SCB->DCISW = (((sets << SCB_DCISW_SET_SHIFT) & SCB_DCISW_SET_MASK) |
                      ((ways << SCB_DCISW_WAY_SHIFT) & SCB_DCISW_WAY_MASK)  );

    MCAL_DATA_SYNC_BARRIER();
      } while (ways-- != 0U);
    } while(sets-- != 0U);
    MCAL_DATA_SYNC_BARRIER();
    S32_SCB->CCR |=  (uint32)SCB_CCR_DC_MASK;  /* enable D-Cache */
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
#endif /*D_CACHE_ENABLE*/

#ifdef I_CACHE_ENABLE
    /*init Code caches*/
    S32_SCB->ICIALLU = 0UL;                    /* invalidate I-Cache */
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
    S32_SCB->CCR |=  (uint32)SCB_CCR_IC_MASK;  /* enable I-Cache */
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
#endif /*I_CACHE_ENABLE*/
}

static INLINE void sys_m7_cache_disable(void)
{
    sys_m7_cache_clean();
    S32_SCB->CCR &= ~((uint32)1U << 17U);
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
    S32_SCB->CCR &= ~((uint32)1U << 16U);
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
}

static INLINE void sys_m7_cache_clean(void)
{
#ifdef D_CACHE_ENABLE
    uint32 ccsidr = 0U;
    uint32 sets = 0U;
    uint32 ways = 0U;

    S32_SCB->CSSELR = 0U;                       /* select Level 1 data cache */
    MCAL_DATA_SYNC_BARRIER();
    ccsidr = S32_SCB->CCSIDR;
    sets = (uint32)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32)(CCSIDR_WAYS(ccsidr));
      do {
        S32_SCB->DCCISW = (((sets << SCB_DCCISW_SET_SHIFT) & (uint32)SCB_DCCISW_SET_MASK) |
                      ((ways << SCB_DCCISW_WAY_SHIFT) & (uint32)SCB_DCCISW_WAY_MASK)  );
        MCAL_DATA_SYNC_BARRIER();
      } while (ways-- != 0U);
    } while(sets-- != 0U);
    MCAL_DATA_SYNC_BARRIER();
    S32_SCB->CSSELR = (uint32)((S32_SCB->CSSELR) | 1U);
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
#endif /*D_CACHE_ENABLE*/

#ifdef I_CACHE_ENABLE
    S32_SCB->ICIALLU = 0UL;
    MCAL_DATA_SYNC_BARRIER();
    MCAL_INSTRUCTION_SYNC_BARRIER();
#endif /*I_CACHE_ENABLE*/
}
/*================================================================================================*/
/*
 * SystemWfiConfig : Implement errata ERR051149
 * SystemWfiConfig : Implement errata ERR051166
 */
#if defined(ERR_CORTEX_M7_E051149) || defined(ERR_CORTEX_M7_E051166)
void SystemWfiConfig(void)
{
    uint32 u32EdbStatus = 0U;
#ifdef S32G3XX
/*  Major Mask Revision
    0000b - Rev 1.x
    0001b - Rev 2.x
    Minor Mask Revision
    0000b - Rev x.0
    0001b - Rev x.1 */
    uint32 U32MajorMinor = (uint32_t)(IP_SIUL2_0->MIDR1);
    uint8 Minor = (uint8)((U32MajorMinor & SIUL2_MINOR_MASK) >> SIUL2_MINOR_SHIFT);
    uint8 Major = (uint8)((U32MajorMinor & SIUL2_MAJOR_MASK) >> SIUL2_MAJOR_SHIFT);
    if (Major == 0U && Minor == 0U)
    {
#endif
        u32EdbStatus = (uint32_t)(IP_SECURITY_CC->EXT_DBGSTAT & SECURITY_EXT_DBGSTAT_EDB_MASK);
        if (u32EdbStatus == 0U)
        {
            IP_MDM_AP->DAP_EN_CTRL &= ~MDM_AP_DAP_EN_CTRL_CSPNIDEN_MASK;
            IP_MDM_AP->DAP_EN_CTRL &= ~MDM_AP_DAP_EN_CTRL_CSPIDEN_MASK;
            IP_MDM_AP->DAP_EN_CTRL &= ~MDM_AP_DAP_EN_CTRL_CNIDEN_MASK;
            IP_MDM_AP->DAP_EN_CTRL &= ~MDM_AP_DAP_EN_CTRL_CDBGEN_MASK;
            IP_MDM_AP->CONTROL |= MDM_AP_CONTROL_CM7_0_EDBGREQ_MASK;
            IP_MDM_AP->CONTROL |= MDM_AP_CONTROL_CM7_1_EDBGREQ_MASK;
            IP_MDM_AP->CONTROL |= MDM_AP_CONTROL_CM7_2_EDBGREQ_MASK;
#ifdef S32G3XX
#if defined(ERR_CORTEX_M7_E051166)
            IP_MDM_AP->CORTEX_A53_A0_IP_DBG |= MDM_AP_CORTEX_A53_A0_IP_DBG_CM7_3_EDBGREQ_MASK;
#endif
#endif
        }
        else
        {
            /* do nothing */
        }
#ifdef S32G3XX
    }
    else
    {
        /* do nothing */
    }
#endif
}
#endif

#define PLATFORM_STOP_SEC_CODE
#include "Platform_MemMap.h"

#ifdef __cplusplus
}
#endif /*__cplusplus */


===== 文件 [43/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\include\Core_Heartbeat.h =====
/*==================================================================================================
*
* Copyright 2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#ifndef CORE_HEARTBEAT
#define CORE_HEARTBEAT

#include "StandardTypes.h"

#define HEARTBEAT_STRUCTURE_ADDRESS   (0x4384FFD0U)
#define HEARTBEAT_MAX_TIME_DIFFERENCE (100u)

void Core_Heartbeat_Init(void);
void Core_Heartbeat_Check(void);

#endif /* CORE_HEARTBEAT */


===== 文件 [44/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\include\Llce_Firmware_Load.h =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#ifndef LLCE_FIRMWARE_LOAD_H
#define LLCE_FIRMWARE_LOAD_H

#include "StandardTypes.h"

Std_ReturnType Llce_Firmware_Load(void);
boolean Llce_Firmware_Load_GetBootStatus(void);

#endif /* LLCE_FIRMWARE_LOAD_H */


===== 文件 [45/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\include\PlatformInit.h =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#ifndef APP_PLATFORM_INIT
#define APP_PLATFORM_INIT

void PlatformInit(void);

#endif /* APP_PLATFORM_INIT */


===== 文件 [46/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\include\can_common.h =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#ifndef CAN_COMMON
#define CAN_COMMON

#ifdef ASR_NOT_USED
    #include "PlatformTypes.h"    
#endif

#define CAN_FD_FRAME_LEN 64U
#define CAN_STD_FRAME_LEN 8U
#define TP_TIMEOUT 800000U
#define CONTROLLER1 1
#define CONTROLLER0 0
#define CONTROLLER2 2
#define CONTROLLER3 3
#define CONTROLLER4 4
#define CONTROLLER5 5
#define CONTROLLER7 7
#define CONTROLLER10 10
#define CONTROLLER11 11
#define CONTROLLER12 12
#define CONTROLLER14 14
#define CONTROLLER15 15
#define ITER_NR 200
#define MAX_BUFFER_FRAME_FD 64
#define CAN_LPDU_FD_U32 ((uint32)0x40000000)
#define MAX_NUM_OF_CORES 8U
#define ON  1
#define OFF 0

/* Sample app specific variable. Possible values: ON, OFF */
extern volatile uint8 fail;

#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    extern volatile uint32 last_RxIndication;
    extern volatile uint32 last_TxConfirmation;
#else
    extern volatile uint32 last_RxIndication[MAX_NUM_OF_CORES];
    extern volatile uint32 last_TxConfirmation[MAX_NUM_OF_CORES];
#endif

void Circular_Permutation(volatile uint8 *Payload, uint8 n);
StatusType Check_Status(Can_PduType *CanMessage);


#endif  /* CAN_COMMON */


===== 文件 [47/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\include\check_example.h =====
/*
*   (c) Copyright 2020 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be used strictly
*   in accordance with the applicable license terms.  By expressly accepting
*   such terms or by downloading, installing, activating and/or otherwise using
*   the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms.  If you do not agree to
*   be bound by the applicable license terms, then you may not retain,
*   install, activate or otherwise use the software.
*
*   This file contains sample code only. It is not part of the production code deliverables.
*/

#ifndef CHECK_EXAMPLE_H
#define CHECK_EXAMPLE_H

#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/


/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/

/**
* @brief        Function used for testing automatically examples
* @details      Writes a pass or fail status in the memory at a given address
* @internal
*/
static inline void Exit_Example(boolean result) 
{
    volatile uint8 * testResultBasePtr;
    
    testResultBasePtr = (volatile uint8 *)VV_RESULT_ADDRESS;
    
    if (TRUE == result)
    {
        *testResultBasePtr = 0x5AU;
    }
    else
    {
        *testResultBasePtr = 0x33U;
    }
}

static inline void EX_ASSERT(boolean result) 
{
    volatile uint8 * testResultBasePtr;
    
    testResultBasePtr = (volatile uint8 *)VV_RESULT_ADDRESS;
    
    if (TRUE == result)
    {
        if(*testResultBasePtr != 0x33U)
        {
            *testResultBasePtr = 0x5AU;
        }
    }
    else
    {
        *testResultBasePtr = 0x33U;
    }
}

#ifdef __cplusplus
}
#endif

#endif 

/** @} */


===== 文件 [48/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\include\stubs.h =====
#ifndef STUBS_H
#define STUBS_H

#include "Can_43_LLCE.h"
#include "can_common.h"
#include "Platform_Types.h"

#define ASSERT(expr) \
    if (!(expr)) \
        fail = ON

/* Stub functions */
void CanIf_RxIndication( const Can_HwType* Mailbox, const PduInfoType* PduInfoPtr );
void CanIf_TxConfirmation( PduIdType CanTxPduId);
void CanIf_ControllerModeIndication( uint8 Controller, Can_ControllerStateType ControllerMode);
void CanIf_ControllerBusOff( uint8 Controller);
void RxTimestampNotification(Can_HwHandleType Hoh, uint32 u32TimestampVal);
void TxTimestampNotification(Can_HwHandleType Hoh, PduIdType CanTxPduId, uint32 u32TimestampVal);
void CanErrorNotification(uint8 u8CanIfCtrlId, Llce_Can_NotificationIdType eNotifId, volatile Llce_Can_ErrorNotifType* ErrorInfo);

void Can_CallBackSetUp(void);

extern volatile uint8   Can_RxData[CAN_FD_FRAME_LEN];
extern volatile uint8  Can_RxHandle;
extern volatile Can_IdType Can_RxId;
extern volatile uint8  Can_RxDlc;
extern volatile uint8  Can_ControllerId;
extern volatile PduIdType Can_TxConfirmation_CanTxPduId;
extern volatile uint8  Can_BusOffConfirmation;
extern volatile uint32   Can_Tx_No[16];
extern volatile uint32 u32CustomCallbackExecutions;
#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    extern volatile uint32 Can_RxIndication;
    extern volatile uint32 Can_TxConfirmation;
#else
    extern volatile uint32 Can_RxIndication[MAX_NUM_OF_CORES];
    extern volatile uint32 Can_TxConfirmation[MAX_NUM_OF_CORES];
#endif

#endif /* STUBS_H */


===== 文件 [49/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\src\Core_Heartbeat.c =====
/*==================================================================================================
*
* Copyright 2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#include "Core_Heartbeat.h"
#include "Llce_RegAccess.h"
#include "Llce_InterfaceFwMgr.h"

/* Macro used for rollover detection of the global counter u32SysTickCounter. (Rollover every ~118h when counting hundreds of microseconds (100us granularity)) */
#define MAX_UINT32_VALUE (uint32)4294967295U
#define MAX_NR_OF_CORE_TIMEOUT   10u

/* Counter increases when a timeout occurs (up to 10) and decreases when it doesn't */
static struct 
{
  uint8 core1TimeoutCounter;
  uint8 core2TimeoutCounter;
  uint8 core3TimeoutCounter;
}timeoutCoreCounter;


static Llce_Mgr_TimeStampCoresType Core_Heartbeat_Time_Elapsed(Llce_Mgr_TimeStampCoresType currentHeartbeatValue, Llce_Mgr_TimeStampCoresType previousHeartbeatValue);
static uint32 Core_Heartbeat_Calculate_Time_Difference(uint32 currentHeartbeatCoreValue, uint32 previousHeartbeatCoreValue);
static void Core_Heartbeat_Update_All_Counters(Llce_Mgr_TimeStampCoresType heartbeatTimeDifference);
static void Core_Heartbeat_Update_Counter(uint32 timestampDifference, uint8 *counter);

void Core_Heartbeat_Init(void)
{
  /* Init already done in Can_Enable_Timestamp() from Platform_Init.c */

}

void Core_Heartbeat_Check(void)
{   
  static volatile Llce_Mgr_TimeStampCoresType previousHeartbeatValue;
  static volatile Llce_Mgr_TimeStampCoresType* pcurrentHeartbeatValue = (Llce_Mgr_TimeStampCoresType*)HEARTBEAT_STRUCTURE_ADDRESS;
  Llce_Mgr_TimeStampCoresType heartbeatTimeDifference;

  heartbeatTimeDifference = Core_Heartbeat_Time_Elapsed(*pcurrentHeartbeatValue, previousHeartbeatValue);

  Core_Heartbeat_Update_All_Counters(heartbeatTimeDifference);

  if(
       (timeoutCoreCounter.core1TimeoutCounter >= MAX_NR_OF_CORE_TIMEOUT) 
    || (timeoutCoreCounter.core2TimeoutCounter >= MAX_NR_OF_CORE_TIMEOUT) 
    || (timeoutCoreCounter.core3TimeoutCounter >= MAX_NR_OF_CORE_TIMEOUT)
    )
  {
    /* Insert reaction here */
  }

  previousHeartbeatValue = *pcurrentHeartbeatValue;
}

/* Increment or decrement a counter based on the time difference between two consecutive timestamps */
static void Core_Heartbeat_Update_Counter(uint32 timestampDifference, uint8 *counter)
{
  if((timestampDifference) > HEARTBEAT_MAX_TIME_DIFFERENCE)
  {
    if(*counter < 255u)
    {
      (*counter)++;
    }
  }
  else
  {
    if(*counter > 0u)
    {
      (*counter)--;
    }
  }
}

/* Update the counter value for every core */
static void Core_Heartbeat_Update_All_Counters(Llce_Mgr_TimeStampCoresType heartbeatTimeDifference)
{
  Core_Heartbeat_Update_Counter(heartbeatTimeDifference.timeStampCore1, &timeoutCoreCounter.core1TimeoutCounter);
  Core_Heartbeat_Update_Counter(heartbeatTimeDifference.timeStampCore2, &timeoutCoreCounter.core2TimeoutCounter);
  Core_Heartbeat_Update_Counter(heartbeatTimeDifference.timeStampCore3, &timeoutCoreCounter.core3TimeoutCounter);
}

/* Update for every core the difference between two consecutive timestamps. */
static Llce_Mgr_TimeStampCoresType Core_Heartbeat_Time_Elapsed(Llce_Mgr_TimeStampCoresType currentHeartbeatValue, Llce_Mgr_TimeStampCoresType previousHeartbeatValue)
{
  Llce_Mgr_TimeStampCoresType heartbeatTimeDifference;

  heartbeatTimeDifference.timeStampCore1 = Core_Heartbeat_Calculate_Time_Difference(currentHeartbeatValue.timeStampCore1, previousHeartbeatValue.timeStampCore1);
  heartbeatTimeDifference.timeStampCore2 = Core_Heartbeat_Calculate_Time_Difference(currentHeartbeatValue.timeStampCore2, previousHeartbeatValue.timeStampCore2);
  heartbeatTimeDifference.timeStampCore3 = Core_Heartbeat_Calculate_Time_Difference(currentHeartbeatValue.timeStampCore3, previousHeartbeatValue.timeStampCore3);

  return heartbeatTimeDifference;
}

/* Calculate the time difference between two consecutive timestamps */
static uint32 Core_Heartbeat_Calculate_Time_Difference(uint32 currentHeartbeatCoreValue, uint32 previousHeartbeatCoreValue)
{
  uint32 timeDifference;
  if(currentHeartbeatCoreValue >= previousHeartbeatCoreValue)
  {
    timeDifference = currentHeartbeatCoreValue - previousHeartbeatCoreValue;
  }
  else
  {
    /* In case of overflow of currentHeartbeatValue */
    timeDifference = MAX_UINT32_VALUE - previousHeartbeatCoreValue + currentHeartbeatCoreValue;
  }
  
  return timeDifference;
}


===== 文件 [50/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\src\Llce_Firmware_Load.c =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#include "Llce_Firmware_Load.h"
#include "Llce_InterfaceFwMgr.h"
#include "Llce_RegAccess.h"


typedef struct {
    uint8* const pu8MemLocation;
    const uint32 u32RAMSize;
    const uint8* const pu8CodeData;
    const uint32* u32CodeSize;
} Llce_CoreProgramType;


#define LLCE_NUM_CORES              4U
#define LLCE_ENABLE_CORE_ADDR       ((uint32)0x43FF8000U)
#define LLCE_DATA_RAM_START_ADDR    0x43800000
#define LLCE_DATA_RAM_LENGTH        0x50000
#define LLCE_FW_STARTUP_DURATION    1000000

#if defined(S32G3) || defined(S32G3XX)
    #define DTE_RAM_SIZE        0x4000
    #define PPE_RX_RAM_SIZE     0x18000
    #define PPE_TX_RAM_SIZE     0x8000
    #define FRPE_RAM_SIZE       0x40000
#else /* S32G2 */
    #define DTE_RAM_SIZE        0x2000
    #define PPE_RX_RAM_SIZE     0x8000
    #define PPE_TX_RAM_SIZE     0x8000
    #define FRPE_RAM_SIZE       0x10000
#endif

/* This variable contains information about fw boot end */
__attribute__((section(".llce_boot_end"))) volatile Llce_Mgr_StatusType Llce_Mgr_Status;

extern const uint8 dte_bin[];
extern const uint32 dte_bin_len;

extern const uint8 ppe_rx_bin[];
extern const uint32 ppe_rx_bin_len;

extern const uint8 ppe_tx_bin[];
extern const uint32 ppe_tx_bin_len;

extern const uint8 frpe_bin[];
extern const uint32 frpe_bin_len;

#ifdef LLCE_USE_HEADLESS
extern const uint8 LLCE_HeadlessConfig_bin[];
#endif

static const Llce_CoreProgramType Llce_CoreData[LLCE_NUM_CORES] = 
{
    { (uint8*)0x43000000, DTE_RAM_SIZE,  dte_bin,    &dte_bin_len },
    { (uint8*)0x43100000, PPE_RX_RAM_SIZE, ppe_rx_bin, &ppe_rx_bin_len},
    { (uint8*)0x43200000, PPE_TX_RAM_SIZE, ppe_tx_bin, &ppe_tx_bin_len},
    { (uint8*)0x43300000, FRPE_RAM_SIZE, frpe_bin,   &frpe_bin_len }
};

/**
* @brief          Service routine used to load the firmware from host memory to LLCE internal memory and enable LLCE cores in order to start running.
* @details        This routine is called by:
*                  - Can_Llce_Init
*
* @param[in]      void
*
* @return
* @retval        E_OK  Timeout was not reached. LLCE internal cores started correctly
* @retval        E_NOT_OK  Timeout was reached. LLCE internal cores not started correctly
*/
Std_ReturnType Llce_Firmware_Load(void)
{   
    uint8 i;
    uint32 crtOffset;
    uint32 byteIndex;
    uint64 *u64MemPointer;
    uint64 *u64MemPointer2;
    const uint64 *u64DataPointer;
	
    /* Put all cores in reset*/
    Reg_Write32(LLCE_ENABLE_CORE_ADDR, 0x0);

    for (i = 0U; i < LLCE_NUM_CORES; i++) 
    {
        /* Move code to core's code section*/
        /* Performance optimisation: write 8 bytes at a time */
        u64MemPointer  = (uint64*)Llce_CoreData[i].pu8MemLocation;
        u64DataPointer = (uint64*)Llce_CoreData[i].pu8CodeData;

        /* Offset is in words (32 bit) */
        for (crtOffset = 0U; crtOffset <  (*(Llce_CoreData[i].u32CodeSize)) / 8; crtOffset++)
        {
            u64MemPointer[crtOffset] = u64DataPointer[crtOffset];
        }
        
        /* Write 2 words at a time before copying bytes */
        u64MemPointer[crtOffset] = (uint64)0;

        /* Back to 1 byte mode */
        for (byteIndex = crtOffset * 8U; byteIndex <  (*(Llce_CoreData[i].u32CodeSize)); byteIndex++)
        {
            Llce_CoreData[i].pu8MemLocation[byteIndex] = Llce_CoreData[i].pu8CodeData[byteIndex];
        }

        crtOffset++;

        /* Fill the rest of the core's RAM in order to enable ECC RAM */
        for ( ; crtOffset < (Llce_CoreData[i].u32RAMSize) / 8 ; crtOffset++)
        {
            u64MemPointer[crtOffset] = (uint64)0;
        }
    }

    /* Pointer to the first half of LLCE Shared RAM */
    u64MemPointer  = (uint64*)LLCE_DATA_RAM_START_ADDR;
    /* Pointer to the second half of LLCE Shared RAM */
    u64MemPointer2  = (uint64*)(LLCE_DATA_RAM_START_ADDR + (LLCE_DATA_RAM_LENGTH/2));

    /* Write all the Shared Memory in order to enable ECC RAM: 8 bytes at a time */
    for (crtOffset = 0U; crtOffset <  LLCE_DATA_RAM_LENGTH / 16; crtOffset++)
    {
        u64MemPointer[crtOffset] = (uint64)0;
        u64MemPointer2[crtOffset] = (uint64)0;
    }

#ifdef LLCE_USE_HEADLESS
    /* Copy magic value from headless config */
    *((uint32*)LLCE_DATA_RAM_START_ADDR) = *((uint32*)LLCE_HeadlessConfig_bin);
    /* Set headless config address */
    *(((uint32*)LLCE_DATA_RAM_START_ADDR) + 1U) = (uint32)&LLCE_HeadlessConfig_bin;
#endif    

    /* Clear memory area where Llce notifies about boot ending */
    Llce_Mgr_Status.eTxBootStatus = LLCE_FW_NOTRUN;
    Llce_Mgr_Status.eRxBootStatus = LLCE_FW_NOTRUN;
    Llce_Mgr_Status.eDteBootStatus = LLCE_FW_NOTRUN;
    Llce_Mgr_Status.eFrpeBootStatus = LLCE_FW_NOTRUN;

    Reg_Write32(LLCE_ENABLE_CORE_ADDR, 0xF);      /*start all cores */

    return Llce_Firmware_Load_GetBootStatus();
}

boolean Llce_Firmware_Load_GetBootStatus(void)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;
    uint32 u32Timeout = LLCE_FW_STARTUP_DURATION;
    Llce_Fw_ReturnType eTxBootStatus   = LLCE_FW_NOTRUN;
    Llce_Fw_ReturnType eRxBootStatus   = LLCE_FW_NOTRUN;
    Llce_Fw_ReturnType eDteBootStatus  = LLCE_FW_NOTRUN;
    Llce_Fw_ReturnType eFrpeBootStatus = LLCE_FW_NOTRUN; 

    /*Wait that the LLCE firmware cores to start running and boot.*/
    while (( (LLCE_FW_SUCCESS != eTxBootStatus) || (LLCE_FW_SUCCESS != eRxBootStatus) || \
			(LLCE_FW_SUCCESS != eDteBootStatus) || (LLCE_FW_SUCCESS != eFrpeBootStatus) ) && (u32Timeout > 0))
    {
        /* Volatile variables should be read separately */
        eTxBootStatus   = Llce_Mgr_Status.eTxBootStatus;
        eRxBootStatus   = Llce_Mgr_Status.eRxBootStatus;
        eDteBootStatus  = Llce_Mgr_Status.eDteBootStatus;
        eFrpeBootStatus = Llce_Mgr_Status.eFrpeBootStatus;
		u32Timeout--;
    }
    
    if (u32Timeout != 0)	
    {
            eReturnValue = E_OK;
    }

    return  eReturnValue;
}


===== 文件 [51/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\src\Platform_Init.c =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#include "Llce_RegAccess.h"
#include "Mcu.h"
#include "OsIf.h"
#include "Platform.h"
#include "CDD_Rm.h"
#ifdef USE_PORT_HLD
    #include "Port.h" /* EB Tresos demo project */
#else
    #include "Siul2_Port_Ip.h" /* S32DS demo project */
#endif

#define MACRO_CONCAT(a,b) a##b
#define MACRO_CONFIG(a,b) MACRO_CONCAT(a, b)
#ifndef CONFIG_VARIANT_USED
 #define MCU_VARIANT    NULL_PTR
 #define PORT_VARIANT   NULL_PTR
#else
 #define MCU_VARIANT    &MACRO_CONFIG(Mcu_Config_, CONFIG_VARIANT_USED)
 #define PORT_VARIANT   &MACRO_CONFIG(Port_Config_, CONFIG_VARIANT_USED)
#endif

/* Bcan Timestamping related defines */
#define TST_CTRL_REG_ADDR   0x4007C0F0  /* TIMESTAMP_CONTROL_REGISTER */
#define TST_SOURCE_SEL_MASK 0x00000001  /* Timestamp 1 counter output is selected as timestamp module output */
#define TST_ENABLE_MASK     0x00000004  /* Timestamp module enable control */
#define STM7_BASE_ADDR      0x40228000  /* STM_7 base address */
#define STM7_ENABLE_MASK    0x00000001  /* STM_7 enable bit */
#define STMTS_REG_ADDR      0x4400C000  /* STM_TS register address */
#define STMTS_SEL_MASK      0x00008501  /* STM_TS mask to set presclarer to 133 */

static void Can_Enable_Timestamp(void);

void PlatformInit(void)
{
    #if (RM_PRECOMPILE_SUPPORT == STD_OFF)
        Rm_Init(&Rm_Config_VS_0);
    #else
        Rm_Init(NULL_PTR);
    #endif

    /* Configure S32G clocks */
    /* Enable LLCE partition */
    Mcu_Init(MCU_VARIANT);
    Mcu_InitClock(McuClockSettingConfig_0);
    while ( MCU_PLL_LOCKED != Mcu_GetPllStatus() )
    {
        /* Busy wait until the System PLL is locked */
    }
    Mcu_DistributePllClock();
    Mcu_SetMode(McuModeSettingConf_0);

#ifdef USE_PORT_HLD
    Port_Init(PORT_VARIANT);
#else
    Siul2_Port_Ip_Init(NUM_OF_CONFIGURED_PINS0, g_pin_mux_InitConfigArr0);
#endif

    OsIf_Init(NULL_PTR); /* enable system timer for timeout detection */

    /* Configurations for IRQ routing, priority and enable through Platform plugin. */
    Platform_Init(NULL_PTR);

    Can_Enable_Timestamp();

}

/*================================================================================================*/
/**
@brief         Enable Bcan timestamping
@details       Select timestamp source and enable timestamping
*/
/*================================================================================================*/
static void Can_Enable_Timestamp(void)
{
	/* Select timestamp source STM_7 and enable timestamp module in TIMESTAMP_CONTROL_REGISTER */
    Reg_Bit_Set32(TST_CTRL_REG_ADDR, TST_SOURCE_SEL_MASK | TST_ENABLE_MASK);

	/*start STM_7*/
	Reg_Bit_Set32(STM7_BASE_ADDR, STM7_ENABLE_MASK);

    /* Set STM Prescaler 133. - This shall offer 1ms ticks */
    Reg_Bit_Set32(STMTS_REG_ADDR, STMTS_SEL_MASK);
}


===== 文件 [52/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\src\can_common.c =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/


#ifndef ASR_NOT_USED
    #include "stubs.h"
    #include "Can_43_LLCE.h"
#endif

#include "can_common.h"


#ifdef __cplusplus
extern "C"
{
#endif

volatile uint8 fail = OFF;

#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    volatile uint32 last_RxIndication;
    volatile uint32 last_TxConfirmation;
#else
    volatile uint32 last_RxIndication[MAX_NUM_OF_CORES];
    volatile uint32 last_TxConfirmation[MAX_NUM_OF_CORES];
#endif

/* Circular permutation on data buffer. The reason of using this function is for checking data sent is the same with data received every time.  */
void Circular_Permutation(volatile uint8 *Payload, uint8 n)
{
    uint8 temp = Payload[0];

    for (uint8 Idx = 0; Idx < n - 1; Idx++)
    {
        Payload[Idx] = Payload[Idx + 1];
    }

    Payload[n - 1] = temp;
}

StatusType Check_Status(Can_PduType *CanMessage)
{
    uint32 can_counter = 0;
    uint8 u8Idx = 0;
    StatusType transmission_status = E_OK;

#if CAN_43_LLCE_MAX_PARTITIONS != 1U    
    uint32 u32CoreId = OsIf_GetCoreID();
#endif

    /* Wait for transmission and reception */
#if CAN_43_LLCE_MAX_PARTITIONS == 1U    
    while ( (( (Can_TxConfirmation - last_TxConfirmation) < 1) || ( (Can_RxIndication - last_RxIndication) < 1))  && (can_counter < TP_TIMEOUT) )
#else
    while ( (( (Can_TxConfirmation[u32CoreId] - last_TxConfirmation[u32CoreId]) < 1) || ( (Can_RxIndication[u32CoreId] - last_RxIndication[u32CoreId]) < 1))  && (can_counter < TP_TIMEOUT) )
#endif
    {
        can_counter++;
    }

    /* Check received Data length */
    if (Can_RxDlc != CanMessage->length)
    {
        transmission_status = E_NOT_OK;
    }

    /* Check integrity of received Data content */
    for (u8Idx = 0; u8Idx < CanMessage->length; u8Idx++)
    {
        if (Can_RxData[u8Idx] != CanMessage->sdu[u8Idx])
        {
            transmission_status = E_NOT_OK;
            break;
        }
    }

#if CAN_43_LLCE_MAX_PARTITIONS == 1U    
    last_RxIndication++;
    last_TxConfirmation++;
#else
    last_RxIndication[u32CoreId]++;
    last_TxConfirmation[u32CoreId]++;
#endif

    /* Shuffle the data in order to check sending/receiving of another frame */
    Circular_Permutation(CanMessage->sdu, CAN_FD_FRAME_LEN);

    return transmission_status;
}


===== 文件 [53/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\src\main.c =====
/*==================================================================================================
*
* Copyright 2018-2024 NXP  
*
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#include "stubs.h"
#include "Can_43_LLCE.h"
#include "PlatformInit.h"
#include "Llce_Firmware_Load.h"
#include "can_common.h"
#include "Core_Heartbeat.h"

#ifdef __cplusplus
extern "C"
{
#endif

#define MACRO_CONCAT(a,b) a##b
 #define CAN_VARIANT(var) MACRO_CONCAT(Can_43_LLCE_Config_, var)
#ifndef CONFIG_VARIANT_USED
 #define CAN_LLCE_VARIANT   NULL_PTR
#else
 #define CAN_LLCE_VARIANT   &CAN_VARIANT(CONFIG_VARIANT_USED)     
#endif


/* Autosar Configuration (see CAN2CAN_Project ) mapping is: idx 2 -> hwCtrl (BCAN) 14; idx 3 -> hwCtrl (BCAN)  15 */
#define LOGICAL_CONTROLLER15 3
#define LOGICAL_CONTROLLER14 2


void Can_Driver_Sample_Test(void)
{
    Can_ErrorStateType ErrorState;
    Std_ReturnType can_retval = E_NOT_OK;
    Can_PduType CanMessage;
    static uint8 can_fd_data[CAN_FD_FRAME_LEN];
    static uint8 can_std_data[CAN_STD_FRAME_LEN];
    uint16 u16MbGlobalIndex = 0U;

    Can_43_LLCE_Init(CAN_LLCE_VARIANT);

    /* Reset global flags and counters. */
    Can_CallBackSetUp();

    /*Initialize transmission data buffer with a standard Can frame.*/
    for (u16MbGlobalIndex = 0; u16MbGlobalIndex < CAN_STD_FRAME_LEN; u16MbGlobalIndex++)
    {
        can_std_data[u16MbGlobalIndex] = u16MbGlobalIndex;
    }

    /*Initialize transmission data buffer with a Can Fd frame.*/
    for (u16MbGlobalIndex = 0; u16MbGlobalIndex < CAN_FD_FRAME_LEN; u16MbGlobalIndex++)
    {
        can_fd_data[u16MbGlobalIndex] = u16MbGlobalIndex;
    }

    (void)can_retval;

/* In headless mode the call of Can_SetBaudrate() would cause a re-initialization of the CAN Controller 
   when it is in STARTED state and will return E_NOT_OK according to (SWS_Can_00256) */

    /* Start CONTROLLER0 */
#ifndef LLCE_USE_HEADLESS
    can_retval = Can_43_LLCE_SetBaudrate(CONTROLLER0, 1); /* Index 1 corresponds to a baudrate configuration of (500 kbps; 2000 kbps).See Tresos configuration*/
    ASSERT(E_OK == can_retval);
#endif
    can_retval = Can_43_LLCE_SetControllerMode(CONTROLLER0, CAN_CS_STARTED);
    ASSERT(E_OK == can_retval);
    can_retval = Can_43_LLCE_GetControllerErrorState(CONTROLLER0, &ErrorState);
    ASSERT(E_OK == can_retval);
    /* Start CONTROLLER1 */
#ifndef LLCE_USE_HEADLESS    
    can_retval = Can_43_LLCE_SetBaudrate(CONTROLLER1, 1); /* Index 1 corresponds to a baudrate configuration of (500 kbps; 2000 kbps).See Tresos configuration*/
    ASSERT(E_OK == can_retval);
#endif
    can_retval = Can_43_LLCE_SetControllerMode(CONTROLLER1, CAN_CS_STARTED);
    ASSERT(E_OK == can_retval);
    can_retval = Can_43_LLCE_GetControllerErrorState(CONTROLLER1, &ErrorState);
    ASSERT(E_OK == can_retval);

    /* Make sure that Tx Message Buffers used for host are less than 16. The difference between 16(max number of tx mb) 
    and tx Mb reserved or host will be used for routing on that channel. In this demo, that's channel 15.
    It has 4 MBs used for standard transmission, and 12 MBs used for routing frames to other channels. */

    /* Start CONTROLLER15 */
#ifndef LLCE_USE_HEADLESS
    can_retval = Can_43_LLCE_SetBaudrate(LOGICAL_CONTROLLER15, 0); /* Index 0 corresponds to a baudrate configuration of (250 kbps; 500 kbps). See Tresos configuration*/
    ASSERT(E_OK == can_retval);
#endif
    can_retval = Can_43_LLCE_SetControllerMode(LOGICAL_CONTROLLER15, CAN_CS_STARTED);
    ASSERT(E_OK == can_retval);
    /* Start CONTROLLER14 */
#ifndef LLCE_USE_HEADLESS
    can_retval = Can_43_LLCE_SetBaudrate(LOGICAL_CONTROLLER14, 0);  /* Index 0 corresponds to a baudrate configuration of (250 kbps; 500 kbps). See Tresos configuration*/
    ASSERT(E_OK == can_retval);
#endif
    can_retval = Can_43_LLCE_SetControllerMode(LOGICAL_CONTROLLER14, CAN_CS_STARTED);
    ASSERT(E_OK == can_retval);

    /* Send data */
    Can_TxConfirmation = 0;
    Can_RxIndication = 0;
    Can_RxDlc = 0;

    last_RxIndication = 0;
    last_TxConfirmation = 0;

    for (u16MbGlobalIndex = 0; u16MbGlobalIndex < ITER_NR; u16MbGlobalIndex++)
    {   
        Core_Heartbeat_Check();

        /* Set-up CAN frame data */
        CanMessage.length = CAN_FD_FRAME_LEN;
        CanMessage.sdu = can_fd_data;
        CanMessage.swPduHandle = u16MbGlobalIndex & 15; //%16

        /* Ctrl1 send frame to Ctrl0. This is an unrouted frame. In configuration, the HRH which receive frame with ID=1 has the routing option OFF */
        CanMessage.id = 1 | CAN_LPDU_FD_U32;
        can_retval = Can_43_LLCE_Write(CanHO_Config1_TX1, &CanMessage);
        ASSERT(E_OK == can_retval);

        /* Check status of transmission and reception */
        can_retval = Check_Status(&CanMessage);
        ASSERT(E_OK == can_retval);
        
        /* Ctrl 1 will send a message to ctrl 0, which does internal routing to channel 15, which will send the frame
        with id=15 to ctrl 14 on the external bus. Now, ctrl 0 will receive the frame on another HRH which receive frame with ID=15 and has the routing option ON,
        and the routing table indicates destination channel = 15 (configurable in Llce plugin)  */
        /* This is a routed frame */
        CanMessage.id = 15 | CAN_LPDU_FD_U32;
        can_retval = Can_43_LLCE_Write(CanHO_Config1_TX1, &CanMessage);
        ASSERT(E_OK == can_retval);
        
        /* Check status of transmission and reception */
        can_retval = Check_Status(&CanMessage);
        ASSERT(E_OK == can_retval);

        /* Now, Ctrl 1 will send a message with ID=888 to ctrl 0, which has a filter that accepts that ID. In the same time, it has an advanced feature reference
        (CanAdvancedFeature_3 in Llce_Af plugin, linked to the HRH CanHOH_Routing_RX0_IdRemap in Can_Llce plugin) which says "change the frame ID to 999 and forward
         it to destination channel 15, and don't deliver it to the host". It's also possible to send the frame also to the host core, to a logging core and to a list
         of multiple channel destinations simultaneously. */
        CanMessage.id = 888 | CAN_LPDU_FD_U32;
        can_retval = Can_43_LLCE_Write(CanHO_Config1_TX1, &CanMessage);
        ASSERT(E_OK == can_retval);
        
        /* Check status of transmission and reception */
        can_retval = Check_Status(&CanMessage);
        ASSERT(E_OK == can_retval);
        
        /* New Id value received */
        ASSERT((Can_RxId & ~CAN_LPDU_FD_U32) == 999);
        
        /* --- Routing with converting frame between CAN and CAN-FD --- */
        /* Set-up CAN frame data */
        CanMessage.length = CAN_STD_FRAME_LEN;
        CanMessage.sdu = can_std_data;

        /* Now, Ctrl 1 will send a message with ID=321 to ctrl 0, which has a filter (named CanHOH_CanFD2Can) which accepts that ID. In the same time, it is linked to an advanced feature 
            reference (CanAdvancedFeature_2) which says "change the frame format from CAN-FD to CAN and forward it to channel 15, and don't deliver it to the host" */
        CanMessage.id = 321 | CAN_LPDU_FD_U32;
        can_retval = Can_43_LLCE_Write(CanHO_Config1_TX1, &CanMessage);
        ASSERT(E_OK == can_retval);
        
        /* Check status of transmission and reception */
        can_retval = Check_Status(&CanMessage);
        ASSERT(E_OK == can_retval);

        /* Check received RxID frame */
        ASSERT(CAN_LPDU_FD_U32 != (Can_RxId & CAN_LPDU_FD_U32));
       
        /* Now, Ctrl 1 will send a message with ID=123 to ctrl 0, which has a filter (named CanHOH_Can2CanFD) which accepts that ID. In the same time, it is linked to an advanced feature 
            reference (CanAdvancedFeature_1) which says "change the frame format from CAN-FD to CAN and forward it to channel 15, and don't deliver it to the host" */
        CanMessage.id = 123;
        can_retval = Can_43_LLCE_Write(CanHO_Config1_TX1, &CanMessage);
        ASSERT(E_OK == can_retval);
        
        /* Check status of transmission and reception */
        can_retval = Check_Status(&CanMessage);
        ASSERT(E_OK == can_retval);

        /* Check received RxID frame */
        ASSERT(CAN_LPDU_FD_U32 == (Can_RxId & CAN_LPDU_FD_U32));
    }

	/* Check eventual errors configured to be reported in polling. This will trigger CanErrorNotification. */
	Can_43_LLCE_MainFunction_ErrorNotification();
    can_retval = Can_43_LLCE_SetControllerMode(CONTROLLER0, CAN_CS_STOPPED);
    ASSERT(E_OK == can_retval);
    can_retval = Can_43_LLCE_SetControllerMode(CONTROLLER1, CAN_CS_STOPPED);
    ASSERT(E_OK == can_retval);
    can_retval = Can_43_LLCE_SetControllerMode(LOGICAL_CONTROLLER14, CAN_CS_STOPPED);
    ASSERT(E_OK == can_retval);
    can_retval = Can_43_LLCE_SetControllerMode(LOGICAL_CONTROLLER15, CAN_CS_STOPPED);
    ASSERT(E_OK == can_retval);

    /* 5 writes was executed per iteration */
    ASSERT(5 * ITER_NR == Can_TxConfirmation);
    ASSERT(5 * ITER_NR == Can_RxIndication);

	Can_43_LLCE_DeInit();

}

int main(void)
{
    PlatformInit();
    
    Llce_Firmware_Load();
    Can_Driver_Sample_Test();

    while (1);
}

#ifdef __cplusplus
}
#endif


===== 文件 [54/112]: examples\S32DS\S32G3\Can_Llce_DS_Can2Can_S32G399A_M7\src\stubs.c =====
#include "stubs.h"

/* RX Specific variables used by stub functions */
volatile uint8 Can_RxData[CAN_FD_FRAME_LEN];
volatile uint8  Can_RxHandle;
volatile Can_IdType Can_RxId;
volatile uint8  Can_RxDlc;
volatile uint8  Can_ControllerId;

/* TX  Ok Transmission Specific variables */
volatile PduIdType Can_TxConfirmation_CanTxPduId;
volatile uint32   Can_Tx_No[16];

/* RX and TX specific counters */
#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    volatile uint32 Can_RxIndication;
    volatile uint32 Can_TxConfirmation;
#else
    volatile uint32 Can_RxIndication[MAX_NUM_OF_CORES];
    volatile uint32 Can_TxConfirmation[MAX_NUM_OF_CORES];
#endif

/* Bus Off Specific variables */
volatile uint8  Can_BusOffConfirmation;
volatile uint32 u32CustomCallbackExecutions = 0;

/*==================================================================================================
*                                      CAN stub functions implementation
==================================================================================================*/

void Can_CallBackSetUp(void)
{

#if CAN_43_LLCE_MAX_PARTITIONS != 1U
    uint8 u8Idx = 0U;
#endif
    
    /* Reset global flags. */
    Can_BusOffConfirmation = 0U;    
    Can_RxDlc = 0U;

#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    Can_TxConfirmation = 0U;
    Can_RxIndication = 0U;
#else
    for (u8Idx = 0U; u8Idx < MAX_NUM_OF_CORES; u8Idx++)
    {
        Can_TxConfirmation[u8Idx] = 0U;
        Can_RxIndication[u8Idx] = 0U; 
    }
#endif

}

void CanIf_RxIndication( const Can_HwType* Mailbox, const PduInfoType* PduInfoPtr )
{   
    /* Local variable */
    uint8 i = 0U;
#if CAN_43_LLCE_MAX_PARTITIONS != 1U
    uint32 u32CoreId = OsIf_GetCoreID();
#endif

    for (i = 0; i < PduInfoPtr->SduLength; i++)
    {
        /* Pointer to received L-SDU (payload) */
        Can_RxData[i] = PduInfoPtr->SduDataPtr[i];
    }

     for (i = PduInfoPtr->SduLength; i < CAN_FD_FRAME_LEN; i++)
    {
        /* Clean the rest of the payload if it's not a CAN FD frame*/
        Can_RxData[i] = 0;
    }

    /* Get the id of the corresponding hardware object: Range is 0 .. (total number of HRH-1) */
    Can_RxHandle = Mailbox->Hoh;
    /* standard/Extended Can ID of L-PDU  that has been successfully received */
    Can_RxId = Mailbox->CanId;
    /* Data length code (length of L0PDU payload) */
    Can_RxDlc = PduInfoPtr->SduLength;
    /*Get the id of Controller*/
    Can_ControllerId = Mailbox->ControllerId;

    /* Increment counter to record reception of a message */
#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    Can_RxIndication++;
#else
    Can_RxIndication[u32CoreId]++;
#endif
}

void CanIf_ControllerBusOff( uint8 Controller)
{   
    /* Increment counter to record bus off events */
    Can_BusOffConfirmation++;
    (void)Controller;
}

void CanIf_ControllerModeIndication( uint8 Controller, Can_ControllerStateType ControllerMode )
{
    (void)ControllerMode;
    (void)Controller;
}

void CanIf_TxConfirmation( PduIdType CanTxPduId)
{
#if CAN_43_LLCE_MAX_PARTITIONS != 1U
    uint32 u32CoreId = OsIf_GetCoreID();
#endif
    /* Increment counter to record transmission of a message */
#if CAN_43_LLCE_MAX_PARTITIONS == 1U
    Can_TxConfirmation++;
#else
    u32CoreId = OsIf_GetCoreID();
    Can_TxConfirmation[u32CoreId]++;
#endif
    /* Store the PDU ID for debug purposes */
    Can_TxConfirmation_CanTxPduId = CanTxPduId;
    Can_Tx_No[CanTxPduId]++;
}

void RxTimestampNotification(Can_HwHandleType Hoh, uint32 u32TimestampVal)
{
	(void)u32TimestampVal; /* timestamp for current received frame identified through Hoh */
	(void)Hoh;
}

void TxTimestampNotification(Can_HwHandleType Hoh, PduIdType CanTxPduId, uint32 u32TimestampVal)
{
	(void)u32TimestampVal; /* timestamp for current frame confirmation identified through Hoh and CanTxPduId (frameTag1 and frameTag2) */
	(void)Hoh;
	(void)CanTxPduId;
}

/* Callback for errors. This is triggered for errors configured in INTERRUPT or by calling MainFunction_Error */
void CanErrorNotification(uint8 u8CanIfCtrlId, Llce_Can_NotificationIdType eNotifId, volatile Llce_Can_ErrorNotifType* ErrorInfo)
{
	(void)u8CanIfCtrlId; 
	(void)eNotifId;
	(void)ErrorInfo;
}

void CanWriteCustomCallback(Can_HwHandleType Hoh, PduIdType CanTxPduId, uint32 u32TxMb)
{
	(void)Hoh; 
	(void)CanTxPduId;
	(void)u32TxMb;
}

void CanTxConfirmationCustomCallback(Can_HwHandleType Hoh, PduIdType CanTxPduId)
{
	(void)Hoh; 
	(void)CanTxPduId;
}


boolean Can_43_LLCE_RxCustomCallback(uint8 Hrh, Can_IdType CanId, uint8 CanDataLength, const uint8* CanSduPtr, uint32 u32RxMb)
{
    /* Suppress warnings for unused arguments */
    (void)Hrh; (void)CanId; (void)CanDataLength; (void)CanSduPtr; (void)u32RxMb;

    u32CustomCallbackExecutions++;

    /* Returns FALSE for even IDs */
    return (CanId & 0x01);
}


===== 文件 [55/112]: generate_PB\include\Can_43_LLCE_AFcfg.h =====
/**
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/
#ifndef CAN_AFCFG_H
#define CAN_AFCFG_H

#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Can_43_LLCE_Cfg.h"
[!NOCODE!]
[!INCLUDE "Can_43_LLCE_Macros.m"!][!//
[!ENDNOCODE!]
/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/
[!AUTOSPACING!][!//
[!VAR "AF_CNT"  = "num:i(0)"!][!//
[!VAR "C2C_CNT" = "num:i(0)"!][!//
[!VAR "C2E_CNT" = "num:i(0)"!][!//
[!VAR "ETH2CAN_BUF_CNT" = "num:i(0)"!][!//
[!VAR "ETH2CAN_BUF_SIZE" = "num:i(0)"!][!//
[!VAR "ETH2CAN_FORMAT_CNT" = "num:i(0)"!][!//
[!VAR "ETH2CAN_ENABLED" = "'STD_OFF'"!][!//
[!INDENT "0"!][!//
[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!][!//
    [!CALL "CountDestinations"!]
[!ENDSELECT!]
    [!WS "0"!]#define LLCE_CAN_ADVANCED_FEATURE_AF_CNT          [!"$AF_CNT"!]U
    [!WS "0"!]#define LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT     [!"$C2C_CNT"!]U
    [!WS "0"!]#define LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT     [!"$C2E_CNT"!]U
    [!WS "0"!]#define LLCE_CAN_ADVANCED_FEATURE_CAN2PCIE_CNT    [!"num:i($C2PCIE_CNT)"!]U
    [!WS "0"!]#define LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT   [!"num:i($C2O_CNT)"!]U

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral/Eth2Can"!]
    [!IF "Eth2CanEnable"!]
        [!VAR "ETH2CAN_ENABLED" = "'STD_ON'"!]
        [!VAR "ETH2CAN_BUF_CNT" = "num:i(Eth2CanBufferCount)"!]
        [!VAR "ETH2CAN_BUF_SIZE" = "num:i(Eth2CanBufferSize + (Eth2CanBufferSize mod 2))"!]
        [!VAR "ETH2CAN_FORMAT_CNT" = "num:i(count(Eth2CanEnabledFormats/*))"!]

        #define LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_CNT       [!"$ETH2CAN_BUF_CNT"!]U
        #define LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_SIZE      [!"$ETH2CAN_BUF_SIZE"!]U
        #define LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_FORMAT_CNT    [!"$ETH2CAN_FORMAT_CNT"!]U
    [!ENDIF!]
[!ENDSELECT!]
#define LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED       [!"$ETH2CAN_ENABLED"!]

#if(LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0)
/*
* @brief          CAN2ETH with external buffer
* @details        User shall use the external rings instead of internal ones.
*
*/
[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!]
[!IF "node:exists(CAN2ETHWithExternalRingBuffer) and (CAN2ETHWithExternalRingBuffer = 'true')"!]
#define LLCE_USE_EXTERNAL_RING_BUF (STD_ON)

#define LLCE_PFE_HIF_RING_CFG_LENGTH         128U /*number of BD*/

#define LLCE_PFE_BD_SIZE                     16U /*bytes*/
#define LLCE_PFE_BD_RING_SIZE                (LLCE_PFE_BD_SIZE * LLCE_PFE_HIF_RING_CFG_LENGTH)

#define LLCE_PFE_BD_WB_SIZE                  8U /*bytes*/
#define LLCE_PFE_BD_WB_RING_SIZE             (LLCE_PFE_BD_WB_SIZE * LLCE_PFE_HIF_RING_CFG_LENGTH)

#define LLCE_PFE_TX_HDR_EACH_SIZE            16U /*bytes*/
#define LLCE_PFE_TX_HDR_COUNT                LLCE_PFE_HIF_RING_CFG_LENGTH /*required by LLCE driver*/
#define LLCE_PFE_TX_HDR_SIZE                 (LLCE_PFE_TX_HDR_EACH_SIZE * LLCE_PFE_TX_HDR_COUNT)

#define LLCEIF_MIN_NUM_RX_BUF                72U
[!ELSE!]
    #define LLCE_USE_EXTERNAL_RING_BUF (STD_OFF)
[!ENDIF!]
[!ENDSELECT!]
#endif
/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/
[!IF "$AF_CNT > 0"!]
/* Configuration for advanced features */
extern const Llce_Can_AdvancedFeatureType Can_Llce_AdvancedFeature[LLCE_CAN_ADVANCED_FEATURE_AF_CNT];
[!ENDIF!]


[!IF "num:i($C2E_CNT + $C2PCIE_CNT) > 0"!]
/* Array with ETH and PCIE buffer addresses */
extern const uint8* pLlce_Can_AfBuffer[LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT];
[!ENDIF!]
[!IF "num:i($C2C_CNT + $C2E_CNT + $C2O_CNT) > 0"!]
/* Configuration for Routing Rules (CAN2CAN, CAN2ETH, CAN2OTHER)  */
extern const Can_Af_DestRulesType Llce_Can_AfRoutingTable[LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT];
    [!IF "num:i(count(as:modconf('Can')[CommonPublishedInformation/VendorApiInfix = 'LLCE']/CanGeneral/CanEcucPartitionRef/*)) != 0"!][!// Multicore
extern const uint32 Llce_Can_AfDestOwnerCoreId[LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT];
    [!ENDIF!][!// CanGeneral/CanEcucPartitionRef/* != 0"
[!ENDIF!]
    
[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral/Eth2Can"!]
    [!IF "Eth2CanEnable"!]
        VAR_ALIGN(extern uint8 Llce_Eth2Can_Buffer[LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_CNT][LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_SIZE], 2U)
        extern Llce_Can_EthEncapsulationFormat Llce_Eth2Can_EnabledFormats[LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_FORMAT_CNT];
    [!ENDIF!]
[!ENDSELECT!]

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!]
[!IF "node:exists(CAN2ETHWithExternalRingBuffer) and (CAN2ETHWithExternalRingBuffer = 'true')"!]
    extern volatile uint8 Llce_PfeIf_RxRing  [LLCE_PFE_BD_RING_SIZE];
    extern volatile uint8 Llce_PfeIf_RxWbRing[LLCE_PFE_BD_WB_RING_SIZE];
    extern volatile uint8 Llce_PfeIf_TxRing  [LLCE_PFE_BD_RING_SIZE];
    extern volatile uint8 Llce_PfeIf_TxWbRing[LLCE_PFE_BD_WB_RING_SIZE];
    extern volatile uint8 Llce_PfeIf_Hdr     [LLCE_PFE_TX_HDR_SIZE];
[!ENDIF!]
[!ENDSELECT!]
/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/

[!ENDINDENT!]
#ifdef __cplusplus
}
#endif

#endif /* CAN_AFCFG_H */

/** @} */


===== 文件 [56/112]: generate_PB\include\Can_43_LLCE_PBcfg.h =====
/**
*   @file    Can_43_LLCE_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBcfg.h
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Configuration settings generated by user settings.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifndef CAN_43_LLCE_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H
#define CAN_43_LLCE_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H

#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/*
* @file           Can_43_LLCE_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBcfg.h
*/
#define CAN_43_LLCE_VENDOR_ID_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H                  43
#define CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H           4
#define CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H           4
#define CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H        0
#define CAN_43_LLCE_SW_MAJOR_VERSION_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H           1
#define CAN_43_LLCE_SW_MINOR_VERSION_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H           0
#define CAN_43_LLCE_SW_PATCH_VERSION_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H           10

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/
[!NOCODE!]
[!IF "var:defined('postBuildVariant')"!]
    [!VAR "postBuildVariantNameUnderscore" = "concat('_',$postBuildVariant)"!]
    [!CODE!]#define CAN_43_LLCE_CONFIG_[!"$postBuildVariant"!]_PB \[!CR!][!ENDCODE!]
[!ELSE!]
    [!VAR "postBuildVariantNameUnderscore" = "string(null)"!]
    [!CODE!]#define CAN_43_LLCE_CONFIG_PB \[!CR!][!ENDCODE!]
[!ENDIF!]
[!VAR "CanConfiguredPartitions" = "num:i((count(CanGeneral/CanEcucPartitionRef/*)))"!]
[!INDENT "4"!]
[!IF "((IMPLEMENTATION_CONFIG_VARIANT != 'VariantPostBuild') and (variant:size()>1)) or (IMPLEMENTATION_CONFIG_VARIANT = 'VariantPostBuild')"!]
    [!IF "$CanConfiguredPartitions > 0"!]
        [!VAR "CanPartitionIdx" = "0"!]
        [!LOOP "CanGeneral/CanEcucPartitionRef/*"!]
            [!VAR "CanPartitionIdx" = "$CanPartitionIdx + 1"!]
            [!VAR "currentPartition" = "substring-after(substring-after(., 'EcuC/EcuC/'), '/')"!]
            [!CODE!]extern const Can_43_LLCE_ConfigType[!WS!]Can_43_LLCE_Config[!"$postBuildVariantNameUnderscore"!]_[!"$currentPartition"!]; [!IF "$CanPartitionIdx < $CanConfiguredPartitions"!]\[!ENDIF!][!CR!][!ENDCODE!]
        [!ENDLOOP!]
    [!ELSE!]
        [!CODE!]extern const Can_43_LLCE_ConfigType[!WS!]Can_43_LLCE_Config[!"$postBuildVariantNameUnderscore"!];[!ENDCODE!]
    [!ENDIF!]
[!ELSE!]
    [!IF "$CanConfiguredPartitions > 0"!]
        [!VAR "maxCoreDefConfig" = "num:i(1)"!]
        [!IF "CanGeneral/CanMulticoreSupport = 'true'"!]
            [!IF "node:exists(as:modconf('EcuC')[1]/EcucHardware/*/EcucCoreDefinition)"!]
                [!VAR "maxCoreDefConfig" = "num:i(count(as:modconf('EcuC')[1]/EcucHardware/*/EcucCoreDefinition/*))"!]
             [!ENDIF!]
        [!ENDIF!]
        [!VAR "CanPartitionIdx" = "0"!]
        [!LOOP "CanGeneral/CanEcucPartitionRef/*"!]
            [!VAR "CanPartitionIdx" = "$CanPartitionIdx + 1"!]
            [!VAR "currentPartition" = "substring-after(substring-after(., 'EcuC/EcuC/'), '/')"!]
            [!IF "var:defined('postBuildVariant')"!]
                [!CODE!]extern const Can_43_LLCE_ConfigType[!WS!]Can_43_LLCE_Config_[!"$currentPartition"!]; \[!CR!][!ENDCODE!]
            [!ELSE!]
                [!CODE!]extern const Can_43_LLCE_ConfigType[!WS!]Can_43_LLCE_Config[!"$postBuildVariantNameUnderscore"!]_[!"$currentPartition"!]; \[!CR!][!ENDCODE!]
            [!ENDIF!]
        [!ENDLOOP!]
        [!CODE!]extern const Can_43_LLCE_ConfigType* const Can_43_LLCE_Config[[!"$maxCoreDefConfig"!]];[!ENDCODE!]
    [!ELSE!]
        [!CODE!]extern const Can_43_LLCE_ConfigType Can_43_LLCE_Config;[!ENDCODE!]
    [!ENDIF!]

[!ENDIF!]
[!ENDINDENT!]
[!ENDNOCODE!]
#ifdef __cplusplus
}
#endif

#endif /* _CAN_43_LLCE_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H_ */

/** @} */


===== 文件 [57/112]: generate_PB\src\Can_43_LLCE_AFcfg.c =====
/**
*   @file    Can_43_LLCE_AFcfg.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Configuration Structures for PostBuild.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifdef __cplusplus
extern "C"{
#endif

/**
* @file           Can_43_LLCE_AFcfg.c
*/

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Llce_InterfaceCanTypes.h"
#include "Mcal.h"
#include "Can_43_LLCE_AFcfg.h"

[!AUTOSPACING!]
[!INDENT "0"!]
[!NOCODE!]
[!INCLUDE "Can_43_LLCE_Macros.m"!][!//
[!ENDNOCODE!]
/*==================================================================================================
*                                   GLOBAL FUNCTION PROTOTYPES
==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_VAR_CLEARED_16_NO_CACHEABLE
#include "Can_43_LLCE_MemMap.h"

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!]
[!IF "node:exists(CAN2ETHWithExternalRingBuffer) and (CAN2ETHWithExternalRingBuffer = 'true')"!]

VAR_ALIGN(volatile uint8 Llce_PfeIf_RxRing  [LLCE_PFE_BD_RING_SIZE]     , 16U)
VAR_ALIGN(volatile uint8 Llce_PfeIf_RxWbRing[LLCE_PFE_BD_WB_RING_SIZE]  , 16U)
VAR_ALIGN(volatile uint8 Llce_PfeIf_TxRing  [LLCE_PFE_BD_RING_SIZE]     , 16U)
VAR_ALIGN(volatile uint8 Llce_PfeIf_TxWbRing[LLCE_PFE_BD_WB_RING_SIZE]  , 16U)
VAR_ALIGN(volatile uint8 Llce_PfeIf_Hdr     [LLCE_PFE_TX_HDR_SIZE]      , 16U)

[!ENDIF!]
[!ENDSELECT!]

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!]
    [!VAR "C2E_CNT" = "num:i(count(Can2EthRoutingTable/*))"!]
    [!IF "$C2E_CNT > 0"!]
        /**
        * @brief Can2Eth buffers
        * @details Memory space to be used by the LLCE Can2Eth feature. All buffers must be 16-bit aligned.
        *
        */
        [!VAR "crtIdx" = "0"!]
        [!LOOP "Can2EthRoutingTable/*"!]
            VAR_ALIGN(static uint8 Llce_Can2Eth_Buffer[!"num:i($crtIdx)"!][[!"Can2EthBufferCount"!]][[!"num:i(Can2EthBufferSize + (Can2EthBufferSize mod 2))"!]] , 2U)
            [!VAR "crtIdx" = "$crtIdx+1"!]
        [!ENDLOOP!]
    [!ENDIF!]
[!ENDSELECT!]

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!]
    [!VAR "crtIdx" = "0"!]
    [!LOOP "Can2OtherRoutingTable/*"!]
      [!IF "RoutingType = 'PCIe'"!]
        VAR_ALIGN(static uint8 Llce_Can2Pcie_Buffer[!"num:i($crtIdx)"!][[!"BufferCount"!]][[!"num:i(BufferSize + (BufferSize mod 2))"!]] , 2U)
        [!VAR "crtIdx" = "$crtIdx+1"!]
      [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!]

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!][!//
[!VAR "C2C_CNT" = "num:i(count(Can2CanRoutingTable/*))"!][!//
[!VAR "C2E_CNT" = "num:i(count(Can2EthRoutingTable/*))"!][!//
[!//
[!CALL "CountDestinations"!][!//
[!IF "num:i($C2E_CNT + $C2PCIE_CNT) > 0"!][!//
const uint8* pLlce_Can_AfBuffer[LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT] = {
    [!LOOP "Can2CanRoutingTable/*"!][!//
        [!WS "4"!]NULL_PTR,
    [!ENDLOOP!][!//
    [!VAR "Idx" = "0"!][!//
    [!LOOP "Can2EthRoutingTable/*"!][!//
        [!WS "4"!]&Llce_Can2Eth_Buffer[!"num:i($Idx)"!][0][0],
        [!VAR "Idx" = "$Idx+1"!][!//
    [!ENDLOOP!][!//
    [!VAR "Idx" = "0"!][!//
    [!LOOP "Can2OtherRoutingTable/*"!][!//
        [!IF "RoutingType = 'PCIe'"!]
            [!WS "4"!]&Llce_Can2Pcie_Buffer[!"num:i($Idx)"!][0][0],
            [!VAR "Idx" = "$Idx+1"!][!//
        [!ENDIF!]
    [!ENDLOOP!][!//
};
[!ENDIF!][!//
[!ENDSELECT!]           

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral/Eth2Can"!]
    [!IF "Eth2CanEnable"!]
        /**
        * @brief Eth2Can RX buffers
        * @details Memory space to be used by PFE to store incoming Eth2Can frames. All buffers must be 16-bit aligned.
        */
        VAR_ALIGN( uint8 Llce_Eth2Can_Buffer[LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_CNT][LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_SIZE] , 2U)

        Llce_Can_EthEncapsulationFormat Llce_Eth2Can_EnabledFormats[LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_FORMAT_CNT] =
        {
            [!INDENT "4"!]
            [!LOOP "Eth2CanEnabledFormats/*"!]
                LLCE_AF_CAN2[!"."!][!IF "not(node:islast(.))"!], [!ENDIF!][!CR!]
            [!ENDLOOP!]
            [!ENDINDENT!]
        };
    [!ENDIF!]
[!ENDSELECT!]

#define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_16_NO_CACHEABLE
#include "Can_43_LLCE_MemMap.h"
[!ENDINDENT!]

/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_CONFIG_DATA_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!][!//
[!IF "num:i($C2C_CNT + $C2E_CNT + $C2O_CNT) > 0"!][!//
/* Configuration for Can2Can and Can2Eth and Can2Other routing */
const Can_Af_DestRulesType Llce_Can_AfRoutingTable[LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT] =
{
    [!CALL "GenerateAdvancedDestinations"!]    
};
[!//
    [!IF "num:i(count(as:modconf('Can')[CommonPublishedInformation/VendorApiInfix = 'LLCE']/CanGeneral/CanEcucPartitionRef/*)) != 0"!][!// Multicore
        [!/* Fantastic speed optimization: preload list of cores associated with each CanEcucPartitionRef. Then each destination can just look it up */!]
        [!VAR "GLOBAL_ECUCPARTITION_COREID" = "''"!]
        [!LOOP "as:modconf('EcuC')[1]/EcucPartitionCollection/*[1]/EcucPartition/*"!]
            [!VAR "EcucPartitionName" = "node:name(.)"!]
            [!VAR "CoreID" = "'0xFFFFFFFF'"!]
            [!LOOP "as:modconf('Os')[1]/OsApplication/*"!]
                [!IF "contains(node:value(./OsAppEcucPartitionRef), $EcucPartitionName)"!]
                    [!VAR "CoreID" = "node:value(node:ref(./OsApplicationCoreRef)/EcucCoreId)"!]
                    [!BREAK!]
                [!ENDIF!]
            [!ENDLOOP!]
            [!VAR "GLOBAL_ECUCPARTITION_COREID"   = "concat($GLOBAL_ECUCPARTITION_COREID,' ', num:i($CoreID))"!]
        [!ENDLOOP!]
[!// Generate array of destination - owner core mappings
const uint32 Llce_Can_AfDestOwnerCoreId[LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT] = {
        [!LOOP "Can2CanRoutingTable/*"!][!//
          [!CALL "PrintCrtDestOwnerPartition", "DestType" = "'Can2Can'"!][!//
        [!ENDLOOP!][!//
        [!LOOP "Can2EthRoutingTable/*"!][!//
          [!CALL "PrintCrtDestOwnerPartition", "DestType" = "'Can2Eth'"!][!//
        [!ENDLOOP!][!//
        [!LOOP "Can2OtherRoutingTable/*"!][!//
          [!CALL "PrintCrtDestOwnerPartition", "DestType" = "'Can2Other'"!][!//
        [!ENDLOOP!]
};
    [!ENDIF!][!// CanGeneral/CanEcucPartitionRef/* != 0"
[!ENDIF!][!// num:i($C2C_CNT + $C2E_CNT + $C2O_CNT) > 0
[!ENDSELECT!][!// as:modconf('Llce_Af')/LlceAfGeneral

#define CAN_43_LLCE_STOP_SEC_CONFIG_DATA_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/

#ifdef __cplusplus
}
#endif

/** @} */


===== 文件 [58/112]: generate_PB\src\Can_43_LLCE_Headless_Ip_PBcfg.c =====
/**
*   @file    Can_43_LLCE_HeadlessCfg.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Configuration Structures for PostBuild.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/
[!IF "not((node:exists(CanGeneral/CanLlceHeadlessModeUsed)) and (CanGeneral/CanLlceHeadlessModeUsed ='true'))"!]
    [!SKIPFILE!]
    /* Headless option not activated in driver. This file is not used */
[!ELSE!]
#ifdef __cplusplus
extern "C"{
#endif

#include "Llce_InterfaceCanTypes.h"
#include "Llce_Headless.h"

[!AUTOSPACING!]
[!INDENT "0"!]
[!NOCODE!]
[!INCLUDE "Can_43_LLCE_Macros.m"!][!//
[!ENDNOCODE!]

#define CAN_43_LLCE_MAX_IDMASK    (uint32)0x1FFFFFFFU
[!NOCODE!]
[!CALL "CountFilters"!]
[!VAR "AdvancedDestinationCount" = "count(as:modconf('Llce_Af')/LlceAfGeneral/CanAdvancedFeature/*)"!],
[!SELECT "CanConfigSet"!]
[!VAR "RegularFilterCount" = "0"!]
[!VAR "AdvancedFilterCount" = "0"!]
[!FOR "i" = "0" TO "15"!] 
    [!VAR "RegularFilterCount" = "num:i($RegularFilterCount) + num:i(text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($i+1)])"!]
    [!VAR "AdvancedFilterCount" = "num:i($AdvancedFilterCount) + num:i(text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($i+1)])"!]
[!ENDFOR!]
[!VAR "CONFIGURED_CONTROLLERS_COUNT" = "num:i(0)"!]
[!LOOP "CanController/*"!]
    [!IF "CanControllerActivation = 'true'"!]
        [!VAR "CONFIGURED_CONTROLLERS_COUNT"="num:i($CONFIGURED_CONTROLLERS_COUNT) + 1"!]
    [!ENDIF!]
[!ENDLOOP!]
[!ENDSELECT!]
[!ENDNOCODE!]

__attribute__((section(".llce_headlessconfig")))
volatile struct {
[!INDENT "2"!]
    Llce_Headless_Descriptor descriptor;
    Llce_Can_InitPlatformCmdType initPlatform;
    Llce_Can_InitCmdType initChannels[[!"num:i($CONFIGURED_CONTROLLERS_COUNT)"!]];
    Llce_Can_SetBaudrateCmdType baudrates[[!"num:i($CONFIGURED_CONTROLLERS_COUNT)"!]];
    [!IF "num:i($AdvancedDestinationCount) > 0"!]
    Can_Af_DestRulesType advancedDestinations[[!"num:i($AdvancedDestinationCount)"!]];
    [!ENDIF!]
    [!IF "num:i($RegularFilterCount) > 0"!]
    Llce_Can_ReceiveFilterType regularFilters[[!"num:i($RegularFilterCount)"!]];
    [!ENDIF!]
    [!IF "num:i($AdvancedFilterCount) > 0"!]
    Llce_Can_AdvancedFilterType advancedFilters[[!"num:i($AdvancedFilterCount)"!]];
    [!ENDIF!]
[!ENDINDENT!]
} LLCE__ALIGNED__PACKED Can_43_LLCE_HeadlessCfg = {
[!INDENT "2"!]
    /* Headless config descriptor */
    {
        [!INDENT "4"!]
        /** "Magic number" used to detect headless mode */
        LLCE_HEADLESSMODE_MAGICVALUE,
        /** Number of channels used */
        [!"num:i($CONFIGURED_CONTROLLERS_COUNT)"!]U, 
        /** Number of routing destinations used. Used for advanced filters */
        [!"num:i($AdvancedDestinationCount)"!]U, 
        /** Number of regular filters used */
        {[!//
        [!FOR "i" = "0" TO "15"!] 
            [!"num:i(text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($i+1)])"!]U, [!//
        [!ENDFOR!]
        },
        /** Number of advanced filters used */
        {[!//
        [!FOR "i" = "0" TO "15"!] 
            [!"num:i(text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($i+1)])"!]U, [!//
        [!ENDFOR!]
        }
        [!ENDINDENT!]
    },
    /* Platform init */
    {
        [!CALL "GeneratePlatformInit"!]
    },
    /* Channel init */
    {
        [!CALL "GenerateChannelInit", "SkipGenerateEmpty" = "1"!]
    },
    /* Default Baudrates */
    {
        [!FOR "crtBcan"="0" TO "15"!]
            [!LOOP "node:order(CanConfigSet/CanController/*,'node:value(CanControllerId)')"!][!//
                [!IF "substring-after(./CanHwChannel,'BCAN_') = $crtBcan "!]
                    [!VAR "CanClockSrc"="0"!]
                    [!IF "(node:exists(./CanCpuClockRef)) = 'true'"!]
                        [!VAR "CanClockSrc" = "node:ref(./CanCpuClockRef)/McuClockReferencePointFrequency"!]
                    [!ELSE!]
                        [!VAR "CanClockSrc" = "num:i(40000000)"!] [!/* Default Can Clock value 40 Mhz */!]
                    [!ENDIF!]
                    [!SELECT "node:ref(CanControllerDefaultBaudrate)"!]
                        [!CALL "GenerateBaudrate"!]
                    [!ENDSELECT!]
                [!ENDIF!]
            [!ENDLOOP!]
        [!ENDFOR!]
    },
    [!IF "num:i($AdvancedDestinationCount) > 0"!]
    /* Advanced destinations */
    {
        [!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!][!//
        [!CALL "GenerateAdvancedDestinations"!]    
        [!ENDSELECT!][!//
    },    
    [!ENDIF!]
    [!IF "num:i($RegularFilterCount) > 0"!]
    /* Regular filters */
    {
        [!FOR "crtCtrl" = "0" TO "15"!] 
        [!IF "text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
            [!VAR "crtFilter" = "0"!]
            [!INDENT "4"!]     
                [!LOOP "node:order(CanConfigSet/CanHardwareObject/*,'node:value(CanObjectId)')"!]
                    [!IF "(node:ref(CanControllerRef)/CanControllerActivation = 'true') and (CanObjectType = 'RECEIVE') and (substring-after(node:ref(CanControllerRef)/CanHwChannel,'BCAN_') = num:i($crtCtrl)) and not(node:exists(CanAdvancedFeature))"!]
                        { /* Regular filter [!"num:i($crtFilter)"!] for BCAN_[!"num:i($crtCtrl)"!] */
                        [!CALL "GenerateFilterConfig"!]
                        },
                        [!VAR "crtFilter" = "$crtFilter+1"!]
                    [!ENDIF!]
                [!ENDLOOP!]
            [!ENDINDENT!]
        [!ENDIF!]
        [!ENDFOR!]
    },
    [!ENDIF!]
    [!IF "num:i($AdvancedFilterCount) > 0"!]  
    /* Advanced filters */
    {
        [!FOR "crtCtrl" = "0" TO "15"!] 
        [!IF "text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
            [!VAR "crtFilter" = "0"!]
            [!INDENT "4"!]     
                [!LOOP "node:order(CanConfigSet/CanHardwareObject/*,'node:value(CanObjectId)')"!]
                    [!IF "(node:ref(CanControllerRef)/CanControllerActivation = 'true') and (CanObjectType = 'RECEIVE') and (substring-after(node:ref(CanControllerRef)/CanHwChannel,'BCAN_') = num:i($crtCtrl)) and node:exists(CanAdvancedFeature)"!]
                        [!CALL "GenerateAdvancedFilterConfig"!],
                        [!VAR "crtFilter" = "$crtFilter+1"!]
                    [!ENDIF!]
                [!ENDLOOP!]
            [!ENDINDENT!]
        [!ENDIF!]
        [!ENDFOR!]
    }
    [!ENDIF!]
[!ENDINDENT!]
};

[!ENDINDENT!]
#ifdef __cplusplus
}
#endif
[!ENDIF!]


===== 文件 [59/112]: generate_PB\src\Can_43_LLCE_PBcfg.c =====
/**
*   @file    Can_43_LLCE_PBcfg.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Configuration Structures for PostBuild.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifdef __cplusplus
extern "C"{
#endif

/*
   (CAN078) The code file structure shall not be defined within this specification completely.
            At this point it shall be pointed out that the code-file structure shall include the following file named: Can_43_LLCE_PBcfg.c.
            This file shall contain all post-build time configurable parameters.
   (CAN221) VariantPB: (Mix of precompile and Post Build multiple selectable configurable configurations.
*/
/**
* @file           Can_43_LLCE_PBcfg.c
*/

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Can_43_LLCE.h"
#include "Can_43_LLCE_IPW.h"

[!AUTOSPACING!]
[!//
[!NOCODE!][!//
[!INCLUDE "Can_43_LLCE_VersionCheck_Src_PB.m"!][!//
[!INCLUDE "Can_43_LLCE_Can_BaudRate_Inference.m"!][!//
[!INCLUDE "Can_43_LLCE_Macros.m"!][!//
[!ENDNOCODE!][!//
[!//
/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/*
* @file           Can_43_LLCE_PBcfg.c
*/
#define CAN_43_LLCE_VENDOR_ID_PBCFG_C                   43
#define CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_PBCFG_C     4
#define CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_PBCFG_C     4
#define CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_PBCFG_C  0
#define CAN_SW_MAJOR_VERSION_PBCFG_C             1
#define CAN_SW_MINOR_VERSION_PBCFG_C             0
#define CAN_SW_PATCH_VERSION_PBCFG_C             10

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/* Check if current file and Can configuration header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID_PBCFG_C != CAN_43_LLCE_VENDOR_ID)
#error "Can_43_LLCE.h and Can_43_LLCE_Cfg.h have different vendor ids"
#endif
/* Check if current file and CAN header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_PBCFG_C != CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_PBCFG_C != CAN_43_LLCE_AR_RELEASE_MINOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_PBCFG_C != CAN_43_LLCE_AR_RELEASE_REVISION_VERSION))
  #error "AutoSar Version Numbers of Can_43_LLCE_PBcfg.c and Can_43_LLCE.h are different"
#endif
/* Check if current file and CAN header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_PBCFG_C != CAN_43_LLCE_SW_MAJOR_VERSION) || \
     (CAN_SW_MINOR_VERSION_PBCFG_C != CAN_43_LLCE_SW_MINOR_VERSION) || \
     (CAN_SW_PATCH_VERSION_PBCFG_C != CAN_43_LLCE_SW_PATCH_VERSION))
       #error "Software Version Numbers of Can_43_LLCE_PBcfg.c and Can_43_LLCE.h are different"
#endif

/* Check if current file and Can_IPW configuration header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID_PBCFG_C  != CAN_IPW_VENDOR_ID_H)
#error "Can_43_LLCE.h and Can_43_LLCE_Cfg.h have different vendor ids"
#endif
/* Check if current file and CAN_IPW header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_PBCFG_C != CAN_IPW_AR_RELEASE_MAJOR_VERSION_H) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_PBCFG_C != CAN_IPW_AR_RELEASE_MINOR_VERSION_H) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_PBCFG_C != CAN_IPW_AR_RELEASE_REVISION_VERSION_H))
  #error "AutoSar Version Numbers of Can_43_LLCE_PBcfg.c and Can_43_LLCE_IPW.h are different"
#endif
/* Check if current file and CAN_IPW header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_PBCFG_C != CAN_IPW_SW_MAJOR_VERSION_H) || \
     (CAN_SW_MINOR_VERSION_PBCFG_C != CAN_IPW_SW_MINOR_VERSION_H) || \
     (CAN_SW_PATCH_VERSION_PBCFG_C != CAN_IPW_SW_PATCH_VERSION_H))
       #error "Software Version Numbers of Can_43_LLCE_PBcfg.c and Can_43_LLCE_IPW.h are different"
#endif

/*==================================================================================================
*                                   GLOBAL FUNCTION PROTOTYPES
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_CONFIG_DATA_UNSPECIFIED

#include "Can_43_LLCE_MemMap.h"


/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/
[!NOCODE!]
[!SELECT "CanConfigSet"!]
    [!VAR "CanEcucPartitionRefCount" = "num:i(count(./CanGeneral/CanEcucPartitionRef/*))"!]
    [!VAR "HOHCount" = "num:i(count(CanHardwareObject/*))"!]
    [!VAR "CustomProcessingFlag"="'false'"!]
    [!VAR "HRHcount" = "0"!]
    [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
            [!IF "(CanObjectType = 'RECEIVE')"!]
                [!VAR "HRHcount" = "$HRHcount + 1"!]
                [!IF "node:exists(CanAdvancedFeature)"!]
                    [!SELECT "node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)"!]
                        [!IF "CustomProcessingEnable = 'true'"!]
                            [!VAR "CustomProcessingFlag"="'true'"!]
                        [!ENDIF!]
                    [!ENDSELECT!]
                [!ENDIF!]
            [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!]

[!MACRO "GetCoreIdOfEcucPartition"!][!// Call with an CanEcucPartitionRef selected
    [!VAR "PartitionMatch" = "num:i(0)"!]
    [!VAR "CanEcucPartitionPath" = "node:value(.)"!]
    [!VAR "CanEcucPartitionName" = "substring-after(substring-after($CanEcucPartitionPath, 'EcuC/EcuC/'), '/')"!]
    [!LOOP "as:modconf('Os')[1]/OsApplication/*"!]
        [!IF "contains(node:value(./OsAppEcucPartitionRef), $CanEcucPartitionName)"!]
            [!VAR "CoreID" = "node:value(node:ref(./OsApplicationCoreRef)/EcucCoreId)"!]
            [!VAR "PartitionMatch" = "num:i(1)"!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$PartitionMatch = 1"!]    
        [!CODE!][!WS "4"!](uint32)[!"$CoreID"!]U /* Core ID */[!ENDCODE!]
    [!ELSE!]
        [!CODE!][!WS "4"!](uint32)0xFFFFFFFFU /* No core defined for selected partition */[!ENDCODE!]
    [!ENDIF!]        
[!ENDMACRO!]    
[!ENDNOCODE!]

[!CALL "CountFilters"!]
[!FOR "i" = "0" TO "15"!] 
    [!IF "text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($i+1)] > 0"!]
        [!WS "0"!]#define LLCE_CTRL_[!"num:i($i)"!]_MAX_RX_FILTERS      [!"num:i(text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($i+1)])"!]
    [!ENDIF!]
    [!IF "text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($i+1)] > 0"!]
        [!WS "0"!]#define LLCE_CTRL_[!"num:i($i)"!]_MAX_RXAF_FILTERS    [!"num:i(text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($i+1)])"!]
    [!ENDIF!]
[!ENDFOR!]

/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/
[!IF "$CustomProcessingFlag='true'"!]
VAR_ALIGN( static const uint32 CanFilterId2CustomIdx[[!"num:i($HRHcount)"!]], 32U)
[!ENDIF!]

/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/
/*==================================================================================================*/
/**
* @brief        Configuration parameters of the entire platform.
* @details      Config parameters needed for init platform command. E.g:
*               Maximum number of filters requested to be supported by filtering hardware. It is used to generate the data structures used for tracking used hardware filters.
*               Maximum number of RX hardware objects (for interrupt mode) of each channel needed to be reserved for RX buffering mechanism.
*               Maximum number of RX hardware objects of each polling class needed to be reserved for RX buffering mechanism.
*               Maximum number of TX confirmation buffers (for interrupt mode) of each channel needed to be reserved for TX confirmations buffering mechanism.
*               Maximum number of TX confirmation buffers of each polling class needed to be reserved for TX confirmations buffering mechanism.
*
*/
/*==================================================================================================*/
[!VAR "CanEcucPartitionRefCount" = "num:i(count(CanGeneral/CanEcucPartitionRef/*))"!]
[!IF "$CanEcucPartitionRefCount = 0"!][!// No CAN EcucPartition References
static const Llce_Can_InitPlatformCmdType PlatformInitConfig[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!] =
{   
[!CALL "GeneratePlatformInit"!]
};
[!ELSE!][!//
    [!LOOP "CanGeneral/CanEcucPartitionRef/*"!]
        [!VAR "crtEcucPartitionPath" = "node:value(.)"!]
        [!VAR "CanEcucPartitionName" = "substring-after(substring-after($crtEcucPartitionPath, 'EcuC/EcuC/'), '/')"!]
static const Llce_Can_InitPlatformCmdType PlatformInitConfig_[!"$CanEcucPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!] =
{   
        [!SELECT "../../.."!]
[!CALL "GeneratePlatformInit", "CanEcuCPartitionPath" = "$crtEcucPartitionPath"!]
};
        [!ENDSELECT!]

    [!ENDLOOP!]
[!ENDIF!]

/*==================================================================================================*/
/**
* @brief          Arrays of filters for LLCE
* @details        Lists of regular and advanced reception filters to be sent to LLCE, grouped by controller
*
*/
/*==================================================================================================*/
[!SELECT "CanConfigSet"!]
[!FOR "crtCtrl" = "0" TO "15"!] 
[!IF "text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
 [!WS "0"!]static Llce_Can_ReceiveFilterType Llce_Rx_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!] [ LLCE_CTRL_[!"num:i($crtCtrl)"!]_MAX_RX_FILTERS ] =
 [!VAR "crtFilter" = "0"!]
{   
[!INDENT "2"!]     
    [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
        [!IF "(node:ref(CanControllerRef)/CanControllerActivation = 'true') and (CanObjectType = 'RECEIVE') and (substring-after(node:ref(CanControllerRef)/CanHwChannel,'BCAN_') = num:i($crtCtrl)) and not(node:exists(CanAdvancedFeature))"!]
            [!IF "$crtFilter > 0"!],
            [!ENDIF!]
            { /* Regular filter [!"num:i($crtFilter)"!] for BCAN_[!"num:i($crtCtrl)"!] */
            [!CALL "GenerateFilterConfig"!]
            }[!//
            [!VAR "crtFilter" = "$crtFilter+1"!]
         [!ENDIF!]
    [!ENDLOOP!]
[!ENDINDENT!]

};
[!ENDIF!]
[!ENDFOR!]

/* List of regular filter arrays */
[!IF "$CanEcucPartitionRefCount = 0"!][!// No CAN EcucPartition References - dump filter count list
static Llce_Can_ReceiveFilterType * Llce_Rx_Filters_List[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][] =
{ 
    [!FOR "crtCtrl" = "0" TO "15"!] 
        [!IF "$crtCtrl > 0"!],
        [!ENDIF!]
        [!IF "text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
    Llce_Rx_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][!//
        [!ELSE!][!//
    NULL_PTR /* No regular filters for channel [!"$crtCtrl"!] */[!//
        [!ENDIF!]
    [!ENDFOR!]

};
[!ELSE!][!//
    [!LOOP "../CanGeneral/CanEcucPartitionRef/*"!]
        [!VAR "crtEcucPartitionPath" = "node:value(.)"!]
        [!VAR "CanEcucPartitionName" = "substring-after(substring-after($crtEcucPartitionPath, 'EcuC/EcuC/'), '/')"!]
static Llce_Can_ReceiveFilterType * Llce_Rx_Filters_List_[!"$CanEcucPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][] =
{ 
        [!FOR "crtCtrl" = "0" TO "15"!][!//
            [!IF "$crtCtrl > 0"!],
            [!ENDIF!][!//
                [!IF "text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!][!//
                        [!LOOP "node:order(../../../CanConfigSet/CanController/*,'node:value(CanControllerId)')"!][!//
                            [!IF "substring-after(./CanHwChannel,'BCAN_') = $crtCtrl"!][!//
                                [!IF "node:exists(./CanControllerEcucPartitionRef) and (node:value(./CanControllerEcucPartitionRef) = $crtEcucPartitionPath)"!][!//
    Llce_Rx_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][!//
                                [!ELSE!][!//
    NULL_PTR /* Channel [!"$crtCtrl"!] not in current partition*/[!//
                                [!ENDIF!]
                            [!ENDIF!]
                        [!ENDLOOP!]
                [!ELSE!][!//
    NULL_PTR /* No regular filters for channel [!"$crtCtrl"!] */[!//
                [!ENDIF!]
        [!ENDFOR!]

};

    [!ENDLOOP!]
[!ENDIF!]
   
[!FOR "crtCtrl" = "0" TO "15"!] 
[!IF "text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
 [!WS "0"!]static Llce_Can_AdvancedFilterType Llce_RxAf_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!] [ LLCE_CTRL_[!"num:i($crtCtrl)"!]_MAX_RXAF_FILTERS ] =
 [!VAR "crtFilter" = "0"!]
 {   
        [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
            [!IF "(node:ref(CanControllerRef)/CanControllerActivation = 'true') and (CanObjectType = 'RECEIVE') and (substring-after(node:ref(CanControllerRef)/CanHwChannel,'BCAN_') = num:i($crtCtrl)) and node:exists(CanAdvancedFeature)"!]
              [!IF "$crtFilter > 0"!],
              [!ENDIF!]
              [!CALL "GenerateAdvancedFilterConfig"!]
              [!VAR "crtFilter" = "$crtFilter+1"!]
            [!ENDIF!]
        [!ENDLOOP!]

 };

[!ENDIF!]
[!ENDFOR!]

[!IF "$CanEcucPartitionRefCount = 0"!][!// No CAN EcucPartition References - dump filter count list
static Llce_Can_AdvancedFilterType * Llce_RxAf_Filters_List[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][] =
{ 
    [!FOR "crtCtrl" = "0" TO "15"!] 
        [!IF "$crtCtrl > 0"!],
        [!ENDIF!]
        [!IF "text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
    Llce_RxAf_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][!//
        [!ELSE!][!//
    NULL_PTR /* No advanced filters for channel [!"$crtCtrl"!] */[!//
        [!ENDIF!]
    [!ENDFOR!]

};
[!ELSE!][!//
    [!LOOP "../CanGeneral/CanEcucPartitionRef/*"!]
        [!VAR "crtEcucPartitionPath" = "node:value(.)"!]
        [!VAR "CanEcucPartitionName" = "substring-after(substring-after($crtEcucPartitionPath, 'EcuC/EcuC/'), '/')"!]
static Llce_Can_AdvancedFilterType * Llce_RxAf_Filters_List_[!"$CanEcucPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][] =
{ 
        [!FOR "crtCtrl" = "0" TO "15"!][!//
            [!IF "$crtCtrl > 0"!],
            [!ENDIF!][!//
                [!IF "text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!][!//
                        [!LOOP "node:order(../../../CanConfigSet/CanController/*,'node:value(CanControllerId)')"!][!//
                            [!IF "substring-after(./CanHwChannel,'BCAN_') = $crtCtrl"!][!//
                                [!IF "node:exists(./CanControllerEcucPartitionRef) and (node:value(./CanControllerEcucPartitionRef) = $crtEcucPartitionPath)"!][!//
    Llce_RxAf_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][!//
                                [!ELSE!][!//
    NULL_PTR /* Channel [!"$crtCtrl"!] not in current partition*/[!//
                                [!ENDIF!]
                            [!ENDIF!]
                        [!ENDLOOP!]
                [!ELSE!][!//
    NULL_PTR /* No advanced filters for channel [!"$crtCtrl"!] */[!//
                [!ENDIF!]
        [!ENDFOR!]

};

    [!ENDLOOP!]
[!ENDIF!]

[!ENDSELECT!]    
/*==================================================================================================*/
/**
* @brief          Information about hardware objects.
* @details        (CAN100)Several TX hardware objects with unique HTHs may be configured. The CanIf module provides the HTH as parameter of the TX request. See Figure 7-2 for a possible configuration.
*
*/
/*==================================================================================================*/

[!SELECT "CanConfigSet"!]
    [!VAR "MAX_RX_LONGMB_COUNT" = "num:i(0)"!]
    [!VAR "MAX_RX_SHORTMB_COUNT" = "num:i(0)"!]
    [!VAR "MAX_TXMB_COUNT" = "num:i(0)"!]
    [!WS "0"!]static const Can_43_LLCE_HOHType MessageBufferConfigs_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][CAN_43_LLCE_MAXHOH_CONFIGURED] =
    [!WS "0"!]{
    [!VAR "END_COMMA"="0"!]
    [!VAR "MASK_COUNT"="num:i(count(CanHardwareObject/*))"!]
    [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
        [!VAR "END_COMMA"="$END_COMMA + 1"!]
                [!WS "4"!]/* [!"@name"!] Message Buffer [!"@index"!] on Can Controller [!"num:i(node:ref(CanControllerRef)/CanControllerId)"!] */
                [!WS "4"!]{
                [!INDENT "8"!]
                [!IF "CanObjectType = 'RECEIVE'"!]
                    [!IF "node:exists(CanAdvancedFeature/CanAdvancedFeatureRef)"!]
                        CAN_43_LLCE_RECEIVE_AF, /* Object Type */
                    [!ELSE!]        
                        CAN_43_LLCE_RECEIVE,  /* Object Type */
                    [!ENDIF!]
                    [!IF "node:exists('CanObjectPayloadLength') and (CanObjectPayloadLength='CAN_OBJECT_PL_8')"!]
                        [!VAR "MAX_RX_SHORTMB_COUNT"="num:i($MAX_RX_SHORTMB_COUNT) + num:i(CanHwObjectCount)"!]
                    [!ELSE!]
                        [!VAR "MAX_RX_LONGMB_COUNT"="num:i($MAX_RX_LONGMB_COUNT) + num:i(CanHwObjectCount)"!]
                    [!ENDIF!]

                [!ELSE!]
                        CAN_43_LLCE_TRANSMIT,  /* Object Type */
                    [!VAR "MAX_TXMB_COUNT"="num:i($MAX_TXMB_COUNT) + num:i(CanHwObjectCount)"!]
                [!ENDIF!]
                [!IF " (node:exists(CanHwObjectCount))"!]
                    (uint16)[!"num:inttohex(CanHwObjectCount)"!], /* MBCount */
                [!ELSE!]
                    (uint16)1U, /* MBCount */
                [!ENDIF!]
                    (uint8)[!"num:i(node:ref(CanControllerRef)/CanControllerId)"!]U, /* ControllerId  - based on the order from CanController list */
                [!IF " (node:exists(CanFdPaddingValue)) and (node:exists(../../../CanConfigSet/CanController/*/CanControllerBaudrateConfig/*/CanControllerFdBaudrateConfig)) and (node:fallback(CanObjectType,'TRANSMIT') = 'TRANSMIT')"!]
                    (uint8)[!"num:inttohex(CanFdPaddingValue)"!], /**< @brief Padding value for MB > 8 bytes */
                [!ELSE!]
                    (uint8)0U, /**< @brief Padding value for MB > 8 bytes */
                [!ENDIF!]
                [!IF "CanObjectType = 'TRANSMIT'"!]
                    /* Read/Write period reference used when polling mode is selected for this HTH */
                    [!IF "node:refexists(CanMainFunctionRWPeriodRef) and (((node:ref(CanControllerRef)/CanTxProcessing = 'MIXED') and (CanHardwareObjectUsesPolling = 'true')) or (((node:ref(CanControllerRef)/CanTxProcessing = 'POLLING'))))"!]
                        [!SELECT "node:ref(CanMainFunctionRWPeriodRef)"!]
                            (uint8)[!"@index"!]U,    /* HTH reference is from [!"node:name(.)"!]. */
                            (uint8)[!"num:i(AckInterface)"!],   /* Ack reported through this interface . */
                        [!ENDSELECT!]
                    [!ELSE!]
                        LLCE_CAN_REFERENCE_NOT_USED,   /* HTH configured for interrupt mode, reference not used.*/
                        [!WS "8"!][!CALL "GetRWDestInterfaceFromHOH"!], /* Ack is reported through this interface . */
                    [!ENDIF!][!//
                    [!IF "CanTxAddFrameMac = 'true'"!]
                        TRUE, /* Add MAC code and Key Handle for all frames transmitted using this HTH. */
                        (uint32)[!"num:inttohex(CanLlceKeyHandle)"!],
                    [!ELSE!]
                        FALSE, /* Add no MAC code for frames transmitted using this HTH. */
                        0u,    /* No key handler required if no MAC code is requested */
                    [!ENDIF!][!//
                [!ELSE!] [!// Receive object
                    [!IF "node:refexists(CanMainFunctionRWPeriodRef) and (((node:ref(CanControllerRef)/CanRxProcessing = 'MIXED') and (CanHardwareObjectUsesPolling = 'true')) or (((node:ref(CanControllerRef)/CanRxProcessing = 'POLLING'))))"!]
                        [!SELECT "node:ref(CanMainFunctionRWPeriodRef)"!]
                            (uint8)[!"@index"!]U,    /* HRH reference is from [!"node:name(.)"!] */
                            (uint8)[!"num:i(RxInterface)"!],   /* Rx is reported through this interface. */
                        [!ENDSELECT!]
                    [!ELSE!]
                        LLCE_CAN_REFERENCE_NOT_USED,   /* HRH configured for interrupt mode, reference not used. */
                        [!WS "2"!][!CALL "GetRWDestInterfaceFromHOH"!], /* Rx is reported through this interface . */
                    [!ENDIF!][!//
                    FALSE, /* Adding MAC code and key handler do not apply for receiving HRH. */
                    0u,
                [!ENDIF!][!//
                [!IF "(node:exists(CanTriggerTransmitEnable)) and (node:value(CanTriggerTransmitEnable) ='true')"!]
                    #if (CAN_43_LLCE_TRIGGER_TRANSMIT_EN == STD_ON)
                    (boolean)TRUE, /* Trigger Transmit enabled */
                    #endif
                [!ELSE!]
                    #if (CAN_43_LLCE_TRIGGER_TRANSMIT_EN == STD_ON)
                    (boolean)FALSE, /* Trigger Transmit disabled */
                    #endif
                [!ENDIF!]
                [!IF "(node:exists(Dummy_HRH)) and (node:value(Dummy_HRH) ='true')"!]
                    #if (CAN_43_LLCE_DUMMY_HRH_EN == STD_ON)
                    (boolean)TRUE /* Dummy HRH enabled */
                    #endif
                [!ELSE!]
                    #if (CAN_43_LLCE_DUMMY_HRH_EN == STD_ON)
                    (boolean)FALSE /* Dummy HRH disabled */
                    #endif
                [!ENDIF!]
                [!ENDINDENT!]
                [!WS "4"!]}[!CR!]
        [!IF "$END_COMMA < $MASK_COUNT"!][!//
            [!WS "0"!],
        [!ENDIF!]
        [!CR!]
    [!ENDLOOP!]
    [!WS "0"!]};
    [!IF "num:i($MAX_TXMB_COUNT) > 256"!][!//
        [!ERROR!]The hardware platform does not include enough message buffers in order to service all configured HTHs. Please decrease the number of HTHs and/or the number of MB used by each HTHs.[!ENDERROR!]
    [!ENDIF!]
    [!IF "num:i($MAX_RX_LONGMB_COUNT) > 1700"!][!//
        [!ERROR!]The hardware platform does not include enough long (64B) message buffers in order to service all configured HRHs. Please decrease the number of HRHs and/or the number of long MB used by each HRHs.[!ENDERROR!]
    [!ENDIF!]
    [!IF "num:i($MAX_RX_SHORTMB_COUNT) > 2396"!][!//
        [!ERROR!]The hardware platform does not include enough short (8B) message buffers in order to service all configured HRHs. Please decrease the number of HRHs and/or the number of short MB used by each HRHs.[!ENDERROR!]
    [!ENDIF!]
[!ENDSELECT!]

/*==================================================================================================*/
/**
* @brief          Configuration of Bcan controller
* @details        Configuration of Bcan controller
*
*/
[!SELECT "CanConfigSet"!]
    [!INDENT "0"!]
    [!VAR "CONFIGURED_CONTROLLERS_COUNT" = "num:i(0)"!]
    [!LOOP "CanController/*"!]
        [!IF "CanControllerActivation = 'true'"!]
            [!VAR "CONFIGURED_CONTROLLERS_COUNT"="num:i($CONFIGURED_CONTROLLERS_COUNT) + 1"!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!LOOP "CanController/*"!]
        [!VAR "CanClockSrc"="0"!]
        [!IF "(node:exists(./CanCpuClockRef)) = 'true'"!]
            [!VAR "CanClockSrc" = "node:ref(./CanCpuClockRef)/McuClockReferencePointFrequency"!]
        [!ELSE!]
            [!VAR "CanClockSrc" = "num:i(40000000)"!] [!/* Default Can Clock value 40 Mhz */!]
        [!ENDIF!]
        [!VAR "MASK_COUNT2"="num:i(count(CanControllerBaudrateConfig/*))"!]
        [!VAR "END_COMMA2"="0"!]
        static const Can_43_LLCE_ControllerBaudrateConfigType ControllerBaudrateCfgSet_PB_[!"CanControllerId"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][CAN_43_LLCE_MAX_BAUDRATE_FC_[!"substring-after(CanHwChannel,'BCAN_')"!]_[!"@index"!]] =
        {
        [!LOOP "CanControllerBaudrateConfig/*"!]
            [!WS "4"!]{
            [!CALL "GenerateBaudrate"!]
            #if (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON)
            [!WS "8"!](uint16)[!"CanControllerBaudRateConfigID"!]
            #endif
            [!WS "4"!]}
            [!VAR "END_COMMA2"="$END_COMMA2 + 1"!]
            [!IF "$END_COMMA2 < $MASK_COUNT2"!]
                ,
            [!ENDIF!]
            [!CR!]
        [!ENDLOOP!]
        };
    [!ENDLOOP!]
    [!ENDINDENT!]
[!ENDSELECT!]

/*==================================================================================================*/
/**
* @brief          LLCE Per-channel Init 
* @details        Information needed to initialize each LLCE channel
*
*/

[!IF "$CanEcucPartitionRefCount = 0"!][!// No CAN EcucPartition References
static const Llce_Can_InitCmdType ControllerInit[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][LLCE_CAN_CONFIG_MAXCTRL_COUNT] =
{
[!CALL "GenerateChannelInit"!]
};
[!ELSE!][!//
    [!LOOP "CanGeneral/CanEcucPartitionRef/*"!]
        [!VAR "crtEcucPartitionPath" = "node:value(.)"!]
        [!VAR "CanEcucPartitionName" = "substring-after(substring-after($crtEcucPartitionPath, 'EcuC/EcuC/'), '/')"!]
static const Llce_Can_InitCmdType ControllerInit_[!"$CanEcucPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][LLCE_CAN_CONFIG_MAXCTRL_COUNT] =
{   
        [!SELECT "../../.."!]
[!CALL "GenerateChannelInit", "CanEcuCPartitionPath" = "$crtEcucPartitionPath"!]
};
        [!ENDSELECT!]

    [!ENDLOOP!]
[!ENDIF!]

/*==================================================================================================*/
/**
* @brief          Description of individual Bcan controllers on chip
* @details        Description of individual Bcan controllers on chip
*
*/

[!SELECT "CanConfigSet"!]
    [!WS "0"!]static const Can_43_LLCE_ControllerDescriptorType ControllerDescriptors_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][CAN_43_LLCE_MAXCTRL_CONFIGURED] =
    [!WS "0"!]{
    [!VAR "MASK_COUNT4"="num:i(count(CanController/*))"!]
    [!VAR "END_COMMA4"="0"!]
    [!VAR "CanGeneralPath" = "as:path(../CanGeneral, true())"!]
    [!LOOP "node:order(CanController/*,'node:value(CanControllerId)')"!]
        [!WS "4"!]/* ControllerDescriptor of CanController_[!"node:value(CanControllerId)"!]*/
        [!WS "4"!]{
                    [!INDENT "8"!]
                    [!IF "CanControllerActivation = 'true'"!]
                        /* No. of BaudRate configured for current controller - u8MaxBaudRateCount */
                        (uint8)[!"num:i(count(CanControllerBaudrateConfig/*))"!]U,
                        [!IF "not(contains(node:path(node:ref(CanControllerDefaultBaudrate)),node:path(CanControllerBaudrateConfig)))"!]
                            [!ERROR!]
                                Please select CanControllerDefaultBaudrate from the "[!"substring-after(node:path(CanControllerBaudrateConfig),'ELEMENTS/')"!]" container.
                            [!ENDERROR!]
                        [!ENDIF!]
                        /* Default BaudRate configured for current controller - u8DefaultBaudRateIndex */
                        (uint8)[!"num:i(node:ref(CanControllerDefaultBaudrate)/@index)"!]U,
                        /* pControllerBaudrateConfigsPtr - pControllerBaudrateConfigsPtr*/
                        ControllerBaudrateCfgSet_PB_[!"CanControllerId"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
                        /* u32CoreId */ 
                        [!IF "node:exists(./CanControllerEcucPartitionRef)"!]
                            [!SELECT "./CanControllerEcucPartitionRef"!]
                            [!CALL "GetCoreIdOfEcucPartition"!],[!CR!]
                            [!ENDSELECT!] 
                        [!ELSE!]        
                            0xFFFFFFFFU, /* No partition selected */
                        [!ENDIF!]
                        /* Can Controller Offset on chip: Can_A=offset 0, Can_B=offset 1, .. -u8ControllerOffset */
                        (uint8)[!"substring-after(CanHwChannel,'BCAN_')"!]
                    [!ELSE!]
                        /* No. of BaudRate configured for current controller - u8MaxBaudRateCount */
                        (uint8)0U,
                        /* Default BaudRate configured for current controller */
                        (uint8)0U,
                        /* pControllerBaudrateConfigsPtr */
                        ControllerBaudrateCfgSet_PB_[!"CanControllerId"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
                        /* u32CoreId */ 
                        [!IF "node:exists(./CanControllerEcucPartitionRef)"!]
                            [!SELECT "./CanControllerEcucPartitionRef"!]
                            [!CALL "GetCoreIdOfEcucPartition"!],[!CR!]
                            [!ENDSELECT!] 
                        [!ELSE!]        
                            0xFFFFFFFFU, /* No partition selected */
                        [!ENDIF!]
                        /* Can Controller Offset on chip: Can_A=offset 0, Can_B=offset 1, .. -u8ControllerOffset */
                        (uint8)LLCE_NULL_OFFSET_U8
                    [!ENDIF!]
                   [!ENDINDENT!]
        [!WS "4"!]}[!//
        [!VAR "END_COMMA4"="$END_COMMA4 + 1"!][!//
        [!IF "$END_COMMA4 < $MASK_COUNT4"!][!//
            [!WS "0"!], /* ControllerDescriptors CanController_[!"node:value(CanControllerId)"!] end */
        [!ENDIF!]
        [!CR!]
    [!ENDLOOP!]
    [!WS "0"!]};
[!ENDSELECT!]


[!SELECT "CanConfigSet"!]
    [!WS "0"!]static const Can_43_LLCE_HwControllerDescriptorType HwControllerDescriptors_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][LLCE_CAN_CONFIG_MAXCTRL_COUNT] =
    [!WS "0"!]{
    [!VAR "MASK_COUNT4"="15"!]
    [!VAR "END_COMMA4"="0"!]
    [!VAR "CanGeneralPath" = "as:path(../CanGeneral, true())"!]
    [!FOR "i" = "0" TO "$MASK_COUNT4"!][!//
        [!VAR "HwObjFound"="'false'"!]
        [!WS "4"!]/* ControllerDescriptor of HwCanController_[!"$i"!]*/
        [!WS "4"!]{
        [!LOOP "node:order(CanController/*,'node:value(CanControllerId)')"!][!//
            [!IF "substring-after(./CanHwChannel,'BCAN_') = $i "!]
                            [!INDENT "8"!]
                            [!IF "CanControllerActivation = 'true'"!]
                                /* ===== Controller Options for the driver ===== */
                                (uint32)(
                                [!IF "CanRxProcessing = 'INTERRUPT' or CanRxProcessing = 'MIXED'"!]
                                    LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32 | /* Rx select by interrupt */
                                [!ELSE!]
                                    /* RxPoll Enabled */
                                [!ENDIF!]
                                [!IF "CanTxProcessing = 'INTERRUPT' or CanTxProcessing = 'MIXED'"!]
                                    LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32 | /* Tx select by interrupt */
                                [!ELSE!]
                                    /* TxPoll Enabled */
                                [!ENDIF!]
                                [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                                    LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32 | /* BusOff select by interrupt */
                                [!ELSE!]
                                    /* BusOffPoll Enabled */
                                [!ENDIF!]
                                    0U [!/*dummy value, to avoid checks for '|' on each macro definition*/!]
                                ),
                                /* Can Controller ID in CanIf */
                                [!VAR "CanControllerPath" = "as:path(., true())"!]
                                [!VAR "AbstCanIfControllerID" = "0"!]
                                [!SELECT "as:modconf('CanIf')[1]"!]
                                    [!VAR "CanCanIfMatchCounter" = "0"!]
                                    [!LOOP "./CanIfCtrlDrvCfg/*"!]
                                        [!IF "node:value(./CanIfCtrlDrvNameRef) = $CanGeneralPath"!]
                                            [!VAR "CanCanIfMatchCounter" = "$CanCanIfMatchCounter + 1"!]
                                        [!ENDIF!]
                                        [!IF "$CanCanIfMatchCounter = 1"!]
                                            [!LOOP "./CanIfCtrlCfg/*"!]
                                                [!IF "node:value(./CanIfCtrlCanCtrlRef) = $CanControllerPath"!]
                                                    [!VAR "AbstCanIfControllerID" = "node:value(./CanIfCtrlId)"!]
                                                [!ENDIF!]
                                            [!ENDLOOP!]
                                        [!ENDIF!]
                                    [!ENDLOOP!]
                                [!ENDSELECT!]
                                    (uint8)[!"num:i($AbstCanIfControllerID)"!]U,
                                    [!CALL "GetRWDestInterfaceFromCtrl"!] /**< LLCE FIFO Interface used for interrupt processing */
                            [!ELSE!]
                                /* ===== Controller Options for the driver ===== */
                                (uint32)(0U),
                                /* Can Controller ID in CanIf */
                                (uint8)LLCE_NULL_OFFSET_U8,
                                /**< LLCE FIFO Interface ID used for interrupt processing of RX/ACK events. */
                                (uint8)LLCE_NULL_OFFSET_U8
                            [!ENDIF!]
                            [!VAR "HwObjFound"="'true'"!]
                            [!BREAK!]
                        [!ENDINDENT!]
            [!ENDIF!]
        [!ENDLOOP!]
        [!IF "$HwObjFound = 'false'"!][!//
            /* ===== Controller Options for the driver ===== */
            (uint32)(0U),
            /* Can Controller ID in CanIf */
            (uint8)LLCE_NULL_OFFSET_U8,
            /**< LLCE FIFO Interface ID used for interrupt processing of RX/ACK events. */
            (uint8)LLCE_NULL_OFFSET_U8
        [!ENDIF!]
        [!WS "4"!]}[!//
        [!IF "$i < $MASK_COUNT4"!][!//
            [!WS "0"!], /* ControllerDescriptors HwCanController_[!"$i"!] end */
        [!ENDIF!]
        [!CR!]
    [!ENDFOR!]
    [!WS "0"!]};
[!ENDSELECT!]


[!SELECT "CanConfigSet"!]
[!IF "$CustomProcessingFlag='true'"!]
static const uint32 CanFilterId2CustomIdx[[!"num:i($HRHcount)"!]] =
{
    [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
        [!IF "(CanObjectType = 'RECEIVE')"!]
            [!IF "node:exists(CanAdvancedFeature)"!]
                [!SELECT "node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)"!]
                    [!IF "CustomProcessingEnable = 'true'"!]
                        [!WS "4"!](uint32)[!"num:i(CustomProcessingIndex)"!]U,
                    [!ELSE!]
                        [!WS "4"!](uint32)0U, /* No custom index attached */
                    [!ENDIF!]
                [!ENDSELECT!]
            [!ELSE!]
                [!WS "4"!](uint32)0U, /* No custom index attached */
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
};
[!ENDIF!]
[!//
[!//
[!IF "node:exists(../CanGeneral/CanAuxFilterEnable)"!]
[!IF "node:value(../CanGeneral/CanAuxFilterEnable) = 'true'"!]
[!FOR "ctrl" = "0" TO "15"!] 
    [!IF "text:split($GLOBAL_AUX_RX_FILTERCOUNT_LIST)[num:i($ctrl+1)] > 0"!]
        [!VAR "comma_count" = "text:split($GLOBAL_AUX_RX_FILTERCOUNT_LIST)[num:i($ctrl+1)]"!]
        [!VAR "filter_count" = "num:i(0)"!]
        [!WS "0"!]static Llce_Can_AuxFilterType Llce_AuxRx_Filters_Ctrl[!"$ctrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!] [[!"text:split($GLOBAL_AUX_RX_FILTERCOUNT_LIST)[num:i($ctrl+1)]"!]] =
        [!WS "0"!]{
        [!LOOP "CanAuxFilter/*"!]
            [!IF "substring-after(node:ref(./CanControllerRef)/CanHwChannel,'BCAN_') = $ctrl"!]
                [!WS "2"!]{ /* Auxilliary filter [!"num:i($filter_count)"!] for BCAN_[!"$ctrl"!] */
                    [!INDENT "4"!] 
                    [!VAR "filter_count" = "$filter_count + num:i(1)"!]
                    [!IF "Filter_Type = 'RANGE'"!]
                        [!IF "num:i(./RangeEnd) > 2047"!]
                            (Can_IdType)([!"num:i(./RangeEnd)"!]U | LLCE_CAN_MB_IDE_U32), /* uIdMask = RangeEnd */
                        [!ELSE!]
                            (Can_IdType)[!"num:i(./RangeEnd)"!], /* uIdMask = RangeEnd */
                        [!ENDIF!]
                        [!IF "num:i(./RangeStart) > 2047"!]
                            (Can_IdType)([!"num:i(./RangeStart)"!]U | LLCE_CAN_MB_IDE_U32), /* MessageId = RangeStart*/
                        [!ELSE!]
                            (Can_IdType)[!"num:i(./RangeStart)"!], /* MessageId = RangeStart */
                        [!ENDIF!]                
                    [!ELSE!]
                        [!IF "(Filter_Type = 'EXACT_MATCH')"!]
                            (Can_IdType)((CAN_43_LLCE_MAX_IDMASK 
                        [!ELSE!]
                            (Can_IdType)((([!"num:inttohex(./CanHwFilterMask)"!]U & CAN_43_LLCE_MAX_IDMASK) [!//
                        [!ENDIF!][!//
                        | LLCE_CAN_MB_RTR_U32)[!//
                        [!IF "CanIdType != 'MIXED'"!] |[!WS "1"!] [!ELSE!] & ~[!ENDIF!] LLCE_CAN_MB_IDE_U32),  /* uIdMask */
                            (Can_IdType)(([!"num:inttohex(./CanHwFilterCode)"!]U & CAN_43_LLCE_MAX_IDMASK)[!IF "CanIdType = 'EXTENDED'"!] | LLCE_CAN_MB_IDE_U32[!ENDIF!]),   /* MessageId */
                    [!ENDIF!]
                    (uint16_t)[!"num:inttohex(./AuxSearchResult)"!], /* Auxilliary Search Result */
                    [!IF "Filter_Type = 'RANGE'"!]
                        LLCE_CAN_ENTRY_CFG_RANGED  /* Filter type */
                    [!ELSE!] 
                        [!IF "Filter_Type = 'MASK'"!]
                            LLCE_CAN_ENTRY_CFG_MASKED  /* Filter type */
                        [!ELSE!]
                            LLCE_CAN_ENTRY_EXACT_MATCH  /* Filter type */
                        [!ENDIF!] 
                    [!ENDIF!]
                    [!ENDINDENT!]
                    [!WS "2"!]}[!//
                    [!IF "num:i($comma_count) > 1"!],
                    [!ELSE!]

                    [!ENDIF!] 
                    [!VAR "comma_count" = "$comma_count - num:i(1)"!]
            [!ENDIF!]
        [!ENDLOOP!]
        [!WS "0"!]};

    [!ENDIF!]
[!ENDFOR!]

[!VAR "AUX_FILTERS_COUNT" = "num:i(count(CanAuxFilter/*))"!]
[!IF "$AUX_FILTERS_COUNT != num:i(0)"!]
/* Array containing maximum number of auxilliary filters per hardware controller */
static uint16 Llce_MaxAuxilliaryFilterCount[LLCE_CAN_CONFIG_MAXCTRL_COUNT] =
{[!//
[!FOR "i" = "0" TO "15"!] 
    [!WS "4"!](uint16)[!"text:split($GLOBAL_AUX_RX_FILTERCOUNT_LIST)[num:i($i+1)]"!]U[!//
    [!IF "$i < 15"!],
    [!ENDIF!]
[!ENDFOR!]
};

/* List of auxilliary filter arrays */
[!IF "$CanEcucPartitionRefCount = 0"!][!// No CAN EcucPartition References - dump filter count list
static Llce_Can_AuxFilterType * Llce_AuxRx_Filters_List[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][LLCE_CAN_CONFIG_MAXCTRL_COUNT] =
{ 
    [!FOR "crtCtrl" = "0" TO "15"!] 
        [!IF "$crtCtrl > 0"!],
        [!ENDIF!]
        [!IF "text:split($GLOBAL_AUX_RX_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
    Llce_AuxRx_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][!//
        [!ELSE!][!//
    NULL_PTR /* No filters for channel [!"$crtCtrl"!] */[!//
        [!ENDIF!]
    [!ENDFOR!]

};
[!ELSE!][!//
    [!LOOP "../CanGeneral/CanEcucPartitionRef/*"!]
        [!VAR "crtEcucPartitionPath" = "node:value(.)"!]
        [!VAR "CanEcucPartitionName" = "substring-after(substring-after($crtEcucPartitionPath, 'EcuC/EcuC/'), '/')"!]
static Llce_Can_AuxFilterType * Llce_AuxRx_Filters_List_[!"$CanEcucPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][LLCE_CAN_CONFIG_MAXCTRL_COUNT] =
{ 
    [!FOR "crtCtrl" = "0" TO "15"!][!//
        [!IF "$crtCtrl > 0"!],
        [!ENDIF!][!//
        [!IF "text:split($GLOBAL_AUX_RX_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
            [!LOOP "node:order(../../../CanConfigSet/CanController/*,'node:value(CanControllerId)')"!][!//
                [!IF "substring-after(./CanHwChannel,'BCAN_') = $crtCtrl"!][!//
                    [!IF "node:exists(./CanControllerEcucPartitionRef) and (node:value(./CanControllerEcucPartitionRef) = $crtEcucPartitionPath)"!][!//
Llce_AuxRx_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][!//
                    [!ELSE!][!//
NULL_PTR /* Channel [!"$crtCtrl"!] not in current partition*/[!//
                    [!ENDIF!]
                [!ENDIF!]
            [!ENDLOOP!]
        [!ELSE!][!//
NULL_PTR /* No aux filters for channel [!"$crtCtrl"!] */[!//
        [!ENDIF!]
    [!ENDFOR!]

};

    [!ENDLOOP!]
[!ENDIF!][!// $CanEcucPartitionRefCount = 0
[!ENDIF!][!// $AUX_FILTERS_COUNT != num:i(0)
[!ENDIF!][!// node:exists(../CanGeneral/CanAuxFilterEnable)
[!ENDIF!][!// node:value(../CanGeneral/CanAuxFilterEnable) = 'true'
[!ENDSELECT!]
/*==================================================================================================*/
/**
* @brief          Top level structure containing all Can driver configurations
* @details        Top level structure containing all Can driver configurations
*
*/[!//
[!// To be called with CanEcucPartitionRef selected for multicore
[!MACRO "GenerateTopConfig", "crtEcuCPartitionName", "pbVariantName", "defaultController"!]
const Can_43_LLCE_ConfigType Can_43_LLCE_Config[!"$pbVariantName"!][!"$crtEcuCPartitionName"!] =
[!WS "0"!]{
[!INDENT "4"!]
[!SELECT "as:modconf('Can')[CommonPublishedInformation/VendorApiInfix = 'LLCE']/CanGeneral"!][!// select CanGeneral even in multicore
[!IF "$crtEcuCPartitionName = ''"!][!VAR "hostInterface" = "node:value(HostInterface)"!][!ENDIF!][!// save this value for outside the select
    &PlatformInitConfig[!"$crtEcuCPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    ControllerInit[!"$crtEcuCPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    Llce_Rx_Filters_List[!"$crtEcuCPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    Llce_RxAf_Filters_List[!"$crtEcuCPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    [!IF "node:exists(CanAuxFilterEnable) and ($AUX_FILTERS_COUNT != num:i(0)) and (CanAuxFilterEnable = 'true')"!]
    Llce_AuxRx_Filters_List[!"$crtEcuCPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    Llce_MaxAuxilliaryFilterCount,
    [!ELSE!]
    NULL_PTR, /* There are no filters configured for the second rxlut */ 
    NULL_PTR,
    [!ENDIF!]
    MessageBufferConfigs_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    ControllerDescriptors_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    HwControllerDescriptors_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    [!IF "$CustomProcessingFlag = 'true'"!]
    CanFilterId2CustomIdx,
    [!ELSE!]
    NULL_PTR, /* No custom processing defined for any HRH */
    [!ENDIF!]
    [!IF "node:exists(CanLlceHeadlessModeUsed) and (node:value(CanLlceHeadlessModeUsed) = 'true')"!]
        [!IF "not(node:exists(CanLlceEnableHeadlessMode) and (node:value(CanLlceEnableHeadlessMode) = 'true'))"!]
            [!ERROR "To enable headless mode for this variant, also enable the global option"!]
        [!ENDIF!]
    (boolean)TRUE, /* LLCE started in Headless Mode */
    [!ELSE!]
    (boolean)FALSE, /* LLCE started normally */
    [!ENDIF!]
[!ENDSELECT!]
    [!IF "$crtEcuCPartitionName != ''"!][!CALL "GetCoreIdOfEcucPartition"!],[!ELSE!]0xFFFFFFFFU, /* No partition selected */[!ENDIF!][!CR!] 
    [!IF "$crtEcuCPartitionName != ''"!]LLCE_CAN_HIF[!"@index"!],[!ELSE!][!"$hostInterface"!],[!ENDIF!] /* LLCE HIF */ 
    [!"num:i($defaultController)"!]U /* Default controller */    
[!ENDINDENT!]
};
[!ENDMACRO!]

[!SELECT "CanConfigSet"!]
[!VAR "PBname" = "''"!]
[!VAR "crtDefaultController" = "0"!]
[!IF "((../IMPLEMENTATION_CONFIG_VARIANT = 'VariantPostBuild') or (variant:size() > 1))"!][!// VariantPostBuild or more than 1 configured variant
    [!IF "var:defined('postBuildVariant')"!]
        [!VAR "PBname" = "concat('_', $postBuildVariant)"!]
    [!ENDIF!]
[!ENDIF!]
[!//
[!IF "$CanEcucPartitionRefCount = 0"!][!// No CAN EcucPartition References
    [!LOOP "node:order(CanController/*,'node:value(CanControllerId)')"!][!//
        [!IF "CanControllerActivation = 'true'"!]
        [!VAR "crtDefaultController" = "node:value(CanControllerId)"!]
            [!BREAK!]
        [!ENDIF!]
    [!ENDLOOP!]    
    [!CALL "GenerateTopConfig", "pbVariantName" = "$PBname", "defaultController" = "$crtDefaultController"!]
[!ELSE!][!//
    [!LOOP "../CanGeneral/CanEcucPartitionRef/*"!]
        [!VAR "CanEcucPartitionName" = "concat('_', substring-after(substring-after(., 'EcuC/EcuC/'), '/'))"!]
        [!VAR "crtEcucPartitionPath" = "node:value(.)"!]
        [!LOOP "node:order(../../../CanConfigSet/CanController/*,'node:value(CanControllerId)')"!][!//
            [!IF "CanControllerActivation = 'true' and node:exists(./CanControllerEcucPartitionRef) and (node:value(./CanControllerEcucPartitionRef) = $crtEcucPartitionPath)"!][!//
                [!VAR "crtDefaultController" = "node:value(CanControllerId)"!]
                [!BREAK!]
            [!ENDIF!]
        [!ENDLOOP!]    
        [!CALL "GenerateTopConfig", "pbVariantName" = "$PBname", "crtEcuCPartitionName" = "$CanEcucPartitionName", "defaultController" = "$crtDefaultController"!]
    [!ENDLOOP!]
[!ENDIF!]
[!ENDSELECT!]

[!// Special case for PreCompile with multiple partitions
[!IF "(./IMPLEMENTATION_CONFIG_VARIANT != 'VariantPostBuild') and (variant:size() <= 1)"!]
    [!IF "$CanEcucPartitionRefCount != 0"!][!// Existing CAN EcucPartition References
        [!SELECT "as:modconf('EcuC')[1]"!]
            [!VAR "MaxCoreIdConfig" = "num:i(count(./EcucHardware/*[1]/EcucCoreDefinition/*))"!]
        [!ENDSELECT!]
    [!INDENT "0"!]        
    const Can_43_LLCE_ConfigType * const [!WS!]Can_43_LLCE_Config[[!"$MaxCoreIdConfig"!]U] =
    {
        [!VAR "coreIdx" = "0"!]
        [!LOOP "node:order(as:modconf('EcuC')[1]/EcucHardware/*[1]/EcucCoreDefinition/*, './EcucCoreId')"!]
            [!VAR "OsAppPart" = "''"!]
            [!VAR "coreIdx" = "$coreIdx + 1"!]
            [!VAR "CoreId" = "node:value(./EcucCoreId)"!]
            [!VAR "CanPartShortName" = "''"!]
            [!VAR "CanPartMatchCounter" = "0"!]
            [!LOOP "as:modconf('Os')[1]/OsApplication/*"!]
                [!IF "$CoreId = node:value(node:ref(./OsApplicationCoreRef)/EcucCoreId)"!]
                    [!VAR "OsAppPart" = "node:value(./OsAppEcucPartitionRef)"!]
                [!ENDIF!]
            [!ENDLOOP!]
            [!LOOP "as:modconf('Can')[CommonPublishedInformation/VendorApiInfix = 'LLCE']/CanGeneral/CanEcucPartitionRef/*"!]
                [!IF "$OsAppPart = node:value(.)"!]
                    [!VAR "CanPartMatchCounter" = "$CanPartMatchCounter + 1"!]
                    [!VAR "CanPartShortName" = "substring-after(substring-after(., 'EcuC/EcuC/'), '/')"!]
                [!ENDIF!]
            [!ENDLOOP!]
            [!WS "4"!][!IF "$CanPartMatchCounter = 1"!]&Can_43_LLCE_Config_[!"$CanPartShortName"!] [!ELSE!] NULL_PTR[!ENDIF!][!IF "$coreIdx < $MaxCoreIdConfig"!],[!ENDIF!][!CR!]
        [!ENDLOOP!]
    };
    [!ENDINDENT!]        
    [!ENDIF!]
[!ENDIF!]


/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/

#define CAN_43_LLCE_STOP_SEC_CONFIG_DATA_UNSPECIFIED

#include "Can_43_LLCE_MemMap.h"

#ifdef __cplusplus
}
#endif

/** @} */


===== 文件 [60/112]: generate_PC\include\Can_43_LLCE_Cfg.h =====
/**
*   @file    Can_43_LLCE_Cfg.h
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Configuration settings generated by user settings.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/
/*
@brief   (CAN023) The consistency of the configuration must be checked by the configuration tool(s).
@brief   (CAN022) The code configurator of the Can module is CAN controller specific.
         If the CAN controller is sited on-chip, the code generation tool for the Can module is Controller specific.
         If the CAN controller is an external device the generation tool must not be Controller specific.
@brief   (CAN024) The valid values that can be configured are hardware dependent.
         Therefore the rules and constraints can't be given in the standard.
         The configuration tool is responsible to do a static configuration checking, also regarding dependencies between modules (i.e. Port driver, MCU driver etc.)
*/
/*
* @file    Can_43_LLCE_Cfg.h
*/

#ifndef CAN_43_LLCE_CFG_H
#define CAN_43_LLCE_CFG_H

#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Std_Types.h"
#include "Soc_Ips.h"
#include "OsIf.h"

[!AUTOSPACING!]
[!INDENT "0"!]
[!IF "var:defined('postBuildVariant')"!]
    [!LOOP "variant:all()"!]
        #include "Can_43_LLCE_[!"."!]_PBcfg.h"
    [!ENDLOOP!]
[!ELSE!]
    #include "Can_43_LLCE_PBcfg.h"
[!ENDIF!]

[!NOCODE!][!//
[!INCLUDE "Can_43_LLCE_VersionCheck_Inc.m"!][!//
[!ENDNOCODE!][!//

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/*
* @file           Can_43_LLCE_Cfg.h
*/
#define CAN_43_LLCE_VENDOR_ID_CFG_H                     43
#define CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_CFG_H      4
#define CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_CFG_H      4
#define CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_CFG_H   0
#define CAN_43_LLCE_SW_MAJOR_VERSION_CFG_H              1
#define CAN_43_LLCE_SW_MINOR_VERSION_CFG_H              0
#define CAN_43_LLCE_SW_PATCH_VERSION_CFG_H              10

#ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
    /* Check if header file and Std_Types.h file are of the same Autosar version */
    #if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_CFG_H != STD_AR_RELEASE_MAJOR_VERSION) || \
         (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_CFG_H != STD_AR_RELEASE_MINOR_VERSION)    \
        )
        #error "AutoSar Version Numbers of Can_43_LLCE_Cfg.h and Std_Types.h are different"
    #endif

#endif

[!IF "var:defined('postBuildVariant')"!]
    [!LOOP "variant:all()"!]
        /* Check if source file and CAN_43_LLCE_.h configuration header file are of the same vendor */
        #if (CAN_43_LLCE_VENDOR_ID_[!"."!]_PBCFG_H != CAN_43_LLCE_VENDOR_ID_CFG_H)
            #error "CAN_43_LLCE_[!"."!]_PBcfg.h and CAN_43_LLCE_Cfg.h have different vendor IDs"
        #endif
         /* Check if header file and CAN_43_LLCE_.h configuration header file are of the same Autosar version */
        #if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_[!"."!]_PBCFG_H != CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_CFG_H) || \
         (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_[!"."!]_PBCFG_H != CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_CFG_H) || \
         (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_[!"."!]_PBCFG_H != CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_CFG_H))
        #error "AutoSar Version Numbers of CAN_43_LLCE_[!"."!]_PBcfg.h and CAN_43_LLCE_Cfg.h are different"
        #endif
        /* Check if header file and CAN_43_LLCE_.h configuration header file are of the same software version */
        #if ((CAN_43_LLCE_SW_MAJOR_VERSION_[!"."!]_PBCFG_H != CAN_43_LLCE_SW_MAJOR_VERSION_CFG_H) || \
         (CAN_43_LLCE_SW_MINOR_VERSION_[!"."!]_PBCFG_H != CAN_43_LLCE_SW_MINOR_VERSION_CFG_H) || \
         (CAN_43_LLCE_SW_PATCH_VERSION_[!"."!]_PBCFG_H != CAN_43_LLCE_SW_PATCH_VERSION_CFG_H))
        #error "Software Version Numbers of CAN_43_LLCE_[!"."!]_PBcfg.h and CAN_43_LLCE_Cfg.h are different"
        #endif
    [!ENDLOOP!]
[!ELSE!]
    /* Check if source file and CAN_43_LLCE_.h configuration header file are of the same vendor */
    #if (CAN_43_LLCE_VENDOR_ID_PBCFG_H != CAN_43_LLCE_VENDOR_ID_CFG_H)
     #error "CAN_43_LLCE_PBcfg.h and CAN_43_LLCE_Cfg.h have different vendor IDs"
    #endif
     /* Check if header file and CAN_43_LLCE_.h configuration header file are of the same Autosar version */
    #if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_PBCFG_H != CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_PBCFG_H != CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_PBCFG_H != CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_CFG_H))
    #error "AutoSar Version Numbers of CAN_43_LLCE_PBcfg.h and CAN_43_LLCE_Cfg.h are different"
    #endif
    /* Check if header file and CAN_43_LLCE_.h configuration header file are of the same software version */
    #if ((CAN_43_LLCE_SW_MAJOR_VERSION_PBCFG_H != CAN_43_LLCE_SW_MAJOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_SW_MINOR_VERSION_PBCFG_H != CAN_43_LLCE_SW_MINOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_SW_PATCH_VERSION_PBCFG_H != CAN_43_LLCE_SW_PATCH_VERSION_CFG_H))
    #error "Software Version Numbers of CAN_43_LLCE_PBcfg.h and CAN_43_LLCE_Cfg.h are different"
    #endif
[!ENDIF!]


/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/
/**
* @brief          Enable support for MAC generation and verification.
* @details        Enable support for MAC generation and verification.
*
*/
[!// Loop on all Configuration Sets
[!SELECT "CanConfigSet"!][!//
    [!VAR "MAC_SUPPORT" = "num:i(0)"!][!//
    [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!][!//
    [!IF "CanObjectType = 'TRANSMIT'"!][!//
        [!IF "CanTxAddFrameMac = 'true'"!][!//
            [!VAR "MAC_SUPPORT"="$MAC_SUPPORT + 1"!][!//
        [!ENDIF!][!//
    [!ELSE!] [!// Receive object
        [!IF "node:exists(CanAdvancedFeature/CanAdvancedFeatureRef) and node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)/AuthenticationFrameEnable = 'true'"!][!//
        [!VAR "MAC_SUPPORT"="$MAC_SUPPORT + 1"!]
        [!ENDIF!][!//
    [!ENDIF!][!//
    [!ENDLOOP!][!//
[!IF "num:i($MAC_SUPPORT) > 0"!][!//
#define CAN_43_LLCE_HSE_SUPPORT_ENABLE    (STD_ON)
[!ELSE!]
#define CAN_43_LLCE_HSE_SUPPORT_ENABLE    (STD_OFF)
[!ENDIF!]


[!VAR "AUX_FILTERS_COUNT" = "num:i(count(CanAuxFilter/*))"!]
[!VAR "GenerateCanAuxFilter" = "'false'"!]
[!IF "node:exists(../CanGeneral/CanAuxFilterEnable)"!]
    [!IF "($AUX_FILTERS_COUNT != num:i(0)) and (node:value(../CanGeneral/CanAuxFilterEnable) = 'true')"!]
        [!VAR "GenerateCanAuxFilter"="'true'"!]
    [!ENDIF!]
[!ENDIF!]

[!IF "$GenerateCanAuxFilter = 'true'"!]
#define RXLUT2_ENABLE  (STD_ON)
[!ELSE!]
#define RXLUT2_ENABLE  (STD_OFF) 
[!ENDIF!]
[!ENDSELECT!]




/**
* @brief          Implicit index value used by Full can hardware objects.
* @details        Implicit index value used by Full can hardware objects.
*
*/
#define CAN_43_LLCE_MAX_IDMASK    (Can_IdType)0x1FFFFFFFU

[!NOCODE!]
[!// Loop on all Configuration Sets
[!SELECT "CanConfigSet"!][!//
    [!VAR "ConfigSetIndex" = "0"!][!//
    [!LOOP "CanController/*"!][!//
    [!// Loop on all channels inside the same Configuration Set
        [!VAR "SavedIndex" = "CanControllerId"!][!//
        [!VAR "Name" = "@name"!][!//
        [!// Loop on all other Configuration Sets
        [!LOOP "../../../*[@index>$ConfigSetIndex]/CanController/*"!][!//
            [!IF "($Name = node:name(.))"!][!//
                [!IF "($SavedIndex != CanControllerId)"!][!//
                    [!// Error
                    [!ERROR!][!//
                        [!"$Name"!][!"'- Symbolic name for controller Ids can be repeated only if they have the same CanControllerId in each of the config set.'"!][!//
                    [!ENDERROR!][!//
                [!ENDIF!][!//
            [!ENDIF!][!//
        [!ENDLOOP!][!//     
    [!ENDLOOP!][!//
[!ENDSELECT!]
[!/* Check status of CanHwFilter and CanMainFunctionRWPeriodRef */!]
[!SELECT "CanConfigSet"!]
    [!LOOP "CanHardwareObject/*"!]
        [!IF "((((CanObjectType = 'TRANSMIT') and ((node:ref(CanControllerRef))/CanTxProcessing) = 'POLLING')  or
                ((CanObjectType = 'RECEIVE' ) and ((node:ref(CanControllerRef))/CanRxProcessing) = 'POLLING'))
                   and (not(node:refexists(CanMainFunctionRWPeriodRef))))"!]
            [!ERROR!]
            The "CanMainFunctionRWPeriodRef" must be enabled when user configure the Can controller operate in the Polling mode (both to transmission and reception)
            [!ENDERROR!]
        [!ENDIF!]
        [!IF "((CanObjectType = 'RECEIVE')) and (not(node:exists(CanHwFilter)))"!]
            [!ERROR!]
            The "CanHwFilter" of each HOH must be enabled when user configure HOH is receive.
            [!ENDERROR!]
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!]
[!ENDNOCODE!]
[!/* Check if two controllers have the same name in any ConfigSet */!]
[!VAR "OuterLoopCounter" = "0"!][!VAR "InnerLoopCounter" = "0"!]
[!LOOP "CanConfigSet/CanController/*"!]
    [!VAR "OuterLoopCounter" = "$OuterLoopCounter + 1"!]
    [!VAR "InnerLoopCounter" = "0"!]
    [!VAR "Matchcounter" = "0"!]
    [!VAR "Name" = "node:name(.)"!]
    [!LOOP "../../CanController/*"!]
        [!VAR "InnerLoopCounter" = "$InnerLoopCounter + 1"!]
        [!IF "$OuterLoopCounter >= $InnerLoopCounter"!]
            [!IF "($Name = node:name(.))"!]
                [!VAR "Matchcounter" = "$Matchcounter + 1"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$Matchcounter != 1"!]
        [!WARNING!] Some controllers have identical name. Should avoid this because of multiple generated DEFINEs with the same name![!ENDWARNING!]
    [!ENDIF!]
[!ENDLOOP!]

[!NOCODE!][!//
// Loop on all Configuration Sets to check if the symbolic names are duplicated between config sets
[!SELECT "CanConfigSet"!][!//
    [!VAR "ConfigSetIndex" = "0"!][!//
    // Loop on all channels inside the same Configuration Set
    [!LOOP "CanHardwareObject/*"!][!//
    [!VAR "SavedIndex" = "CanObjectId"!][!//
        [!VAR "Name" = "@name"!][!//
        // Loop on all other Configuration Sets
        [!LOOP "../../../*[@index>$ConfigSetIndex]/CanHardwareObject/*"!][!//
            [!IF "($Name = node:name(.))"!][!//
                [!IF "($SavedIndex != CanObjectId)"!][!//
                    // Error
                    [!ERROR!][!//
                        [!"$Name"!][!"'- Symbolic name for hardware object Ids can be repeated only if they have the same value for CanObjectId in each of the config set.'"!][!//
                    [!ENDERROR!][!//
                [!ENDIF!][!//
            [!ENDIF!][!//
        [!ENDLOOP!][!//     
    [!ENDLOOP!][!//
[!ENDSELECT!]
 
[!VAR "OuterLoopCounter" = "0"!][!VAR "InnerLoopCounter" = "0"!]
[!LOOP "CanConfigSet/CanHardwareObject/*"!]
    [!VAR "OuterLoopCounter" = "$OuterLoopCounter + 1"!]
    [!VAR "InnerLoopCounter" = "0"!]
    [!VAR "Matchcounter" = "0"!]
    [!VAR "Name" = "node:name(.)"!]
    [!LOOP "../../CanHardwareObject/*"!]
        [!VAR "InnerLoopCounter" = "$InnerLoopCounter + 1"!]
        [!IF "$OuterLoopCounter >= $InnerLoopCounter"!]
            [!IF "($Name = node:name(.))"!]
                [!VAR "Matchcounter" = "$Matchcounter + 1"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$Matchcounter != 1"!]
        [!WARNING!] Some MBs have identical name. Should avoid this because of multiple generated DEFINEs with the same name![!ENDWARNING!]
    [!ENDIF!]
[!ENDLOOP!]

[!SELECT "CanConfigSet"!]
    [!VAR "MaxObjectIdForReceiveHO" = "-1"!]
    [!LOOP "CanHardwareObject/*"!]
        [!IF "CanObjectType = 'RECEIVE'"!]
            [!IF "$MaxObjectIdForReceiveHO < CanObjectId"!]
                [!VAR "MaxObjectIdForReceiveHO" = "CanObjectId"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!LOOP "CanHardwareObject/*"!]
        [!IF "CanObjectType = 'TRANSMIT'"!]
            [!IF "$MaxObjectIdForReceiveHO >= CanObjectId"!]
                [!ERROR!]
                The HRH and HTH Ids are defined under two different name-spaces (Refer to CAN326).
                Example: HRH0-0, HRH1-1, HTH0-2, HTH1-3.
                The HRHs of all controllers are grouped before the HTHs of all controllers
                    (there must not be any HTH of any controller with an object ID lower than
                    that of any HRH configured for this driver).
                [!ENDERROR!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!]
[!ENDNOCODE!]


/*
* @brief          Symbolic names for CanObjectId
* @details        Symbolic names for CanObjectId maintained for compatibility with old testcases/applications 
*
*/
[!SELECT "CanConfigSet"!][!//
 [!LOOP "CanHardwareObject/*"!]
    [!IF "CanObjectType = 'RECEIVE'"!]
        #define [!WS "1"!][!"@name"!] [!WS "1"!][!"num:i(CanObjectId)"!]U /* RECEIVE object of Can Controller ID = [!"num:i(node:ref(CanControllerRef)/CanControllerId)"!] */
    [!ENDIF!]
[!ENDLOOP!]
[!ENDSELECT!]
[!SELECT "CanConfigSet"!][!//
[!LOOP "CanHardwareObject/*"!]
    [!IF "CanObjectType = 'TRANSMIT'"!]
        #define [!WS "1"!][!"@name"!] [!WS "1"!][!"num:i(CanObjectId)"!]U /* TRANSMIT object of Can Controller ID = [!"num:i(node:ref(CanControllerRef)/CanControllerId)"!] */
    [!ENDIF!]
[!ENDLOOP!]
[!ENDSELECT!]

/*
* @brief          Lpdu callout name
* @details        (CAN357_Conf) CanLPduReceiveCalloutFunction - This parameter sets the name of the LPDU callout.
*
*/
[!IF "node:exists(CanGeneral/CanLPduReceiveCalloutFunction) and (normalize-space(CanGeneral/CanLPduReceiveCalloutFunction) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_LPDU_NOTIFICATION_ENABLE  (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_LPDU_NOTIFICATION_ENABLE  (STD_OFF)
[!ENDIF!]

#define CAN_43_LLCE_LPDU_CALLOUT_EXTENSION [!WS "1"!][!IF "((node:exists(CanGeneral/LPDUCalloutExtension)) and (CanGeneral/LPDUCalloutExtension ='true'))"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

/*
* @brief          Callout function name for timestamp of received frames
*
*/
[!IF "node:exists(CanGeneral/RxTimestampNotification) and (normalize-space(CanGeneral/RxTimestampNotification) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_RX_TIMESTAMP  (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_RX_TIMESTAMP  (STD_OFF)
[!ENDIF!]

/*
* @brief          Callout function name for timestamp of frame confirmations
*
*/
[!IF "node:exists(CanGeneral/TxTimestampNotification) and (normalize-space(CanGeneral/TxTimestampNotification) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_ACK_TIMESTAMP  (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_ACK_TIMESTAMP  (STD_OFF)
[!ENDIF!]

/*
* @brief          Callback for frames received through customization filters
*
*/
[!IF "node:exists(CanGeneral/CanCustomRxFunction) and (normalize-space(CanGeneral/CanCustomRxFunction) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED  (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED  (STD_OFF)
[!ENDIF!]

/*
* @brief          Callback for each frame sent to LLCE firmware through Can_Write
*
*/
[!IF "node:exists(CanGeneral/CanWriteCustomCallback) and (normalize-space(CanGeneral/CanWriteCustomCallback) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_CUSTOM_WRITE_CALLBACK_USED  (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_CUSTOM_WRITE_CALLBACK_USED  (STD_OFF)
[!ENDIF!]

/*
* @brief          Callback for each TX Confirmation received from LLCE firmware.
*
*/
[!IF "node:exists(CanGeneral/CanTxConfirmationCustomCallback) and (normalize-space(CanGeneral/CanTxConfirmationCustomCallback) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_CUSTOM_CONFIRMATION_CALLBACK  (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_CUSTOM_CONFIRMATION_CALLBACK  (STD_OFF)
[!ENDIF!]


/*
* @brief          Callout function name for reporting errors.
*
*/
[!IF "node:exists(CanConfigSet/CanErrorReporting/CanErrorNotif) and (normalize-space(CanConfigSet/CanErrorReporting/CanErrorNotif) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_ERROR_NOTIF_ENABLE  (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_ERROR_NOTIF_ENABLE  (STD_OFF)
[!ENDIF!]

/*
* @brief          Extended identifiers.
* @details        Extended identifiers.
                   - (STD_ON)  - if at least one extended identifier is used.
                   - (STD_OFF) - if no extended identifiers are used at all
                  If no extended identifiers are used then the IDs and MASKs can be stored in uint16 rather than uint32.
*
*/

#define CAN_43_LLCE_SET_BAUDRATE_API [!WS "1"!][!IF "((node:exists(CanGeneral/CanSetBaudrateApi)) and (CanGeneral/CanSetBaudrateApi ='true'))"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

#define CAN_LLCE_USE_HEADLESSMODE [!WS "1"!][!IF "((node:exists(CanGeneral/CanLlceEnableHeadlessMode)) and (CanGeneral/CanLlceEnableHeadlessMode ='true'))"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

/** Report controllers started without waiting to synchronise on bus */
#define CAN_43_LLCE_CONTROLLER_START_NOSYNC [!WS "1"!][!IF "((node:exists(CanGeneral/CanLlceControllerStartNoSync)) and (CanGeneral/CanLlceControllerStartNoSync ='true'))"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

/*
* @brief          Switches the Development Error Detection and Notification ON or OFF.
* @details        (CAN028) Call the Development Error Tracer when DET is switched on and the Can module detects an error.
                  (CAN082) The detection of development errors is configurable (ON / OFF) at pre- compile time.
                  The switch CanDevErrorDetect (see chapter 10) shall activate or deactivate the detection of all development errors.
*
*/
#define CAN_43_LLCE_DEV_ERROR_DETECT [!WS "1"!][!IF "CanGeneral/CanDevErrorDetect = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

/*
* @brief          Switches between user mode and supervisor mode.
* @details        Switches between user mode and supervisor mode. Some peripherals, eg. sema42 require supervisor mode.
*
*/

[!IF "CanGeneral/CanEnableUserModeSupport = 'true'"!]
#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
#error MCAL_ENABLE_USER_MODE_SUPPORT must be defined when driver is configured in user mode
#endif
#define CAN_LLCE_ENABLE_USER_MODE_SUPPORT
[!ENDIF!]

/*
* @brief          Support for version info API
* @details        Switches the Can_43_LLCE_GetVersionInfo() API ON or OFF.
*
*/
#define CAN_43_LLCE_VERSION_INFO_API [!WS "1"!][!IF "CanGeneral/CanVersionInfoApi = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

/*
* @brief          Instance # of the driver - used for Det_ReportError().
* @details        Instance # of the driver - used for Det_ReportError().
*
*/
#define CAN_43_LLCE_INSTANCE [!WS "1"!][!"num:i(CanGeneral/CanIndex)"!]U

/*
* @brief          Enables the reporting to AUTOSAR modules. (e.g. CanIf, Det)
* @details        It's used for compatibility with DS, which can operate in non-ASR mode. 
*
*/
#ifndef AUTOSAR_COMPATIBLE_MODE
#define AUTOSAR_COMPATIBLE_MODE   (STD_ON)
#endif


    
/**
*   @brief      The definition used for guarding GetCoreID/Multicore
*/
#define CAN_43_LLCE_MULTICORE_ENABLED[!WS "4"!][!IF "num:i(count(CanGeneral/CanEcucPartitionRef/*)) > 0"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/**
*   @brief      The definition represent for number of ECUC partition configured.
*/
[!NOCODE!]
    [!VAR "maxCoreDefConfig" = "num:i(1)"!]
    [!IF "CanGeneral/CanMulticoreSupport = 'true'"!]
        [!IF "node:exists(as:modconf('EcuC')[1]/EcucHardware/*/EcucCoreDefinition)"!]
            [!VAR "maxCoreDefConfig" = "num:i(count(as:modconf('EcuC')[1]/EcucHardware/*/EcucCoreDefinition/*))"!]
        [!ENDIF!]
    [!ENDIF!]
[!ENDNOCODE!]
#define CAN_43_LLCE_MAX_PARTITIONS[!WS "4"!][!"$maxCoreDefConfig"!]U

/*
* @brief          The define in order to check the trigger transmit feature is enabled or disabled.
* @details        The define in order to check the trigger transmit feature is enabled or disabled.
*
*/
[!IF "num:i(count(CanConfigSet/CanHardwareObject/*[CanTriggerTransmitEnable = 'true'])) > 0"!]
    #define CAN_43_LLCE_TRIGGER_TRANSMIT_EN (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_TRIGGER_TRANSMIT_EN (STD_OFF)
[!ENDIF!]

/*
* @brief          The define in order to check the dummy hrh feature is enabled or disabled.
* @details        The define in order to check the dummy hrh transmit feature is enabled or disabled.
*
*/
[!IF "num:i(count(CanConfigSet/CanHardwareObject/*[Dummy_HRH = 'true'])) > 0"!]
    #define CAN_43_LLCE_DUMMY_HRH_EN (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_DUMMY_HRH_EN (STD_OFF)
[!ENDIF!]

/*123 Calculate the maximum number of HRH and HTH amd MBs from all config sets */
[!SELECT "CanConfigSet"!]
    [!VAR "HrhCount"="0"!]
    [!VAR "HthCount"="0"!]
    [!VAR "RxMbCount"="0"!]
    [!VAR "TxMbCount"="0"!]
    [!VAR "Can_First_HTH_Index" = "0"!]
    [!VAR "Can_Check_ExistHTH" = "0"!]
    [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]  
        [!IF "CanObjectType = 'RECEIVE'"!]
            [!VAR "HrhCount"="$HrhCount + 1"!]  
            [!IF "node:exists(CanHwObjectCount)"!]
                [!VAR "RxMbCount"="$RxMbCount + node:value(CanHwObjectCount)"!] 
            [!ELSE!]
                [!VAR "RxMbCount"="$RxMbCount + 1"!] 
            [!ENDIF!]                
        [!ELSE!]
            [!VAR "HthCount"="$HthCount + 1"!] 
            [!IF "node:exists(CanHwObjectCount)"!]
                [!VAR "TxMbCount"="$TxMbCount + node:value(CanHwObjectCount)"!] 
            [!ELSE!]
                [!VAR "TxMbCount"="$TxMbCount + 1"!] 
            [!ENDIF!] 
            [!IF "$Can_Check_ExistHTH = 0"!]
                [!VAR "Can_First_HTH_Index" = "CanObjectId"!]
                [!VAR "Can_Check_ExistHTH" = "1"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]

/*
* @brief          Maximum number of HRHs configured.
*
*/
#define CAN_43_LLCE_MAXHRH_CONFIGURED [!WS "1"!]
        [!IF "num:i($HrhCount) > 0"!]
             [!"num:i($HrhCount)"!]U
        [!ELSE!]
             1U
        [!ENDIF!] 

 /*
* @brief          Maximum number of HTHs configured.
*
*/       
#define CAN_43_LLCE_MAXHTH_CONFIGURED [!WS "1"!]
        [!IF "num:i($HthCount) > 0"!]
             [!"num:i($HthCount)"!]U
        [!ELSE!]
             1U
        [!ENDIF!] 

 /*
* @brief          Maximum number of HOHs configured.
*
*/       
#define CAN_43_LLCE_MAXHOH_CONFIGURED [!WS "1"!]
        (CAN_43_LLCE_MAXHRH_CONFIGURED [!WS "1"!] + CAN_43_LLCE_MAXHTH_CONFIGURED [!WS "1"!])

/*
* @brief          The index of the first HTH configured
*
*/  
#define CAN_43_LLCE_FIRST_HTH_CONFIGURED [!WS "1"!]
        [!IF "$Can_Check_ExistHTH = 0"!][!/* Unless it has any HTH, Can_First_HTH_Index will be equal Max MB count  */!]
            [!"num:i($HrhCount + $HthCount)"!]U
        [!ELSE!]
            [!"num:i($Can_First_HTH_Index)"!]U
        [!ENDIF!]

/*
* @brief          Maximum number of RXMBs configured.
*
*/  
#define CAN_43_LLCE_MAXRXMB_CONFIGURED [!WS "1"!]
    [!IF "num:i($RxMbCount) > 0"!]
        [!"num:i($RxMbCount)"!]U
    [!ELSE!]
        1U
    [!ENDIF!]

/*
* @brief          Maximum number of TXMBs configured.
*
*/ 
#define CAN_43_LLCE_MAXTXMB_CONFIGURED [!WS "1"!]
    [!IF "num:i($TxMbCount) > 0"!]
        [!"num:i($TxMbCount)"!]U
    [!ELSE!]
        1U
    [!ENDIF!] 
[!ENDSELECT!]


/*
* @brief          Maximum No. of controllers Configured
* @details      Maximum No. of controllers Configured
*
*/
[!NOCODE!]
[!VAR "ctrl_no" = "0"!]
[!SELECT "CanConfigSet"!]
    [!VAR "ctrl_no" = "num:i(count(CanController/*))"!] 
[!ENDSELECT!]
[!ENDNOCODE!]
#define CAN_43_LLCE_MAXCTRL_CONFIGURED [!WS "1"!][!"$ctrl_no"!]U

/**
* @brief          Hardware events detected by an interrupt or by polling
* @details        (CAN099) The hardware events may be detected by an interrupt or by polling status flags of the hardware objects.
*                 The configuration possibilities regarding polling is hardware dependent (i.e. which events can be polled, which events need to be polled), and not restricted by this standard.
*                 (CAN007)It shall be possible to configure the driver such that no interrupts at all are used (complete polling).
*
*/
[!NOCODE!]
[!VAR "tx_pol_en"="0"!]
[!SELECT "CanConfigSet"!]
    [!LOOP "CanController/*"!]
        [!IF "CanTxProcessing = 'POLLING'"!]
            [!VAR "tx_pol_en" = "1"!]
            [!BREAK!]  
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$tx_pol_en = 0"!]
        [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
            [!IF "CanObjectType = 'TRANSMIT' and node:ref(CanControllerRef)/CanTxProcessing = 'MIXED' and CanHardwareObjectUsesPolling = 'true'"!]
                [!VAR "tx_pol_en" = "1"!]
                [!BREAK!]  
            [!ENDIF!]
        [!ENDLOOP!]
    [!ENDIF!]
[!ENDSELECT!]
[!ENDNOCODE!]

/*
* @brief          This macro enables Can_43_LLCE_MainFunction_Write() if at least one controller is set to process Tx in Polling Mode.
* @details        This macro enables Can_43_LLCE_MainFunction_Write() if at least one controller is set to process Tx in Polling Mode.
*
*/
#define CAN_43_LLCE_TXPOLL_SUPPORTED   [!IF "$tx_pol_en = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!]

[!NOCODE!]
[!VAR "rx_pol_en"="0"!]
[!SELECT "CanConfigSet"!]
    [!LOOP "CanController/*"!]
        [!IF "CanRxProcessing = 'POLLING'"!]
            [!VAR "rx_pol_en" = "1"!]
            [!BREAK!]  
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$rx_pol_en = 0"!]
        [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
            [!IF "CanObjectType = 'RECEIVE' and node:ref(CanControllerRef)/CanRxProcessing = 'MIXED' and CanHardwareObjectUsesPolling = 'true'"!]
                [!VAR "rx_pol_en" = "1"!]
                [!BREAK!]  
            [!ENDIF!]
        [!ENDLOOP!]
    [!ENDIF!]
[!ENDSELECT!]
[!ENDNOCODE!]

/*
* @brief          This macro enables Can_43_LLCE_MainFunction_Read() if at least one controller is set to process Rx in Polling Mode.
* @details        This macro enables Can_43_LLCE_MainFunction_Read() if at least one controller is set to process Rx in Polling Mode.
*
*/
#define CAN_43_LLCE_RXPOLL_SUPPORTED   [!IF "$rx_pol_en = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]


[!NOCODE!]
[!VAR "bo_pol_en"="0"!]
[!SELECT "CanConfigSet"!][!//
    [!LOOP "CanController/*"!]
        [!IF "CanBusoffProcessing = 'POLLING'"!]
            [!VAR "bo_pol_en" = "1"!]
            [!BREAK!]  
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!]
[!ENDNOCODE!]


/*
* @brief          This macro enables Can_43_LLCE_MainFunction_BusOff() if at least one controller is set to process BusOff in Polling Mode.
* @details        This macro enables Can_43_LLCE_MainFunction_BusOff() if at least one controller is set to process BusOff in Polling Mode.
*
*/
#define CAN_43_LLCE_BUSOFFPOLL_SUPPORTED   [!IF "$bo_pol_en = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]


/*
* @brief          This macro enables Can_43_LLCE_MainFunction_ErrorNotification() and is used for reporting errors configured in Polling Mode.
*
*/
[!SELECT "CanConfigSet"!]
[!SELECT "CanErrorReporting"!]
#define CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED   [!IF "CanMainFunctionErrorEn = 'true'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]
[!ENDSELECT!]
[!ENDSELECT!]


/**
* @brief          Maximum number of baudrate configured.
* @details        Maximum number of baudrate configured.
*                 Controller Baudrates configured are in kbps
*
*/
[!SELECT "CanConfigSet"!][!//
    [!LOOP "CanController/*"!]
        [!VAR "HWChannel" = "CanHwChannel"!]
        #define CAN_43_LLCE_MAX_BAUDRATE_FC_[!"substring-after($HWChannel,'BCAN_')"!]_[!"@index"!]   [!WS "1"!][!"num:i(count(CanControllerBaudrateConfig/*))"!]U[!CR!]
    [!ENDLOOP!]
[!ENDSELECT!]

/* CAN FD INIT*/
[!NOCODE!]
[!VAR "CNT_FD" = "0"!]
[!SELECT "CanConfigSet"!][!//
    [!IF "node:exists(CanController/*/CanControllerBaudrateConfig/*/CanControllerFdBaudrateConfig)"!]
        [!VAR "CNT_FD" = "$CNT_FD+1"!] 
    [!ENDIF!]
[!ENDSELECT!]
[!ENDNOCODE!]
[!IF "$CNT_FD > 0"!]
    #define CAN_43_LLCE_FD_MODE_ENABLE (STD_ON)
    [!VAR "CNT_FD" = "0"!]
[!ELSE!]
    #define CAN_43_LLCE_FD_MODE_ENABLE (STD_OFF)
[!ENDIF!]

[!SELECT "CanGeneral"!]
/*
* @brief          (CAN113_Conf) Specifies the maximum time for blocking function until a timeout is detected. Unit in loops.
* @details        (CAN281) The Can module shall use the free running timer provided by the system service for timeout detection in case the hardware does not react
*                  in the expected time (hardware malfunction) to prevent endless loops.
*
*/
/* Time out value in uS */
#define CAN_43_LLCE_TIMEOUT_DURATION    [!"num:i(./CanTimeoutDuration * 1000000)"!]U

/* This will set the timer source for osif that will be used for timeout */
#define CAN_43_LLCE_SERVICE_TIMEOUT_TYPE    [!"CanTimeoutMethod"!]

[!ENDSELECT!]


/*
* @brief          Precompile Support.
* @details        (CAN220)VARIANT-PRE-COMPILE: Only pre-compile configuration parameters
*
*/
[!IF "IMPLEMENTATION_CONFIG_VARIANT = 'VariantPreCompile' and (variant:size()<=1)"!]
    #define CAN_43_LLCE_PRECOMPILE_SUPPORT (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_PRECOMPILE_SUPPORT (STD_OFF)
[!ENDIF!]

[!IF "node:exists(CanGeneral/CanMainFunctionBusoffPeriod)"!]
    /*
    * @brief          Periods for cyclic call of Main function
    * @details        (CAN355_Conf) CanMainFunctionBusoffPeriod - This parameter describes the period for cyclic call to Can_MainFunction_Busoff. Unit is seconds.
    *
    */
    #define CAN_43_LLCE_MAINFUNCTION_PERIOD_BUSOFF  [!WS "1"!][!SELECT "CanGeneral"!]([!"./CanMainFunctionBusoffPeriod"!]F)[!ENDSELECT!][!CR!]
[!ENDIF!]


/*
* @brief          Periods for cyclic call of Main function
* @details        (ECUC_Can_00484) This parameter describes the period for cyclic call to Can_43_LLCE_MainFunction_Read or Can_43_LLCE_MainFunction_Write depending on the referring item. Unit is seconds. 
*                 Different poll-cycles will be configurable if more than one CanMainFunctionPeriod is configured. 
*                 In this case multiple Can_43_LLCE_MainFunction_Read() or Can_43_LLCE_MainFunction_Write() will be provided by the CAN Driver module..
*
*/
[!VAR "MainFuncPeriodCount" = "num:i(count(CanGeneral/CanMainFunctionRWPeriods/*))"!]

[!IF "$MainFuncPeriodCount = 0 or $MainFuncPeriodCount = 1"!]
    #define CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ  (STD_OFF)
    #define CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE (STD_OFF)
[!ELSE!]
    [!VAR "MAX_CTRL_COUNT"="16"!]
    [!IF "$rx_pol_en = 1"!]
        #define CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ   (STD_ON)
    [!ELSE!]
        #define CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ  (STD_OFF)
    [!ENDIF!]
    [!IF "$tx_pol_en = 1"!]
        #define CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE   (STD_ON)
    [!ELSE!]
        #define CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE  (STD_OFF)
    [!ENDIF!]
    [!LOOP "CanGeneral/CanMainFunctionRWPeriods/*"!]
        [!VAR "rx_hoh_pol_en"="0"!]
        [!VAR "tx_hoh_pol_en"="0"!]
        [!VAR "CanMainFunctionPeriodName" = "@name"!]
        [!LOOP "../../../CanConfigSet/CanHardwareObject/*"!]
            [!IF "($rx_hoh_pol_en = 0) and ((node:ref(CanControllerRef)/CanRxProcessing = 'POLLING' or (node:ref(CanControllerRef)/CanRxProcessing = 'MIXED' and CanHardwareObjectUsesPolling = 'true')) and (CanObjectType = 'RECEIVE')) and ($CanMainFunctionPeriodName = node:ref(CanMainFunctionRWPeriodRef)/@name)"!]
                [!VAR "rx_hoh_pol_en" = "1"!]
            [!ENDIF!]
            [!IF "($tx_hoh_pol_en = 0) and ((node:ref(CanControllerRef)/CanTxProcessing = 'POLLING' or (node:ref(CanControllerRef)/CanTxProcessing = 'MIXED' and CanHardwareObjectUsesPolling = 'true')) and (CanObjectType = 'TRANSMIT')) and ($CanMainFunctionPeriodName = node:ref(CanMainFunctionRWPeriodRef)/@name)"!]
                [!VAR "tx_hoh_pol_en" = "1"!]    
            [!ENDIF!]
            [!IF "($rx_hoh_pol_en = 1) and ($tx_hoh_pol_en = 1)"!]
                [!BREAK!]    
            [!ENDIF!]
        [!ENDLOOP!]
        [!IF "$rx_hoh_pol_en = 1"!]
            #define Can_43_LLCE_MainFunction_Read_[!"@name"!]()       Can_43_LLCE_MainFunction_Multiple_Read([!"num:i(RxInterface - $MAX_CTRL_COUNT)"!]) [!// RxInterface translates into polling class by subtracting 16
        [!ENDIF!]
        [!IF "$tx_hoh_pol_en = 1"!]
            #define Can_43_LLCE_MainFunction_Write_[!"@name"!]()       Can_43_LLCE_MainFunction_Multiple_Write([!"num:i(AckInterface - $MAX_CTRL_COUNT)"!]) [!// AckInterface translates into polling class by subtracting 16
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDIF!]


/*
* @brief          Periods for cyclic call of Main function Mode
* @details        (CAN376_Conf) This parameter describes the period for cyclic call to Can_43_LLCE_MainFunction_Mode. Unit is seconds.
*
*/
#define CAN_43_LLCE_MAINFUNCTION_MODE_PERIOD   [!WS "1"!][!SELECT "CanGeneral"!]([!"./CanMainFunctionModePeriod"!]F)[!ENDSELECT!]


/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/
#define CAN_43_LLCE_CONFIG_EXT \
    [!INDENT "4"!]
    [!IF "var:defined('postBuildVariant') or (variant:size() > 1)"!]
        [!VAR "variantIndex"="0"!]
        [!VAR "variantNumber"="variant:size()"!]
        [!LOOP "variant:all()"!]
            [!VAR "variantIndex"="$variantIndex + 1"!]
            CAN_43_LLCE_CONFIG_[!"."!]_PB [!IF "$variantIndex < $variantNumber"!]\[!ENDIF!][!CR!]
        [!ENDLOOP!]
    [!ELSE!]
        CAN_43_LLCE_CONFIG_PB
    [!ENDIF!]
    [!ENDINDENT!]

/*
* @brief          Support for Special MB Abort API
* @details        Enables an additional API which adds support for aborting a message transmission.
*/
#define CAN_43_LLCE_API_ENABLE_ABORT_MB [!WS "1"!][!IF "(CanGeneral/CanApiEnableMbAbort = 'true')"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Support for single MB Abort  API
* @details        Extra information for AbortMB API which selects between single MB abort and aborting all the MBs corresponding to a specific HTH.
*/
#define CAN_43_LLCE_ABORT_ONLY_ONE_MB [!WS "1"!][!IF "(CanGeneral/CanAbortOnlyOneMB = 'true') and (CanGeneral/CanApiEnableMbAbort = 'true')"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Support for Manual BusOff recovery request API
* @details        Enables an additional API for requesting recovery from BusOff confinement state. 
*                 It is enabled when at least one controller configuration handles the recovery from bus-off manually.
*                 Not Autosar required.
*/
#define CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY [!WS "1"!][!VAR "ManualBusOffRec" = "CanConfigSet/CanController/*/ManualBusOffRecovery = 'true'"!] [!// At least one controller has ManualBusOffRecovery enabled
[!IF "$ManualBusOffRec = 'true'"!] (STD_ON)[!ELSE!] (STD_OFF)[!ENDIF!]

/*
* @brief          Checks whether the BUSOFF_RECOVERY mode is ENABLED.
* @details        BUSOFF_RECOVERY is ENABLED when Manual or Auto Bus-off Recovery is set for any controller.
*                 Not Autosar required.
*/
[!SELECT "CanGeneral"!][!IF "node:exists(./BusOffNotification) and (normalize-space(./BusOffNotification) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED     (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED     (STD_OFF)
[!ENDIF!][!ENDSELECT!]

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/

/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/

[!ENDINDENT!]

#ifdef __cplusplus
}
#endif

#endif /* CAN_43_LLCE_CFG_H */

/** @} */


===== 文件 [61/112]: generate_PC\include\Can_43_LLCE_Externals.h =====
/**
*   @file    Can_43_LLCE_Externals.h
*   @implements Can_Externals.h_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface.
*   @details API header for CAN driver.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/
#ifndef CAN_43_LLCE_EXTERNALS_H
#define CAN_43_LLCE_EXTERNALS_H

#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

#define CAN_43_LLCE_EXTERNALS_VENDOR_ID_H                       43
#define CAN_43_LLCE_EXTERNALS_MODULE_ID_H                       80
#define CAN_43_LLCE_EXTERNALS_AR_RELEASE_MAJOR_VERSION_H        4
#define CAN_43_LLCE_EXTERNALS_AR_RELEASE_MINOR_VERSION_H        4
#define CAN_43_LLCE_EXTERNALS_AR_RELEASE_REVISION_VERSION_H     0
#define CAN_43_LLCE_EXTERNALS_SW_MAJOR_VERSION_H                1
#define CAN_43_LLCE_EXTERNALS_SW_MINOR_VERSION_H                0
#define CAN_43_LLCE_EXTERNALS_SW_PATCH_VERSION_H                10

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_CODE
#include "Can_43_LLCE_MemMap.h"
[!NOCODE!][!INDENT "0"!]
[!SELECT "CanGeneral"!]
    [!IF "node:exists(./CanLPduReceiveCalloutFunction)"!]
        [!IF "(normalize-space(./CanLPduReceiveCalloutFunction) != 'NULL_PTR')"!]
            [!CODE!]
            [!IF "((node:exists(./LPDUCalloutExtension)) and (./LPDUCalloutExtension ='true'))"!]
                boolean [!"normalize-space(./CanLPduReceiveCalloutFunction)"!](uint16 Hrh, Can_IdType CanId, uint8 CanDataLength, const uint8* CanSduPtr);[!CR!]
            [!ELSE!]
                boolean [!"normalize-space(./CanLPduReceiveCalloutFunction)"!](uint8 Hrh, Can_IdType CanId, uint8 CanDataLength, const uint8* CanSduPtr);[!CR!]
            [!ENDIF!]            
            #define Can_43_LLCE_LPduReceiveCalloutFunction     ([!"normalize-space(CanLPduReceiveCalloutFunction)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

    [!IF "node:exists(./RxTimestampNotification)"!]
        [!IF "(normalize-space(./RxTimestampNotification) != 'NULL_PTR')"!]
            [!CODE!]
            void [!"normalize-space(./RxTimestampNotification)"!](Can_HwHandleType Hoh, uint32 u32TimestampVal);[!CR!]
            #define Can_43_LLCE_RxTimestampNotification     ([!"normalize-space(RxTimestampNotification)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

    [!IF "node:exists(./TxTimestampNotification)"!]
        [!IF "(normalize-space(./TxTimestampNotification) != 'NULL_PTR')"!]
            [!CODE!]
            void [!"normalize-space(./TxTimestampNotification)"!](Can_HwHandleType Hoh, PduIdType CanTxPduId, uint32 u32TimestampVal);[!CR!]
            #define Can_43_LLCE_TxTimestampNotification     ([!"normalize-space(TxTimestampNotification)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

    [!IF "node:exists(./CanCustomRxFunction)"!]
        [!IF "(normalize-space(./CanCustomRxFunction) != 'NULL_PTR')"!]
            [!CODE!]
            boolean [!"normalize-space(./CanCustomRxFunction)"!](uint8 Hrh, Can_IdType CanId, uint8 CanDataLength, uint8* CanSduPtr, uint16 u16RxMbDescIdx);[!CR!]
            #define Can_43_LLCE_CustomRxCallback        ([!"normalize-space(CanCustomRxFunction)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

    [!IF "node:exists(./CanWriteCustomCallback)"!]
        [!IF "(normalize-space(./CanWriteCustomCallback) != 'NULL_PTR')"!]
            [!CODE!]
            void [!"normalize-space(./CanWriteCustomCallback)"!](Can_HwHandleType Hoh, PduIdType CanTxPduId, uint16 u16TxMbDescIdx);[!CR!]
            #define Can_43_LLCE_CustomWriteCallback        ([!"normalize-space(CanWriteCustomCallback)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

    [!IF "node:exists(./CanTxConfirmationCustomCallback)"!]
        [!IF "(normalize-space(./CanTxConfirmationCustomCallback) != 'NULL_PTR')"!]
            [!CODE!]
            void [!"normalize-space(./CanTxConfirmationCustomCallback)"!](Can_HwHandleType Hoh, PduIdType CanTxPduId);[!CR!]
            #define Can_43_LLCE_CustomTxConfirmationCallback        ([!"normalize-space(CanTxConfirmationCustomCallback)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

    [!IF "node:exists(./CanAuxFilterCallback)"!]
        [!IF "(normalize-space(./CanAuxFilterCallback) != 'NULL_PTR')"!]
            [!CODE!]
            void [!"normalize-space(./CanAuxFilterCallback)"!](uint16 u16FilterId, uint16 u16AuxSearchResult);[!CR!]
            #define Can_43_LLCE_CanAuxFilterCallback        ([!"normalize-space(CanAuxFilterCallback)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

    [!IF "node:exists(./BusOffNotification)"!]
        [!IF "(normalize-space(./BusOffNotification) != 'NULL_PTR')"!]
            [!CODE!]
            void [!"normalize-space(./BusOffNotification)"!](uint8 u8CanIfCtrlId);[!CR!]
            #define Can_43_LLCE_ControllerBusOffCallback        ([!"normalize-space(BusOffNotification)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

[!ENDSELECT!]

[!SELECT "CanConfigSet/CanErrorReporting"!]
    [!IF "node:exists(./CanErrorNotif)"!]
        [!IF "(normalize-space(./CanErrorNotif) != 'NULL_PTR')"!]
            [!CODE!]
            void [!"normalize-space(./CanErrorNotif)"!](CanErrorNotificationType* error);[!CR!]
            #define Can_43_LLCE_ErrorNotificationCallback     ([!"normalize-space(CanErrorNotif)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]
[!ENDSELECT!]


[!ENDINDENT!][!ENDNOCODE!]
#define CAN_43_LLCE_STOP_SEC_CODE
#include "Can_43_LLCE_MemMap.h"
#ifdef __cplusplus
}
#endif
#endif /* CAN_43_LLCE_EXTERNALS_H */
/** @} */


===== 文件 [62/112]: generate_PC\src\Can_43_LLCE_Cfg.c =====
/**
*   @file    Can_43_LLCE_Cfg.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Configuration Structures for PreCompile.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Can_43_LLCE.h"
#include "Can_43_LLCE_IPW.h"

/**
* @file           Can_43_LLCE_Cfg.c
*/

[!AUTOSPACING!]

[!NOCODE!][!//
[!INCLUDE "Can_43_LLCE_VersionCheck_Src.m"!][!//
[!ENDNOCODE!][!//

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
#define CAN_43_LLCE_VENDOR_ID_PCCFG_C                   43
#define CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_PCCFG_C     4
#define CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_PCCFG_C     4
#define CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_PCCFG_C  0
#define CAN_SW_MAJOR_VERSION_PCCFG_C             1
#define CAN_SW_MINOR_VERSION_PCCFG_C             0
#define CAN_SW_PATCH_VERSION_PCCFG_C             10

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/* Check if current file and Can configuration header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID_PCCFG_C != CAN_43_LLCE_VENDOR_ID)
#error "Can_43_LLCE.h and Can_43_LLCE_Cfg.h have different vendor ids"
#endif
/* Check if current file and CAN header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_PCCFG_C != CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_PCCFG_C != CAN_43_LLCE_AR_RELEASE_MINOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_PCCFG_C != CAN_43_LLCE_AR_RELEASE_REVISION_VERSION))
  #error "AutoSar Version Numbers of Can_43_LLCE_Cfg.c and Can_43_LLCE.h are different"
#endif
/* Check if current file and CAN header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_PCCFG_C != CAN_43_LLCE_SW_MAJOR_VERSION) || \
     (CAN_SW_MINOR_VERSION_PCCFG_C != CAN_43_LLCE_SW_MINOR_VERSION) || \
     (CAN_SW_PATCH_VERSION_PCCFG_C != CAN_43_LLCE_SW_PATCH_VERSION))
       #error "Software Version Numbers of Can_43_LLCE_Cfg.c and Can_43_LLCE.h are different"
#endif

/* Check if current file and Can_IPW configuration header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID_PCCFG_C  != CAN_IPW_VENDOR_ID_H)
#error "Can_43_LLCE.h and Can_43_LLCE_Cfg.h have different vendor ids"
#endif
/* Check if current file and CAN_IPW header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_PCCFG_C != CAN_IPW_AR_RELEASE_MAJOR_VERSION_H) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_PCCFG_C != CAN_IPW_AR_RELEASE_MINOR_VERSION_H) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_PCCFG_C != CAN_IPW_AR_RELEASE_REVISION_VERSION_H))
  #error "AutoSar Version Numbers of Can_43_LLCE_Cfg.c and Can_43_LLCE.h are different"
#endif
/* Check if current file and CAN_IPW header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_PCCFG_C != CAN_IPW_SW_MAJOR_VERSION_H) || \
     (CAN_SW_MINOR_VERSION_PCCFG_C != CAN_IPW_SW_MINOR_VERSION_H) || \
     (CAN_SW_PATCH_VERSION_PCCFG_C != CAN_IPW_SW_PATCH_VERSION_H))
       #error "Software Version Numbers of Can_43_LLCE_Cfg.c and Can_43_LLCE.h are different"
#endif


/*==================================================================================================
*                                   GLOBAL FUNCTION PROTOTYPES
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_CONFIG_DATA_UNSPECIFIED

#include "Can_43_LLCE_MemMap.h"


/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/
[!NOCODE!] [!/* This section is for global variables, local to this file */!]
    [!/*
    Sync-seg = is the segment that is used to synchronise the nodes on the bus. A bit edge (if there is a data change) is expected during this segment.
    Prop-Seg = is a period of time that is used to compensate for physical delay times within the network.
    Phase-seg1 = is a buffer segment that may be lengthened during resynchronisation to compensate for oscillator drift and positive phase differences between the oscillators of the transmitting and receiving node(s).
    Phase-seg2 = is a buffer segment that may be shortened during resynchronisation (described below) to compensate for negative phase errors and oscillator drift.

    The Sample point is always at the end of Phase-seg1 and is the time at which the bus level is read and interpreted as the value of the current bit.
    Whether transmitting or receiving, all nodes on a single CAN bus must have the same nominal bit time. Bit time is programmable at each node on a CAN Bus and is a function
        of the period of the oscillator local to each node, the value that is user-programmed into a Baud Rate Prescaler (BRP) register in the controller at each node, and the programmed number of time quanta per bit.
    When any node receives a data frame or a remote frame, it is necessary for the receiver to synchronise with the transmitter.
        1. The first is hard synchronisation and occurs at Start-of-Frame (SOF).
        2. For subsequent bits in any received frame, if a bit edge does not occur in the Sync-seg segment of bit time, resynchronisation is automatically invoked and will shorten or lengthen the current bit time depending
            on where the edge occurs. The maximum amount by which the bit time is lengthened or shortened is determined by a user-programmable number of time quanta known as the Synchronisation Jump Width (SJW).
    */!]
[!ENDNOCODE!]

/*==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/

#define CAN_43_LLCE_STOP_SEC_CONFIG_DATA_UNSPECIFIED

#include "Can_43_LLCE_MemMap.h"

#ifdef __cplusplus
}
#endif

/** @} */


===== 文件 [63/112]: include\Can_43_LLCE.h =====
/**
*   @internal
*   @file    Can_43_LLCE.h
*   @implements Can.h_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface.
*   @details API header for CAN driver.
*
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/


#ifndef CAN_43_LLCE_H
#define CAN_43_LLCE_H

#ifdef __cplusplus
extern "C"{
#endif

/*
(CAN043) The file Can_43_LLCE.h contains the declaration of the Can module API.
(CAN037) The file Can_43_LLCE.h only contains 'extern' declarations of constants, global data, type definitions and services
            that are specified in the Can module SWS.
*/

/**
* @file           Can_43_LLCE.h
*/



/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
/**
* @file           Can_43_LLCE.h
*/
#include "ComStackTypes.h"
#include "Can_43_LLCE_Cfg.h"
#include "Can_GeneralTypes.h"
#include "Can_Llce_Types.h"
#include "Soc_Ips.h"
#include "Llce_FwVersion.h"
#include "Llce_InterfaceCanTypes.h"
#include "Mcal.h"


/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/*
    Internal micro-dependent versioning. Check of AUTOSAR & Vendor specification version.
*/
/**
* @{
* @file           Can_43_LLCE.h
*/
#define CAN_43_LLCE_VENDOR_ID                   43
#define CAN_43_LLCE_MODULE_ID                   80
#define CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION    4
#define CAN_43_LLCE_AR_RELEASE_MINOR_VERSION    4
#define CAN_43_LLCE_AR_RELEASE_REVISION_VERSION 0
#define CAN_43_LLCE_SW_MAJOR_VERSION            1
#define CAN_43_LLCE_SW_MINOR_VERSION            0
#define CAN_43_LLCE_SW_PATCH_VERSION            10
/**@}*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/
/* Check if current file and Can configuration header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID != CAN_43_LLCE_VENDOR_ID_CFG_H)
#error "Can_43_LLCE.h and Can_43_LLCE_Cfg.h have different vendor ids"
#endif
/* Check if current file and Can configuration header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION != CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION != CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION != CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_CFG_H))
  #error "AutoSar Version Numbers of Can_43_LLCE.h and Can_43_LLCE_Cfg.h are different"
#endif

/* Check if current file and CAN configuration header file are of the same software version */
#if ((CAN_43_LLCE_SW_MAJOR_VERSION != CAN_43_LLCE_SW_MAJOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_SW_MINOR_VERSION != CAN_43_LLCE_SW_MINOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_SW_PATCH_VERSION != CAN_43_LLCE_SW_PATCH_VERSION_CFG_H))
  #error "Software Version Numbers of Can_43_LLCE.h and Can_43_LLCE_Cfg.h are different"
#endif
/* Check if current file and CAN configuration header file are of the same software version */
#ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION != COMTYPE_AR_RELEASE_MAJOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION != COMTYPE_AR_RELEASE_MINOR_VERSION) )
  #error "Software Version Numbers of Can_43_LLCE.h and ComStackTypes.h are different"
#endif
#endif


/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/**
* @brief          Can_43_LLCE_ObjType
* @details        Used for value received by Tressos interface configuration.
*                 Describes the HOH configuration.
*
*/
typedef enum
    {
        CAN_43_LLCE_RECEIVE = 0U,    /**< @brief Regular Receive */
        CAN_43_LLCE_RECEIVE_AF,      /**< @brief Receive with Advanced Features*/
        CAN_43_LLCE_TRANSMIT    /**< @brief Transmit MB */
    } Can_43_LLCE_ObjType;


    
/**
* @brief          Can_43_LLCE_StatusType
* @details        CAN Driver status used for checking and preventing double driver initialization.
*                 CAN_43_LLCE_UNINIT = The CAN controller is not initialized. The CAN Controller is not participating on the CAN bus.
*                              All registers belonging to the CAN module are in reset state, CAN interrupts are disabled.
*                 CAN_43_LLCE_READY = Controller has initialized: static variables, including flags;
*                             Common setting for the complete CAN HW unit; CAN controller specific settings for each CAN controller.
*
*/
typedef enum
    {
        CAN_43_LLCE_UNINIT = 0U, /**< @brief Driver not initialized */
        CAN_43_LLCE_READY       /**< @brief Driver ready */
    } Can_43_LLCE_StatusType;



/**
* @brief          Can_43_LLCE_FilterStateType
* @details        Used for enabling or disabling filters at runtime.
*
*/
typedef enum
    {
        CAN_43_LLCE_FILTERSTATE_DISABLED = 0U, /**< @brief Filter disabled at runtime */
        CAN_43_LLCE_FILTERSTATE_ENABLED        /**< @brief Filter enabled at runtime */
    } Can_43_LLCE_FilterStateType;

/**
* @brief          Can_43_LLCE_ChannelStateType
* @details        Used for enabling or disabling channels in multicast routing configuration.
*
*/
typedef enum
    {
        CAN_43_LLCE_CHANNELSTATE_DISABLED = 0U, /**< @brief Channel disabled */
        CAN_43_LLCE_CHANNELSTATE_ENABLED        /**< @brief Channel enabled */
    } Can_43_LLCE_ChannelStateType;
/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/**
* @brief          Configuration of BCAN controller.
* @details        This structure is initialized by Tresos considering user settings.
*                 Used by Can_43_LLCE_SetBaudrate() API to set the default baudrate after initialization.
*                 and to change the baudrate when the BCAN is in stopped mode.
*
*/
typedef struct
    {
        const Llce_Can_SetBaudrateCmdType baudrateConfig;

#if (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON)
        const uint16 u16ControllerBaudRateConfigID;
#endif
    } Can_43_LLCE_ControllerBaudrateConfigType;


/**
* @brief          Can_43_LLCE_HOHType
* @details        Type for storing information about hardware objects.
*                 Used by Can_43_LLCE_MBConfigContainerType.
*
*/
typedef struct
    {
        Can_43_LLCE_ObjType eMBType; /**< @brief Receive/ Receive AF / Transmit */

        const uint16 u16MbCount; /**< @brief Maximum number of message buffers for this HOH */

        const uint8 u8ControllerId; /**< @brief Controller ID (index into controller address array containing Can_ControllerPtrType). */

        uint8 u8FdPaddingValue; /**< @brief Padding value for MB > 8 bytes */

        const uint8 u8CanMainFuncRWPeriodRef; /**< @brief read write period reference */

        const uint8 u8RWInterface; /**< @brief Rx/Ack interface. Specifies which interface to be used for current HOH. */

        const uint8 u8EnableTxFrameMac; /**< @brief The parameter is used to enable adding of MAC code to transmitted frames.*/

        const uint32 u32TxHseKeyHandle; /**< @brief The parameter is used to add the key handle for generation of MAC code to transmitted frames.*/

#if (CAN_43_LLCE_TRIGGER_TRANSMIT_EN == STD_ON)
        const boolean CanTriggerTransmitEnable; /**< @brief The parameter is used to detect the MB which run with trigger transmit feature*/
#endif
#if (CAN_43_LLCE_DUMMY_HRH_EN == STD_ON)
        const boolean bDummyHRH; /**< @brief True for dummy HRH */
#endif
    } Can_43_LLCE_HOHType;

/**
* @brief          Structure for describing individual BCAN controllers on the chip.
* @details        HRH = Hardware Receive Handle (HRH) is defined and provided by the CAN driver.
*                       Each HRH represents exactly one hardware object.
*                       The HRH can be used to optimize software filtering.
*                 HTH = The Hardware Transmit Handle (HTH) is defined and provided by the CAN driver.
*                       Each HTH represents one or several hardware objects, that are
*                       configured as hardware transmit pool.
*
*/
typedef struct
    {
        const uint8 u8MaxBaudRateCount; /**< @brief Max BaudRate number. */
        const uint8 u8DefaultBaudRateIndex; /**< @brief Default baudrate index. */
        const Can_43_LLCE_ControllerBaudrateConfigType * const pControllerBaudrateConfigsPtr; /**< @brief Pointer to the Configuration of Baudrate timing parameter for BCAN baudrate controller ( CTRL value register). */
        const uint32 u32CoreId;  /**< @brief ID of the application core this is assigned to */ 
        const uint8 u8HwCtrl; /**< @brief Hardware ID for BCAN controller */
    } Can_43_LLCE_ControllerDescriptorType;

/**
* @brief          Structure for describing individual Hardware controllers.
* @details        This structure is initialized by Tresos/Design Studio considering user settings. It generates an array (HwControllerDescriptors_PB) that is indexed
*                 using the Hardware ID of the BCAN controller. 
*                 The structure contains data needed by the driver (Event Trigger Mode / CanIf ID).
*
*/
typedef struct
    {
        const uint32 u32DrvControllerOptions; /*< @brief Variable used only by driver. Event Trigger Mode TxProcessing/RxProcessing/BusoffProcessing. */
        const uint8 u8CanIfCtrlId; /**< @brief Controller ID defined by CanIf */
        const uint8 u8FifoInterface; /**< @brief LLCE FIFO Interface used for interrupt processing. Default is 1 to 1 mapped with Can Hardware Channel. */
    }Can_43_LLCE_HwControllerDescriptorType;

/**
* @brief          Top Level structure containing all Driver configuration.
* @details        A pointer to this structure is transmitted to Can_43_LLCE_Init() to initialize the driver at startup.
*                 The application selects one of the configurations by using a pointer to one of the elements
*                 of this array as a parameter of the Can_43_LLCE_Init function.
*
*/
typedef struct
    {

        const Llce_Can_InitPlatformCmdType * const pPlatfInitConfig; /**< @brief Configuration used by platform init command.(e.g Maximum number of filters or MB/channel) */

        const Llce_Can_InitCmdType * const pChannelInitConfig; /**< @brief Configuration used by channel init command. */

        Llce_Can_ReceiveFilterType** paReceiveFilters;
        
        Llce_Can_AdvancedFilterType** paAdvancedFilters;

        Llce_Can_AuxFilterType** paAuxFilters; /**< @brief Pointer to the list of auxilliary filters */

        uint16* paLlce_MaxAuxilliaryFilterCount; /**< @brief Pointer to an array with the number of auxilliary filters per controller */

        const Can_43_LLCE_HOHType * const aHohList; /**< @brief Pointer to the list of hardware objects */

        const Can_43_LLCE_ControllerDescriptorType * const aControllerDescriptors; /**< @brief Pointer to the first BCAN Controller description. */

        const Can_43_LLCE_HwControllerDescriptorType * const aHwControllerDescriptors; /**< @brief Pointer to the Hardware Controller description. */

        const uint32* CanFilterId2CustomIdx; /**< @brief Mapping array CanObjectId <-> CustomProcessingIndex */

        const boolean bHeadlessModeEnabled; /**< @brief True when LLCE is started in headless mode */

        const uint32 u32CoreId; /** @brief Configuration Core ID */

        const uint8 u8ActiveHif;  /**< @brief LLCE Host interface used by this driver instance */

        const uint8 u8DefaultController;  /**< @brief Controller used when sending generic commands to LLCE */
    } Can_43_LLCE_ConfigType;

/**
* @brief          Structure containing filter configuration data.
* @details        
*
*/
typedef struct
    {
        uint32 uMessageId; /**< @brief Configuration used by platform init command.(e.g Maximum number of filters or MB/channel) */

        uint32 uIdMask; /**< @brief Mask to use (for Mask filter) or Range End */

        uint16 u16MbCount; /**< @brief Number of message buffers to allocate to new filter */

        Can_HwHandleType Hrh; /**< @brief HRH to which to attach the filter */

        uint8 u8RWInterface; /**< @brief Rx interface for current filter. First 16 interfaces (0-15) are reserved for interrupt processing, next 6 interfaces (16-21) are for polling classes. */

        Llce_Can_IdLengthType eIdType; /**< @brief Standard or Extended Can ID */

        Llce_Can_EntryType eFilterType; /**< @brief Filter type (Exact Match, Mask or Range) */

        Llce_CanRx_MbLengthType eFilterMbLength; /**< @brief Message buffer payload length: 8 or 64 bytes */
    } Can_SetFilterType;

/**
* @brief          Structure containing advanced filter configuration data.
*/
typedef struct
{
    Can_SetFilterType Filter;
    Llce_Can_AdvancedFeatureType AdvancedFeature;
} Can_SetAfFilterType;

/**
* @brief          CanErrorNotification callback input type.
* @details        
*
*/
typedef struct
    {
        volatile Llce_Can_ErrorNotifType* ErrorInfo; /**< @brief Error description */

        uint8 u8CanIfCtrlId; /**< @brief Controller Id */

        Llce_Can_NotificationIdType eNotifId; /**< @brief Error type */
    } CanErrorNotificationType;

/**
* @brief          Structure containing the baudrate index.
* @details        
*
*/
typedef struct 
    {
        uint8 u8CurrentBaudRateIndex; /*< @brief Current controller baud rate */
    }Can_43_LLCE_ControllerBaudRate;

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_VAR_INIT_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

/*
    Holds current status/run-time of CAN driver: CAN_43_LLCE_UNINIT or CAN_43_LLCE_READY (declared as global variable in "Can_43_LLCE.c" file).
    (CAN103) After power-up/reset, the Can module shall be in the state CAN_43_LLCE_UNINIT.
    Covers CAN103
*/
extern Can_43_LLCE_StatusType Can_43_LLCE_eDriverStatus[CAN_43_LLCE_MAX_PARTITIONS];

/*
    Holds the baudrate index of every configured controller. Declared as a global variable in Can_IPW.c file.
*/
extern Can_43_LLCE_ControllerBaudRate   Can_43_LLCE_ControllerBaudRateIndexes[CAN_43_LLCE_MAXCTRL_CONFIGURED];

/* Pointer to the current Driver Configuration (passed to the driver during initialization). Initialized by Can_43_LLCE_Init(). */
extern const Can_43_LLCE_ConfigType * Can_43_LLCE_pCurrentConfig[CAN_43_LLCE_MAX_PARTITIONS];

#define CAN_43_LLCE_STOP_SEC_VAR_INIT_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

#define CAN_43_LLCE_START_SEC_CONFIG_DATA_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

/* Export Driver configuration */
CAN_43_LLCE_CONFIG_EXT

#define CAN_43_LLCE_STOP_SEC_CONFIG_DATA_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

#define CAN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

extern volatile uint16 Can_au16TransmitHwObjectCnt[CAN_43_LLCE_MAXHTH_CONFIGURED];

#define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"
/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/

#define CAN_43_LLCE_START_SEC_CODE
#include "Can_43_LLCE_MemMap.h"
/*================================================================================================*/
/**
* @brief         This service obtains the error state of the CAN controller.
* @details       This service shall read the error state register of Can Controller and shall return the error status to upper layer.
*
* @param[in]     Controller - Abstracted CanIf ControllerId which is assigned to a CAN controller, which is requested for ErrorState.
* @param[out]    ErrorStatePtr - Pointer to a memory location, where the error state of the CAN controller will be stored.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Driver must be initialized.
*
* @implements     Can_GetControllerErrorState_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerErrorState( uint8 Controller,
                                                Can_ErrorStateType * ErrorStatePtr
                                              );

/*================================================================================================*/
/**
* @brief         This service obtains the number of RX errors of the CAN controller.
* @details       This service shall read the error state register of Can Controller and shall return the number of rx errors to upper layer.
*
* @param[in]     ControllerId - Abstracted CanIf ControllerId which is assigned to a CAN controller, which is requested for rx error counter.
* @param[out]    RxErrorCounterPtr - Pointer to a memory location, where the rx error counter of the CAN controller will be stored.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Driver must be initialized.
* @implements    Can_GetControllerRxErrorCounter_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerRxErrorCounter ( uint8 ControllerId, uint8 * RxErrorCounterPtr );

/*================================================================================================*/
/**
* @brief         This service obtains the number of Tx errors of the CAN controller.
* @details       This service shall read the error state register of Can Controller and shall return the number of Tx errors to upper layer.
*
* @param[in]     ControllerId - Abstracted CanIf ControllerId which is assigned to a CAN controller, which is requested for rx error counter.
* @param[out]    TxErrorCounterPtr - Pointer to a memory location, where the tx error counter of the CAN controller will be stored.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Driver must be initialized.
* @implements    Can_GetControllerTxErrorCounter_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerTxErrorCounter ( uint8 ControllerId, uint8 * TxErrorCounterPtr);

/*================================================================================================*/
/**
* @brief         This service obtains the Llce Can controller status.
* @details       This service obtains a structure containing values from HW registers of the specified channel.
*
* @param[in]     component - The component to be queried.
* @param[out]    value - The version of the fw component.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Llce firmware must be loaded.
*   
*/
Std_ReturnType Can_43_LLCE_GetControllerStatus( uint8 ControllerId, Llce_Can_GetStatusCmdType * StatusPtr);

/*================================================================================================*/
/**
* @brief          Initialize the CAN driver. SID is 0x00.
* @details        Initialize all the controllers.
*                 The CAN module shall be initialized by Can_43_LLCE_Init(<&Can_Configuration>) service call during the start-up.
*                 This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      pxConfig Pointer to driver configuration.
*
* @return         void
*
*
* @pre            Can_43_LLCE_Init shall be called at most once during runtime.
* @post           Can_43_LLCE_Init shall initialize all the controllers and set the driver in READY state.
*
* @implements     Can_Init_Activity
*/
void Can_43_LLCE_Init( const Can_43_LLCE_ConfigType * pxConfig);

/*================================================================================================*/
/**
* @brief          De-initialize the CAN driver. SID is 0x10.
* @details        De-initialize all the controllers.
*                 The CAN module shall be de-initialized by Can_DeInit() service call during the start-up.
*                 This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      None
*
* @return         void
*
*
* @pre            Before controller de-initialization, the driver must be initialized and the controllers must be not in Start state.
* @post           Can_DeInit shall de-initialize all the controllers and set the driver in UNINIT state.
*
* @implements     Can_DeInit_Activity
*/
void Can_43_LLCE_DeInit(void);

/*================================================================================================*/
/**
* @brief          Shut down LLCE
* @details        Send the shutdown command to LLCE.
*                 Can only be called if both HIFs are deinitialized. LLCE becomes unusable until reset.
*
* @param[in]      None
*
* @return         E_OK if command accepted, E_NOT_OK otherwise
*
*
* @pre            Both LLCE HIFs must be uninitialized 
* @post           LLCE is disabled
*
*/
Std_ReturnType Can_43_LLCE_Shutdown(void);

/*================================================================================================*/
/**
* @brief          Reports about the current status of the requested CAN controller. SID is 0x12
* @details        This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller: CAN controller for which the status shall be requested.
*
* @param[out]     ControllerModePtr: Pointer to a memory location, where the current mode of the CAN controller will be stored.
*
* @retval         E_OK : Controller mode request has been accepted.
* @retval         E_NOT_OK : Controller mode request has not been accepted.
*
* @pre            Controller is initialized
* @post           The host has got the current controller state.
*
* @implements     Can_GetControllerMode_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerMode( uint8 Controller, Can_ControllerStateType * ControllerModePtr);

#if (CAN_43_LLCE_VERSION_INFO_API == STD_ON)
/**
* @brief          Returns the version information of this module. SID is 0x07
* @details        This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      versioninfo A pointer to location to store version info
*                             Must be omitted if the function does not have parameters.
*
* @return         void
*
*
* @pre            The CAN_43_LLCE_VERSION_INFO_API define must be configured on.
* @post           The version information is return if the parameter versionInfo is not a null pointer.
*
* @implements     Can_GetVersionInfo_Activity
*/
void Can_43_LLCE_GetVersionInfo( Std_VersionInfoType * versioninfo);
#endif /* (CAN_43_LLCE_VERSION_INFO_API == STD_ON) */

#if (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON)
/*================================================================================================*/
/**
* @brief         This function set baudrate
* @details       This routine is called by an upper layer.
*
* @param[in]     Controller controller ID
* @param[in]     BaudRateConfigID baudrateID selection
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Switch baudrate operation was ok.
* @retval        E_NOT_OK  Switch baudrate operation was not ok.
*
* @pre           Driver must be initialized.
* @implements    Can_SetBaudrate_Activity
*/
Std_ReturnType Can_43_LLCE_SetBaudrate( uint8 Controller,
                                                       const uint16 BaudRateConfigID
                                                     );
#endif /* (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON) */

/*================================================================================================*/
/**
* @brief          Put the controller into a required state. SID is 0x03.
* @details        Switch the controller from one state to another.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller - Can controller for which the status shall be changed - based on configuration order list (CanControllerId).
* @param[in]      Transition - Possible transitions (CAN_CS_STOPPED , CAN_CS_STARTED , CAN_CS_SLEEP , CAN_T_WAKEUP)
* @return         Std_ReturnType  Result of the transition.
* @retval         E_OK   Transition initiated.
* @retval         E_NOT_OK  Development or production error.
*
*
* @pre            Before changing the controller state the driver must be initialized.
* @post           After the transition to the new state the interrupts required for that state must be enabled.
*
* @implements     Can_SetControllerMode_Activity
*/
Std_ReturnType Can_43_LLCE_SetControllerMode( uint8 Controller,
                                                             Can_ControllerStateType Transition
                                                           );

/*================================================================================================*/
/**
* @brief          Disable INTs. SID is 0x04.
* @details        Switch OFF the controller's interrupts.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller Can controller for which interrupts shall be disabled - based on configuration order list (CanControllerId).
*
* @return         void
*
*
* @pre            Driver must be initalzied before changing the interrupts state (en or dis).
* @post           Controller must not respond to any interrupt assertion.
*
* @implements     Can_DisableControllerInterrupts_Activity
*/
void Can_43_LLCE_DisableControllerInterrupts( uint8 Controller);

/*================================================================================================*/
/**
* @brief          Enable INTs. SID is 0x05.
* @details        Switch ON the controller's interrupts.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller Can controller for which interrupts shall be disabled - based on configuration order list (CanControllerId).
*
* @return         void
*
*
* @pre            Driver must be initalzied before changing the interrupts state (en or dis).
* @post           Controller must respond to interrupt assertion.
*
* @implements     Can_EnableControllerInterrupts_Activity
*/
void Can_43_LLCE_EnableControllerInterrupts( uint8 Controller);

/*================================================================================================*/
/**
* @brief          Transmit information on CAN bus. SID is 0x06.
* @details        Can_43_LLCE_Write checks if hardware transmit object that is identified by the HTH is free.
*                    Can_43_LLCE_Write checks if another Can_43_LLCE_Write is ongoing for the same HTH.
*                     a) hardware transmit object is free:
*                         The mutex for that HTH is set to 'signaled' the ID, DLC and SDU are put in a format appropriate for
*                           the hardware (if necessary) and copied in the appropriate hardware registers or buffers.
*                        All necessary control operations to initiate the transmit are done.
*                         The mutex for that HTH is released. The function returns with E_OK.
*                    b) hardware transmit object is busy with another transmit request.
*                         The function returns with CAN_BUSY.
*                     c) A preemptive call of Can_43_LLCE_Write has been issued, that could not be handled reentrant (i.e. a call with the same HTH).
*                        The function returns with CAN_BUSY the function is non blocking
*                     d) The hardware transmit object is busy with another transmit request for an L-PDU that has lower priority than that for the current request
*                        The transmission of the previous L-PDU is cancelled (asynchronously).
*                        The function returns with CAN_BUSY.
*                   This routine is called by:
*                   - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Hth Information which HW-transmit handle shall be used for transmit.
*                 Implicitly this is also the information about the controller to use because the Hth numbers are unique inside one hardware unit.
* @param[in]      PduInfo Pointer to SDU user memory, DLC and Identifier.
* @return         Std_ReturnType   Result of the write operation.
* @retval         E_OK   Write command has been accepted.
* @retval         E_NOT_OK  Development error occurred.
* @retval         CAN_BUSY   No of TX hardware buffer available or preemtive call of Can_43_LLCE_Write() that can't be implemented reentrant.
*
*
* @pre            Driver must be initialized and MB must be configured for Tx.
* @post           The data can be transmitted or rejected because of another data with a higher priority.
*
* @implements     Can_Write_Activity
*/
Std_ReturnType Can_43_LLCE_Write( Can_HwHandleType Hth,
                                                 const Can_PduType * PduInfo
                                               );

/*================================================================================================*/
/**
* @brief          Process check of WakeUp condition. SID is 0x0B.
* @details        This service shall evaluate the WakeupSource parameter to get the information,
*                 which dedicate wakeup source needs to be checked, either a CAN transceiver or controller device.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      controller Can controller ID - based on configuration order list (CanControllerId).
* @return         Std_ReturnType Result of the wakeup verification.
* @retval         E_OK  Wakeup was detected for the given controller.
* @retval         E_NOT_OK  No wakeup was detected for the given controller.
*
*
* @pre            Driver must be initialized.
* @post           Return the Wakeup event occurrence.
* Compiler_Warning: This warning is thrown because it doesn't exist hardware support for Wakeup, and parameter "controller" it is not used.
*
* @implements     Can_CheckWakeup_Activity
*/
Std_ReturnType Can_43_LLCE_CheckWakeup( uint8 controller);

/*================================================================================================*/
/**
* @brief         This service obtains the Llce firmware version.
* @details       This service obtains a string which encapsulates all of the components versions for the Llce firmware.
*
* @param[out]    pVersionString - The string with all the components versions for the Llce firmware. 
* @param[out]    pStringLength - Length of the string.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Llce firmware must be loaded.
* @implements    Can_GetFwVersion_Activity
*/
Std_ReturnType Can_43_LLCE_GetFwVersion( const uint8 ** pVersionString, \
                                                                                  uint8 * pStringLength);

/*================================================================================================*/
/**
* @brief         This service set a single standard filter.
* @details       This service set a single standard filter.
*
* @param[in]     pCanFilter - parameter of Can_SetFilterType, containing filter type and message buffer related configuration data
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetFilter_Activity
*/
Std_ReturnType Can_43_LLCE_SetFilter(const Can_SetFilterType * pCanFilter);

/*================================================================================================*/
/**
* @brief         This service set a single standard filter.
* @details       This service set a single standard filter.
*
* @param[in]     pCanFilter - parameter of Can_SetFilterType, containing filter type and message buffer related configuration data
* @param[in]     u16FilterAddr - address returned by the RemoveFilter function
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetFilter_Activity
*/
Std_ReturnType Can_43_LLCE_SetFilterAtAddress(const Can_SetFilterType * pCanFilter, const uint16 u16FilterAddr);

/*================================================================================================*/
/**
* @brief         This service set a single advanced filter at a given address.
* @details       This service set a single advanced filter at a given address.
*
* @param[in]     pAfFilter - parameter of Can_SetAfFilterType, containing filter type and message buffer related configuration data along with routing rules and other advanced features
* @param[in]     u16FilterAddr - address returned by the RemoveFilter function
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetAfFilterAtAddress_Activity
*/
Std_ReturnType Can_43_LLCE_SetAfFilterAtAddress(const Can_SetAfFilterType * pAfFilter, const uint16 u16FilterAddr);

/*================================================================================================*/
/**
* @brief         This service set a single advanced filter.
* @details       This service set a single advanced filter.
*
* @param[in]     pAfFilter - parameter of Can_SetAfFilterType, containing advanced filter type and message buffer related configuration data
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetAfFilter_Activity
*/
Std_ReturnType Can_43_LLCE_SetAfFilter(const Can_SetAfFilterType * pAfFilter);

/*================================================================================================*/
/**
* @brief         This service a new destination for advanced features
* @details       This service a new destination for advanced features
**
* @param[in]      destRule - The destination to add to the LLCE destination list
* @param[out]     pu8RuleIdx - The index of the new destination in the LLCE list. Needed for SetAdvancedFilter.
*
* @return        Std_ReturnType. Result of the request.
* @retval        E_OK  Destination created
* @retval        E_NOT_OK  Error
*
* @pre           Llce firmware must be loaded and the controller initialized
*/
Std_ReturnType Can_43_LLCE_CreateAfDestination(const Can_Af_DestRulesType destRule, uint8* pu8RuleIdx);

/*================================================================================================*/
/**
* @brief         This service removes an existing destination for advanced features
* @details       This service removes an existing destination for advanced features
*
* @param[in]     u8RuleIdx - The index of the destination to be removed from the LLCE list.
*
* @return        Std_ReturnType. Result of the request.
* @retval        E_OK  Destination removed
* @retval        E_NOT_OK  Error
*
* @pre           Llce firmware must be loaded and the controller initialized
*/
Std_ReturnType Can_43_LLCE_RemoveAfDestination(uint8 u8RuleIdx);

/*================================================================================================*/
/**
* @brief         This service removes a single standard filter.
* @details       This service removes a single standard filter.
*
* @param[in]     Hrh - HRH to which the filter is attached.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_RemoveFilter_Activity
*/
Std_ReturnType Can_43_LLCE_RemoveFilter(Can_HwHandleType Hrh, uint16 *u16FilterAddr);

/*================================================================================================*/
/**
* @brief         This service enables or disables a single standard filter.
* @details       This service enables or disables a single standard filter.
*
* @param[in]     Hrh - HRH to which the filter is attached.
* @param[in]     Enabled - Logical value to select if filter is enabled or disabled
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully enabled/disabled.
* @retval        E_NOT_OK  filter was not successfully enabled/disabled.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetFilterState_Activity
*/
Std_ReturnType Can_43_LLCE_SetFilterState(Can_HwHandleType Hrh, Can_43_LLCE_FilterStateType eState);

/*================================================================================================*/
/**
* @brief         This service sets the state of controller in a multicast routing configuration.
* @details       
*
* @param[in]     ControllerId - hardware controller to be enabled or disabled.
* @param[in]     eChannelStatus - enable or disable channel
*
* @return        Std_ReturnType.  Result of the command.
* @retval        E_OK  channel was successfully enabled/disabled.
* @retval        E_NOT_OK  channel was not successfully enabled/disabled.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetChannelRoutingOutputState_Activity
*/
Std_ReturnType Can_43_LLCE_SetChannelRoutingOutputState(uint8 ControllerId, Can_43_LLCE_ChannelStateType eChannelStatus);

/*================================================================================================*/
/**
* @brief         This service forces a deinit of the driver
* @details       When LLCE is not responding and must be reset, this service may be used to allow another init call. 
*
*/
void Can_43_LLCE_ForceDeInit(void);

/*================================================================================================*/

#if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)
    /**
    * @brief          Function called at fixed cyclic time. SID is 0x01.
    * @details        Service for performs the polling of TX confirmation and TX cancellation confirmation when CAN_TX_PROCESSING is set to POLLING.
    *                 This routine is called by:
    *                 - CanIf or an upper layer according to Autosar requirements.
    *
    *
    * @pre            Driver must be initialized.
    * @post           Send the data from that MB that is configured for Tx.
    *
    * @implements     Can_MainFunction_Multiple_Write_Activity
    */
void Can_43_LLCE_MainFunction_Multiple_Write( uint8 writepoll);
#endif /* (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON) */

#if (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON)
    /**
    * @brief          Function called at fixed cyclic time.  SID is 0x08.
    * @details        Service for performs the polling of RX indications when CAN_RX_PROCESSING is set to POLLING.
    *                 This routine is called by:
    *                 - CanIf or an upper layer according to Autosar requirements.
    *
    *
    * @pre            Driver must be initialized.
    * @post           Receive the data from that MB that is configured for Rx.
    *
    * @implements     Can_MainFunction_Multiple_Read_Activity
    */
void Can_43_LLCE_MainFunction_Multiple_Read( uint8 readpoll);
#endif /* (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON) */

#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
/**
* @brief          Function called at fixed cyclic time.
* @details        This Service performs the polling of Error notifications that are configured as 'to be polled'.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
*
* @pre            Driver must be initialized.
* @post           Handle the Error notifications in polling.
*
* @implements     Can_MainFunction_ErrorNotification_Activity
*/
void Can_43_LLCE_MainFunction_ErrorNotification(void);
#endif /* (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON) */

#if (CAN_43_LLCE_API_ENABLE_ABORT_MB == STD_ON)
/**
* @brief          Process a pending transmission abort
* @details        This function requests aborting of the lowest priority pending transmission
*                 of controller ControllerId and returns the hardware transmis handler Hth which
*                 has been freed along with the message tracking information swPduHandle
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      ControllerId - Logical Id of the hardware controller 
* @param[out]     Hth - HW-transmit handler
* @param[out]     swPduHandle - tracking information of the aborted MB
*
* @return         Std_ReturnType.  Result of the abort lowest priority MB service.
* @retval         E_OK  Lowest Priority Message Buffer has been discarded
* @retval         E_NOT_OK  Lowest Priority Message Buffer has not been discarded
*
* @pre            Driver must be initialized; Hardware channel of ControllerId must be started
*
* @note           Not AUTOSAR required. This is user implementation.
* @implements     Can_AbortMb_Activity
*/
Std_ReturnType Can_43_LLCE_AbortMb( Can_HwHandleType Hth);
#endif

#if (CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY == STD_ON)
Std_ReturnType Can_43_LLCE_ManualBusOffRecovery( uint8 ControllerId );
#endif

/* Function used to read the ID of the core currently in use */
static inline uint32 Can_43_LLCE_GetCoreID(void)
{
    uint32 u32CoreId;

    #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) 
        u32CoreId = (uint32)OsIf_GetCoreID();

        /* Check if the CoreId is within range and send 0 if not */
        if(u32CoreId >= CAN_43_LLCE_MAX_PARTITIONS)
        {
            u32CoreId = 0U;
        }
    #else
        u32CoreId = (uint32)0U;
    #endif

    return u32CoreId;
}

/* Utility function to handle reading the global configuration */
static inline const Can_43_LLCE_ConfigType* Can_43_LLCE_GetCurrentConfig(void)
{
    const Can_43_LLCE_ConfigType* pxTempCurrentConfig;
    
    pxTempCurrentConfig = Can_43_LLCE_pCurrentConfig[Can_43_LLCE_GetCoreID()];
    
    return pxTempCurrentConfig;
}

#define CAN_43_LLCE_STOP_SEC_CODE
#include "Can_43_LLCE_MemMap.h"

#ifdef __cplusplus
}
#endif

#endif /* CAN_43_LLCE_H */

/** @} */


===== 文件 [64/112]: include\Can_43_LLCE_IPW.h =====
/**
*   @file    Can_43_LLCE_IPW.h
*   @implements Can_IPW.h_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Main header file - can include different IPV models.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifndef CAN_43_LLCE_IPW_H
#define CAN_43_LLCE_IPW_H

#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Can_Llce.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/**
* @{
* @file           Can_43_LLCE_IPW.h
*/
#define CAN_IPW_VENDOR_ID_H                    43
#define CAN_IPW_AR_RELEASE_MAJOR_VERSION_H     4
#define CAN_IPW_AR_RELEASE_MINOR_VERSION_H     4
#define CAN_IPW_AR_RELEASE_REVISION_VERSION_H  0
#define CAN_IPW_SW_MAJOR_VERSION_H             1
#define CAN_IPW_SW_MINOR_VERSION_H             0
#define CAN_IPW_SW_PATCH_VERSION_H             10
/**@}*/


/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/


/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/
    #define     CAN_43_LLCE_NULL_OFFSET      (LLCE_NULL_OFFSET_U8)

    #define         Can_43_LLCE_IPW_DeInitPlatform()                                            (Can_Llce_DeInitPlatform())

Llce_Fw_ReturnType Can_43_LLCE_IPW_SetCachedCtrlState(uint8 u8HwCtrl);

#if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)
    #if (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE == STD_OFF)
        #define         Can_43_LLCE_IPW_MainFunctionWrite()                                     (Can_Llce_MainFunctionWrite())
    #else
        #define         Can_43_LLCE_IPW_MainFunctionMultipleWritePoll(writepoll)                (Can_Llce_MainFunctionMultipleWritePoll(writepoll))
    #endif
#endif
    
#if (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON)
    #if (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ == STD_OFF)
        #define         Can_43_LLCE_IPW_MainFunctionRead()                                      (Can_Llce_MainFunctionRead())
    #else
        #define         Can_43_LLCE_IPW_MainFunctionMultipleReadPoll(readpoll)                  (Can_Llce_MainFunctionMultipleReadPoll(readpoll))
    #endif 
#endif

#if (CAN_43_LLCE_BUSOFFPOLL_SUPPORTED == STD_ON)
    #define         Can_43_LLCE_IPW_ProcessBusOffPoll(void)                                     (Can_Llce_ProcessBusOffNotification(void))
#endif    

#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
    #define         Can_43_LLCE_IPW_ProcessErrorNotification(void)                              (Can_Llce_ProcessErrorNotification(void))
#endif    

    #define         Can_43_LLCE_IPW_GetFwVersion(pVersionString, u8StringLength) \
                                    (Can_Llce_GetFwVersion(pVersionString, u8StringLength))
                            
    #define         Can_43_LLCE_IPW_SetFilter(pCanFilter)                                       (Can_Llce_SetFilter(pCanFilter))
    
    #define         Can_43_LLCE_IPW_SetFilterAtAddress(pCanFilter, u16FilterAddr)               (Can_Llce_SetFilterAtAddress(pCanFilter, u16FilterAddr))

    #define         Can_43_LLCE_IPW_SetAfFilterAtAddress(pAfFilter, u16FilterAddr)              (Can_Llce_SetAfFilterAtAddress(pAfFilter, u16FilterAddr))

    #define         Can_43_LLCE_IPW_SetAfFilter(pAfFilter)                                      (Can_Llce_SetAfFilter(pAfFilter))

    #define         Can_43_LLCE_IPW_CreateAfDestination(destRule, pu8RuleIdx)                   (Can_Llce_CreateAfDestination(destRule, pu8RuleIdx))

    #define         Can_43_LLCE_IPW_RemoveAfDestination(u8RuleIdx)                              (Can_Llce_RemoveAfDestination(u8RuleIdx))

    #define         Can_43_LLCE_IPW_RemoveFilter(Hrh, u16FilterAddr)                            (Can_Llce_RemoveFilter(Hrh, u16FilterAddr))

    #define         Can_43_LLCE_IPW_SetFilterState(Hrh, eState)                                 (Can_Llce_SetFilterState(Hrh, eState))

    #define         Can_43_LLCE_IPW_EnableNotifInterrupt(u8ActiveHif)                           (Can_Llce_EnableNotifInterrupt(u8ActiveHif))

    #define         Can_43_LLCE_IPW_Shutdown()                                                  (Can_Llce_Shutdown())

#if (CAN_43_LLCE_API_ENABLE_ABORT_MB == STD_ON)
    #define         Can_43_LLCE_Ipw_AborMb(Hth)                    (Can_Llce_AbortMb(Hth))
#endif

#if (CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY == STD_ON)
Std_ReturnType Can_43_LLCE_Ipw_ManualBusOffRecovery(uint8 ControllerId);
#endif

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/

/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/

Llce_Fw_ReturnType Can_43_LLCE_IPW_Init(const Can_43_LLCE_ConfigType * pxCurrentConfig);
Std_ReturnType Can_43_LLCE_IPW_DeInitController(uint8 Controller);
Std_ReturnType Can_43_LLCE_IPW_GetControllerMode(uint8 Controller, Can_ControllerStateType* ControllerModePtr);
Std_ReturnType Can_43_LLCE_IPW_SetControllerMode( uint8 Controller, Can_ControllerStateType Transition);
Std_ReturnType Can_43_LLCE_IPW_GetControllerStatus(uint8 Controller, Llce_Can_GetStatusCmdType* StatusPtr);
Std_ReturnType Can_43_LLCE_IPW_GetControllerErrorState(uint8 Controller,Can_ErrorStateType* ErrorStatePtr);
Std_ReturnType Can_43_LLCE_IPW_GetControllerRxErrorCounter(uint8 Controller, uint8* RxErrorCounterPtr);
Std_ReturnType Can_43_LLCE_IPW_GetControllerTxErrorCounter(uint8 Controller, uint8* TxErrorCounterPtr);
Std_ReturnType Can_43_LLCE_IPW_Write (Can_HwHandleType Hth, const Can_PduType * PduInfo, PduInfoType PduInfoTriggerTransmit);
Std_ReturnType Can_43_LLCE_IPW_ChangeBaudrate(uint8 Controller, uint8 u8BaudrateIndex);
Std_ReturnType Can_43_LLCE_IPW_SetChannelRoutingOutputState(uint8 ControllerId, Can_43_LLCE_ChannelStateType eChannelStatus);
void Can_43_LLCE_IPW_DisableControllerInterrupts(uint8 Controller);
void Can_43_LLCE_IPW_EnableControllerInterrupts(uint8 Controller);
void Can_43_LLCE_IPW_MainFunctionMode(uint8 Controller);

#ifdef __cplusplus
}
#endif

#endif /* CAN_43_LLCE_IPW_H */

/** @} */


===== 文件 [65/112]: include\Can_43_LLCE_IrqConfig.h =====
/**
*   @file    Can_IrqConfig.h
*   
*   @version 1.0.0
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Header file used to map ISRs to specific hardware FIFOs.It shall be synchronised also with the LLCE firmware configuration.
*
*   @addtogroup CAN_LLCE
*   @{
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifndef CAN_43_LLCE_IRQCONFIG_H
#define CAN_43_LLCE_IRQCONFIG_H


#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Llce_RegAccess.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/
#define LLCE_FIFO_TXACK_00_EN   (STD_ON)
#define LLCE_FIFO_TXACK_01_EN   (STD_ON)
#define LLCE_FIFO_TXACK_02_EN   (STD_ON)
#define LLCE_FIFO_TXACK_03_EN   (STD_ON)
#define LLCE_FIFO_TXACK_04_EN   (STD_ON)
#define LLCE_FIFO_TXACK_05_EN   (STD_ON)
#define LLCE_FIFO_TXACK_06_EN   (STD_ON)
#define LLCE_FIFO_TXACK_07_EN   (STD_ON)
#define LLCE_FIFO_TXACK_08_EN   (STD_ON)
#define LLCE_FIFO_TXACK_09_EN   (STD_ON)
#define LLCE_FIFO_TXACK_10_EN   (STD_ON)
#define LLCE_FIFO_TXACK_11_EN   (STD_ON)
#define LLCE_FIFO_TXACK_12_EN   (STD_ON)
#define LLCE_FIFO_TXACK_13_EN   (STD_ON)
#define LLCE_FIFO_TXACK_14_EN   (STD_ON)
#define LLCE_FIFO_TXACK_15_EN   (STD_ON)


#define LLCE_FIFO_RXOUT_00_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_01_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_02_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_03_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_04_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_05_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_06_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_07_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_08_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_09_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_10_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_11_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_12_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_13_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_14_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_15_EN   (STD_ON)


#define LLCE_FIFO_RXIN_00_EN    (STD_ON)
#define LLCE_FIFO_RXIN_01_EN    (STD_OFF) /* It used without interrupt service routine.*/
#define LLCE_FIFO_RXIN_02_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_03_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_04_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_05_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_06_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_07_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_08_EN    (STD_ON)
#define LLCE_FIFO_RXIN_09_EN    (STD_OFF) /* It used without interrupt service routine.*/
#define LLCE_FIFO_RXIN_10_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_11_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_12_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_13_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_14_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_15_EN    (STD_OFF)


#define LLCE_FIFO_TXACK_00_ISR() Can_Llce_ProcessTx(0)
#define LLCE_FIFO_TXACK_01_ISR() Can_Llce_ProcessTx(1)
#define LLCE_FIFO_TXACK_02_ISR() Can_Llce_ProcessTx(2)
#define LLCE_FIFO_TXACK_03_ISR() Can_Llce_ProcessTx(3)
#define LLCE_FIFO_TXACK_04_ISR() Can_Llce_ProcessTx(4)
#define LLCE_FIFO_TXACK_05_ISR() Can_Llce_ProcessTx(5)
#define LLCE_FIFO_TXACK_06_ISR() Can_Llce_ProcessTx(6)
#define LLCE_FIFO_TXACK_07_ISR() Can_Llce_ProcessTx(7)
#define LLCE_FIFO_TXACK_08_ISR() Can_Llce_ProcessTx(8)
#define LLCE_FIFO_TXACK_09_ISR() Can_Llce_ProcessTx(9)
#define LLCE_FIFO_TXACK_10_ISR() Can_Llce_ProcessTx(10)
#define LLCE_FIFO_TXACK_11_ISR() Can_Llce_ProcessTx(11)
#define LLCE_FIFO_TXACK_12_ISR() Can_Llce_ProcessTx(12)
#define LLCE_FIFO_TXACK_13_ISR() Can_Llce_ProcessTx(13)
#define LLCE_FIFO_TXACK_14_ISR() Can_Llce_ProcessTx(14)
#define LLCE_FIFO_TXACK_15_ISR() Can_Llce_ProcessTx(15)


#define LLCE_FIFO_RXOUT_00_ISR() Can_Llce_ProcessRx(0)
#define LLCE_FIFO_RXOUT_01_ISR() Can_Llce_ProcessRx(1)
#define LLCE_FIFO_RXOUT_02_ISR() Can_Llce_ProcessRx(2)
#define LLCE_FIFO_RXOUT_03_ISR() Can_Llce_ProcessRx(3)
#define LLCE_FIFO_RXOUT_04_ISR() Can_Llce_ProcessRx(4)
#define LLCE_FIFO_RXOUT_05_ISR() Can_Llce_ProcessRx(5)
#define LLCE_FIFO_RXOUT_06_ISR() Can_Llce_ProcessRx(6)
#define LLCE_FIFO_RXOUT_07_ISR() Can_Llce_ProcessRx(7)
#define LLCE_FIFO_RXOUT_08_ISR() Can_Llce_ProcessRx(8)
#define LLCE_FIFO_RXOUT_09_ISR() Can_Llce_ProcessRx(9)
#define LLCE_FIFO_RXOUT_10_ISR() Can_Llce_ProcessRx(10)
#define LLCE_FIFO_RXOUT_11_ISR() Can_Llce_ProcessRx(11)
#define LLCE_FIFO_RXOUT_12_ISR() Can_Llce_ProcessRx(12)
#define LLCE_FIFO_RXOUT_13_ISR() Can_Llce_ProcessRx(13)
#define LLCE_FIFO_RXOUT_14_ISR() Can_Llce_ProcessRx(14)
#define LLCE_FIFO_RXOUT_15_ISR() Can_Llce_ProcessRx(15)


#define LLCE_FIFO_RXIN_00_ISR() Can_Llce_ProcessNotificationISR()
#define LLCE_FIFO_RXIN_01_ISR() 
#define LLCE_FIFO_RXIN_02_ISR() 
#define LLCE_FIFO_RXIN_03_ISR() 
#define LLCE_FIFO_RXIN_04_ISR() 
#define LLCE_FIFO_RXIN_05_ISR() 
#define LLCE_FIFO_RXIN_06_ISR() 
#define LLCE_FIFO_RXIN_07_ISR() 
#define LLCE_FIFO_RXIN_08_ISR() Can_Llce_ProcessNotificationISR()
#define LLCE_FIFO_RXIN_09_ISR() 
#define LLCE_FIFO_RXIN_10_ISR() 
#define LLCE_FIFO_RXIN_11_ISR() 
#define LLCE_FIFO_RXIN_12_ISR() 
#define LLCE_FIFO_RXIN_13_ISR() 
#define LLCE_FIFO_RXIN_14_ISR() 
#define LLCE_FIFO_RXIN_15_ISR() 

/*==================================================================================================
*                                      Interrupts
==================================================================================================*/

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/   
   
/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/
  
/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/


#ifdef __cplusplus
}
#endif

#endif /* CAN_43_LLCE_IRQCONFIG_H */

/** @} */


===== 文件 [66/112]: include\Can_Callback.h =====
/**
*   @file    Can_Callback.h
*   @version 1.0.10
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifndef CAN_43_LLCE_CALLBACK_H
#define CAN_43_LLCE_CALLBACK_H

#include "Can_43_LLCE_Cfg.h"
#if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
    #include "Can_43_LLCE.h"
    #include "CanIf_Can.h"

#endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
#include "Reg_eSys_Llce.h"


void Can_43_LLCE_ReportError(uint8 sid , uint8 eTransition);
void Can_43_LLCE_ReportRuntimeError(uint8 sid , uint8 eTransition);
void Can_43_LLCE_TxConfirmation(uint16 tag);
void Can_43_LLCE_RxIndication(uint32 u32MbMessageId, uint16 u16FilterId, uint8* u8FramePayload, uint8 u8MbDataLength);
void Can_43_LLCE_ControllerBusOff(uint8 u8HwCtrl);
void Can_43_LLCE_ControllerModeIndication(uint8 u8HwCtrl, Can_ControllerStateType ctrlState);
void Can_Hth_FreeTxObject(uint16 Hth, uint8 freeObjCount);





#endif /* CAN_43_LLCE_CALLBACK_H */


===== 文件 [67/112]: include\Can_Llce.h =====
/**
*   @file    Can_Llce.h
*   @implements Can_Llce.h_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - LLD module interface.
*   @details Low Level Driver header file for IPV = Llce.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/



#ifndef CAN_LLCE_H
#define CAN_LLCE_H


#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

/*  (CAN222) Imported types: Dem_Types.h, CanIf_Types.h, Std_Types.h, ComStackTypes.h */
/*
* @file           Can_Llce.h
*/


#include "Llce_RegAccess.h"
#include "Reg_eSys_Llce.h"
#include "Can_GeneralTypes.h"
#include "ComStackTypes.h"
#include "CanIf_Can.h"
#include "Mcal.h"
#include "Can_43_LLCE.h"
#include "Can_43_LLCE_AFcfg.h"
#include "Llce_InterfaceCanTypes.h"


/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/**
* @file           Can_Llce.h
*/
#define CAN_LLCE_VENDOR_ID_H                    43
#define CAN_LLCE_AR_RELEASE_MAJOR_VERSION_H     4
#define CAN_LLCE_AR_RELEASE_MINOR_VERSION_H     4
#define CAN_LLCE_AR_RELEASE_REVISION_VERSION_H  0
#define CAN_LLCE_SW_MAJOR_VERSION_H             1
#define CAN_LLCE_SW_MINOR_VERSION_H             0
#define CAN_LLCE_SW_PATCH_VERSION_H             10

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/

/** @brief   STM timer used for performance measurements. */
#ifdef CAN_43_LLCE_STM_MEASUREMENT_ENABLE
    #define LLCE_STM_BASEADDR          ((uint32)0x43C1A000UL)
    #define LLCE_STM_CR                 (LLCE_STM_BASEADDR)
    #define LLCE_STM_CNT                (LLCE_STM_BASEADDR + 4 )
#endif

#if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U)
#define CAN_LLCE_FILTER_DEFAULT_EMPTY_ADDRESS_U16   ((uint16)0xFFFF)
#endif

#define LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32   ((uint32)0x00000200U) /**< @brief   Enable interrupt on receive.*/
#define LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32   ((uint32)0x00000100U) /**< @brief   Enable interrupt on transmit.*/
#define LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32   ((uint32)0x00001000U) /**< @brief   Enable interrupt mode for Bus off.*/
#define LLCE_CAN_REFERENCE_NOT_USED              ((uint8)0xFFU)  /**< @brief   R/W period reference not used */

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/**
* @brief          CAN Interrupts state.
* @details        CAN Interrupts state.
*
*/
typedef enum
{
    CAN_INTERRUPT_DISABLED = 0U,  /*< @brief Interrupts disabled */
    CAN_INTERRUPT_ENABLED         /*< @brief Interrupts enabled */
} Can_InterruptStateType;

#if(LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0)
/**
* @brief          Can2Eth state type
*
*/
typedef enum
{
    CAN_LLCE_CAN2ETH_DISABLED = 0U,
    CAN_LLCE_CAN2ETH_ENABLED
} Can_Llce_Can2EthStateType;
#endif

#if(LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON)
/**
* @brief          Eth2Can state type
*
*/
typedef enum
{
    CAN_LLCE_ETH2CAN_DISABLED = 0U,
    CAN_LLCE_ETH2CAN_ENABLED
} Can_Llce_Eth2CanStateType;
#endif

#if LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0
/**
* @brief          Can2Pcie state type
*
*/
typedef enum
{
    CAN_LLCE_CAN2PCIE_DISABLED = 0U,
    CAN_LLCE_CAN2PCIE_ENABLED
} Can_Llce_Can2PcieStateType;
#endif
/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/
    
/**
* @brief          Records the status of a CAN Controller during runtime.
* @details        Records the status of a CAN Controller during runtime.
*
* @note           This structure is not configured by Tresos.
*/
typedef struct
    {
        uint8 u8IntDisableLevel; /*< @brief Storage space for Can_43_LLCE_DisableControllerInterrupts nesting level */
        
        Can_InterruptStateType eInterruptMode; /*< @brief Global interrupt authorization state */
        
        Can_ControllerStateType eCachedControllerState; /*< @brief Local copy of controller state */

        Can_InterruptStateType eSetIntEnRequest;   /*< @brief Interrupt Enable Request for given controller */

    } Can_43_LLCE_ControllerStatusType;


/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/

/*==================================================================================================
*                                           MACROS
=====================================================================================================*/
    
/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_CODE

#include "Can_43_LLCE_MemMap.h"

Llce_Fw_ReturnType Can_Llce_Init( const Can_43_LLCE_ConfigType * pxCurrentConfig);

#if((LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON))
Std_ReturnType Can_Llce_Init_PfeIf( uint8 Hif);
Std_ReturnType Can_Llce_Start_PfeIf(void);
#endif

#if(LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0)
Std_ReturnType Can_Llce_SetCan2EthState(Can_Llce_Can2EthStateType eState);
#endif

#if (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON)
Llce_Fw_ReturnType Can_Llce_SetEth2CanFormatState(Llce_Can_EthEncapsulationFormat eFormat, Can_Llce_Eth2CanStateType eState);
#endif 

#if LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0
Std_ReturnType Can_Llce_SetCan2PcieState(Can_Llce_Can2PcieStateType eState);
#endif

Std_ReturnType Can_Llce_DeInitController(uint8 u8HwCtrl);

Std_ReturnType Can_Llce_DeInitPlatform(void);

Std_ReturnType Can_Llce_Shutdown(void);

Std_ReturnType Can_Llce_ChangeBaudrate(uint8 u8HwCtrl, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr);

Std_ReturnType Can_Llce_GetControllerMode(uint8 u8HwCtrl, Can_ControllerStateType * ControllerModePtr);

Std_ReturnType Can_Llce_SetControllerMode(uint8 u8HwCtrl, Can_ControllerStateType Transition, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr);

void Can_Llce_DisableControllerInterrupts(uint8 u8HwCtrl);
void Can_Llce_EnableControllerInterrupts(uint8 u8HwCtrl);

void Can_Llce_EnableNotifInterrupt(uint8 u8ActiveHif);
void Can_Llce_DisableNotifInterrupt(uint8 u8ActiveHif);

Std_ReturnType Can_Llce_Write(uint8 u8HwCtrl, Can_43_LLCE_TxFrameInfoType* TxFrameInfo);

void Can_Llce_ProcessTx(const uint8 u8AckInterface );

#if (CAN_43_LLCE_BUSOFFPOLL_SUPPORTED == STD_ON)
void Can_Llce_ProcessBusOffNotification(void);
#endif /* (CAN_43_LLCE_BUSOFFPOLL_SUPPORTED == STD_ON) */

#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
void Can_Llce_ProcessErrorNotification(void);
#endif /* (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON) */

void Can_Llce_ProcessNotificationISR(void);

void Can_Llce_ProcessRx(const uint8 u8RxInterface);

#if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)

void Can_Llce_MainFunctionWrite(void);

void Can_Llce_MainFunctionMultipleWritePoll(uint8 writepoll);

#endif /* (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON) */

#if (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON)

void Can_Llce_MainFunctionRead(void);

void Can_Llce_MainFunctionMultipleReadPoll(uint8 readpoll);

#endif /* (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON) */

void Can_Llce_MainFunctionMode(uint8 u8HwCtrl);
Std_ReturnType Can_Llce_GetControllerErrorState(uint8 u8HwCtrl, Can_ErrorStateType * ErrorStatePtr);
Std_ReturnType Can_Llce_GetControllerRxErrorCounter(uint8 u8HwCtrl, uint8 * RxErrorCounterPtr);
Std_ReturnType Can_Llce_GetControllerTxErrorCounter(uint8 u8HwCtrl, uint8 * TxErrorCounterPtr);
Std_ReturnType Can_Llce_GetControllerStatus(uint8 u8HwCtrl, Llce_Can_GetStatusCmdType * StatusPtr);

Std_ReturnType Can_Llce_GetFwVersion(const uint8 ** pVersionString, uint8 * pStringLength);
Std_ReturnType Can_Llce_SetFilter(const Can_SetFilterType * pCanFilter);
Std_ReturnType Can_Llce_SetFilterAtAddress(const Can_SetFilterType * pCanFilter, const uint16 u16FilterAddr);
Std_ReturnType Can_Llce_SetAfFilterAtAddress(const Can_SetAfFilterType * pAfFilter, const uint16 u16FilterAddr);
Std_ReturnType Can_Llce_CreateAfDestination(Can_Af_DestRulesType destRule, uint8* pu8RuleIdx);
Std_ReturnType Can_Llce_RemoveAfDestination(uint8 u8RuleIdx);
Std_ReturnType Can_Llce_SetAfFilter(const Can_SetAfFilterType * pAfFilter);
Std_ReturnType Can_Llce_RemoveFilter(Can_HwHandleType Hrh, uint16* u16FilterAddr);
Std_ReturnType Can_Llce_SetFilterState(Can_HwHandleType Hrh, Can_43_LLCE_FilterStateType eState);
Std_ReturnType Can_Llce_SetChannelRoutingOutputState(uint8 u8HwCtrl, Can_43_LLCE_ChannelStateType eChannelStatus);

Std_ReturnType Can_Llce_ExecuteCustomCommand(const void* const argument);

#if (CAN_43_LLCE_API_ENABLE_ABORT_MB == STD_ON)
Std_ReturnType Can_Llce_AbortMb(Can_HwHandleType Hth);
#endif

#if (CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY == STD_ON)
Std_ReturnType Can_Llce_ManualBusOffRecovery(uint8 u8HwCtrl);
#endif

#define CAN_43_LLCE_STOP_SEC_CODE

#include "Can_43_LLCE_MemMap.h"

#ifdef __cplusplus
}
#endif

#endif /* CAN_LLCE_H */

/** @} */


===== 文件 [68/112]: include\Can_Llce_Types.h =====
/**
*   @file    Can_Llce_Types.h
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface.
*   @details API header for CAN driver.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/


#ifndef CAN_LLCE_TYPES_H
#define CAN_LLCE_TYPES_H

#ifdef __cplusplus
extern "C"{
#endif



/**
* @file           Can_Llce_Types.h
*/

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

#include "Can_43_LLCE_Cfg.h"
#include "Llce_InterfaceCanTypes.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/
/**
* @{
* @brief          Development errors.
* @details        (CAN104) The Can module shall be able to detect the following errors and exceptions depending on its configuration (development/production).
*                 (CAN026) Development Errors shall indicate errors that are caused by erroneous usage of the Can module API. This covers API
*                   parameter checks and call sequence errors.
*                 (CAN080) Development error values are of type uint8.
*
*/
#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)

    #define CAN_43_LLCE_E_PARAM_POINTER      ((uint8)0x01U)
    #define CAN_43_LLCE_E_PARAM_HANDLE       ((uint8)0x02U)
    #define CAN_43_LLCE_E_PARAM_DATA_LENGTH  ((uint8)0x03U)
    #define CAN_43_LLCE_E_PARAM_CONTROLLER   ((uint8)0x04U)
    #define CAN_43_LLCE_E_UNINIT             ((uint8)0x05U)

#endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

#define CAN_43_LLCE_E_TRANSITION         ((uint8)0x06U)

#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)

#if (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON)
    #define CAN_43_LLCE_E_PARAM_BAUDRATE     ((uint8)0x07U)
#endif

    #define CAN_43_LLCE_E_PARAM_CONFIG       ((uint8)0x08U)

    #define CAN_43_LLCE_E_INIT_FAILED        ((uint8)0x09U)

    #define CAN_43_LLCE_E_LLCE_FAILED        ((uint8)0x0AU) /* FIFO Interface communication failed. 1 TX token is lost. Requires controller restart. */

#endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

/**@}*/

/**
* @{
* @brief          Runtime errors.
*
*/
#define CAN_43_LLCE_E_DATALOST           ((uint8)0x01U)

/**@}*/

/**
* @{
* @brief          Service ID (APIs) for Det reporting
*
*/
#define CAN_43_LLCE_SID_INIT                          ((uint8)0x00U)
#define CAN_43_LLCE_SID_CREATE_DESTINATION            ((uint8)0x01U)
#define CAN_43_LLCE_SID_SET_CONTROLLER_MODE           ((uint8)0x03U)

#define CAN_43_LLCE_SID_DISABLE_CONTROLLER_INTERRUPTS ((uint8)0x04U)
#define CAN_43_LLCE_SID_ENABLE_CONTROLLER_INTERRUPTS  ((uint8)0x05U)
#define CAN_43_LLCE_SID_WRITE                         ((uint8)0x06U)

#if (CAN_43_LLCE_VERSION_INFO_API == STD_ON)
#define CAN_43_LLCE_SID_GET_VERSION_INFO              ((uint8)0x07U)
#endif

#define CAN_43_LLCE_SID_CBK_CHECK_WAKEUP              ((uint8)0x0BU)

#if (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON)
#define CAN_43_LLCE_SID_SET_BAUDRATE                  ((uint8)0x0FU)
#endif

#define CAN_43_LLCE_SID_DEINIT                            ((uint8)0x10U)
#define CAN_43_LLCE_SID_GETCONTROLLERERRORSTATE           ((uint8)0x11U)
#define CAN_43_LLCE_SID_GETCONTROLLERMODE                 ((uint8)0x12U)
#define CAN_43_LLCE_SID_GET_CTRL_RX_ERROR_COUNTER         ((uint8)0x13U)
#define CAN_43_LLCE_SID_GET_CTRL_TX_ERROR_COUNTER         ((uint8)0x14U)

#define CAN_43_LLCE_SID_PROCESS_NOTIFICATION_ISR          ((uint8)0x15U)
#define CAN_43_LLCE_SID_REMOVE_DESTINATION                ((uint8)0x16U)
#define CAN_43_LLCE_SID_SET_FILTER                        ((uint8)0x17U)
#define CAN_43_LLCE_SID_REMOVE_FILTER                     ((uint8)0x18U)
#define CAN_43_LLCE_SID_SET_FILTER_ENABLE_STATE           ((uint8)0x1AU)
#define CAN_43_LLCE_SID_SETCHANNEL_ROUTING_OUTPUTSTATE    ((uint8)0x1BU)

#if (CAN_43_LLCE_API_ENABLE_ABORT_MB == STD_ON)
#define CAN_43_LLCE_SID_ABORT_LOWEST_PRIO_MB          ((uint8)0x19U)
#endif

#if (CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY == STD_ON)
#define CAN_43_LLCE_SID_MANUAL_BUSOFF_RECOVERY        ((uint8)0x20U)
#endif


/*==================================================================================================
                                 STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/
typedef struct 
{
    uint32 u32MessageId;
    uint32 u32TxHseKeyHandle;
    uint32 u32SduLength;
    uint16 u16FrameTag1;
    uint16 u16FrameTag2;
    uint16 u16MbFrameIdx;
    uint8 u8AckInterface;
    uint8 u8EnableTxFrameMac;    
    uint8 u8FdEnabled;
    uint8 u8FdPaddingValue;
    const uint8* u8SduDataPtr;
    
}Can_43_LLCE_TxFrameInfoType;



#ifdef __cplusplus
}
#endif

#endif /* CAN_LLCE_TYPES_H */

/** @} */


===== 文件 [69/112]: include\Llce_FwVersion.h =====
/**
 *   @file    Llce_FwVersion.h
 *
 *   @brief   LLCE Version module data structures and defines
 *   @details This file contains the LLCE Version data structures, defines and
 *            function declarations to specify the version information included
 *            in the binaries.
 *
 *   @addtogroup LLCE_version LLCE firmware version
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_FW_VERSION_H
#define LLCE_FW_VERSION_H

#ifdef __cplusplus
extern "C" {
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
#include "Llce_RegAccess.h"

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/
#define LLCE_VERSION_MAX_LENGTH 50

/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/
/**
 * @brief Firmware version datatype.
 * It contains the versionString which encodes the 
 * firmware image characteristics, such as: build time,
 * target derivative and the versions of each feature
 **/
typedef struct
{
    /** @brief OUTPUT: LLCE FW version string actual length. */
    uint8 stringLength;
    /** @brief OUTPUT: LLCE FW version string. */
    uint8 versionString[LLCE_VERSION_MAX_LENGTH];
} LLCE__ALIGNED__PACKED Llce_Fw_VersionType;

/*==================================================================================================
 *                                GLOBAL VARIABLE DECLARATIONS
 ==================================================================================================*/

#ifdef __cplusplus
}
#endif

#endif /* LLCE_FW_VERSION_H*/

/** @} */


===== 文件 [70/112]: include\Llce_InterfaceCanConfig.h =====
/**
 *   @file    Llce_InterfaceCanConfig.h
 *
 *   @brief LLCE defines used to configure the LLCE firmware and interface
 *   @details LLCE  defines used to configure the LLCE firmware and interface.
 *                  Those configuration parameters are used both by LLCE
 *                  firmware and host software.
 *
 *
 *   @addtogroup Llce_configuration LLCE precompile configuration parameters
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_INTERFACECONFIG_H
#define LLCE_INTERFACECONFIG_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __DOXYGEN__
/**
 *
 * @page misra_violations MISRA-C:2012 violations
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 2.5, A project should not contain unused
 * macro declarations Some macros are used either in FW or driver, or provided
 * as API
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 2.3, A project should not contain unused
 * type declarations. Some type declarations are used either in FW or driver, or
 * provided as API
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.1, Identifiers (internal and external)
 * shall not rely on the significance of more than 31 characters. The used
 * compilers use more than 31 chars for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.2, Identifiers declared in the same scope
 * and name space shall be distinct. The used compilers use more than 31 chars
 * for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.4, Macro identifiers shall be distinct.
 * The used compilers use more than 31 chars for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.5, Identifiers shall be distinct from
 * macro names. The identifier clash is between macro identifiers. Therefore,
 * this rule is incorrectly reported by the tool.
 */
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
#include "Llce_RegAccess.h"
#include "Llce_InterfaceFwMgr.h"
#include "Llce_Sema42.h"

/*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/

/* LLCE configuration parameters.*/
/**
 * @brief Default controller ID needed by the host 0 interface in order to
 * transmit INIT_PLATFORM and DEINIT_PLATFORM commands from host to LLCE.
 */
#define LLCE_CAN_CONFIG_DEFAULT_CAN_CTRL_HOST0_U8 ((uint8)0U)
/**
 * @brief Default controller ID needed by the host 1 interface in order to
 * transmit INIT_PLATFORM and DEINIT_PLATFORM commands from host to LLCE.
 */
#define LLCE_CAN_CONFIG_DEFAULT_CAN_CTRL_HOST1_U8 ((uint8)8U)

/**
 * @brief Maximum number of notifications which can be reported by LLCE
 * to host.
 */
#define LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE (17U)
/**
 * @brief Maximum buffer size used to store the CAN FD frame payload.
 * See \link Llce_Can_MbType \endlink
 */
#define LLCE_CAN_CONFIG_PAYLOAD_MAX_SIZE (64U)
/**
 * @brief Maximum buffer size used to store the short CAN FD frame payload.
 * See \link Llce_Can_ShortMbType \endlink
 */
#define LLCE_CAN_CONFIG_SHORT_PAYLOAD_MAX_SIZE (8U)
/**
 * @brief Maximum number of hardware controllers usable inside LLCE.
 * See \link Llce_Can_InitCmdType \endlink
 */
#define LLCE_CAN_CONFIG_MAXCTRL_COUNT (16U)
/**
 * @brief Maximum number of polling classes usable inside LLCE.
 * A polling class is used to tie together multiple filters which
 * report the received frames in polling.
 * See \link Llce_Can_InitCmdType \endlink
 */
#define LLCE_CAN_MAX_POLLING_CLASSES (6U)

/**
 * @brief Maximum number of transmission message buffers.
 * See \link Llce_Can_TxMbDescriptorType \endlink
 */
#define LLCE_CAN_CONFIG_MAXTXMB (256U)
/**
 * @brief Maximum number of 64B reception message buffers.
 * Note: 32 from those are reserved
 * for internal usage and are not available to the host.
 * See \link Llce_Can_RxMbDescriptorType \endlink
 */
#define LLCE_CAN_CONFIG_MAXRXMB (1732U)

/**
 * @brief Maximum number of 8B reception message buffers.
 * for internal usage and are not available to the host.
 * See \link Llce_Can_RxMbDescriptorType \endlink
 */
#define LLCE_CAN_CONFIG_MAX_SHORTRXMB (2396U)


/**
 * @brief Number of AF descriptors reserved for each
 * internal path within LLCE frame routing
*/
#define LLCE_CAN_CONFIG_MAXAFRXMB (256U)
#define LLCE_CAN_CONFIG_MAXAFTXMB (256U)
#define LLCE_CAN_CONFIG_MAXAFFRMB (256U)

/**
 * @brief Maximum number of standard filters which can be configured using
 * using a single command. Multiple commands can be executed when more filters
 * are needed.
 * See \link Llce_Can_ReceiveFilterType \endlink
 */
#define LLCE_CAN_CONFIG_MAX_FILTERS_COUNT ((uint16)20U)
/**
 * @brief Number of entries of the circular buffer used to send ack information
 * from TX core to host core. There is 1 extra buffer for each interface for
 * consistency purpose.
 */
#define LLCE_CAN_CONFIG_MAX_TXACKINFO ((uint16)(512U + LLCE_CAN_RX_TX_INTERFACES))
/**
 * @brief Mask used to get the right data from FIFOs.
 * See FMR config register of FIFO.
 */
#define LLCE_CAN_CONFIG_FIFO_FIXED_MASK_U32 ((uint32)0x0007FFFF)
/**
 * @brief Maximum number of advanced filters which can be configured using a
 * single command. Multiple commands can be executed when more filters are
 * needed.
 * See \link Llce_Can_AdvancedFilterType \endlink
 */
#define LLCE_CAN_CONFIG_ADVANCED_FILTERS_COUNT (8U)
/**
 * @brief Shared memory size allocated for each channel for
 * commands exchange.
 */
#define LLCE_CAN_CONFIG_CTRL_SHARED_MEMORY_SIZE ((uint32)0x400)
/**
 * @brief Reserved value in order to detect if an advanced filter entry
 * is not used.
 */
#define LLCE_CAN_ADVANCED_FILTER_NOT_USED (0xFFU)
/** @brief Interface ID used by different hosts for multihost scenarios. */
#define LLCE_CAN_HIF0 (0U)
/** @brief Interface ID used by different hosts for multihost scenarios. */
#define LLCE_CAN_HIF1 (1U)
/** @brief Number of interfaces which can be used by host cores. */
#define LLCE_CAN_CONFIG_HIF_COUNT (2U)
/** @brief Number of semaphores for each HIF. */
#define LLCE_CAN_CONFIG_IER_SEMA4_COUNT   (2U)
/** @brief Index of FIFO_RXOUT inside Can_Sema4_Ier array. */
#define LLCE_FIFO_RXOUT_INDEX             (0U)
/** @brief Index of FIFO_TXACK inside Can_Sema4_Ier array. */
#define LLCE_FIFO_TXACK_INDEX             (1U)
/** @brief Number of FIFOs used by first HIF. */
#define LLCE_CAN_HIF0_FIFO_CNT            (8U)
/** @brief Semaphore core domain */
#define LLCE_HOST_CORE_SEMA42_DOMAIN         (LLCE_SEMA42_GR_GTFSM_9)
/** @brief No result from RxLut2 */
#define LLCE_RXLUT2_NO_RESULT             ((uint16)0xFFFFU)


/* LIN defines */
/** @brief Maximum buffer size used to store the LIN frame payload */
#define LLCE_LIN_CONFIG_PAYLOAD_MAX_SIZE (8U)
/** @brief Maximum number of LIN transmission buffers */
#define LLCE_LIN_CONFIG_MAXTXBUFF (64U)
/** @brief Maximum number of LIN reception buffers */
#define LLCE_LIN_CONFIG_MAXRXBUFF (64U)

/*==================================================================================================
 *                                      Interrupts
 ==================================================================================================*/

/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/*==================================================================================================
 *                                STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/

/*==================================================================================================
 *                                GLOBAL VARIABLE DECLARATIONS
 ==================================================================================================*/

/*==================================================================================================
 *                                    FUNCTION PROTOTYPES
 ==================================================================================================*/
 
void DisableFifoInterrupts (uint8 u8FifoInterface, uint8 u8Hif);
void EnableFifoInterrupts (uint8 u8FifoInterface, uint8 u8Hif);

#ifdef __cplusplus
}
#endif

#endif /* LLCE_FIFO_H */

/** @} */


===== 文件 [71/112]: include\Llce_InterfaceCanTypes.h =====
/**
 *   @file    Llce_InterfaceCanTypes.h
 *
 *   @brief   LLCE data structures used to implement the LLCE interface
 *   @details This file contains data structures used to implement the LLCE
 *            interface
 *
 *   @addtogroup LLCE_CAN_firmware_interface LLCE CAN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/
#ifndef LLCE_INTERFACECANTYPES_H
#define LLCE_INTERFACECANTYPES_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __DOXYGEN__
/**
 *
 * @page misra_violations MISRA-C:2012 violations
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 2.3, A project should not contain unused
 * type declarations Some types are used either in FW or driver, or provided as
 * API
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 2.5, A project should not contain unused
 * macro declarations Some macros are used either in FW or driver, or provided
 * as API
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.1, Identifiers (internal and external)
 * shall not rely on the significance of more than 31 characters. The used
 * compilers use more than 31 chars for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.2, Identifiers declared in the same scope
 * and name space shall be distinct. The used compilers use more than 31 chars
 * for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.4, Macro identifiers shall be distinct.
 * The used compilers use more than 31 chars for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.5, Identifiers shall be distinct from
 * macro names. The identifier clash is between macro identifiers. Therefore,
 * this rule is incorrectly reported by the tool.
 *
 * @section Llce_InterfaceCanTypes_h_REF_1
 * Violates MISRA 2012 Required Rule 21.1, #define and #undef shall not be used
 * on a reserved identifier or reserved macro name. The #define is enabled only
 * when PC-LINT analyses the code as a workaround for a bug in the tool (it
 * doesn't recognize structure name when __attribute__ keyword prefixes it).
 *
 * @section Llce_InterfaceCanTypes_h_REF_2
 * Violates MISRA 2012 Advisory Rule 4.9, A function should be used in
 * preference to a function-like macro where they are interchangeable. The
 * #define is enabled only when PC-LINT analyses the code as a workaround for a
 * bug in the tool (it doesn't recognize structure name when __attribute__
 * keyword prefixes it).
 */
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
#ifdef CHECK_ABI_COMPATIBILITY
#pragma ABICHECK stop
#endif

#include "Llce_RegAccess.h"
#include "Llce_InterfaceCanConfig.h"
#include "Llce_FwVersion.h"
#include "Llce_InterfaceFwMgr.h"

#ifdef CHECK_ABI_COMPATIBILITY
#pragma ABICHECK start
#endif
/*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/
/**
 * @{
 * @brief Offset bits for NCBT register
 */
#define LLCE_NCBT_NPRESDIV_SHIFT_U8 ((uint8)23U)
#define LLCE_NCBT_NRJW_SHIFT_U8 ((uint8)16U)
#define LLCE_NCBT_NTSEG2_SHIFT_U8 ((uint8)9U)
/**@}*/

/**
 * @{
 * @brief Offset bits for DCBT register
 */
#define LLCE_DCBT_DPRESDIV_SHIFT_U8 ((uint8)23U)
#define LLCE_DCBT_DRJW_SHIFT_U8 ((uint8)16U)
#define LLCE_DCBT_DTSEG2_SHIFT_U8 ((uint8)9U)
/**@}*/

/*==================================================================================================
 *                                CONTROLLER OPTIONS
 ==================================================================================================*/
/**
 * @brief Controller option used by the initialization command in order to
 * inform LLCE firmware that a specific controller shall be initialized.
 * See \link Llce_Can_InitCmdType \endlink
 */
#define LLCE_CAN_CONTROLLERCONFIG_CTRL_EN_U32 ((uint32)0x10000000U)
/**
 * @brief CAN controller option used to enable reporting of the Protocol
 * Exception errors.
 * See \link Llce_Can_GetStatusCmdType \endlink
 */
#define LLCE_CAN_CONTROLLERCONFIG_PE_EN_U32 ((uint32)0x00040000U)
/** @brief CAN controller option used to enable Timestamp feature. */
#define LLCE_CAN_CONTROLLERCONFIG_TST_END_U32 ((uint32)0x00080000U)
/**
 * @brief CAN controller option used to enable Timestamp feature at the start
 * of the CAN frame.
 */
#define LLCE_CAN_CONTROLLERCONFIG_TST_START_U32 ((uint32)0x00000080U)
/**
 * @brief CAN controller option used to enable Timestamp feature in the start of
 * frame for classical CAN frames and in the res bit for CAN FD frames.
 */
#define LLCE_CAN_CONTROLLERCONFIG_TST_FD_U32 ((uint32)0x00000040U)
/** @brief CAN controller option used to enable Listen-Only mode. */
#define LLCE_CAN_CONTROLLERCONFIG_LOM_EN_U32 ((uint32)0x00100000U)
/** @brief CAN controller option used to enable internal LoopBack mode. */
#define LLCE_CAN_CONTROLLERCONFIG_LPB_EN_U32 ((uint32)0x00200000U)
/** @brief CAN controller option used to enable self-reception mode. */
#define LLCE_CAN_CONTROLLERCONFIG_SRX_EN_U32 ((uint32)0x00400000U)
/**< @brief   CAN controller option used to enable automatic bus-off recovery. */
#define LLCE_CAN_CONTROLLERCONFIG_ABR_EN_U32  ((uint32)0x00000001U) 
/**< @brief   CAN controller option used to enable TX FIFO mode. */
#define LLCE_CAN_CONTROLLERCONFIG_TXFIFO_EN_U32  ((uint32)0x00000002U) 
/**< @brief   CAN controller option used to enable manual bus-off recovery. */
#define LLCE_CAN_CONTROLLERCONFIG_MBR_EN_U32  ((uint32)0x00000004U) 
/**
 * @brief Number of interfaces used for interrupt reporting
 * (one per channel) + number of polling classes.
 */
#define LLCE_CAN_RX_TX_INTERFACES                                              \
    ((uint8)(LLCE_CAN_CONFIG_MAXCTRL_COUNT + LLCE_CAN_MAX_POLLING_CLASSES))
/**
 * @brief Default value in the transmission request informing LLCE that tx
 * confirmation is not needed for that frame.
 */
#define LLCE_CAN_ACK_DISABLED ((uint8)0xADU)
#define LLCE_CAN_PARAM_NOT_USED ((uint8)0xFFU)

/*==================================================================================================
                 DEFINES SHARED BETWEEN HOST AND LLCE
==================================================================================================*/
/** @brief Frame DLC field mask. */
#define LLCE_CAN_MB_DLC_MASK_U32 ((uint32)0x0000000FU)
/** @brief Frame ID field mask. */
#define LLCE_CAN_MB_ID_MASK_U32 ((uint32)0x1FFFFFFFU)
/** @brief Frame FDF field mask. */
#define LLCE_CAN_MB_FDF_U32 ((uint32)0x00008000U)
/** @brief Frame BRS field mask. */
#define LLCE_CAN_MB_BRS_U32 ((uint32)0x00010000U)
/** @brief Frame ESI field mask. */
#define LLCE_CAN_MB_ESI_U32 ((uint32)0x00020000U)
/** @brief Frame IDE field mask. */
#define LLCE_CAN_MB_IDE_U32 ((uint32)0x40000000U)
/** @brief Frame RTR field mask. */
#define LLCE_CAN_MB_RTR_U32 ((uint32)0x80000000U)
/** @brief Frame standard ID field mask. */
#define LLCE_CAN_MB_IDSTD_MASK_U32 ((uint32)0x1FFC0000U)
/** @brief Frame extended ID field mask. */
#define LLCE_CAN_MB_IDEXT_MASK_U32 ((uint32)0x0003FFFFU)
/** @brief Routing feature default configuration. */
#define LLCE_CAN_ROUTING_OPTION_DEFAULT_CONFIG ((uint32)0x00000000U)
/** @brief Routing feature mask for non-converting frame. */
#define LLCE_CAN_ROUTING_NOCHANGE ((uint32)0x00000001U)
/** @brief Routing feature mask for converting frame (CANFD->CAN). */
#define LLCE_CAN_ROUTING_CAN ((uint32)0x00000002U)
/** @brief Routing feature mask for converting frame (CAN->CANFD). */
#define LLCE_CAN_ROUTING_CANFD ((uint32)0x00000004U)
/** @brief Routing feature mask for id remapping. */
#define LLCE_CAN_ROUTING_ID_REMAPPING_EN ((uint32)0x00000008U)

/** @brief Shift value for extracting FD flag  from CAN frame. */
#define LLCE_CAN_MB_FDF_SHIFT_U32 ((uint32)15U)
/** @brief Shift value for extracting Baud Rate Switch flag from CAN frame. */
#define LLCE_CAN_MB_BRS_SHIFT_U32 ((uint32)16U)
/** @brief Shift value for extracting ESI flag feature from CAN frame. */
#define LLCE_CAN_MB_ESI_SHIFT_U32 ((uint32)17U)
/** @brief Shift value for extracting frame ID from CAN frame. */
#define LLCE_CAN_MB_IDSTD_SHIFT_U32 ((uint32)18U)
/** @brief Shift value for extracting IDE flag from CAN frame. */
#define LLCE_CAN_MB_IDE_SHIFT_U32 ((uint32)30U)
/** @brief Shift value for extracting RTR flag from CAN frame. */
#define LLCE_CAN_MB_RTR_SHIFT_U32 ((uint32)31U)

/** @brief Shift value for extracting precalculated length from CAN frame. */
#define LLCE_CAN_MB_PRECALC_LEN_SHIFT_U32 ((uint32)24U)

/** @brief Constant used to identify a reserved mask id. */
#define LLCE_CAN_FULLCAN_MASK_U32 ((uint32)0xFFFFFFFFU)

/*=========================================================
              DEFINES FOR INTERACTING WITH PFE
=========================================================*/
#define LLCE_CAN2ETH_PFE_EMAC0          (0x0001U)
#define LLCE_CAN2ETH_PFE_EMAC1          (0x0002U)
#define LLCE_CAN2ETH_PFE_EMAC2          (0x0004U)
#define LLCE_CAN2ETH_PFE_HIF0           (0x0008U)
#define LLCE_CAN2ETH_PFE_HIF1           (0x0010U)
#define LLCE_CAN2ETH_PFE_HIF2           (0x0020U)
#define LLCE_CAN2ETH_PFE_HIF3           (0x0040U)
#define LLCE_CAN2ETH_PFE_HIFNOCPY       (0x0080U)
#define LLCE_CAN2ETH_PFE_AUX            (0x0100U)

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/**
 * @brief Notification IDs used to interface with LLCE.
 *
 * Notifications send by LLCE to host core.
 **/
typedef enum LLCE__PACKED
{
    /** @brief No error. */
    LLCE_CAN_NOTIF_NOERROR = 0U,
    /** @brief Error related to the common platform area. */
    LLCE_CAN_NOTIF_PLATFORMERROR,
    /** @brief Error related to a specific channel.*/
    LLCE_CAN_NOTIF_CHANNELERROR,
    /** @brief Notification related to changing CAN controller mode.*/
    LLCE_CAN_NOTIF_CTRLMODE,
} Llce_Can_NotificationIdType;

/**
 * @brief Command IDs used to interface with LLCE.
 *
 * Some of those commands are sent by the host to LLCE module and others are
 * sent by LLCE module to the host.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Host initializes LLCE module. */
    LLCE_CAN_CMD_INIT = 0U,
    /** @brief Host deinitializes a specific CAN controller. */
    LLCE_CAN_CMD_DEINIT,
    /** @brief Host sets a baud rate for a specific CAN controller.*/
    LLCE_CAN_CMD_SETBAUDRATE,
    /** @brief Host checks the state for a specific CAN controller.*/
    LLCE_CAN_CMD_GETCONTROLLERMODE,
    /** @brief Host changes the state for a specific CAN controller.*/
    LLCE_CAN_CMD_SETCONTROLLERMODE,
    /**
     * @brief Host requests the recovery from bus-off state
     * transmission of a specific CAN controller.
     */
    LLCE_CAN_CMD_MANUAL_BUSOFF_RECOVERY,
    /**
     * @brief LLCE delivers to the host the content of all status registers
     * of the CAN controller.
     */
    LLCE_CAN_CMD_GETSTATUS,
    /** @brief The host configures multiple filters on the reception side.*/
    LLCE_CAN_CMD_SETFILTER,
    /** @brief The host configures multiple advanced feature filters on reception side*/
    LLCE_CAN_CMD_SETADVANCEDFILTER,
    /** @brief The host enables/disables the already set filter. */
    LLCE_CAN_CMD_SETFILTERENABLESTATUS,
    /** @brief The host invalidates a specific filter.*/
    LLCE_CAN_CMD_REMOVE_FILTER,
    /** @brief Request version string from FW.*/
    LLCE_CAN_CMD_GETFWVERSION,
    /** @brief Host request for platform initialization.*/
    LLCE_CAN_CMD_INIT_PLATFORM,
    /**
     * @brief LLCE internal command request for initialization of
     * common resources.
     */
    LLCE_CAN_CMD_INIT_PLATFORM_COMMON,
    /** @brief Host request for platform deinitialization.*/
    LLCE_CAN_CMD_DEINIT_PLATFORM,
    /**
     * @brief Host request for platform initialization regarding
     * CAN2ETH-ETH2CAN use case.
     */
    LLCE_CAN_CMD_INIT_PFE,
        /**
     * @brief Host request for platform initialization regarding
     * CAN2ETH-ETH2CAN use case using ring buffers generated on host side.
     */
    LLCE_CAN_CMD_INIT_PFE_EXT_RING_BUF,
    /**
     * @brief Host request for platform initialization regarding
     * HSE bridge use case.
     */
    LLCE_CAN_CMD_INIT_HSE,
    /**
     * @brief Host creates a destination to be used by the advanced
     * routing filters.
     */
    LLCE_CAN_CMD_CREATE_AF_DESTINATION,
    /**
     * @brief Host requests the abortion of the lowest priority pending
     * transmission of a specific CAN controller.
     */
    LLCE_CAN_CMD_ABORT_MB,
    /** @brief Custom command to be implemented by user in FDK */
    LLCE_CAN_CMD_CUSTOM,
    /** @brief The host configures multiple filters on the reception side for rxlut2 on g3.*/
    LLCE_CAN_CMD_SETAUXFILTER,
    /** @brief The host requests the addition of a new filter by specifying filter address.*/
    LLCE_CAN_CMD_SETFILTER_AT_ADDRESS,
    /** @brief The host enables or disables a channel in a routing multicast configuration.*/
    LLCE_CAN_CMD_SETCHANNELROUTINGOUTPUTSTATE,
    /** @brief The host enables or disables Can2Eth processing entirely.*/
    LLCE_CAN_CMD_SETCAN2ETHSTATE,
    /** @brief The host enables or disables Eth2Can processing for a format.*/
    LLCE_CAN_CMD_SETETH2CANFORMATSTATE,
    /** @brief The host requests the addition of a new advanced filter by specifying filter address.*/
    LLCE_CAN_CMD_SETADVANCEDFILTER_AT_ADDRESS,
    /** @brief The host enables or disables Can2Pcie processing entirely.*/
    LLCE_CAN_CMD_SETCAN2PCIESTATE,
    /** @brief The host requests all LLCE cores to execute WFI and shut down.*/
    LLCE_CAN_CMD_SHUTDOWN,
    /** @brief Host removes a destination which is used by the advanced routing filters. Stored data of this destination will be lost. */
    LLCE_CAN_CMD_REMOVE_AF_DESTINATION
} Llce_Can_CommandIdType;

/**
 * @brief CAN frame ID type.
 *
 * Specifies the CAN frame ID type based on it's length as it is
 * defined by the CAN specification.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Extended ID (29 bits) */
    LLCE_CAN_EXTENDED = 0U,
    /** @brief Standard ID (11 bits) */
    LLCE_CAN_STANDARD,
    /** @brief Mixed ID (29 bits) */
    LLCE_CAN_MIXED
} Llce_Can_IdLengthType;

/**
 * @brief Requested transitions of a CAN controller.
 *
 * These controller state transitions are requested by the host in a specific
 * order.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Request transition from START state into STOP state. */
    LLCE_CAN_T_STOP = 0U,
    /** @brief Request transition from STOP state into START state. */
    LLCE_CAN_T_START,
} Llce_Can_StateTransitionType;

/**
 * @brief CAN controller states.
 *
 * CAN controller states as they are reported by the LLCE firmware as a result
 * of state transition requests.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Controller is uninitialised (default) */
    LLCE_CAN_UNINIT_CTRL = 0U,
    /**
     * @brief Controller is in a pending state of unitialization, waiting
     * for the resources to be restored (e.g Rx tokens)
     */
    LLCE_CAN_UNINIT_CTRL_PENDING,
    /** @brief Controller is stopping, but not offline yet */
    LLCE_CAN_STOP_PENDING,
    /**
     * @brief Controller is in the BUSOFF_PENDING state which means that it
     * does not do any bus transactions.
     */
    LLCE_CAN_BUSOFF_PENDING,
    /**
     * @brief Controller is in the STOPPED state which means that it does
     * not do any bus transactions.
     */
    LLCE_CAN_STOPPED,
    /** @brief Controller is starting, but cannot do bus transactions yet.*/
    LLCE_CAN_START_PENDING,
    /**
     * @brief Controller is in the STARTED state which means that it do bus
     * transactions.
     */
    LLCE_CAN_STARTED,
    /**
     * @brief Controller is in the IDLE state. This state is not used
     * by LLCE module.
     */
    LLCE_CAN_IDLE,
    /**
     * @brief Controller is in state when the common components of the
     * platform are not initialized.
     */
    LLCE_CAN_UNINIT_PLATFORM
} Llce_Can_CtrlStateType;

/**
 * @brief CAN firmware components IDs.
 *
 * CAN firmware components IDs used to identify the component which generated a
 * specific error.
 **/
typedef enum LLCE__PACKED
{
    /** @brief CAN TX firmware component. */
    LLCE_TX = 101U,
    /** @brief CAN RX firmware component. */
    LLCE_RX,
    /** @brief CAN DTE firmware component. */
    LLCE_DTE,
    /** @brief CAN FRPE firmware component. */
    LLCE_FRPE,
    /** @brief CAN2CAN TX firmware component. */
    LLCE_CAN2CAN_TX,
    /** @brief CAN2CAN RX firmware component. */
    LLCE_CAN2CAN_RX,
    /** @brief CAN2CAN FRPE firmware component. */
    LLCE_CAN2CAN_FRPE,
    /** @brief AF ETH2CAN TX firmware component. */
    LLCE_AF_ETH_TX,
    /** @brief AF CAN2ETH RX firmware component. */
    LLCE_AF_ETH_RX,
    /** @brief AF CAN2ETH or ETH2CAN FRPE firmware component. */
    LLCE_AF_ETH_FRPE,
    /** @brief HSE TX firmware component. */
    LLCE_AF_HSE_TX,
    /** @brief HSE RX firmware component. */
    LLCE_AF_HSE_RX,
    /** @brief HSE FRPE firmware component. */
    LLCE_AF_HSE_FRPE,
    /** @brief AF TX  firmware component. */
    LLCE_AF_TX,
    /** @brief AF RX  firmware component. */
    LLCE_AF_RX,
    /** @brief AF FRPE firmware component. */
    LLCE_AF_FRPE
} Llce_Can_ModuleType;

/**
 * @brief CAN Logging options.
 *
 * CAN options for logging frames feature.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Logging of CAN frame is disabled.*/
    LLCE_AF_LOGGING_DISABLED = 1U,
    /** @brief Logging of CAN frame is enabled.*/
    LLCE_AF_LOGGING_ENABLED
} Llce_Af_LoggingOptionsType;

typedef enum LLCE__PACKED
{
    /** @brief Reception of the CAN frame by the host is disabled.*/
    LLCE_AF_HOSTRECEIVE_DISABLED = 1U,
    /** @brief Reception of the CAN frame by the host is enabled.*/
    LLCE_AF_HOSTRECEIVE_ENABLED
} Llce_Can_HostReceiveOptionsType;

typedef enum LLCE__PACKED
{
    /** @brief Authentication of CAN frame is disabled.*/
    LLCE_AF_AUTHENTICATION_DISABLED = 1U,
    /** @brief Authentication of CAN frame is enabled.*/
    LLCE_AF_AUTHENTICATION_ENABLED,
    LLCE_AF_AUTHENTICATION_NOT_SUPPORTED
} Llce_Af_AuthenticationOptionsType;

typedef enum LLCE__PACKED
{
    /** @brief Custom processing of CAN frame is disabled.*/
    LLCE_AF_CUSTOMPROCESSING_DISABLED = 1U,
    /** @brief Custom processing of CAN frame is enabled.*/
    LLCE_AF_CUSTOMPROCESSING_ENABLED,
} Llce_Af_CustomProcessingOptionsType;

/**
 * @brief RXLUT entries type
 *
 * Specifies the type of entry in the table.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Exact match entry type. */
    LLCE_CAN_ENTRY_EXACT_MATCH = 0U,
    /** @brief Masked match entry type. */
    LLCE_CAN_ENTRY_CFG_MASKED,
    /** @brief Range match entry type. */
    LLCE_CAN_ENTRY_CFG_RANGED,
} Llce_Can_EntryType;

/**
 * @brief Type of Advanced Feature(AF) rule.
 *
 * Specifies the type of entry in the destination rule table.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Destination rule type used for Can2Can use case. */
    CAN_AF_CAN2CAN = 0U,
    /** @brief Destination rule type used for Can2Eth use case. */
    CAN_AF_CAN2ETH,
    /** @brief Destination rule type used for Can2Pcie use case. */
    CAN_AF_CAN2PCIE,
    /** @brief Destination rule type used for Can2Hse use case. */
    CAN_AF_CAN2HSE
} Llce_Af_RuleIdType;

/**
 * @brief Type of Can2Eth routing
 *
 * Speccifies the type of packing to apply for Can2Eth
 **/
typedef enum LLCE__PACKED
{
    /** @brief IEEE1722-2016 AVPT non-time-synchronous CAN brief format */
    LLCE_AF_CAN2AVTP_NTSCF_BRIEF = 0U,
    /** @brief IEEE1722-2016 AVPT non-time-synchronous CAN regular format */
    LLCE_AF_CAN2AVTP_NTSCF_FULL,
    /** @brief IEEE1722-2016 AVPT time-synchronous CAN brief format */
    LLCE_AF_CAN2AVTP_TSCF_BRIEF,
    /** @brief IEEE1722-2016 AVPT time-synchronous CAN regular format */
    LLCE_AF_CAN2AVTP_TSCF_FULL,
    /** @brief UDP format */
    LLCE_AF_CAN2UDP,
    /** @brief UDP format, type B */
    LLCE_AF_CAN2UDP_B,
    /** @brief Placeholder for maximum value */
    LLCE_AF_CAN2ETH_FORMAT_MAX

} Llce_Can_EthEncapsulationFormat;
/**
 * @brief Initialization status of the controllers.
 *
 * Initialization status of the controllers.
 * See \link Llce_Can_InitPlatformCmdType \endlink.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Entity is initialised */
    INITIALIZED = 1U,
    /** @brief Entity is uninitialised (default) */
    UNINITIALIZED = 2U
} Llce_Can_StatusType;

/**
 * @brief Processing type of a specific error
 *
 * Processing type of a specific error.
 * See \link Llce_Can_InitPlatformCmdType \endlink.
 **/
typedef enum LLCE__PACKED
{
    /** @brief LLCE Firmware does not report the error */
    IGNORE = 1U,
    /**
     * @brief LLCE Firmware reports the error through the notification table
     * corresponding to processing type configured by host
     */
    NOTIF_FIFO0,
    /**
     * @brief LLCE Firmware reports the error through the notification table
     * corresponding to processing type configured by host
     */
    NOTIF_FIFO1,
} Llce_Can_ErrorProcessingType;

/**
 * @brief AbortMB Type
 *
 * Specifies the type of AbortMB command. It can be either Single MB
 * abort or All MBs abort
 **/
typedef enum LLCE__PACKED
{
    /** @brief Request aborting of a single MB with a specific MB tag. */
    ABORT_ONLY_ONE_MB = 0U,
    /** @brief Request aborting of all the MBs with a specific MB tag. */
    ABORT_ALL_MB
} Llce_Can_AbortMbType;

/** @brief    MB length accepted by a filter
 *  @details  MB length (8/64 bytes) configured to be accepted by a filter.
 *            No mixed mode available. 
 *
 **/  
typedef enum LLCE__PACKED
{
    /** @brief Opt for 64 bytes MB size accepted by a filter */
    USE_LONG_MB = 0U,
    /** @brief Opt for 8 bytes MB size accepted by a filter */
    USE_SHORT_MB,
} Llce_CanRx_MbLengthType;

/**
 * @brief Generic binary type
 *
 * Logical binary type. Redefined for consistency.
 **/
typedef enum LLCE__PACKED
{
    LLCE_FALSE = 0,
    LLCE_TRUE
} Llce_Can_BinaryValueType;


/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*
 * These structure must be kept as they are because BCAN is
 * sending data in this format !
 */
/**
 * @brief CAN message buffer.
 *
 * CAN message buffer is a memory area placed in the shared memory
 * which is used by the LLCE firmware to receive/transmit from/to BCAN
 * controller. LLCE firmware transmit/receive the frame in a word by word way so
 * the content of the 4 structure fields contains the frame fields as they are
 * described in the picture from below. For the reception process the LLCE
 * firmware store inside message buffer frame the time stamp read from the
 * hardware CAN controller.
 *
 * \image latex rx_mb.JPG "LLCE message buffer structure." width=17cm
 *
 * @pre Before to use any message buffer it is needed to initialize, configure
 * and start a CAN controller
 **/
typedef struct
{
    /**
     * @brief INPUT/OUTPUT: The first word of a frame as it is
     * expected/provided by the CAN controller.
     */
    uint32 u32Word0;
    /**
     * @brief INPUT/OUTPUT: The second word of a frame as it is
     * expected/provided by the CAN controller.
     */
    uint32 u32Word1;
    /**
     * @brief INPUT/OUTPUT: Frame payload needed for the maximum
     * payload size case.
     */
    uint8 u8Payload[LLCE_CAN_CONFIG_PAYLOAD_MAX_SIZE];
    /**
     * @brief INPUT: Time stamp of the received frames.It is not used
     * for the transmitted frames.
     */
    uint32 u32Timestamp;


} LLCE__ALIGNED__PACKED Llce_Can_MbType;

typedef struct
{
    /**
     * @brief INPUT/OUTPUT: The first word of a frame as it is
     * expected/provided by the CAN controller.
     */
    uint32 u32Word0;
    /**
     * @brief INPUT/OUTPUT: The second word of a frame as it is
     * expected/provided by the CAN controller.
     */
    uint32 u32Word1;
    /**
     * @brief INPUT/OUTPUT: Frame payload needed for the short
     * payload size case.
     */
    uint8 u8Payload[LLCE_CAN_CONFIG_SHORT_PAYLOAD_MAX_SIZE];
    /**
     * @brief INPUT: Time stamp of the received frames.It is not used
     * for the transmitted frames.
     */
    uint32 u32Timestamp;

} LLCE__ALIGNED__PACKED Llce_Can_ShortMbType;


/**
 * @brief Reception message buffer descriptor.
 *
 * Reception message buffer descriptor is a memory area placed in the shared
 * memory which is written by the LLCE firmware with the specific runtime info
 * needed by the host software.(e.g.matching filter ID ). Also it includes an
 * index to a CAN message buffer allocated during initialization to each
 * descriptor. After reception, the host shall copy the content of the reception
 * message buffer descriptor and the referred message buffer by this descriptor
 * from the shared memory into the host memory in order to be processed later by
 * the host software and to allow the current message buffer descriptor to be
 * used by LLCE firmware for the reception of a new frame.
 *
 * @pre Before to use any receive message buffer descriptor it is needed to
 * initialize, configure and start a CAN controller
 **/
typedef struct
{
    /**
     * @brief OUTPUT: Filter identifier resulted at the end of filtering
     * process.
     *
     * This field is completed by the LLCE filtering mechanism with a value
     * which was configured during initialization time.
     * It is used in order to map a received frame to a specific filter
     * defined by the host.
     */
    uint16 u16FilterId;
    /**
     * @brief OUTPUT: Result of RxLut2 filtering.
     * See \link Llce_Can_MbType \endlink
     */
    uint16 u16AuxSearchResult;
} LLCE__ALIGNED__PACKED Llce_Can_RxMbDescriptorType;

/**
 * @brief Transmission message buffer descriptor.
 *
 * Transmission message buffer descriptor is a memory area placed in the shared
 * memory which is written by the host software with other additional info
 * (e.g. frame tag IDs) which is sent back to the host by the LLCE firmware as
 * acknowledge information. Those internal tags are not changed/used by the
 * LLCE firmware.
 *
 * @pre Before to use any transmission message buffer descriptor it is needed
 * to initialize, configure and start a CAN controller
 **/
typedef struct
{
    /**
     * @brief INPUT: Host defined tag used to track a specific frame.
     *
     * This field is not changed by the LLCE firmware and is returned
     * back to the host as it is.
     * See \link Llce_Can_Tx2HostAckInfoType \endlink
     */
    uint16 u16FrameTag1;
    /**
     * @brief INPUT: Host defined tag used to track a specific frame.
     *
     * This field is not changed by the LLCE firmware and is returned back
     * to the host as it is.
     * See \link Llce_Can_Tx2HostAckInfoType \endlink
     */
    uint16 u16FrameTag2;
    /**
     * @brief OUTPUT: Index to the frame message buffer.
     * See \link Llce_Can_MbType \endlink
     */
    uint16 u16MbFrameIdx;
    /**
     * @brief INPUT: Host defined interface used to select the acknowledge
     * interface of a specific frame.
     *
     * This field is not changed by the LLCE firmware.
     */
    uint8 u8AckInterface;
    /**
     * @brief INPUT: Request firmware to add MAC code to the transmitted
     * frame payload.
     */
    uint8 u8EnableTxFrameMac;
} LLCE__ALIGNED__PACKED Llce_Can_TxMbDescriptorType;

/**
 * @brief Acknowledge transmission information send from LLCE to host.
 *
 * It is used in order to send from LLCE to host needed information in order to
 * identify and confirm that a specific frame was transmitted on the CAN bus.
 * This data structure type is used in order to implement a circular buffer for
 * each channel which is accessed by using indexes transferred from LLCE to host
 * by using TXACK FIFOs.
 * This approach allows usage of existing hardware FIFOs even the size of the
 * transferred data is higher than the FIFO element width size.
 *
 * @pre Before to read any acknowledge information, it is needed to do a
 * transmission request.
 **/
typedef struct
{
    /** @brief OUTPUT: Transmission time stamp.*/
    uint32 u32TxTimestamp;
    /**
     * @brief OUTPUT: Host defined tag used to track a specific frame.
     * This field is not changed by the LLCE firmware and is returned back
     * to the host as it is.
     * See \link Llce_Can_TxMbDescriptorType \endlink
     */
    uint16 u16FrameTag1;
    /**
     * @brief OUTPUT: Host defined tag used to track a specific frame.
     * This field is not changed by the LLCE firmware and is returned back
     * to the host as it is.
     * See \link Llce_Can_TxMbDescriptorType \endlink
     */
    uint16 u16FrameTag2;
} LLCE__ALIGNED__PACKED Llce_Can_Tx2HostAckInfoType;

/**
 * @brief Command for polling of controller state .
 * @details  It is sent from host to LLCE to query it for the controller state.
 *
 **/
typedef struct
{
    /** @brief OUTPUT: Current state of the CAN controller. */
    Llce_Can_CtrlStateType eControllerState;
} LLCE__ALIGNED__PACKED  Llce_Can_GetControllerModeCmdType;

/**
 * @brief Set controller mode command.
 *
 * It is sent from host to LLCE module in order request changing the state of a
 * CAN controller. Currently it allows only to start and stop a controller.
 * When a controller is started it allows to transmit and receive frames from
 * the bus. When the controller is stopped it ignores all frames from the bus
 * and it doesn't transmit any frame.
 *
 * @pre Before changing the controller state it must be initialized.
 **/
typedef struct
{
    /** @brief INPUT: The new state which is requested. */
    Llce_Can_StateTransitionType eTransition;
} LLCE__ALIGNED__PACKED Llce_Can_SetControllerModeCmdType;

/**
 * @brief Data baud rate settings for a CAN FD controller.
 *
 * It is used to configure the CAN FD settings including baud rate used during
 * data phase.
 **/
typedef struct
{
    /**
     * @brief INPUT: Configuration of data phase baud rate:
     * - Prescaler divisor: (bit 23-27)
     * - Resynchronization Jump Width: (bit 16-19)
     * - Time Segment 2: (bit 9-12)
     * - Time Segment 1: (bit 0-4)
     *
     * Each parameter value shall be decreased by 1 when it is written into
     * this data structure field.
     */
    uint32 u32DataBaudrateConfig;
    /**
     * @brief INPUT: Enable or disable FD related features of the CAN
     * controller.
     */
    uint8 u8FdEnable;
    /**
     * @brief INPUT: Enable or disable baud rate switch (BRS) at the level
     * of CAN controller.
     */
    uint8 u8ControllerTxBitRateSwitch;
    /**
     * @brief INPUT: Enable or disable Transceiver Delay Compensation:
     * - TRUE: enabled
     * - FALSE: disabled.
     */
    uint8 u8TrcvDelayCompEnable;
    /**
     * @brief INPUT: Enable or disable Transceiver Delay Measurement:
     * - TRUE: enabled
     * - FALSE: disabled.
     *
     * When it is enabled, the secondary sample point is determined by the
     * sum of the transceiver delay measurement plus transceiver delay
     * compensation offset. When it is disabled, the secondary sample point
     * is determined only by the transceiver delay compensation offset.
     */
    uint8 u8TrcvDelayMeasEnable;
    /** @brief INPUT: Value of Transceiver Delay Compensation Offset*/
    uint8 u8TrcvDelayCompOffset;
} LLCE__ALIGNED__PACKED Llce_Can_ControllerFdConfigType;

/**
 * @brief Set baud rate command.
 *
 * It is sent from host to LLCE module in order to configure baud rate
 * parameters for arbitration phase.
 **/
typedef struct
{
    /**
     * @brief INPUT: Configuration parameters for nominal baud rate:
     * - Prescaler divisor: (bit 23-31)
     * - Resynchronization Jump Width (bit 16-22)
     * - Time Segment 2 (bit 9-15)
     * - Time Segment 1 (bit 0-7)
     *
     * Each parameter value shall be decreased by 1 when it is written into
     * this data structure field.
     */
    uint32 u32NominalBaudrateConfig;
    /**
     * @brief INPUT: Configuration parameters for data baud rate of the
     * CAN controller.
     */
    Llce_Can_ControllerFdConfigType ControllerFD;
} LLCE__ALIGNED__PACKED Llce_Can_SetBaudrateCmdType;

/**
 * @brief Filter element settings.
 *
 * It is used to define a specific filter.Current filtering process suppose to
 * accept a frame if it's frame ID match the filter ID masked with the mask
 * value. At the end of filtering process an internal filter ID is mapped to
 * the accepted frame in order to track it later by the host software.
 * A maximum number of frames accepted by a specific filter can be managed
 * by LLCE at each point in time.
 **/
typedef struct
{
    /**
     * @brief INPUT:
     * - For MASK filters: Frame id mask value. Bit fields containing
     * \b 0 means don't care.
     * - For RANGE filters: Maximum accepted id value.
     * - For EXACT MATCH: not used.
     *
     * Set LLCE_CAN_MB_IDE_U32 to match only standard/extended, unset for mixed
     */
    uint32 uIdMask;
    /**
     * @brief INPUT:
     * - For MASK filters: CAN frame ID value.
     * - For RANGE filters: Minimum accepted id value.
     * - For EXACT MATCH: id value
     *
     * Bit LLCE_CAN_MB_IDE_U32 controls extended/standard if enabled in mask.
     */
    uint32 uMessageId;
    /**
     * @brief INPUT: Filter identifier used to track frames after filtering
     * process on the reception side.
     * See also \link Llce_Can_RxMbDescriptorType \endlink
     */
    uint16 u16FilterId;
    /**
     * @brief INPUT: Maximum number of message buffers which can be used to
     * store frames accepted by this filter at each specific point in time.
     * When the maximum value is reached the firmware will begin to drop the
     * received frames accepted by that filter.It is used also in order to
     * prevent that the frames accepted by a specific filter do not overload
     * the LLCE internal hardware resources (e.g. message buffers, FIFOs).
     */
    uint16 u16MbCount;
    /**
     * @brief OUTPUT: Filter address inside hardware filtering accelerator
     * where the filter fields are stored.
     *
     * Host side application can use this to track used filter entries.
     * The search operation start from low filter addresses and continue to
     * the high filter addresses.
     */
    uint16 u16FilterAddr;
    /**
     * @brief INPUT: Reception interface id used to deliver frames accepted
     * by that filter to the host.
     */
    uint8 u8RxDestInterface;
    /** @brief INPUT: Filter entry type: mask, range, exact match */
    Llce_Can_EntryType eEntryType;
    /** @brief INPUT: Message buffer payload length: 8 or 64 bytes */
    Llce_CanRx_MbLengthType eFilterMbLength;

} LLCE__ALIGNED__PACKED Llce_Can_ReceiveFilterType;

/**
 * @brief Filter element settings for RxLut2.
 *
 * It is used to define a specific filter.Current filtering process supposes to
 * accept a frame if its frame ID matches the filter ID masked with the mask
 * value. At the end of the filtering process, an internal filter ID is mapped to
 * the accepted frame in order to track it later by the host software.
 * A maximum number of frames accepted by a specific filter can be managed
 * by LLCE at each point in time.
 **/
typedef struct
{
    /**
     * @brief INPUT:
     * - For MASK filters: Frame id mask value. Bit fields containing
     * \b 0 means don't care.
     * - For RANGE filters: Maximum accepted id value.
     * - For EXACT MATCH: not used.
     *
     * Set LLCE_CAN_MB_IDE_U32 to match only standard/extended, unset for mixed
     */
    uint32 uIdMask;
    /**
     * @brief INPUT:
     * - For MASK filters: CAN frame ID value.
     * - For RANGE filters: Minimum accepted id value.
     * - For EXACT MATCH: id value
     *
     * Bit LLCE_CAN_MB_IDE_U32 controls extended/standard if enabled in mask.
     */
    uint32 uMessageId;
    /**
     * @brief INPUT: Custom value configured by the user.
     */
    uint16 u16AuxSearchResult;
    /** @brief INPUT: Filter entry type: mask, range, exact match */
    Llce_Can_EntryType eEntryType;
} LLCE__ALIGNED__PACKED Llce_Can_AuxFilterType;

/**
 * @brief Set filter command.
 *
 * It is sent by the host to LLCE in order to configure one or more reception
 * filters inside LLCE.
 **/
typedef struct
{
    /**
     * @brief INPUT: Array containing configuration for reception
     * filters.
     */
    Llce_Can_ReceiveFilterType aRxFilters[LLCE_CAN_CONFIG_MAX_FILTERS_COUNT];
    /** @brief INPUT: Number of configured filters. */
    uint16 u16RxFiltersCount;
} LLCE__ALIGNED__PACKED Llce_Can_SetFilterCmdType;

/**
 * @brief Set filter command.
 *
 * It is sent by the host to LLCE in order to configure one or more auxiliary reception
 * filters inside LLCE.
 **/
typedef struct
{
    /**
     * @brief INPUT: Array containing configuration for reception
     * filters.
     */
    Llce_Can_AuxFilterType aRxAuxFilters[LLCE_CAN_CONFIG_MAX_FILTERS_COUNT];
    /** @brief INPUT: Number of configured filters. */
    uint16 u16RxAuxFiltersCount;
} LLCE__ALIGNED__PACKED Llce_Can_SetAuxFilterCmdType;

/**
 * @brief CAN to CAN routing filter configuration.
 *
 * It is used to define a specific routing filter. Current routing
 * implementation suppose to accept a received frame for a specific
 * ID and ID mask combination, then route that frame to one or more transmission
 * channels.
 **/
typedef struct
{
    /** @brief INPUT: Special options for advanced routing. See
    \link LLCE_CAN_ROUTING_OPTION_DEFAULT_CONFIG \endlink
    \link LLCE_CAN_ROUTING_NOCHANGE \endlink
    \link LLCE_CAN_ROUTING_CAN \endlink
    \link LLCE_CAN_ROUTING_CANFD \endlink
    \link LLCE_CAN_ROUTING_ID_REMAPPING_EN \endlink*/
    uint32 u32Can2CanRoutingOptions;
    /** @brief INPUT: Can Id Remap Value.
     * Copied into u32Word0 of outgoing frame, except RTR flag. See \link Llce_Can_MbType \endlink.
     */
    uint32 u32CanIdRemapValue;
    /**
     * @brief INPUT: List of destination CAN controllers for the
     * accepted frame.
     */
    uint8 u8DestHwChList[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
    /** @brief INPUT: Length of the destination CAN controller list.*/
    uint8 u8DestHwChListCount;
} LLCE__ALIGNED__PACKED Llce_Can_Can2CanRoutingTableType;

/**
 * @brief Data structure type containing CAN to Ethernet destination rule
 * configuration.
 *
 * It is used to define a specific destination rule for Can2Eth internal
 * routing.
 **/
typedef struct
{
    /** @brief   INPUT: Base address of the buffer area for this destination */
    uint32 pu8Can2EthBuffAddr;
    /** @brief   INPUT: Size of each buffer for this destination */
    uint16 u16Can2EthBuffSize;
    /** @brief   INPUT: Number of buffers of size u16Can2EthBuffSize for this destination */
    uint8  u8Can2EthBuffCount;
    /** @brief   INPUT: Type of encapsulation */
    Llce_Can_EthEncapsulationFormat eFormat;
    /** @brief INPUT: Ethernet MAC destination address */
    uint8 u8Can2EthDestMac[6];
    /** @brief INPUT: Ethernet MAC source address */
    uint8 u8Can2EthSrcMac[6];
    /** @brief INPUT: Destination IP address (UDP only) */
    uint8 u8Can2EthDstIp[4];
    /** @brief INPUT: Source IP address (UDP only) */
    uint8 u8Can2EthSrcIp[4];
    /** @brief INPUT: Destination port (UDP only) */
    uint16 u8Can2EthDstPort;
    /** @brief INPUT: Source port (UDP only) */
    uint16 u8Can2EthSrcPort;
    /** @brief INPUT: Ethernet physical interface (bit list) - see LLCE_CAN2ETH_PFE_* */
    uint16 u16Can2EthPhyIfList;
} LLCE__ALIGNED__PACKED Llce_Can_Can2EthRoutingTableType;

/**
 * @brief Data structure type containing CAN to PCIe destination rule
 * configuration.
 *
 * It is used to define a specific destination rule for Can2Pcie routing.
 **/
typedef struct
{
    /** @brief   INPUT: Base address of the buffer area on the RC side*/
    uint64 u64Can2PcieRcBuffAddr;
    /** @brief   INPUT: Base address of the local buffer area for this destination */
    uint32 pu8Can2PcieBuffAddr;
    /** @brief   INPUT: Size of each buffer for this destination */
    uint16 u16Can2PcieBuffSize;
    /** @brief   INPUT: Number of buffers of size u16Can2PcieBuffSize for this destination */
    uint8  u8Can2PcieBuffCount;
    /** @brief   INPUT: PCIe controller used */
    uint8  u8Can2PcieController;
    /** @brief   INPUT: PCIe DMA channel used */
    uint8  u8Can2PcieDmaChannel;
    /** @brief   INPUT: MSI to trigger on transmission; 0xFF to disable */
    uint8  u8Can2PcieMsiId;
} LLCE__ALIGNED__PACKED Llce_Can_Can2PcieRoutingTableType;

/**
 * @brief Data structure type containing CAN to HSE destination rule
 * configuration.
 *
 * It is used to define a specific destination rule for Can2Hse routing.
 **/
typedef struct 
{
    /** @brief   INPUT: Key handle required to compute key on HSE side */
    uint32 u32Can2HseKeyHandle;
}LLCE__ALIGNED__PACKED Llce_Can_Can2HseRoutingTableType;


/**
 * @brief Data structure type representing  destination rule used by Advanced
 * Features(AF)
 *
 * Used to hold a generic type of AF destination rule
 **/
typedef struct
{
    /** @brief Destination rule content.*/
    union {
        /**
         * @brief INPUT: Destination rule for Can2Can internal routing
         * use case.
         */
        Llce_Can_Can2CanRoutingTableType Can2Can;
        /** @brief INPUT: Destination rule for Can2Eth use case.*/
        Llce_Can_Can2EthRoutingTableType Can2Eth;
        /** @brief INPUT: Destination rule for Can2Pcie use case.*/
        Llce_Can_Can2PcieRoutingTableType Can2Pcie;
        /** @brief INPUT: Destination rule for Can2Hse use case.*/
        Llce_Can_Can2HseRoutingTableType Can2Hse;
    } AfDest;
    /** @brief INPUT: Destination rule type.*/
    Llce_Af_RuleIdType eAfDestId;
} LLCE__ALIGNED__PACKED Can_Af_DestRulesType;

/**
 * @brief Advanced filter configuration.
 *
 * It is used to define an advanced filter. It contains references to the
 * individual features configured by the host.
 **/
typedef struct
{
    /** @brief INPUT: Option for frame authentication feature. */
    Llce_Af_AuthenticationOptionsType eCanAuthenticationFeature;
    /** @brief INPUT: Option for host receive feature. */
    Llce_Can_HostReceiveOptionsType eHostReceive;
    /** @brief INPUT: Option for logging feature. */
    Llce_Af_LoggingOptionsType eCanLoggingFeature;
    /** @brief INPUT: Option for custom processing. */
    Llce_Af_CustomProcessingOptionsType eCanCustomProcessing;
    /**
     * @brief INPUT: CAN2CAN routing table index.
     * Reference to the routing table rule.
     * See \link Llce_Can_Can2CanRoutingTableType \endlink
     */
    uint8 u8Can2CanRoutingTableIdx;
    /**
     * @brief INPUT: CAN2ETH routing table index.
     * Reference to the routing table rule.
     * See \link Llce_Can_Can2EthRoutingTableType \endlink
     */
    uint8 u8Can2EthRoutingTableIdx;
    /**
     * @brief INPUT: Other destination routing table index.
     * Reference to a routing table rule.
     */
    uint8 u8OtherRoutingTableIdx;
} LLCE__ALIGNED__PACKED Llce_Can_AdvancedFeatureType;

/**
 * @brief Advanced filter element configuration.
 *
 * It is used to define a specific filter. Current filtering suppose to accept
 * a frame for processing if it's frame ID match the filter ID masked with the
 * mask value. At the end of filtering process the frame is processed according
 * to the advanced configuration of the filter.
 **/
typedef struct
{
    /** @brief INPUT: Standard filter configuration. */
    Llce_Can_ReceiveFilterType Llce_Can_RxFilter;
    /** @brief INPUT: Can advanced features used by the filter. */
    Llce_Can_AdvancedFeatureType Llce_Can_AdvancedFeature;
} LLCE__ALIGNED__PACKED Llce_Can_AdvancedFilterType;

/**
 * @brief Set advanced filter command.
 *
 * It is sent by the host to LLCE in order to set one or more advanced filters.
 **/
typedef struct
{
    /**
     * @brief INPUT: Array containing configuration for one or
     * more filters.
     */
    Llce_Can_AdvancedFilterType aAdvancedFilters[LLCE_CAN_CONFIG_ADVANCED_FILTERS_COUNT];
    /** @brief INPUT: Number of configured filters. */
    uint16 u16RxFiltersCount;
} LLCE__ALIGNED__PACKED Llce_Can_SetAdvancedFilterCmdType;

/**
 * @brief Configurable errors that LLCE Firmware handles.
 *
 * Configurable errors that LLCE Firmware handles using different types of
 * processing.It is part of platform initialization command.
 * Only BusOff processing type is selectable per channel.
 **/
typedef struct
{
    /** @brief CAN Protocol errors supported by CAN controller. */
    Llce_Can_ErrorProcessingType eCanProtocolErr;
    /** @brief DATALOST event as described by Autosar standard */
    Llce_Can_ErrorProcessingType eDataLostErr;
    /**
     * @brief Initialization errors, like resources overflow, bad commands
     * flow, bad command parameters, invalid indexes or any other errors
     * caused by bad usage or a malicious host.
     */
    Llce_Can_ErrorProcessingType eInitErr;
    /** @brief Internal errors, like timeouts. */
    Llce_Can_ErrorProcessingType eInternalErr;
    /** @brief BusOff processing is selectable per channel */
    Llce_Can_ErrorProcessingType eBusOffErr[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
    /** @brief Passive state + TX/RX WRN. */
    Llce_Can_ErrorProcessingType eCanProtocolWarn;
} LLCE__ALIGNED__PACKED Llce_Can_ErrorCategoryType;

/**
 * @brief Platform initialization command.
 *
 * It is sent by the host to LLCE in order to configure the platform related
 * parameters. It is the first command which shall be send to LLCE module after
 * booting in order to configure common LLCE components.
 * Most important operations done by LLCE firmware at platform initialization
 * are:
 * - initializes all common internal LLCE components (hardware and software).
 * - prepare filter management data structures
 **/
typedef struct
{
    /**
     * @brief INPUT: Array containing the initialization status of the
     * controllers
     */
    Llce_Can_StatusType eCtrlInitStatus[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
    /**
     * @brief INPUT: Array containing maximum number of regular filters per
     * channel.
     * See \link LLCE_CAN_CONTROLLERCONFIG_CTRL_EN_U32 \endlink as a
     * controller option example
     */
    uint16 au16MaxRegularFilterCount[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
    /**
     * @brief INPUT: Array containing maximum number of advanced filters
     * per channel.
     * See \link LLCE_CAN_CONTROLLERCONFIG_CTRL_EN_U32 \endlink as a
     * controller option example
     */
    uint16 au16MaxAdvancedFilterCount[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
    /**
     * @brief INPUT: Array containing maximum number of RX message buffers
     * per output interface, considering interrupt processing.
     */
    uint16 au16MaxIntMbCount[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
    /**
     * @brief INPUT: Array containing maximum number of RX message buffers
     * per polling class, considering polling processing.
     * There are a number of \link LLCE_CAN_MAX_POLLING_CLASSES \endlink
     * provided.
     */
    uint16 au16MaxPollMbCount[LLCE_CAN_MAX_POLLING_CLASSES];
    /**
     * @brief INPUT: Array containing maximum number of reserved TX confirmation
     * buffers per output interface, considering interrupt processing.
     */
    uint16 au16MaxIntTxAckCount[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
    /**
     * @brief INPUT: Array containing maximum number of reserved TX
     * confirmation buffers per polling class, considering polling
     * processing.
     * There are a number of \link LLCE_CAN_MAX_POLLING_CLASSES \endlink
     * provided.
     */
    uint16 au16MaxPollTxAckCount[LLCE_CAN_MAX_POLLING_CLASSES];
    /**
     * @brief INPUT: Structure describing the way of processing each errors
     * category. This can be: INTERRUPT, POLLING or IGNORE.
     */
    Llce_Can_ErrorCategoryType CanErrorReporting;
} LLCE__ALIGNED__PACKED Llce_Can_InitPlatformCmdType;

/**
 * @brief Initialization command.
 *
 * It is sent by the host to LLCE in order to load and configure all needed
 * parameters inside LLCE. 
 * Most important operations done by LLCE firmware at initialization are:
 * - when this command is executed for the first CAN channel it initialize also
 * all internal LLCE components.
 * - configure the hardware features of a CAN controller.
 * - set a CAN controller in the stop state.
 **/
typedef struct
{
    /**
     * @brief INPUT: Configuration options for a hardware CAN controller.
     * See \link LLCE_CAN_CONTROLLERCONFIG_CTRL_EN_U32 \endlink as a
     * controller  option example
     */
    uint32 u32CtrlConfig;
    /**
     * @brief INPUT: Number of transmission message buffer descriptors used
     * for transmissions initialized by the host.The remaining elements are
     * used for internal routing scenarios.
     */
    uint8 u8TxMbCount;
} LLCE__ALIGNED__PACKED Llce_Can_InitCmdType;

/**
 * @brief LLCE-PFE Initialization command.
 *
 * It is sent by the host to LLCE in order to activate the LLCE-PFE interface,
 * and obtain the addresses of the relevant data structures.
 * @note Use uint32 instead of void*, for portability
 **/
typedef struct
{
    /** @brief OUTPUT: Address of the PFE RX Ring in LLCE memory */
    uint32 pRxRing;
    /** @brief OUTPUT: Address of the PFE RX Writeback Ring in LLCE memory */
    uint32 pRxWbRing;
    /** @brief OUTPUT: Address of the PFE TX Ring in LLCE memory */
    uint32 pTxRing;
    /** @brief OUTPUT: Address of the PFE TX Writeback Ring in LLCE memory */
    uint32 pTxWbRing;
     /** @brief INPUT: Pointer to the buffers used for RX */
    uint32 pRxBuffers;
    /** @brief INPUT: Size of the buffers used for RX */
    uint16 u16RxBufSize;
    /** @brief INPUT: Number of buffers used for RX */
    uint8 u8RxBufCount;
    /** @brief INPUT: Index of the PFE HIF to use in LLCE */
    uint8 u8Hif;
} LLCE__ALIGNED__PACKED Llce_Can_InitPfeCmdType;

/**
 * @brief LLCE-PFE Configurable Ring Initialization command.
 *
 * It is sent by the host to LLCE in order to activate the LLCE-PFE interface,
 * use the addresses of the relevant data structures provided by the host.
 * @note Use uint32 instead of void*, for portability
 **/
typedef struct
{
    /** @brief INPUT: Address of the PFE RX Ring in LLCE memory */
    uint32 pRxRing;
    /** @brief INPUT: Address of the PFE RX Writeback Ring in LLCE memory */
    uint32 pRxWbRing;
    /** @brief INPUT: Address of the PFE TX Ring in LLCE memory */
    uint32 pTxRing;
    /** @brief INPUT: Address of the PFE TX Writeback Ring in LLCE memory */
    uint32 pTxWbRing;
     /** @brief INPUT: Pointer to the buffers used for RX */
    uint32 pRxBuffers;
    /** @brief INPUT: Ring size of the PFE Rx Ring */
    uint32 u32RingSize;
    /** @brief INPUT: Pointer to the header */
    uint32 pHeader;
    /** @brief INPUT: Size of the buffers used for RX */
    uint16 u16RxBufSize;
    /** @brief INPUT: Number of buffers used for RX */
    uint8 u8RxBufCount;
    /** @brief INPUT: Size of the header */
    uint8 u8HeaderSize;
    /** @brief INPUT: Index of the PFE HIF to use in LLCE */
    uint8 u8Hif;    
} LLCE__ALIGNED__PACKED Llce_Can_InitPfeWithExternRingCmdType;

/**
 * @brief Get status command.
 *
 * It is sent by the host to LLCE in order to get the content of all status
 * registers of a specific CAN controller. This command makes only a read
 * operation on the status registers of CAN controller.
 *
 \image latex bcan_ecr.jpg "LLCE BCAN ECR." width=14cm
 \image html bcan_ecr.jpg "LLCE BCAN ECR."
 \image docbook bcan_ecr.jpg "LLCE BCAN ECR."
 \image rtf bcan_ecr.jpg "LLCE BCAN ECR."
 *
 \image latex bcan_crc.jpg "LLCE BCAN CRC." width=14cm
 \image html bcan_crc.jpg "LLCE BCAN CRC."
 \image docbook bcan_crc.jpg "LLCE BCAN CRC."
 \image rtf bcan_crc.jpg "LLCE BCAN CRC."
 *
 \image latex bcan_isr.jpg "LLCE BCAN ISR." width=14cm
 \image html bcan_isr.jpg "LLCE BCAN ISR."
 \image docbook bcan_isr.jpg "LLCE BCAN ISR."
 \image rtf bcan_isr.jpg "LLCE BCAN ISR."
 *
 \image latex bcan_sr.jpg "LLCE BCAN SR." width=14cm
 \image html bcan_sr.jpg "LLCE BCAN SR."
 \image docbook bcan_sr.jpg "LLCE BCAN SR."
 \image rtf bcan_sr.jpg "LLCE BCAN SR."
 *
 \image latex bcan_sr_2.jpg "LLCE BCAN SR-2." width=14cm
 \image html bcan_sr_2.jpg "LLCE BCAN SR-2."
 \image docbook bcan_sr_2.jpg "LLCE BCAN SR-2."
 \image rtf bcan_sr_2.jpg "LLCE BCAN SR-2."
 *
 **/
typedef struct
{
    /** @brief OUTPUT: Register ECR of CAN controller. */
    uint32 u32ECR;
    /** @brief OUTPUT: Register ISR of CAN controller. */
    uint32 u32ISR;
    /** @brief OUTPUT: Register SR of CAN controller. */
    uint32 u32SR;
    /** @brief OUTPUT: Register CRC of CAN controller. */
    uint32 u32CRC;
} LLCE__ALIGNED__PACKED Llce_Can_GetStatusCmdType;

/**
 * @brief Get firmware version command.
 *
 * It is sent by the host to LLCE in order to get the firmware version string.
 * It is copied in the response.
 **/
typedef Llce_Fw_VersionType Llce_Can_GetFwVersionType;

/**
 * @brief Filter address identifier
 *
 * It is sent by the host to LLCE in order to disable/enable a specific filter,
 * identified by its address
* <TABLE>
* <TR><TD>Type</TD><TD>Direction</TD><TD>Name</TD><TD>Disable filter</TD><TD>Enable filter</TD></TR>
* <TR><TD>uint8</TD><TD>in</TD><TD>u8FilterEnabled</TD><TD>0U</TD><TD>1U</TD></TR>
* </TABLE>
 **/
typedef struct
{
    /**
     * @brief INPUT: Address of the filter which shall be
     * removed/disabled/enabled.
     */
    uint16 u16FilterAddr;
    /** @brief INPUT: Request new state (0 - disable filter / 1 - enable filter) 
     *  of the filter when using SetFilterEnableStatus command. */
    uint8 u8FilterEnabled;
} LLCE__ALIGNED__PACKED Llce_Can_ChangeFilterType;

/**
 * @brief Add AF destination command structure.
 *
 * It is sent by the host to LLCE in order add a destination to be used by AF
 **/
typedef struct
{
    /** @brief INPUT: Destination to add to the list */
    Can_Af_DestRulesType rule;
    /** @brief OUTPUT: Index in LLCE list where destination was inserted */
    uint8 u8Idx;
} LLCE__ALIGNED__PACKED Llce_Can_CreateAfDestination;

/**
 * @brief Remove AF destination command.
 *
 * It is sent by the host to LLCE in order remove a destination used by AF. It is the index in LLCE list of destination to be removed.
 **/
typedef uint8 Llce_Can_RemoveAfDestination;



/**
 * @brief Abort MB command structure
 *
 * It is sent by the host to LLCE in order to abort the lowest priority pending
 * transmission of a specific controller.
 **/
typedef struct
{
    /**
     * @brief INPUT: Host defined tag used to track a specific frame.
     * See \link Llce_Can_TxMbDescriptorType \endlink
     */
    uint16 u16FrameTag;
    /** @brief   OUTPUT: Number of Tx pending transmissions aborted */
    uint8 u8AbortedFrameCnt;
    /** @brief INPUT: Specifies the type of AbortMB command. */
    Llce_Can_AbortMbType eAbortMbType;
} LLCE__ALIGNED__PACKED Llce_Can_AbortMbCmdType;

/**
 * @brief Set Eth2Can decapsulation state.
 *
 * It is sent by the host to LLCE in order to turn on or off decapsulation
 * for a given format.
 **/
typedef struct
{
    /** @brief INPUT: Encapsulation format */
    Llce_Can_EthEncapsulationFormat eFormat;
    /** @brief INPUT: State to set */
    Llce_Can_BinaryValueType eState;
} LLCE__ALIGNED__PACKED Llce_Can_SetEth2CanFormatStateCmdType;


/**
 * @brief List of commands used by host.
 *
 * It is used in order to use the same memory area for all commands send from
 * host to LLCE.
 **/
typedef union {
    /** @brief Command for initializing a specific CAN channel. */
    Llce_Can_InitCmdType Init;
    /**
     * @brief Command for getting the hardware status information for a
     * specific CAN controller.
     */
    Llce_Can_GetStatusCmdType GetStatus;
    /**
     * @brief Command for configuring filters for a specific CAN controller
     * in order to deliver frames to the host.
     */
    Llce_Can_SetFilterCmdType SetFilter;
    /**
     * @brief Command for configuring filters in order to route frames to
     * other destinations than host.
     */
    Llce_Can_SetAdvancedFilterCmdType SetAdvancedFilter;
    /** @brief Hardware address of filter to disable/enable/remove. */
    Llce_Can_ChangeFilterType ChangeFilter;
    /**
     * @brief Command for configuring baud rate parameters for a specific
     * CAN controller.
     */
    Llce_Can_SetBaudrateCmdType SetBaudrate;
    /**
     * @brief Command for getting the status of a specific CAN controller.
     */
    Llce_Can_GetControllerModeCmdType GetControllerMode;
    /**
     * @brief Command for changing the status of a specific CAN controller.
     */
    Llce_Can_SetControllerModeCmdType SetControllerMode;
    /** @brief Command for getting the firmware version. */
    Llce_Can_GetFwVersionType GetFwVersion;
    /**
     * @brief Command for configuring platform related parameters and common
     * HW components used by all CAN channels
     */
    Llce_Can_InitPlatformCmdType InitPlatform;
    /**
     * @brief Command for initializing the LLCE-PFE interface and getting
     * buffer locations
     */
    Llce_Can_InitPfeCmdType InitPfe;
    /**
     * @brief Command for initializing the LLCE-PFE interface using user's
     * ring buffer input
     */
    Llce_Can_InitPfeWithExternRingCmdType InitPfeWithExternRing;
    /** @brief Command for creating a destination for AF */
    Llce_Can_CreateAfDestination CreateAfDest;
    /** @brief Command for removing a destination for AF */
    Llce_Can_RemoveAfDestination RemoveAfDest;
    /**
     * @brief Command for aborting either the lowest priority message buffer
     * or all the message buffers with a specific tag.
     */
    Llce_Can_AbortMbCmdType AbortMb;
    /** @brief Pointer to argument for custom command */
    uint32 pCustomCmdArg;
    /**
     * @brief Command for configuring custom filters for a specific CAN controller
     * in order to deliver frames to the host.
     */
    Llce_Can_SetAuxFilterCmdType SetAuxFilter;
    /**
     * @brief Generic argument for binary values
     */
    Llce_Can_BinaryValueType eBinaryValue;
    /**
     * @brief Command for turning Eth2Can on or off for a certain format
     */
    Llce_Can_SetEth2CanFormatStateCmdType SetEth2CanFormatState;
} Llce_Can_CommandListType;

/**
 * @brief Command used by host.
 *
 * It is used in order to send commands from host to LLCE using shared memory.
 **/
typedef struct
{
    /** @brief INPUT: Command parameters. */
    Llce_Can_CommandListType CmdList;
    /** @brief INPUT: Command ID. */
    Llce_Can_CommandIdType eCmdId;
    /** @brief OUTPUT: Return status code after command completion.*/
    Llce_Fw_ReturnType eReturnValue;
} LLCE__ALIGNED__PACKED Llce_Can_CommandType;

/**
 * @brief Set controller mode notification.
 *
 * Notification send from LLCE to host in order to inform about a specific
 * controller state change.
 **/
typedef struct
{
    /**
     * @brief OUTPUT: Current state of the CAN controller.
     * See also \link Llce_Can_CtrlStateType \endlink
     */
    Llce_Can_CtrlStateType eControllerState;
    /** @brief OUTPUT: CAN controller id. */
    uint8 u8HwCtrl;
} LLCE__ALIGNED__PACKED Llce_Can_CtrlModeNotifType;

/**
 * @brief Platform specific error.
 *
 * Platform error details send to host in order to report an internal
 * LLCE error.
 **/
typedef struct
{
    /**
     * @brief OUTPUT: LLCE firmware component id.
     * See also \link Llce_Can_ModuleType \endlink
     */
    Llce_Can_ModuleType eModuleId;
    /**
     * @brief OUTPUT: LLCE error code.
     * See also \link Llce_Fw_ReturnType \endlink
     */
    Llce_Fw_ReturnType eErrorCode;
    /** @brief OUTPUT: Number of occurrences of the last error. */
    uint16 u16ErrorCount;
} LLCE__ALIGNED__PACKED Llce_Can_ErrorNotifType;

/** @brief Channel specific error.
 *
 * Channel error details send to host in order to report an internal LLCE error.
 **/
typedef struct
{
    Llce_Can_ErrorNotifType ErrorInfo;
    /** @brief OUTPUT: Controller ID. */
    uint8 u8HwCtrl;
} LLCE__ALIGNED__PACKED Llce_Can_ChannelErrorNotifType;

/**
 * List of notifications send by LLCE to host, used by host.
 *
 * It is used by LLCE to notify host about specific events inside LLCE.
 **/
typedef union {
    /**
     * @brief OUTPUT: Notification parameters for controller state changes.
     * See also \link Llce_Can_CtrlModeNotifType \endlink
     */
    Llce_Can_CtrlModeNotifType CtrlMode;
    /**
     * @brief OUTPUT: Notification parameters for platform errors.
     * See also \link Llce_Can_ErrorNotifType \endlink
     */
    Llce_Can_ErrorNotifType PlatformError;
    /**
     * @brief OUTPUT: Notification parameters for channel errors.
     * See also \link Llce_Can_ChannelErrorNotifType \endlink
     */
    Llce_Can_ChannelErrorNotifType ChannelError;
} Llce_Can_NotificationListType;

/**
 * @brief Notifications used by LLCE.
 *
 * It is used in order to send notifications from LLCE to host by using shared
 * memory.
 **/
typedef struct
{
    /**
     * @brief OUTPUT: Notification parameters.
     * See also \link Llce_Can_NotificationListType \endlink
     */
    Llce_Can_NotificationListType NotifList;
    /**
     * @brief OUTPUT: Notification ID.
     * See also \link Llce_Can_NotificationIdType \endlink
     */
    Llce_Can_NotificationIdType eNotifId;
} LLCE__ALIGNED__PACKED Llce_Can_NotificationType;

/**
 * @brief Notification tables.
 *
 * Notification tables used to store the details of the notifications.
 * The index of entries are sent to host cores.The two tables are related to
 * reporting method:interrupt or polling.
 **/
typedef struct
{
    /**
     * @brief OUTPUT: Table used to report notifications in interrupt mode.
     * See also \link Llce_Can_NotificationType \endlink
     */
    Llce_Can_NotificationType
        Can_aNotif0_Table[LLCE_CAN_CONFIG_HIF_COUNT]
                         [LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE];
    /**
     * @brief OUTPUT: Table used to report notifications in polling mode.
     * See also \link Llce_Can_NotificationType \endlink
     */
    Llce_Can_NotificationType
        Can_aNotif1_Table[LLCE_CAN_CONFIG_HIF_COUNT]
                         [LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE];
} LLCE__ALIGNED__PACKED Llce_Can_NotificationTableType;

/**
 * @brief Shared memory structure
 *
 * Structure that encapsulates all the shared memory with LLCE on the CAN side.
 **/
typedef struct
{
    /** @brief Receive message buffer descriptors. */
    Llce_Can_RxMbDescriptorType Can_Rx_aMbDesc[LLCE_CAN_CONFIG_MAXRXMB + LLCE_CAN_CONFIG_MAX_SHORTRXMB];
    /** @brief Transmit message buffer descriptors. */
    Llce_Can_TxMbDescriptorType Can_Tx_aMbDesc[LLCE_CAN_CONFIG_MAXTXMB];
    /** @brief Shared memory used to store the LONG CAN message buffers (64B). */
    Llce_Can_MbType Can_aMb[LLCE_CAN_CONFIG_MAXRXMB + LLCE_CAN_CONFIG_MAXTXMB +
                            LLCE_CAN_CONFIG_MAXAFFRMB];

    /** @brief Shared memory used to store the SHORT CAN message buffers (8B). */
    Llce_Can_ShortMbType Can_aSMb[LLCE_CAN_CONFIG_MAX_SHORTRXMB];

    /** @brief Shared memory used to send commands from Host to LLCE . */
    Llce_Can_CommandType aCanCmd[LLCE_CAN_CONFIG_HIF_COUNT];
    /** @brief Shared memory used to store notifications from LLCE to host.
     */
    Llce_Can_NotificationTableType Can_NotificationTable;
    /**
     * @brief Circular buffer used to send ACK info from TX core to HOST
     * core. Reserved 1 extra buffer for each interface for consistency
     * purposes.
     */
    Llce_Can_Tx2HostAckInfoType Can_Tx_aAckInfo[LLCE_CAN_CONFIG_MAX_TXACKINFO];
} LLCE__ALIGNED__PACKED Llce_Can_SharedMemoryType;

typedef struct
{
    /** @brief Shows the number of CAN frames received by each controller */
    uint32 u32GeneralRxCount;
    /** @brief Shows the number of CAN frames sent by each controller and acknowledged on the bus */
    uint32 u32GeneralTxCount;
    /** @brief All CAN frames received by the controller from other controllers via CAN */
    uint32 u32Can2CanInCount;
    /** @brief All CAN frames sent by the controller to other controller via CAN */
    uint32 u32Can2CanOutCount;
    /** @brief All CAN frames received by controller to be encapsulated in Ethernet format and sent to PFE for transmission over ethernet */
    uint32 u32Can2EthCount;
    /** @brief All Ethernet frames transfered from PFE to LLCE controller for decoding and transmission over CAN */
    uint32 u32Eth2CanCount;
    /** @brief Reserved for future use */
    uint32 u32ReservedCount1;
    /** @brief Reserved for future use */
    uint32 u32ReservedCount2;
    /** @brief Reserved for future use */
    uint32 u32ReservedCount3;
    /** @brief Reserved for future use */
    uint32 u32ReservedCount4;
} LLCE__ALIGNED__PACKED Llce_Can_RxTxCountType;

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/

/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/

#ifdef __cplusplus
}
#endif

#endif /*LLCE_INTERFACECANTYPES_H*/

/** @} */


===== 文件 [72/112]: include\Llce_InterfaceCanUtils.h =====
/**
 *   @file    Llce_InterfaceCanUtils.h
 *
 *   @brief   LLCE data structures and functions for ease of use of LLCE interface
 *   @details This file contains auxiliary data structures and functions wrapped onto the LLCE
 *            interface
 *
 *   @addtogroup LLCE_CAN_firmware_interface LLCE CAN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/
#ifndef LLCE_INTERFACECANUTILS_H
#define LLCE_INTERFACECANUTILS_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __DOXYGEN__
/**
 *
 * @page misra_violations MISRA-C:2012 violations
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.1, Identifiers (internal and external)
 * shall not rely on the significance of more than 31 characters. The used
 * compilers use more than 31 chars for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.2, Identifiers declared in the same scope
 * and name space shall be distinct. The used compilers use more than 31 chars
 * for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.4, Macro identifiers shall be distinct.
 * The used compilers use more than 31 chars for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.5, Identifiers shall be distinct from
 * macro names. The identifier clash is between macro identifiers. Therefore,
 * this rule is incorrectly reported by the tool.
 * 
 */
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
#include "Llce_InterfaceCanTypes.h"

 /*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/
 /* Masks used for un-shifted values, for checking user input */
 /** @brief Frame RTR field mask unpacked. */
 #define LLCE_CAN_MB_RTR_UNPACKED_U32                   ((uint32)0x00000001U)
 /** @brief Frame IDE field mask unpacked. */
 #define LLCE_CAN_MB_IDE_UNPACKED_U32                   ((uint32)0x00000001U)
 /** @brief Frame standard ID field mask unpacked. */
 #define LLCE_CAN_MB_IDSTD_MASK_UNPACKED_U32            ((uint32)0x0000007FF)
 /** @brief Frame BRS field mask unpacked. */
 #define LLCE_CAN_MB_BRS_UNPACKED_U32                   ((uint32)0x00000001U)
 /** @brief Frame FDF field mask unpacked. */
 #define LLCE_CAN_MB_FDF_UNPACKED_U32                   ((uint32)0x00000001U)
 /** @brief Frame ESI field mask unpacked. */
 #define LLCE_CAN_MB_ESI_UNPACKED_U32                   ((uint32)0x00000001U)
/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/
/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/
/**
 * @brief Word0 of a CAN frame.
 *
 * It contains the message ID and related configurations.
 **/
typedef struct
{
    /**
     * @brief INPUT/OUTPUT: Can frame Standard or Extended ID field.
     * In base frame format, only the 11 most significant bits (28-18)
     * are used for frame identification. The 18 least significant bits are ignored.
     * 
     * In extended frame format, all bits (0-28) are used for frame  identification.
     */
    uint32 u32Id;
    /**
     * @brief INPUT/OUTPUT: Can frame Remote Transmission Request field.
     * 
     * If BCAN transmits this bit as one (recessive) and receives it as zero
     * (dominant), it is interpreted as an arbitration 
     * loss. If this bit is transmitted as zero (dominant), then if it 
     * is received as one (recessive), BCAN treats it as a bit error. 
     * If the value received matches the value transmitted, it is considered
     *  a successful bit transmission.
     */
    uint8 u8Rtr;
    /**
     * @brief INPUT/OUTPUT: Can frame Identifier Extension field.
     * 
     * This field identifies whether the frame format is base (standard ID) 
     * or extended.
     */
    uint8 u8Ide;
}LLCE__ALIGNED__PACKED Llce_Can_Word0;

/**
 * @brief Word1 of a CAN frame.
 *
 * It contains CAN frame format and bit rate related configurations.
 **/
typedef struct
{
    /**
     * @brief INPUT/OUTPUT: Can frame Data Length Code field.
     * 
     * This 4-bit field defines the number of bytes in the data field 
     * of a CAN frame (DATA BYTE 0 to DATA BYTE 63). 
     * When RTR = 1, the frame is a remote request and does not include
     * the data field, regardless of the DLC field.
     */
    uint8 u8Dlc;
    /**
     * @brief INPUT/OUTPUT: Can frame FD Format Indicator field.
     * 
     * This bit distinguishes between classical CAN format and CAN FD format frames.
     */
    uint8 u8Fdf;
    /**
     * @brief INPUT/OUTPUT: Can frame Bit Rate Switch field. 
     * 
     * This bit defines whether the bit rate is switched inside a CAN FD frame.
     * This bit is meaningful only if FDF = 1, otherwise it is not used by BCAN.
     */
    uint8 u8Brs;
    /**
     * @brief INPUT/OUTPUT: Can frame Error State Indicator field.
     * 
     * This bit indicates if the transmitting node is error active or error passive.
     * This bit is meaningful only if FDF = 1, otherwise it is not used by BCAN.
     */
    uint8 u8Esi;
}LLCE__ALIGNED__PACKED Llce_Can_Word1;


/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/
/**
 * @brief              Pack members of Llce_Can_Word0 struct into CAN frame format.
 * 
 * @details            This is a helper function abstracts the CAN frame layout away
 *                     from the user when building a CAN frame.
 * 
 * @param Word0*       - pointer to struct holding fields of Word0 part from CAN frame.
 *                       The result is to be copied into u32Word0 field of Llce_Can_MbType struct.
 */
static inline uint32 Llce_Can_Pack_Word0(const Llce_Can_Word0* Word0)
{
    uint32 u32Word0_Temp = 0U;

    u32Word0_Temp |= ((Word0->u8Rtr & LLCE_CAN_MB_RTR_UNPACKED_U32) << LLCE_CAN_MB_RTR_SHIFT_U32);
    u32Word0_Temp |= ((Word0->u8Ide & LLCE_CAN_MB_IDE_UNPACKED_U32) << LLCE_CAN_MB_IDE_SHIFT_U32);
    if(LLCE_CAN_MB_IDE_UNPACKED_U32 == (Word0->u8Ide & LLCE_CAN_MB_IDE_UNPACKED_U32))
    {
        /* Extended Id */
        u32Word0_Temp |= (Word0->u32Id & LLCE_CAN_MB_ID_MASK_U32);
    }
    else
    {
        /* Standard Id */
        u32Word0_Temp |= ((Word0->u32Id & LLCE_CAN_MB_IDSTD_MASK_UNPACKED_U32) << LLCE_CAN_MB_IDSTD_SHIFT_U32);
    }

    return u32Word0_Temp;
}

/**
 * @brief              Pack members of Llce_Can_Word1 struct into CAN frame format.
 * 
 * @details            This is a helper function abstracts the CAN frame layout away
 *                     from the user when building a CAN frame. 
 * 
 * @param Word1*       - pointer to struct holding fields of Word1 part from CAN frame.
 *                       The result is to be copied into u32Word1 field of Llce_Can_MbType struct.
 */
static inline uint32 Llce_Can_Pack_Word1(const Llce_Can_Word1* Word1)
{
    uint32 Word1_temp = 0U;

    Word1_temp |= ((Word1->u8Brs & LLCE_CAN_MB_BRS_UNPACKED_U32) << LLCE_CAN_MB_BRS_SHIFT_U32);
    Word1_temp |= ((Word1->u8Fdf & LLCE_CAN_MB_FDF_UNPACKED_U32) << LLCE_CAN_MB_FDF_SHIFT_U32);
    Word1_temp |= ((Word1->u8Esi & LLCE_CAN_MB_ESI_UNPACKED_U32) << LLCE_CAN_MB_ESI_SHIFT_U32);
    Word1_temp |= (Word1->u8Dlc & LLCE_CAN_MB_DLC_MASK_U32);

    return Word1_temp;
}

/**
 * @brief              Unpack fields from CAN frame into Llce_Can_Word0 struct.
 * 
 * @details            This is a helper function which extracts the fields of Word0
 *                     from a CAN frame and populates the fields of Llce_Can_Word0 struct.
 *                     
 * @param u32Word0     - Word0 part of CAN frame with fields that match CAN layout.
 *                       The input parameter is u32Word0 field of Llce_Can_MbType struct.
 */
static inline Llce_Can_Word0 Llce_Can_Unpack_Word0(uint32 u32Word0)
{
    Llce_Can_Word0 Word0;

    Word0.u8Rtr = (uint8)((u32Word0 & LLCE_CAN_MB_RTR_U32) >> LLCE_CAN_MB_RTR_SHIFT_U32);
    Word0.u8Ide = (uint8)((u32Word0 & LLCE_CAN_MB_IDE_U32) >> LLCE_CAN_MB_IDE_SHIFT_U32);
    if(LLCE_CAN_MB_IDE_UNPACKED_U32 == (Word0.u8Ide & LLCE_CAN_MB_IDE_UNPACKED_U32))
    {
        /* Extended Id */
        Word0.u32Id = u32Word0 & LLCE_CAN_MB_ID_MASK_U32;
    }
    else
    {
        /* Standard Id */
        Word0.u32Id = ((u32Word0 & LLCE_CAN_MB_IDSTD_MASK_U32) >> LLCE_CAN_MB_IDSTD_SHIFT_U32);
    }

    return Word0;
}

/**
 * @brief              Unpack fields from CAN frame into Llce_Can_Word1 struct.
 * 
 * @details            This is a helper function which extracts the fields of Word1
 *                     from a CAN frame and populates the fields of Llce_Can_Word1 struct.
 * 
 * @param u32Word1     - Word1 part of CAN frame with fields that match CAN layout.
 *                       The input parameter is u32Word1 field of Llce_Can_MbType struct.
 */
static inline Llce_Can_Word1 Llce_Can_Unpack_Word1(uint32 u32Word1)
{
    Llce_Can_Word1 Word1;

    Word1.u8Esi = (uint8)((u32Word1 & LLCE_CAN_MB_ESI_U32) >> LLCE_CAN_MB_ESI_SHIFT_U32);
    Word1.u8Brs = (uint8)((u32Word1 & LLCE_CAN_MB_BRS_U32) >> LLCE_CAN_MB_BRS_SHIFT_U32);
    Word1.u8Fdf = (uint8)((u32Word1 & LLCE_CAN_MB_FDF_U32) >> LLCE_CAN_MB_FDF_SHIFT_U32);
    Word1.u8Dlc = (uint8)(u32Word1 & LLCE_CAN_MB_DLC_MASK_U32);

    return Word1;
}

/**
 * @brief              Retrieve message buffer from shared memory based on rx descriptor index and 
 *                     unpack fields from the message buffer.
 * 
 * @details            This is a helper function which takes a descriptor as input
 *                     and returns the corresponding message buffer, which can be either a long (64 bytes) or short (8bytes) one.
 *                     It also retrieves the relevant fields from the message buffer.
 *                     The lower indexes correspond to long message buffers, followed by the short ones 
 *                     in the rx descriptor array, Llce_Can_RxMbDescriptorType Can_Rx_aMbDesc.
 * 
 * @param pCan_SharedMemory   - Pointer to shared memory.
.* @param u16RxMbDescIdx      - Rx message buffer descriptor index.
 * @param u32Word0            - Word0 field of message buffer.
 * @param u32Word1            - Word1 field of message buffer.
 * @param u8Payload           - Payload - either long or short.
 * @param u32Timestamp        - Timestamp from a clock source.
 */
static inline void Llce_Can_GetMbData(volatile Llce_Can_SharedMemoryType* pCan_SharedMemory, uint16 u16RxMbDescIdx, uint32* u32Word0, uint32* u32Word1, uint8** u8Payload, uint32* u32Timestamp)
{   
    /* Decide whether it's a 64B frame or a 8B frame (Short frame) */
    if (u16RxMbDescIdx < LLCE_CAN_CONFIG_MAXRXMB)
    {
        *u32Word0 = pCan_SharedMemory->Can_aMb[u16RxMbDescIdx].u32Word0;
        *u32Word1 =  pCan_SharedMemory->Can_aMb[u16RxMbDescIdx].u32Word1;
        *u8Payload = (uint8*)pCan_SharedMemory->Can_aMb[u16RxMbDescIdx].u8Payload;
        *u32Timestamp = pCan_SharedMemory->Can_aMb[u16RxMbDescIdx].u32Timestamp;
    }
    else
    {
        *u32Word0 = pCan_SharedMemory->Can_aSMb[u16RxMbDescIdx - LLCE_CAN_CONFIG_MAXRXMB].u32Word0;
        *u32Word1 = pCan_SharedMemory->Can_aSMb[u16RxMbDescIdx - LLCE_CAN_CONFIG_MAXRXMB].u32Word1;
        *u8Payload = (uint8*)pCan_SharedMemory->Can_aSMb[u16RxMbDescIdx - LLCE_CAN_CONFIG_MAXRXMB].u8Payload;
        *u32Timestamp = pCan_SharedMemory->Can_aSMb[u16RxMbDescIdx - LLCE_CAN_CONFIG_MAXRXMB].u32Timestamp;
    }

}

/**
* @brief          Retrieve the SEMA42_GATE corresponding to a given FIFO group idx (RXOUT/TXACK) 
*                 and a given HIF (Host Interface)
* @details        The SEMA42_GATE is used to lock the access to the FIFO IER register which is
*                 handled by LLCE and host. 
*
* @param[in]      u8FifoIdx FIFO group idx (RXOUT/TXACK)
* @param[in]      u8Hif Host Interface
*
* <TABLE>
* <TR><TD>Type</TD><TD>Direction</TD><TD>Name</TD><TD>Value Range</TD></TR>
* <TR><TD>uint8</TD><TD>in</TD><TD>u8FifoIdx</TD><TD>LLCE_FIFO_RXOUT_INDEX-LLCE_FIFO_TXACK_INDEX</TD></TR>
* <TR><TD>uint8</TD><TD>in</TD><TD>u8Hif</TD><TD>LLCE_CAN_HIF0-LLCE_CAN_HIF1</TD></TR>
* </TABLE>
* 
* @return         Llce_Sema42_GateType
*
*/
static inline Llce_Sema42_GateType Llce_GetSema42Gate (uint8 u8FifoIdx, uint8 u8Hif)
{
    /** @brief   Semaphore used to protect access to the FIFO IER register shared between
     *           LLCE and host on interrupt enable/disable. */
    static const Llce_Sema42_GateType Can_Sema4_Ier[LLCE_CAN_CONFIG_IER_SEMA4_COUNT][LLCE_CAN_CONFIG_HIF_COUNT] = 
    {
        {LLCE_SEMA42_GATE20, LLCE_SEMA42_GATE21}, 
        {LLCE_SEMA42_GATE22, LLCE_SEMA42_GATE23}
    };

    return Can_Sema4_Ier[u8FifoIdx][u8Hif];
}

#ifdef __cplusplus
}
#endif

#endif /*LLCE_INTERFACECANUTILS_H*/

/** @} */


===== 文件 [73/112]: include\Llce_InterfaceFifo.h =====
/**
 *   @file    Llce_InterfaceFifo.h
 *
 *   @brief   This file contains defines used for accessing LLCE FIFO hw module
 *   @details This file contains defines used for accessing LLCE FIFO hw module
 *
 *   @addtogroup LLCE_CAN_firmware_interface LLCE CAN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_FIFOINTERFACE_H
#define LLCE_FIFOINTERFACE_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __DOXYGEN__
/**
 * @page misra_violations MISRA-C:2012 violations
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 4.9, A function should be used in
 * preference to a function-like macro where they are interchangeable. Function
 * like macro are used to reduce code complexity
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 2.5, A project should not contain unused
 * macro declarations Some macros are used either in FW or driver, or provided
 * as API
 *
 */
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
#include "Llce_RegAccess.h"
#include "Llce_InterfaceCanConfig.h"
/*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

extern const uint32 Llce_Can_u32BlrinBaseAddress[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
extern const uint32 Llce_Can_u32BlroutBaseAddress[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
extern const uint32 Llce_Can_u32TxackBaseAddress[LLCE_CAN_CONFIG_MAXCTRL_COUNT +
                                                 LLCE_CAN_MAX_POLLING_CLASSES];
extern const uint32 Llce_Can_u32RxoutBaseAddress[LLCE_CAN_CONFIG_MAXCTRL_COUNT +
                                                 LLCE_CAN_MAX_POLLING_CLASSES];

extern const uint32 Llce_Can_u32NotifFifo0BaseAddress[LLCE_CAN_CONFIG_HIF_COUNT];
extern const uint32 Llce_Can_u32NotifFifo1BaseAddress[LLCE_CAN_CONFIG_HIF_COUNT];

extern const uint32 Llce_Can_u32RxinBaseAddress[LLCE_CAN_CONFIG_HIF_COUNT];
extern const uint32 Llce_Can_u32CmdBaseAddress[LLCE_CAN_CONFIG_HIF_COUNT];

extern const uint32 Llce_Can_u32RxinLogBaseAddress[1];
extern const uint32 Llce_Can_u32RxoutLogBaseAddress[1];
/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/
 /* LLCE base addresses*/
/** @brief Base address for Generic FIFO 0. */
#define LLCE_GENERIC_FIFO_BASEADDR ((uint32)0x43A12000UL)
/** @brief Base address for the interrupt concentrator registers. */
#define LLCE_ICSR_BASEADDR ((uint32)0x43A14000UL)

#define LLCE_CONFIG_FIFO_DEPTH_U8 ((uint8)16U)

#define LLCE_FIFO_FFULLD_U32 ((uint32)0x00000001U)
#define LLCE_FIFO_FEMTYD_U32 ((uint32)0x00000002U)
#define LLCE_FIFO_SR_QCOUNT_SHIFT_U8 ((uint8)24U)

#define LLCE_FIFO_FCR_FIFOEN_U32 ((uint32)0x00000001U)
#define LLCE_FIFO_FCR_FLENOWEN_U32 ((uint32)0x00000002U)
#define LLCE_FIFO_FCR_POPEN_U32 ((uint32)0x00000004U)
#define LLCE_FIFO_FCR_PUSHEN_U32 ((uint32)0x00000008U)
#define LLCE_FIFO_FCR_FLUSH_U32 ((uint32)0x00000010U)

#define LLCE_FIFO_FCR_RESET_U32 ((uint32)0x0U)

/*Generic defines used to access STATUS, ILR and IER registers of FIFOs.*/
#define LLCE_FIFO_FFULL_U32    ((uint32)0x00000100U)
#define LLCE_FIFO_FNFULL_U32   ((uint32)0x00000200U)
#define LLCE_FIFO_FEMTY_U32    ((uint32)0x00000400U)
#define LLCE_FIFO_FNEMTY_U32   ((uint32)0x00000800U)
#define LLCE_FIFO_POPEVT_U32   ((uint32)0x00001000U)
#define LLCE_FIFO_WMKFL_U32    ((uint32)0x00002000U)
#define LLCE_FIFO_WMKEM_U32    ((uint32)0x00004000U)
#define LLCE_FIFO_POPUND_U32   ((uint32)0x00008000U)
#define LLCE_FIFO_PUSHOVR_U32  ((uint32)0x00010000U)
#define LLCE_FIFO_MSBNOMT_U32  ((uint32)0x00020000U)

/* Default value returned when popping an empty fifo */
#define LLCE_FIFO_NULL_VALUE ((uint32)0xFFFFFFFFU)

#define LLCE_FIFO_0_BASE_ADDRESS            (0x43A00000UL)
#define LLCE_FIFO_1_BASE_ADDRESS            (0x43A00400UL)
#define LLCE_FIFO_2_BASE_ADDRESS            (0x43A00800UL)
#define LLCE_FIFO_3_BASE_ADDRESS            (0x43A00C00UL)
#define LLCE_FIFO_4_BASE_ADDRESS            (0x43A01000UL)
#define LLCE_FIFO_5_BASE_ADDRESS            (0x43A01400UL)
#define LLCE_FIFO_6_BASE_ADDRESS            (0x43A01800UL)
#define LLCE_FIFO_7_BASE_ADDRESS            (0x43A01C00UL)
#define LLCE_FIFO_8_BASE_ADDRESS            (0x43A02000UL)
#define LLCE_FIFO_9_BASE_ADDRESS            (0x43A02400UL)
#define LLCE_FIFO_10_BASE_ADDRESS           (0x43A02800UL)
#define LLCE_FIFO_11_BASE_ADDRESS           (0x43A02C00UL)
#define LLCE_FIFO_12_BASE_ADDRESS           (0x43A03000UL)
#define LLCE_FIFO_13_BASE_ADDRESS           (0x43A03400UL)
#define LLCE_FIFO_14_BASE_ADDRESS           (0x43A03800UL)
#define LLCE_FIFO_15_BASE_ADDRESS           (0x43A03C00UL)
#define LLCE_FIFO_16_BASE_ADDRESS           (0x43A04000UL)
#define LLCE_FIFO_17_BASE_ADDRESS           (0x43A04400UL)
#define LLCE_FIFO_18_BASE_ADDRESS           (0x43A04800UL)
#define LLCE_FIFO_19_BASE_ADDRESS           (0x43A04C00UL)
#define LLCE_FIFO_20_BASE_ADDRESS           (0x43A05000UL)
#define LLCE_FIFO_21_BASE_ADDRESS           (0x43A08000UL)
#define LLCE_FIFO_22_BASE_ADDRESS           (0x43A08400UL)
#define LLCE_FIFO_23_BASE_ADDRESS           (0x43A08800UL)
#define LLCE_FIFO_24_BASE_ADDRESS           (0x43A08C00UL)
#define LLCE_FIFO_25_BASE_ADDRESS           (0x43A09000UL)
#define LLCE_FIFO_26_BASE_ADDRESS           (0x43A09400UL)
#define LLCE_FIFO_27_BASE_ADDRESS           (0x43A09800UL)
#define LLCE_FIFO_28_BASE_ADDRESS           (0x43A09C00UL)
#define LLCE_FIFO_29_BASE_ADDRESS           (0x43A0A000UL)
#define LLCE_FIFO_30_BASE_ADDRESS           (0x43A0A400UL)
#define LLCE_FIFO_31_BASE_ADDRESS           (0x43A0A800UL)
#define LLCE_FIFO_32_BASE_ADDRESS           (0x43A0AC00UL)
#define LLCE_FIFO_33_BASE_ADDRESS           (0x43A0B000UL)
#define LLCE_FIFO_34_BASE_ADDRESS           (0x43A0B400UL)
#define LLCE_FIFO_35_BASE_ADDRESS           (0x43A0B800UL)
#define LLCE_FIFO_36_BASE_ADDRESS           (0x43A0BC00UL)
#define LLCE_FIFO_37_BASE_ADDRESS           (0x43A0C000UL)
#define LLCE_FIFO_38_BASE_ADDRESS           (0x43A0C400UL)
#define LLCE_FIFO_39_BASE_ADDRESS           (0x43A0C800UL)
#define LLCE_FIFO_40_BASE_ADDRESS           (0x43A0CC00UL)
#define LLCE_FIFO_41_BASE_ADDRESS           (0x43A0D000UL)
#define LLCE_FIFO_42_BASE_ADDRESS           (0x43B00000UL)
#define LLCE_FIFO_43_BASE_ADDRESS           (0x43B00400UL)
#define LLCE_FIFO_44_BASE_ADDRESS           (0x43B00800UL)
#define LLCE_FIFO_45_BASE_ADDRESS           (0x43B00C00UL)
#define LLCE_FIFO_46_BASE_ADDRESS           (0x43B01000UL)
#define LLCE_FIFO_47_BASE_ADDRESS           (0x43B01400UL)
#define LLCE_FIFO_48_BASE_ADDRESS           (0x43B01800UL)
#define LLCE_FIFO_49_BASE_ADDRESS           (0x43B01C00UL)
#define LLCE_FIFO_50_BASE_ADDRESS           (0x43B02000UL)
#define LLCE_FIFO_51_BASE_ADDRESS           (0x43B02400UL)
#define LLCE_FIFO_52_BASE_ADDRESS           (0x43B02800UL)
#define LLCE_FIFO_53_BASE_ADDRESS           (0x43B02C00UL)
#define LLCE_FIFO_54_BASE_ADDRESS           (0x43B03000UL)
#define LLCE_FIFO_55_BASE_ADDRESS           (0x43B03400UL)
#define LLCE_FIFO_56_BASE_ADDRESS           (0x43B03800UL)
#define LLCE_FIFO_57_BASE_ADDRESS           (0x43B03C00UL)
#define LLCE_FIFO_58_BASE_ADDRESS           (0x43B04000UL)
#define LLCE_FIFO_59_BASE_ADDRESS           (0x43B04400UL)
#define LLCE_FIFO_60_BASE_ADDRESS           (0x43B04800UL)
#define LLCE_FIFO_61_BASE_ADDRESS           (0x43B04C00UL)
#define LLCE_FIFO_62_BASE_ADDRESS           (0x43B05000UL)
#define LLCE_FIFO_63_BASE_ADDRESS           (0x43B08000UL)
#define LLCE_FIFO_64_BASE_ADDRESS           (0x43B08400UL)
#define LLCE_FIFO_65_BASE_ADDRESS           (0x43B08800UL)
#define LLCE_FIFO_66_BASE_ADDRESS           (0x43B08C00UL)
#define LLCE_FIFO_67_BASE_ADDRESS           (0x43B09000UL)
#define LLCE_FIFO_68_BASE_ADDRESS           (0x43B09400UL)
#define LLCE_FIFO_69_BASE_ADDRESS           (0x43B09800UL)
#define LLCE_FIFO_70_BASE_ADDRESS           (0x43B09C00UL)
#define LLCE_FIFO_71_BASE_ADDRESS           (0x43B0A000UL)
#define LLCE_FIFO_72_BASE_ADDRESS           (0x43B0A400UL)
#define LLCE_FIFO_35_BASE_ADDRESS           (0x43A0B800UL)
#define LLCE_FIFO_36_BASE_ADDRESS           (0x43A0BC00UL)
#define LLCE_FIFO_37_BASE_ADDRESS           (0x43A0C000UL)
#define LLCE_FIFO_38_BASE_ADDRESS           (0x43A0C400UL)
#define LLCE_FIFO_39_BASE_ADDRESS           (0x43A0C800UL)
#define LLCE_FIFO_40_BASE_ADDRESS           (0x43A0CC00UL)
#define LLCE_FIFO_41_BASE_ADDRESS           (0x43A0D000UL)
#define LLCE_FIFO_42_BASE_ADDRESS           (0x43B00000UL)
#define LLCE_FIFO_43_BASE_ADDRESS           (0x43B00400UL)
#define LLCE_FIFO_44_BASE_ADDRESS           (0x43B00800UL)
#define LLCE_FIFO_45_BASE_ADDRESS           (0x43B00C00UL)
#define LLCE_FIFO_46_BASE_ADDRESS           (0x43B01000UL)
#define LLCE_FIFO_47_BASE_ADDRESS           (0x43B01400UL)
#define LLCE_FIFO_48_BASE_ADDRESS           (0x43B01800UL)
#define LLCE_FIFO_49_BASE_ADDRESS           (0x43B01C00UL)
#define LLCE_FIFO_50_BASE_ADDRESS           (0x43B02000UL)
#define LLCE_FIFO_51_BASE_ADDRESS           (0x43B02400UL)
#define LLCE_FIFO_52_BASE_ADDRESS           (0x43B02800UL)
#define LLCE_FIFO_53_BASE_ADDRESS           (0x43B02C00UL)
#define LLCE_FIFO_54_BASE_ADDRESS           (0x43B03000UL)
#define LLCE_FIFO_55_BASE_ADDRESS           (0x43B03400UL)
#define LLCE_FIFO_56_BASE_ADDRESS           (0x43B03800UL)
#define LLCE_FIFO_57_BASE_ADDRESS           (0x43B03C00UL)
#define LLCE_FIFO_58_BASE_ADDRESS           (0x43B04000UL)
#define LLCE_FIFO_59_BASE_ADDRESS           (0x43B04400UL)
#define LLCE_FIFO_60_BASE_ADDRESS           (0x43B04800UL)
#define LLCE_FIFO_61_BASE_ADDRESS           (0x43B04C00UL)
#define LLCE_FIFO_62_BASE_ADDRESS           (0x43B05000UL)
#define LLCE_FIFO_63_BASE_ADDRESS           (0x43B08000UL)
#define LLCE_FIFO_64_BASE_ADDRESS           (0x43B08400UL)
#define LLCE_FIFO_65_BASE_ADDRESS           (0x43B08800UL)
#define LLCE_FIFO_66_BASE_ADDRESS           (0x43B08C00UL)
#define LLCE_FIFO_67_BASE_ADDRESS           (0x43B09000UL)
#define LLCE_FIFO_68_BASE_ADDRESS           (0x43B09400UL)
#define LLCE_FIFO_69_BASE_ADDRESS           (0x43B09800UL)
#define LLCE_FIFO_70_BASE_ADDRESS           (0x43B09C00UL)
#define LLCE_FIFO_71_BASE_ADDRESS           (0x43B0A000UL)
#define LLCE_FIFO_72_BASE_ADDRESS           (0x43B0A400UL)
#define LLCE_FIFO_73_BASE_ADDRESS           (0x43B0A800UL)
#define LLCE_FIFO_74_BASE_ADDRESS           (0x43B0AC00UL)
#define LLCE_FIFO_75_BASE_ADDRESS           (0x43B0B000UL)
#define LLCE_FIFO_76_BASE_ADDRESS           (0x43B0B400UL)
#define LLCE_FIFO_77_BASE_ADDRESS           (0x43B0B800UL)
#define LLCE_FIFO_78_BASE_ADDRESS           (0x43B0BC00UL)
#define LLCE_FIFO_79_BASE_ADDRESS           (0x43B0C000UL)
#define LLCE_FIFO_80_BASE_ADDRESS           (0x43B0C400UL)
#define LLCE_FIFO_81_BASE_ADDRESS           (0x43B0C800UL)
#define LLCE_FIFO_82_BASE_ADDRESS           (0x43B0CC00UL)
#define LLCE_FIFO_83_BASE_ADDRESS           (0x43B0D000UL)
#define LLCE_FIFO_84_BASE_ADDRESS           (0x43B10000UL)
#define LLCE_FIFO_85_BASE_ADDRESS           (0x43B10400UL)
#define LLCE_FIFO_86_BASE_ADDRESS           (0x43B10800UL)
#define LLCE_FIFO_87_BASE_ADDRESS           (0x43B10C00UL)
#define LLCE_FIFO_88_BASE_ADDRESS           (0x43B11000UL)
#define LLCE_FIFO_89_BASE_ADDRESS           (0x43B11400UL)
#define LLCE_FIFO_90_BASE_ADDRESS           (0x43B11800UL)
#define LLCE_FIFO_91_BASE_ADDRESS           (0x43B11C00UL)
#define LLCE_FIFO_92_BASE_ADDRESS           (0x43B12000UL)
#define LLCE_FIFO_93_BASE_ADDRESS           (0x43B12400UL)
#define LLCE_FIFO_94_BASE_ADDRESS           (0x43B12800UL)
#define LLCE_FIFO_95_BASE_ADDRESS           (0x43B12C00UL)
#define LLCE_FIFO_96_BASE_ADDRESS           (0x43B13000UL)
#define LLCE_FIFO_97_BASE_ADDRESS           (0x43B13400UL)
#define LLCE_FIFO_98_BASE_ADDRESS           (0x43B13800UL)
#define LLCE_FIFO_99_BASE_ADDRESS           (0x43B13C00UL)
#define LLCE_FIFO_100_BASE_ADDRESS          (0x43B14000UL)
#define LLCE_FIFO_101_BASE_ADDRESS          (0x43B14400UL)
#define LLCE_FIFO_102_BASE_ADDRESS          (0x43B14800UL)
#define LLCE_FIFO_103_BASE_ADDRESS          (0x43B14C00UL)
#define LLCE_FIFO_104_BASE_ADDRESS          (0x43B15000UL)
#define LLCE_GENERIC_FIFO_0_BASE_ADDRESS    (0x43A12000UL)
#define LLCE_GENERIC_FIFO_1_BASE_ADDRESS    (0x43A12400UL)
#define LLCE_GENERIC_FIFO_2_BASE_ADDRESS    (0x43A12800UL)
#define LLCE_GENERIC_FIFO_3_BASE_ADDRESS    (0x43A12C00UL)


/* Specific FIFOs base address calculation macros. */
#define LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo)                           \
    ((uint32)(LLCE_GENERIC_FIFO_BASEADDR +                                     \
              ((uint32)(u8GenFfo) * (uint32)0x400U))) 

#define LLCE_GENERIC_FIFO_CONFIG(u8GenFfo)                                     \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo)))
#define LLCE_GENERIC_FIFO_STATUS0(u8GenFfo)                                    \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo) + 0x04U))
#define LLCE_GENERIC_FIFO_STATUS1(u8GenFfo)                                    \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo) + 0x08U))
#define LLCE_GENERIC_FIFO_IER(u8GenFfo)                                        \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo) + 0x0CU))
#define LLCE_GENERIC_FIFO_ILR(u8GenFfo)                                        \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo) + 0x10U))
#define LLCE_GENERIC_FIFO_PUSH0(u8GenFfo)                                      \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo) + 0x14U))
#define LLCE_GENERIC_FIFO_POP0(u8GenFfo)                                       \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo) + 0x24U))
#define LLCE_GENERIC_FIFO_FMR(u8GenFfo)                                        \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo) + 0x34U))

#define LLCE_FIFO_CONFIG(u32BaseAddr) ((uint32)(u32BaseAddr))
#define LLCE_FIFO_STATUS0(u32BaseAddr) ((uint32)(u32BaseAddr + 0x04U))
#define LLCE_FIFO_STATUS1(u32BaseAddr) ((uint32)(u32BaseAddr + 0x08U))
#define LLCE_FIFO_IER(u32BaseAddr) ((uint32)(u32BaseAddr + 0x0CU))
#define LLCE_FIFO_ILR(u32BaseAddr) ((uint32)(u32BaseAddr + 0x10U))
#define LLCE_FIFO_PUSH0(u32BaseAddr) ((uint32)(u32BaseAddr + 0x14U))
#define LLCE_FIFO_POP0(u32BaseAddr) ((uint32)(u32BaseAddr + 0x24U))
#define LLCE_FIFO_FMR(u32BaseAddr) ((uint32)(u32BaseAddr + 0x34U))

#define LLCE_FIFO_BLRIN_BASE_ADDRESS(u8HwCtrl)                                 \
    (Llce_Can_u32BlrinBaseAddress[u8HwCtrl])
#define LLCE_FIFO_RXOUT_BASE_ADDRESS(u8HwCtrl)                                 \
    (Llce_Can_u32RxoutBaseAddress[u8HwCtrl])
#define LLCE_FIFO_TXACK_BASE_ADDRESS(u8HwCtrl)                                 \
    (Llce_Can_u32TxackBaseAddress[u8HwCtrl])
#define LLCE_FIFO_BLROUT_BASE_ADDRESS(u8HwCtrl)                                \
    (Llce_Can_u32BlroutBaseAddress[u8HwCtrl])

#define LLCE_NOTIF_FIFO0_BASE_ADDRESS(u8HostCore)                              \
    (Llce_Can_u32NotifFifo0BaseAddress[u8HostCore])
#define LLCE_NOTIF_FIFO1_BASE_ADDRESS(u8HostCore)                              \
    (Llce_Can_u32NotifFifo1BaseAddress[u8HostCore])

#define LLCE_FIFO_RXIN_BASE_ADDRESS(u8HostCore)                                \
    (Llce_Can_u32RxinBaseAddress[u8HostCore])
#define LLCE_FIFO_CMD_BASE_ADDRESS(u8HostCore)                                 \
    (Llce_Can_u32CmdBaseAddress[u8HostCore])

#define LLCE_FIFO_RXINLOG_BASE_ADDRESS() (Llce_Can_u32RxinLogBaseAddress[0])
#define LLCE_FIFO_RXOUTLOG_BASE_ADDRESS() (Llce_Can_u32RxoutLogBaseAddress[0])

/*==================================================================================================
 *                                      Interrupts
 ==================================================================================================*/

/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/*==================================================================================================
 *                                STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/

/*==================================================================================================
 *                                GLOBAL VARIABLE DECLARATIONS
 ==================================================================================================*/

/*==================================================================================================
 *                                    FUNCTION PROTOTYPES
 ==================================================================================================*/

#ifdef __cplusplus
}
#endif

#endif /* LLCE_FIFOINTERFACE_H */

/** @} */


===== 文件 [74/112]: include\Llce_InterfaceFwMgr.h =====
/**
 *   @file    Llce_InterfaceFwMgr.h
 *
 *   @brief   LLCE defines used to configure the LLCE firmware and interface
 *   @details LLCE defines used to configure the LLCE firmware and interface.
 *            Those configuration parameters are used both by LLCE firmware and
 *            host software.
 *
 *   @addtogroup Llce_configuration LLCE precompile configuration parameters
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_INTERFACEFWMGR_H
#define LLCE_INTERFACEFWMGR_H

#ifdef __cplusplus
extern "C" {
#endif

/**
* @page misra_violations MISRA-C:2012 violations
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.1, Identifiers (internal and external) shall not rely
* on the significance of more than 31 characters.
* The used compilers use more than 31 chars for identifiers.
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.4, Macro identifiers shall be distinct.
* This violation is due to the AUTOSAR requirement [SWS_BSW_00036] (perform inter module checks).
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.2, Identifiers declared in the same scope and name space shall be distinct.
* This rule does not apply if either identifier is a macro identifier, because this case is covered
* by Rule 5.4 and Rule 5.5.
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.5, Identifiers shall be distinct from macro names.
* The identifier clash is between macro identifiers. Therefore, this rule is incorrectly reported by the tool.
*
* @section Llce_InterfaceFwMgr_h_REF_1
* Violates MISRA 2012 Required Rule 21.1, #define and #undef shall not be used on a reserved identifier or
* reserved macro name.
* Certain keywords are not recognized by tools such as PC-LINT and LDRA.
*
* @section Llce_InterfaceFwMgr_h_REF_2
* Violates MISRA 2012 Advisory Rule 4.9, A function should be used in
* preference to a function-like macro where they are interchangeable. Function
* like macro are used to reduce code complexity
*
* @section Llce_InterfaceFwMgr_h_REF_3
* Violates MISRA 2012 Advisory Rule 2.3, A project should not contain unused type declarations.
* False detection by lint tool.
*
*/

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/


#include "Llce_RegAccess.h"

#ifdef CHECK_ABI_COMPATIBILITY
#pragma ABICHECK start
#endif
#include "Llce_FwVersion.h"

/*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/

/*==================================================================================================
 *                                      Interrupts
 ==================================================================================================*/

/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/**
 * @brief CAN firmware notification categories.
 * @details Contains the notification categories of the values returned by the LLCE Firmware.
 * @see Llce_Fw_ReturnType
 **/
typedef enum LLCE__PACKED
{
    LLCE_NOTIFCAT_CAN_PROTOCOL = 1U,
    LLCE_NOTIFCAT_DATA_LOST,
    LLCE_NOTIFCAT_CONFIGURATION,
    LLCE_NOTIFCAT_INTERNAL,
    LLCE_NOTIFCAT_BUSOFF,
    LLCE_NOTIFCAT_FW_STATUS,
    LLCE_NOTIFCAT_CAN_PROTOCOL_CRITICAL_STATE

} Llce_Fw_Notification_Category;

/**
 * @brief CAN firmware error values.
 *
 * CAN error values as they are reported by the LLCE firmware. Some of them are
 * channel related and other are platform related.
 **/
typedef enum LLCE__PACKED
{
    /** @brief CAN firmware error: BOTH SW AND HW TXACK FIFOS are full. */
    LLCE_ERROR_TXACK_FIFO_FULL = 1U,
    /** @brief CAN firmware error: RXOUT SW FIFO is full. */
    LLCE_ERROR_RXOUT_FIFO_FULL,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_0,
    /** @brief CAN firmware error: The system lost indexes or HW FIFO was not cleared and it is full. */
    LLCE_ERROR_HW_FIFO_FULL,
    /** @brief CAN firmware error: There was an attempt to perform a pop operation on an empty SW FIFO. */
    LLCE_ERROR_SW_FIFO_EMPTY,
    /** @brief CAN firmware error: There was an attempt to perform a push operation on a full SW FIFO.*/
    LLCE_ERROR_SW_FIFO_FULL,
    /** @brief CAN firmware error: The maximum hardware object count on the reception side was reached. */
    LLCE_ERROR_MB_NOTAVAILABLE,
    /** @brief CAN firmware error: Short Message buffer is configured but a long frame is received. */
    LLCE_ERROR_SHORT_MB_NOTAVAILABLE,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_BCAN_FRZ_EXIT,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_BCAN_SYNC,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_BCAN_FRZ_ENTER,
    /**
     * @brief CAN firmware error: CAN protocol error due to inability to
     * enter in low-power mode.
     */
    LLCE_ERROR_BCAN_LPM_EXIT,
    /**
     * @brief CAN firmware error: CAN protocol error due to inability to
     * enter in soft reset.
     */
    LLCE_ERROR_BCAN_SRT_ENTER,
    /**
     * @brief CAN firmware error: An error callback was called, but no error code matches : unknown CAN protocol error 
     */
    LLCE_ERROR_BCAN_UNKNOWN_ERROR,
    /**
     * @brief CAN firmware error: ACKERR indicates that an acknowledge error
     * has been detected by the transmitter node.
     */
    LLCE_ERROR_BCAN_ACKERR,
    /**
     * @brief CAN firmware error: CRCERR indicates that a CRC error has been
     * detected by the receiver node in a CAN frame.
     */
    LLCE_ERROR_BCAN_CRCERR,
    /**
     * @brief CAN firmware error: BIT0ERR indicates when an inconsistency
     * occurs between the transmitted and the received bit in a CAN frame.
     */
    LLCE_ERROR_BCAN_BIT0ERR,
    /**
     * @brief CAN firmware error: BIT1ERR indicates when an inconsistency
     * occurs between the transmitted and the received bit in a CAN frame.
     */
    LLCE_ERROR_BCAN_BIT1ERR,
    /**
     * @brief CAN firmware error: DPBIT1ERR indicates when an inconsistency
     * occurs between the transmitted and the received bit in the data phase
     * of a CAN-FD frame.
     */
    LLCE_ERROR_BCAN_DPBIT1ERR,
    /**
     * @brief CAN firmware error: DPBIT0ERR indicates when an inconsistency
     * occurs between the transmitted and the received bit in the data phase
     * of a CAN-FD frame.
     */
    LLCE_ERROR_BCAN_DPBIT0ERR,
    /**
     * @brief CAN firmware error: DPSTFERR indicates that a stuffing error has
     * been detected by the receiver node in the data phase of a CAN-FD frame.
     */
    LLCE_ERROR_BCAN_DPSTFERR,
    /**
     * @brief CAN firmware error: DPFRMERR indicates that a form error has
     * been detected by the receiver node in the data phase of a CAN-FD frame
     * - a fixed-form bit field contains at least one illegal bit.
     */
    LLCE_ERROR_BCAN_DPFRMERR,
    /**
     * @brief CAN firmware error: DPCRCERR indicates that a CRC error has been
     * detected by the receiver node in the data phase of a CAN-FD frame
     */
    LLCE_ERROR_BCAN_DPCRCERR,
    /**
     * @brief CAN firmware error: FRMERR indicates that a form error has
     * been detected by the receiver node in a CAN frame - a fixed-form bit
     * field contains at least one illegal bit.
     */
    LLCE_ERROR_BCAN_FRMERR,
    /**
     * @brief CAN firmware error: STFERR indicates that a stuffing error has
     * been detected by the receiver node in a CAN frame.
     */
    LLCE_ERROR_BCAN_STFERR,
    /**
     * @brief CAN firmware error: TDC mechanism is out of range, 
     * unable to compensate the transceiver's loop delay.
     */
    LLCE_ERROR_BCAN_TDCFAIL,
    /**
     * @brief CAN firmware error: DataLost event caused by BCAN RX Fifo
     * Overrun.
     */
    LLCE_ERROR_BCAN_RXFIFO_OVERRUN,
    /**
     * @brief CAN firmware error: Reports data lost event due to resources
     * exceeded after the frame was received
     */
    LLCE_ERROR_DATA_LOST,
    /** @brief CAN firmware error: The number of Message Buffers available for transmission arbitration was exceeded or the status register indicates that the TXLUT accelerator is full. */
    LLCE_ERROR_TXLUT_FULL,
    /** @brief CAN firmware error: A command with an unknown id was issued or the current host tried to overlap the other host's resources at initialization. */
    LLCE_ERROR_CMD_PROCESSING,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_1,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read or write operation on RXLUT registers. */
    LLCE_ERROR_RXLUT_ACCESS_MODE,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read or write operation on RXLUT registers. */
    LLCE_ERROR_RXLUT_SEARCH_MODE,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read on RXLUT registers and no value was obtained within a configured timeout. */
    LLCE_ERROR_RXLUT_SLOW_OPERATION,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read on the RXLUT status register during search operation and no value was obtained within a configured timeout. */
    LLCE_ERROR_RXLUT_INCOMPLETE_OP,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read on the RXLUT status register during flush operation and no value was obtained within a configured timeout. */
    LLCE_ERROR_RXLUT_OPERATING_MODE,
    /** @brief CAN firmware error: Failed to configure the filter entry address and issue write command. */
    LLCE_ERROR_RXLUT_INIT_SLOW_OP,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_2,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_3,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_4,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_5,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_6,
    /** @brief CAN firmware error: Controller is not started or bus-off event has occured. */
    LLCE_ERROR_CTRL_NOT_READY,
    /** @brief CAN firmware error: A bus off event was triggered.
     * This notification is skipped in case of auto-recovery.
     */
    LLCE_ERROR_BUSOFF,
    /** @brief CAN firmware error: Logging FIFO is full. */
    LLCE_ERROR_FIFO_LOG_FULL,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_7,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_8,
    /**
     * @brief CAN firmware error: Error reported due to the rx core not
     * responding.
     */
    LLCE_ERROR_COMMAND_RXPPE_NORESPONSE,
    /**
     * @brief CAN firmware error: Error reported due to frpe core not
     * responding.
     */
    LLCE_ERROR_COMMAND_AF_NORESPONSE,
    /**
     * @brief CAN firmware error: Error reported because the controller is
     * not stopped.
     */
    LLCE_ERROR_COMMAND_DEINIT_NOTSTOP,
    /**
     * @brief CAN firmware error: Error reported because the host didn't
     * read all the RX tokens (indexes in fifos). LLCE waits for indexes
     * to be read and returned.
     */
    LLCE_ERROR_RXTOKENS_UNRETURNED,
    /**
     * @brief CAN firmware error: Error reported because the host didn't
     * read all the ACKs (indexes in fifos). LLCE waits for indexes to be
     * read.
     */
    LLCE_ERROR_TXACK_NOT_READ,
    /**
     * @brief CAN firmware error: Error reported because the requested
     * command is not in the list of supported commands.
     */
    LLCE_ERROR_COMMAND_NOTSUPPORTED,
    /**
     * @brief CAN firmware error: Error reported because command is not
     * validated by the command flow.
     */
    LLCE_ERROR_COMMAND_NOTVALIDATED,
    /**
     * @brief CAN firmware error: Error reported because the requested
     * command is correct but it not accepted.
     */
    LLCE_ERROR_COMMAND_NOTACCEPTED,
    /**
     * @brief CAN firmware error: Error reported because the requested
     * command parameters are invalid.
     */
    LLCE_ERROR_COMMAND_INVALID_PARAMS,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_9,
    /**
     * @brief CAN firmware error: Reports frame accepted, but not delivered
     * to host because of filters misconfiguration.
     */
    LLCE_ERROR_FRAME_NOT_DELIVERED,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_10,
    /**
     * @brief CAN firmware error: Reports frame accepted, but not delivered
     * to host due to lack of descriptors in software FIFO.
     */
    LLCE_ERROR_FRAME_NOT_DELIVERED_TO_HOST,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_12,
    /**
     * @brief CAN firmware error: Error reported because there are no
     * filters available to be set for a specific controller.
     */
    LLCE_ERROR_FILTERS_FULL,
    /**
     * @brief CAN firmware error: The filter pointed by the related address
     * is not used by the related controller.
     */
    LLCE_ERROR_FILTERS_NOTEXIST,
    /** @brief CAN firmware error: There are no free configuration filters.
     */
    LLCE_ERROR_FILTERS_MASK_EMPTY,
    /** @brief CAN firmware error: There are no free configuration filters.
     */
    LLCE_ERROR_FILTERS_RANGE_EMPTY,
    /** @brief CAN firmware error: There are no free exact match filters. */
    LLCE_ERROR_FILTERS_EM_EMPTY,
    /** @brief CAN firmware error: The index returned by host is not valid, possibly a duplicate index. */
    LLCE_ERROR_IDX_NOT_VALID_HOST,
    /** @brief CAN firmware error: The index returned by logging is not valid, the associated destination didn't match.
     */
    LLCE_ERROR_IDX_NOT_VALID_LOG,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_13,
    /**
     * @brief CAN firmware error: Reserved for future use.
     * to HSE because of full FIFO.
     */
    LLCE_ERROR_CODE_RESERVED_14,
    /**
     * @brief CAN firmware error: Tx frame was dropped because MAC generation failed.
     */
    LLCE_ERROR_TXFRAME_MAC_GEN_ERROR,
    /**
     * @brief CAN firmware error: Rx frame was dropped because it is not
     * authentic.
     */
    LLCE_ERROR_RXFRAME_AUTH_ERROR,
    /**
     * @brief CAN firmware error: Reserved for future use.
     * TX core.
     */
    LLCE_ERROR_CODE_RESERVED_16,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_17,
    /** @brief CAN firmware error: RX Software FIFO is empty. */
    LLCE_ERROR_RX_SW_FIFO_EMPTY,
    /** @brief AF error : error communicating with PFE due to PFE internal error*/
    LLCE_ERROR_PFEIF,
    /** @brief AF error : error communicating with HSE due to HSE internal error*/
    LLCE_ERROR_HSEIF,
    /**
     * @brief Generic firmware code: Command was executed successfully by
     * LLCE Firmware.
     */
    LLCE_FW_SUCCESS,
    /**
     * @brief Generic firmware error: During command execution
     * an error condition was detected.
     */
    LLCE_FW_ERROR,
    /**
     * @brief Generic firmware code: Default value of command return
     * status, set by the host before to send it to LLCE firmware.
     */
    LLCE_FW_NOTRUN,
    /**
     * @brief CAN firmware error: Internal Descriptor was not returned
     * to the source.
     */
    LLCE_ERROR_INTERNALDESC_NOT_RETURNED,
    /**
     * @brief CAN firmware error: Internal Descriptor was not delivered
     * to the destination.
     */
    LLCE_ERROR_INTERNALDESC_NOT_DELIVERED,
    /**
     * @brief CAN firmware error: Internal Descriptor is not available because 
     * the internal LLCE software FIFO is empty.
     */
    LLCE_ERROR_INTERNALDESC_NOTAVAIL,
    /**
     * @brief CAN firmware error: Internal Descriptor software FIFO is full.
     */
    LLCE_ERROR_INTERNALDESC_FIFO_FULL,
    /** @brief CAN firmware error: Message Buffer is not available.
     * the internal message buffer software FIFO is empty.
     */
    LLCE_ERROR_MB_NOTAVAIL,
    /** @brief CAN firmware error: Message Buffer software FIFO is full. */
    LLCE_ERROR_MB_FIFO_FULL,
    /**
     * @brief CAN firmware error: Maximum number of Tx MB per controller for
     * AF is reached.
     */
    LLCE_ERROR_NO_MB_AVAILABLE,
    /** @brief CAN firmware error: The source of the request did not match any of the LLCE cores ids. */
    LLCE_ERROR_UNKNOWN_SRC,
    /** @brief CAN firmware error: Unknown destination of the request : it's neither a CAN or ETHERNET channel, nor the host. */
    LLCE_ERROR_UNKNOWN_DEST,
    /** @brief CAN firmware error: Unknown request in intercore communication. */
    LLCE_ERROR_UNKNOWN_REQUEST,
    /** @brief CAN firmware error: Issued for frames with DLC greater than 8 where destination is not FD . */
    LLCE_ERROR_CONVERSION,
    /**
     * @brief CAN firmware error: AbortMB request failed due to no pending
     * transmission that can be aborted.
     */
    LLCE_ERROR_NO_MB_TO_ABORT,
    /**
     * @brief CAN firmware error: Index not recovered from DTE after Stop
     * or busoff event.
     */
    LLCE_ERROR_INDEX_NOT_RECOVERED,
    /** @brief CAN firmware error: The controller did not exit from freeze mode within a conifgured timeout. */
    LLCE_ERROR_RESET_PENDING,
    /** @brief CAN firmware fatal error: core has entered an error state and is not recoverable. */
    LLCE_ERROR_FATAL,
    /** @brief CAN firmware notification: BCAN is ready to leave bus-off
     * state after the automatic recovery procedure
     */
    LLCE_NOTIF_BUSOFF_DONE,
    /** @brief CAN firmware error: TXWRN is set when the Tx error counter ECR[TEC] reached 96. */
    LLCE_ERROR_BCAN_TXWRN,
    /** @brief CAN firmware error: RXWRN is set when the Rx error counter ECR[REC] reached 96. */
    LLCE_ERROR_BCAN_RXWRN,
    /** @brief CAN firmware error: PASSERR is set when BCAN enters Passive state. */
    LLCE_ERROR_BCAN_PASSERR,
    /** @brief CAN firmware notification: BCAN exits Passive state. */
    LLCE_NOTIF_BCAN_EXIT_PASSIVE_STATE,
    /** @brief CAN firmware notification: There was an attempt to perform routing to a disabled destination. */
    LLCE_ERROR_ROUTINGCHANNEL_DISABLED,
    /** @brief CAN firmware notification: Shutdown request received from host. */
    LLCE_SHUTDOWN_REQUESTED,
    /** @brief CAN firmware notification: Core has entered shutdown state. */
    LLCE_SHUTDOWN_ENTERED,
    /** @brief CAN firmware notification: Core has received an unexpected event during shutdown and
     * is halted but awake */
    LLCE_SHUTDOWN_FAILED,
    /** @brief Number of enum elements. It must be kept as the last member of the list. */
    LLCE_FW_RETURNTYPE_COUNT

} Llce_Fw_ReturnType;

/*==================================================================================================
 *                                STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/
/**
 * @brief Boot sequence data type.
 *
 * Data type used to access shared memory area for managing LLCE boot sequence
 **/

typedef struct
{
    /**
     * @brief OUTPUT: Boot Status of TXPPE. This can be NOTRUN, SUCCESS, or
     * a specific ERROR information
     */
    Llce_Fw_ReturnType eTxBootStatus;
    /**
     * @brief OUTPUT: Boot Status of RXPPE. This can be NOTRUN, SUCCESS, or
     * a specific ERROR information
     */
    Llce_Fw_ReturnType eRxBootStatus;
    /**
     * @brief OUTPUT: Boot Status of RXPPE. This can be NOTRUN, SUCCESS, or
     * a specific ERROR information
     */
    Llce_Fw_ReturnType eDteBootStatus;
    /**
     * @brief OUTPUT: Boot Status of RXPPE. This can be NOTRUN, SUCCESS, or
     * a specific ERROR information
     */
    Llce_Fw_ReturnType eFrpeBootStatus;
    /** @brief OUTPUT: LLCE FW version structure. */
    Llce_Fw_VersionType LlceFwVersion;

} LLCE__ALIGNED__PACKED Llce_Mgr_StatusType;

/**
 * @brief Structure for the timestamps of cores 1, 2, and 3
 * 
 * Structure contains the timestamps for the cores 1, 2, and 3 and shall be 
 * read by host in order to verify if a crash, or high delay has occurred or not.
 **/
typedef struct
{
    /** @brief Timestamp for Core 1. */
    uint32 timeStampCore1;
    /** @brief Timestamp for Core 2. */
    uint32 timeStampCore2;
    /** @brief Timestamp for Core 3. */
    uint32 timeStampCore3;
} LLCE__ALIGNED__PACKED Llce_Mgr_TimeStampCoresType;


#ifdef CHECK_ABI_COMPATIBILITY
#pragma ABICHECK stop
#endif
/*==================================================================================================
 *                                GLOBAL VARIABLE DECLARATIONS
 ==================================================================================================*/

/*==================================================================================================
 *                                    FUNCTION PROTOTYPES
 ==================================================================================================*/

 /** @brief   Helper function that returns the category of a value returned by the LLCE FW.
 *   @details Determines the category of a value returned by the LLCE Firmware.
 *            It can take as input errors, notifications and status values (see Llce_Fw_ReturnType).
 *            It will return the category that value belongs to.
 *   @param[in] eNotificationCode CAN error, notification or status values as they are reported by the LLCE firmware.
 *   @return CAN firmware notification category.
 */
static inline Llce_Fw_Notification_Category Llce_GetNotificationCategory(Llce_Fw_ReturnType eNotificationCode)
{
    Llce_Fw_Notification_Category eNotifCategory;

    switch(eNotificationCode)
    {
        case LLCE_ERROR_BUSOFF:
        case LLCE_NOTIF_BUSOFF_DONE:
            eNotifCategory = LLCE_NOTIFCAT_BUSOFF;
            break;

        /* Treat all the cases leading to DATA_LOST which should be reported to the host */
        case LLCE_ERROR_RXOUT_FIFO_FULL:
        case LLCE_ERROR_MB_NOTAVAILABLE:
        case LLCE_ERROR_BCAN_RXFIFO_OVERRUN:
            eNotifCategory = LLCE_NOTIFCAT_DATA_LOST;
            break;

        /* Can protocol errors */
        case LLCE_ERROR_BCAN_TDCFAIL:
        case LLCE_ERROR_BCAN_ACKERR:
        case LLCE_ERROR_BCAN_CRCERR:
        case LLCE_ERROR_BCAN_BIT0ERR:
        case LLCE_ERROR_BCAN_BIT1ERR:
        case LLCE_ERROR_BCAN_DPBIT0ERR:
        case LLCE_ERROR_BCAN_DPBIT1ERR:
        case LLCE_ERROR_BCAN_STFERR:
        case LLCE_ERROR_BCAN_FRMERR:
        case LLCE_ERROR_BCAN_DPSTFERR:
        case LLCE_ERROR_BCAN_DPFRMERR:
        case LLCE_ERROR_BCAN_DPCRCERR:
        case LLCE_ERROR_BCAN_UNKNOWN_ERROR:
        case LLCE_ERROR_BCAN_FRZ_EXIT:
        case LLCE_ERROR_BCAN_SYNC:
        case LLCE_ERROR_BCAN_FRZ_ENTER:
        case LLCE_ERROR_BCAN_LPM_EXIT:
        case LLCE_ERROR_BCAN_SRT_ENTER:
        case LLCE_NOTIF_BCAN_EXIT_PASSIVE_STATE:
            eNotifCategory = LLCE_NOTIFCAT_CAN_PROTOCOL;
            break;
        case LLCE_ERROR_BCAN_TXWRN:
        case LLCE_ERROR_BCAN_RXWRN:
        case LLCE_ERROR_BCAN_PASSERR:
            eNotifCategory = LLCE_NOTIFCAT_CAN_PROTOCOL_CRITICAL_STATE;
            break;

        /* Initialization errors. This category contains errors caused by bad usage or a
           malicious host (eg initialization errors, bad cmd parameters, invalid indexes etc). */
        case LLCE_ERROR_COMMAND_NOTSUPPORTED:
        case LLCE_ERROR_COMMAND_NOTACCEPTED:
        case LLCE_ERROR_COMMAND_INVALID_PARAMS:
        case LLCE_ERROR_RXTOKENS_UNRETURNED:
        case LLCE_ERROR_FILTERS_NOTEXIST:
        case LLCE_ERROR_FILTERS_FULL:
        case LLCE_ERROR_CMD_PROCESSING:
        case LLCE_ERROR_TXACK_NOT_READ:
        case LLCE_ERROR_COMMAND_DEINIT_NOTSTOP:
            eNotifCategory = LLCE_NOTIFCAT_CONFIGURATION;
            break;

        /* Values that are neither errors nor notifications. */
        case LLCE_FW_SUCCESS:
        case LLCE_FW_ERROR:
        case LLCE_FW_NOTRUN:
            eNotifCategory = LLCE_NOTIFCAT_FW_STATUS;
            break;

        default:
            eNotifCategory = LLCE_NOTIFCAT_INTERNAL;
            break;
    }

    return eNotifCategory;
}


#ifdef __cplusplus
}
#endif

#endif /* LLCE_INTERFACEFWMGR_H */

/** @} */


===== 文件 [75/112]: include\Llce_InterfaceIcsr.h =====
/**
 *   @file    Llce_InterfaceIcsr.h
 *
 *   @brief   This file contains defines used for accessing ICSR hw module
 *   @details This file contains defines used for accessing ICSR hw module
 *
 *   @addtogroup LLCE_CAN_firmware_interface LLCE CAN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_INTERFACEICSR_H
#define LLCE_INTERFACEICSR_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __DOXYGEN__
/**
 * @page misra_violations MISRA-C:2012 violations
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 4.9, A function should be used in
 * preference to a function-like macro where they are interchangeable. Function
 * like macro are used to reduce code complexity
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 2.5, A project should not contain unused
 * macro declarations Some macros are used either in FW or driver, or provided
 * as API
 *
 */
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/

/*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/

/*==================================================================================================
                  INTERRUPT CONCENTRATOR DEFINES AND ADDRESS
 CALCULATION MACROS
 =================================================================================================*/
#define LLCE_ICSR_ADDR(u8RegNo)                                                \
    ((uint32)LLCE_ICSR_BASEADDR + ((uint32)(u8RegNo) * (uint32)4U))
#define LLCE_ICSR_RIFA16_U32 ((uint32)0x00000001U)
#define LLCE_ICSR_ROFA16_U32 ((uint32)0x00000010U)
#define LLCE_ICSR_TAFA16_U32 ((uint32)0x00000001U)

#define LLCE_ICSR_GF0AINT_U32 ((uint32)0x00000001U)
#define LLCE_ICSR_GF1AINT_U32 ((uint32)0x00000002U)
#define LLCE_ICSR_GF2AINT_U32 ((uint32)0x00000004U)
#define LLCE_ICSR_GF3AINT_U32 ((uint32)0x00000008U)
#define LLCE_ICSR_GF0BINT_U32 ((uint32)0x00000010U)
#define LLCE_ICSR_GF1BINT_U32 ((uint32)0x00000020U)
#define LLCE_ICSR_GF2BINT_U32 ((uint32)0x00000040U)
#define LLCE_ICSR_GF3BINT_U32 ((uint32)0x00000080U)

#define LLCE_ICSR_INTFLAG_00 (0x01U)
#define LLCE_ICSR_INTFLAG_01 (0x02U)
#define LLCE_ICSR_INTFLAG_02 (0x04U)
#define LLCE_ICSR_INTFLAG_03 (0x08U)
#define LLCE_ICSR_INTFLAG_04 (0x10U)
#define LLCE_ICSR_INTFLAG_05 (0x20U)
#define LLCE_ICSR_INTFLAG_06 (0x40U)
#define LLCE_ICSR_INTFLAG_07 (0x80U)

/*==================================================================================================
 *                                      Interrupts
 ==================================================================================================*/

/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/*==================================================================================================
 *                                STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/

/*==================================================================================================
 *                                GLOBAL VARIABLE DECLARATIONS
 ==================================================================================================*/

/*==================================================================================================
 *                                    FUNCTION PROTOTYPES
 ==================================================================================================*/

#ifdef __cplusplus
}
#endif

#endif /* LLCE_INTERFACEICSR_H */

/** @} */


===== 文件 [76/112]: include\Llce_InterfaceMemLayoutCheck.h =====

/**
 *   @file    Llce_InterfaceMemLayoutCheck.h
 *
 *   @brief   LLCE defines provided to cross check memory layout
 *   @details This file contains defines meant to cross check
 *              the memory layout by using compile-time operators sizeof and offsetof.
 *              If the size or offset of any member in a structure/union does not correspond
 *              to the expected precalculated value, the compiling process of host
 *              application which integrates Llce_Interface*.h fails. 
 *
 *   @addtogroup LLCE_CAN_firmware_interface LLCE CAN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2021-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/
#ifndef LLCE_INTERFACEMEMLAYOUTCHECK_H
#define LLCE_INTERFACEMEMLAYOUTCHECK_H

#ifndef DISABLE_MEM_LAYOUT_CHECK

#include <stddef.h>
#include "Llce_InterfaceCanTypes.h"

/**
 * @brief This macro extracts the member from a structure
*/
#define MEMBER_OF(type,member) (((type *)(void *)0)->member)

/**
 * @brief LLCE_INTERFACE_STATIC_ASSERT macro produces error when the compiler generated size for a datatype 
    does not match the expected value. This makes the datatypes size compatible with the firmware binary image.
*/
#define LLCE_INTERFACE_STATIC_ASSERT(condition) extern uint8 LLCE_CHECK_TYPE_SIZE[(condition) ? 1 : -1]


LLCE_INTERFACE_STATIC_ASSERT(sizeof(Can_Af_DestRulesType) == 40U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Can_Af_DestRulesType,AfDest)) == 36U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Can_Af_DestRulesType,AfDest) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Can_Af_DestRulesType,eAfDestId)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Can_Af_DestRulesType,eAfDestId) == 36U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_AbortMbCmdType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AbortMbCmdType,u16FrameTag)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AbortMbCmdType,u16FrameTag) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AbortMbCmdType,u8AbortedFrameCnt)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AbortMbCmdType,u8AbortedFrameCnt) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AbortMbCmdType,eAbortMbType)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AbortMbCmdType,eAbortMbType) == 3U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_AdvancedFeatureType) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFeatureType,eCanAuthenticationFeature)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFeatureType,eCanAuthenticationFeature) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFeatureType,eHostReceive)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFeatureType,eHostReceive) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFeatureType,eCanLoggingFeature)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFeatureType,eCanLoggingFeature) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFeatureType,eCanCustomProcessing)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFeatureType,eCanCustomProcessing) == 3U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFeatureType,u8Can2CanRoutingTableIdx)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFeatureType,u8Can2CanRoutingTableIdx) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFeatureType,u8Can2EthRoutingTableIdx)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFeatureType,u8Can2EthRoutingTableIdx) == 5U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFeatureType,u8OtherRoutingTableIdx)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFeatureType,u8OtherRoutingTableIdx) == 6U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_AdvancedFilterType) == 28U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFilterType,Llce_Can_RxFilter)) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFilterType,Llce_Can_RxFilter) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFilterType,Llce_Can_AdvancedFeature)) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFilterType,Llce_Can_AdvancedFeature) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_AuxFilterType) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AuxFilterType,uIdMask)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AuxFilterType,uIdMask) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AuxFilterType,uMessageId)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AuxFilterType,uMessageId) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AuxFilterType,u16AuxSearchResult)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AuxFilterType,u16AuxSearchResult) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AuxFilterType,eEntryType)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AuxFilterType,eEntryType) == 10U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_Can2CanRoutingTableType) == 28U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2CanRoutingTableType,u32Can2CanRoutingOptions)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2CanRoutingTableType,u32Can2CanRoutingOptions) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2CanRoutingTableType,u32CanIdRemapValue)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2CanRoutingTableType,u32CanIdRemapValue) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2CanRoutingTableType,u8DestHwChList)) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2CanRoutingTableType,u8DestHwChList) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2CanRoutingTableType,u8DestHwChListCount)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2CanRoutingTableType,u8DestHwChListCount) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_Can2EthRoutingTableType) == 36U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,pu8Can2EthBuffAddr)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,pu8Can2EthBuffAddr) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u16Can2EthBuffSize)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u16Can2EthBuffSize) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u8Can2EthBuffCount)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u8Can2EthBuffCount) == 6U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,eFormat)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,eFormat) == 7U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u8Can2EthDestMac)) == 6U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u8Can2EthDestMac) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u8Can2EthSrcMac)) == 6U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u8Can2EthSrcMac) == 14U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u8Can2EthDstIp)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u8Can2EthDstIp) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u8Can2EthSrcIp)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u8Can2EthSrcIp) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u8Can2EthDstPort)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u8Can2EthDstPort) == 28U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u8Can2EthSrcPort)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u8Can2EthSrcPort) == 30U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u16Can2EthPhyIfList)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u16Can2EthPhyIfList) == 32U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_Can2HseRoutingTableType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2HseRoutingTableType,u32Can2HseKeyHandle)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2HseRoutingTableType,u32Can2HseKeyHandle) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_Can2PcieRoutingTableType) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2PcieRoutingTableType,u64Can2PcieRcBuffAddr)) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2PcieRoutingTableType,u64Can2PcieRcBuffAddr) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2PcieRoutingTableType,pu8Can2PcieBuffAddr)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2PcieRoutingTableType,pu8Can2PcieBuffAddr) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2PcieRoutingTableType,u16Can2PcieBuffSize)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2PcieRoutingTableType,u16Can2PcieBuffSize) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieBuffCount)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieBuffCount) == 14U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieController)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieController) == 15U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieDmaChannel)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieDmaChannel) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieMsiId)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieMsiId) == 17U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_ChangeFilterType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ChangeFilterType,u16FilterAddr)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ChangeFilterType,u16FilterAddr) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ChangeFilterType,u8FilterEnabled)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ChangeFilterType,u8FilterEnabled) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_ChannelErrorNotifType) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ChannelErrorNotifType,ErrorInfo)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ChannelErrorNotifType,ErrorInfo) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ChannelErrorNotifType,u8HwCtrl)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ChannelErrorNotifType,u8HwCtrl) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_CommandListType) == 404U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,Init)) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,Init) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,GetStatus)) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,GetStatus) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,SetFilter)) == 404U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,SetFilter) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,SetAdvancedFilter)) == 228U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,SetAdvancedFilter) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,ChangeFilter)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,ChangeFilter) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,SetBaudrate)) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,SetBaudrate) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,GetControllerMode)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,GetControllerMode) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,SetControllerMode)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,SetControllerMode) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,GetFwVersion)) == 52U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,GetFwVersion) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,InitPlatform)) == 192U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,InitPlatform) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,InitPfe)) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,InitPfe) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,InitPfeWithExternRing)) == 36U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,InitPfeWithExternRing) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,CreateAfDest)) == 44U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,CreateAfDest) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,RemoveAfDest)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,RemoveAfDest) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,AbortMb)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,AbortMb) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,pCustomCmdArg)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,pCustomCmdArg) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,SetAuxFilter)) == 244U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,SetAuxFilter) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,eBinaryValue)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,eBinaryValue) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,SetEth2CanFormatState)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,SetEth2CanFormatState) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_CommandType) == 408U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandType,CmdList)) == 404U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandType,CmdList) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandType,eCmdId)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandType,eCmdId) == 404U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandType,eReturnValue)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandType,eReturnValue) == 405U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_ControllerFdConfigType) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ControllerFdConfigType,u32DataBaudrateConfig)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ControllerFdConfigType,u32DataBaudrateConfig) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ControllerFdConfigType,u8FdEnable)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ControllerFdConfigType,u8FdEnable) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ControllerFdConfigType,u8ControllerTxBitRateSwitch)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ControllerFdConfigType,u8ControllerTxBitRateSwitch) == 5U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ControllerFdConfigType,u8TrcvDelayCompEnable)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ControllerFdConfigType,u8TrcvDelayCompEnable) == 6U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ControllerFdConfigType,u8TrcvDelayMeasEnable)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ControllerFdConfigType,u8TrcvDelayMeasEnable) == 7U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ControllerFdConfigType,u8TrcvDelayCompOffset)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ControllerFdConfigType,u8TrcvDelayCompOffset) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_CreateAfDestination) == 44U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CreateAfDestination,rule)) == 40U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CreateAfDestination,rule) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CreateAfDestination,u8Idx)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CreateAfDestination,u8Idx) == 40U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_CtrlModeNotifType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CtrlModeNotifType,eControllerState)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CtrlModeNotifType,eControllerState) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CtrlModeNotifType,u8HwCtrl)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CtrlModeNotifType,u8HwCtrl) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_ErrorCategoryType) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorCategoryType,eCanProtocolErr)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorCategoryType,eCanProtocolErr) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorCategoryType,eDataLostErr)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorCategoryType,eDataLostErr) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorCategoryType,eInitErr)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorCategoryType,eInitErr) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorCategoryType,eInternalErr)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorCategoryType,eInternalErr) == 3U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorCategoryType,eBusOffErr)) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorCategoryType,eBusOffErr) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorCategoryType,eCanProtocolWarn)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorCategoryType,eCanProtocolWarn) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_ErrorNotifType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorNotifType,eModuleId)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorNotifType,eModuleId) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorNotifType,eErrorCode)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorNotifType,eErrorCode) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorNotifType,u16ErrorCount)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorNotifType,u16ErrorCount) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_GetControllerModeCmdType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_GetControllerModeCmdType,eControllerState)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_GetControllerModeCmdType,eControllerState) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_GetStatusCmdType) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_GetStatusCmdType,u32ECR)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_GetStatusCmdType,u32ECR) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_GetStatusCmdType,u32ISR)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_GetStatusCmdType,u32ISR) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_GetStatusCmdType,u32SR)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_GetStatusCmdType,u32SR) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_GetStatusCmdType,u32CRC)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_GetStatusCmdType,u32CRC) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_InitCmdType) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitCmdType,u32CtrlConfig)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitCmdType,u32CtrlConfig) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitCmdType,u8TxMbCount)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitCmdType,u8TxMbCount) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_InitPfeCmdType) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,pRxRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,pRxRing) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,pRxWbRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,pRxWbRing) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,pTxRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,pTxRing) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,pTxWbRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,pTxWbRing) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,pRxBuffers)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,pRxBuffers) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,u16RxBufSize)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,u16RxBufSize) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,u8RxBufCount)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,u8RxBufCount) == 22U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,u8Hif)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,u8Hif) == 23U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_InitPfeWithExternRingCmdType) == 36U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,pRxRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,pRxRing) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,pRxWbRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,pRxWbRing) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,pTxRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,pTxRing) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,pTxWbRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,pTxWbRing) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,pRxBuffers)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,pRxBuffers) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,u32RingSize)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,u32RingSize) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,pHeader)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,pHeader) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,u16RxBufSize)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,u16RxBufSize) == 28U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,u8RxBufCount)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,u8RxBufCount) == 30U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,u8HeaderSize)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,u8HeaderSize) == 31U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,u8Hif)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,u8Hif) == 32U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_InitPlatformCmdType) == 192U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,eCtrlInitStatus)) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,eCtrlInitStatus) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,au16MaxRegularFilterCount)) == 32U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,au16MaxRegularFilterCount) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,au16MaxAdvancedFilterCount)) == 32U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,au16MaxAdvancedFilterCount) == 48U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,au16MaxIntMbCount)) == 32U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,au16MaxIntMbCount) == 80U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,au16MaxPollMbCount)) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,au16MaxPollMbCount) == 112U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,au16MaxIntTxAckCount)) == 32U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,au16MaxIntTxAckCount) == 124U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,au16MaxPollTxAckCount)) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,au16MaxPollTxAckCount) == 156U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,CanErrorReporting)) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,CanErrorReporting) == 168U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_MbType) == 76U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_MbType,u32Word0)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_MbType,u32Word0) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_MbType,u32Word1)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_MbType,u32Word1) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_MbType,u8Payload)) == 64U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_MbType,u8Payload) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_MbType,u32Timestamp)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_MbType,u32Timestamp) == 72U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_NotificationListType) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_NotificationListType,CtrlMode)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_NotificationListType,CtrlMode) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_NotificationListType,PlatformError)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_NotificationListType,PlatformError) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_NotificationListType,ChannelError)) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_NotificationListType,ChannelError) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_NotificationTableType) == 816U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_NotificationTableType,Can_aNotif0_Table)) == 408U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_NotificationTableType,Can_aNotif0_Table) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_NotificationTableType,Can_aNotif1_Table)) == 408U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_NotificationTableType,Can_aNotif1_Table) == 408U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_NotificationType) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_NotificationType,NotifList)) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_NotificationType,NotifList) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_NotificationType,eNotifId)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_NotificationType,eNotifId) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_ReceiveFilterType) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,uIdMask)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,uIdMask) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,uMessageId)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,uMessageId) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,u16FilterId)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,u16FilterId) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,u16MbCount)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,u16MbCount) == 10U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,u16FilterAddr)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,u16FilterAddr) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,u8RxDestInterface)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,u8RxDestInterface) == 14U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,eEntryType)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,eEntryType) == 15U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,eFilterMbLength)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,eFilterMbLength) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_RxMbDescriptorType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxMbDescriptorType,u16FilterId)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxMbDescriptorType,u16FilterId) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxMbDescriptorType,u16AuxSearchResult)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxMbDescriptorType,u16AuxSearchResult) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_RxTxCountType) == 40U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32GeneralRxCount)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32GeneralRxCount) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32GeneralTxCount)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32GeneralTxCount) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32Can2CanInCount)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32Can2CanInCount) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32Can2CanOutCount)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32Can2CanOutCount) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32Can2EthCount)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32Can2EthCount) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32Eth2CanCount)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32Eth2CanCount) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32ReservedCount1)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32ReservedCount1) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32ReservedCount2)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32ReservedCount2) == 28U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32ReservedCount3)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32ReservedCount3) == 32U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32ReservedCount4)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32ReservedCount4) == 36U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_SetAdvancedFilterCmdType) == 228U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetAdvancedFilterCmdType,aAdvancedFilters)) == 224U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetAdvancedFilterCmdType,aAdvancedFilters) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetAdvancedFilterCmdType,u16RxFiltersCount)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetAdvancedFilterCmdType,u16RxFiltersCount) == 224U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_SetAuxFilterCmdType) == 244U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetAuxFilterCmdType,aRxAuxFilters)) == 240U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetAuxFilterCmdType,aRxAuxFilters) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetAuxFilterCmdType,u16RxAuxFiltersCount)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetAuxFilterCmdType,u16RxAuxFiltersCount) == 240U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_SetBaudrateCmdType) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetBaudrateCmdType,u32NominalBaudrateConfig)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetBaudrateCmdType,u32NominalBaudrateConfig) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetBaudrateCmdType,ControllerFD)) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetBaudrateCmdType,ControllerFD) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_SetControllerModeCmdType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetControllerModeCmdType,eTransition)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetControllerModeCmdType,eTransition) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_SetEth2CanFormatStateCmdType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetEth2CanFormatStateCmdType,eFormat)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetEth2CanFormatStateCmdType,eFormat) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetEth2CanFormatStateCmdType,eState)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetEth2CanFormatStateCmdType,eState) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_SetFilterCmdType) == 404U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetFilterCmdType,aRxFilters)) == 400U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetFilterCmdType,aRxFilters) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetFilterCmdType,u16RxFiltersCount)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetFilterCmdType,u16RxFiltersCount) == 400U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_SharedMemoryType) == 242928U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SharedMemoryType,Can_Rx_aMbDesc)) == 16512U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SharedMemoryType,Can_Rx_aMbDesc) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SharedMemoryType,Can_Tx_aMbDesc)) == 2048U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SharedMemoryType,Can_Tx_aMbDesc) == 16512U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SharedMemoryType,Can_aMb)) == 170544U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SharedMemoryType,Can_aMb) == 18560U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SharedMemoryType,Can_aSMb)) == 47920U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SharedMemoryType,Can_aSMb) == 189104U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SharedMemoryType,aCanCmd)) == 816U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SharedMemoryType,aCanCmd) == 237024U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SharedMemoryType,Can_NotificationTable)) == 816U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SharedMemoryType,Can_NotificationTable) == 237840U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SharedMemoryType,Can_Tx_aAckInfo)) == 4272U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SharedMemoryType,Can_Tx_aAckInfo) == 238656U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_ShortMbType) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ShortMbType,u32Word0)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ShortMbType,u32Word0) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ShortMbType,u32Word1)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ShortMbType,u32Word1) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ShortMbType,u8Payload)) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ShortMbType,u8Payload) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ShortMbType,u32Timestamp)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ShortMbType,u32Timestamp) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_Tx2HostAckInfoType) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Tx2HostAckInfoType,u32TxTimestamp)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Tx2HostAckInfoType,u32TxTimestamp) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Tx2HostAckInfoType,u16FrameTag1)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Tx2HostAckInfoType,u16FrameTag1) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Tx2HostAckInfoType,u16FrameTag2)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Tx2HostAckInfoType,u16FrameTag2) == 6U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_TxMbDescriptorType) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_TxMbDescriptorType,u16FrameTag1)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_TxMbDescriptorType,u16FrameTag1) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_TxMbDescriptorType,u16FrameTag2)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_TxMbDescriptorType,u16FrameTag2) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_TxMbDescriptorType,u16MbFrameIdx)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_TxMbDescriptorType,u16MbFrameIdx) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_TxMbDescriptorType,u8AckInterface)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_TxMbDescriptorType,u8AckInterface) == 6U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_TxMbDescriptorType,u8EnableTxFrameMac)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_TxMbDescriptorType,u8EnableTxFrameMac) == 7U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Fw_VersionType) == 52U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Fw_VersionType,stringLength)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Fw_VersionType,stringLength) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Fw_VersionType,versionString)) == 50U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Fw_VersionType,versionString) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Mgr_StatusType) == 56U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_StatusType,eTxBootStatus)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_StatusType,eTxBootStatus) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_StatusType,eRxBootStatus)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_StatusType,eRxBootStatus) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_StatusType,eDteBootStatus)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_StatusType,eDteBootStatus) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_StatusType,eFrpeBootStatus)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_StatusType,eFrpeBootStatus) == 3U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_StatusType,LlceFwVersion)) == 52U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_StatusType,LlceFwVersion) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Mgr_TimeStampCoresType) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_TimeStampCoresType,timeStampCore1)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_TimeStampCoresType,timeStampCore1) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_TimeStampCoresType,timeStampCore2)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_TimeStampCoresType,timeStampCore2) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_TimeStampCoresType,timeStampCore3)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_TimeStampCoresType,timeStampCore3) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIFCAT_CAN_PROTOCOL == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIFCAT_DATA_LOST == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIFCAT_CONFIGURATION == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIFCAT_INTERNAL == 4U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIFCAT_BUSOFF == 5U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIFCAT_FW_STATUS == 6U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIFCAT_CAN_PROTOCOL_CRITICAL_STATE == 7U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_TXACK_FIFO_FULL == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXOUT_FIFO_FULL == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_0 == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_HW_FIFO_FULL == 4U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_SW_FIFO_EMPTY == 5U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_SW_FIFO_FULL == 6U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_MB_NOTAVAILABLE == 7U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_SHORT_MB_NOTAVAILABLE == 8U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_FRZ_EXIT == 9U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_SYNC == 10U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_FRZ_ENTER == 11U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_LPM_EXIT == 12U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_SRT_ENTER == 13U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_UNKNOWN_ERROR == 14U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_ACKERR == 15U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_CRCERR == 16U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_BIT0ERR == 17U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_BIT1ERR == 18U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_DPBIT1ERR == 19U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_DPBIT0ERR == 20U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_DPSTFERR == 21U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_DPFRMERR == 22U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_DPCRCERR == 23U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_FRMERR == 24U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_STFERR == 25U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_TDCFAIL == 26U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_RXFIFO_OVERRUN == 27U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_DATA_LOST == 28U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_TXLUT_FULL == 29U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CMD_PROCESSING == 30U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_1 == 31U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXLUT_ACCESS_MODE == 32U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXLUT_SEARCH_MODE == 33U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXLUT_SLOW_OPERATION == 34U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXLUT_INCOMPLETE_OP == 35U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXLUT_OPERATING_MODE == 36U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXLUT_INIT_SLOW_OP == 37U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_2 == 38U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_3 == 39U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_4 == 40U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_5 == 41U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_6 == 42U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CTRL_NOT_READY == 43U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BUSOFF == 44U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FIFO_LOG_FULL == 45U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_7 == 46U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_8 == 47U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_COMMAND_RXPPE_NORESPONSE == 48U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_COMMAND_AF_NORESPONSE == 49U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_COMMAND_DEINIT_NOTSTOP == 50U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXTOKENS_UNRETURNED == 51U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_TXACK_NOT_READ == 52U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_COMMAND_NOTSUPPORTED == 53U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_COMMAND_NOTVALIDATED == 54U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_COMMAND_NOTACCEPTED == 55U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_COMMAND_INVALID_PARAMS == 56U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_9 == 57U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FRAME_NOT_DELIVERED == 58U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_10 == 59U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FRAME_NOT_DELIVERED_TO_HOST == 60U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_12 == 61U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FILTERS_FULL == 62U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FILTERS_NOTEXIST == 63U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FILTERS_MASK_EMPTY == 64U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FILTERS_RANGE_EMPTY == 65U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FILTERS_EM_EMPTY == 66U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_IDX_NOT_VALID_HOST == 67U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_IDX_NOT_VALID_LOG == 68U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_13 == 69U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_14 == 70U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_TXFRAME_MAC_GEN_ERROR == 71U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXFRAME_AUTH_ERROR == 72U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_16 == 73U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_17 == 74U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RX_SW_FIFO_EMPTY == 75U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_PFEIF == 76U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_HSEIF == 77U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_FW_SUCCESS == 78U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_FW_ERROR == 79U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_FW_NOTRUN == 80U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_INTERNALDESC_NOT_RETURNED == 81U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_INTERNALDESC_NOT_DELIVERED == 82U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_INTERNALDESC_NOTAVAIL == 83U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_INTERNALDESC_FIFO_FULL == 84U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_MB_NOTAVAIL == 85U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_MB_FIFO_FULL == 86U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_NO_MB_AVAILABLE == 87U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_UNKNOWN_SRC == 88U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_UNKNOWN_DEST == 89U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_UNKNOWN_REQUEST == 90U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CONVERSION == 91U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_NO_MB_TO_ABORT == 92U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_INDEX_NOT_RECOVERED == 93U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RESET_PENDING == 94U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FATAL == 95U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIF_BUSOFF_DONE == 96U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_TXWRN == 97U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_RXWRN == 98U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_PASSERR == 99U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIF_BCAN_EXIT_PASSIVE_STATE == 100U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_ROUTINGCHANNEL_DISABLED == 101U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SHUTDOWN_REQUESTED == 102U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SHUTDOWN_ENTERED == 103U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SHUTDOWN_FAILED == 104U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_FW_RETURNTYPE_COUNT == 105U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE0 == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE1 == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE2 == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE3 == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE4 == 4U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE5 == 5U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE6 == 6U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE7 == 7U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE8 == 8U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE9 == 9U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE10 == 10U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE11 == 11U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE12 == 12U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE13 == 13U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE14 == 14U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE15 == 15U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE16 == 16U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE17 == 17U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE18 == 18U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE19 == 19U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE20 == 20U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE21 == 21U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE22 == 22U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE23 == 23U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE24 == 24U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE25 == 25U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE26 == 26U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE27 == 27U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE28 == 28U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE29 == 29U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE30 == 30U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE31 == 31U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE32 == 32U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE33 == 33U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE34 == 34U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE35 == 35U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE36 == 36U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE37 == 37U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE38 == 38U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE39 == 39U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE40 == 40U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE41 == 41U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE42 == 42U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE43 == 43U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE44 == 44U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE45 == 45U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE46 == 46U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE47 == 47U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE48 == 48U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE49 == 49U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE50 == 50U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE51 == 51U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE52 == 52U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE53 == 53U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE54 == 54U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE55 == 55U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE56 == 56U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE57 == 57U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE58 == 58U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE59 == 59U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE60 == 60U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE61 == 61U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE62 == 62U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE63 == 63U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_NOTIF_NOERROR == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_NOTIF_PLATFORMERROR == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_NOTIF_CHANNELERROR == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_NOTIF_CTRLMODE == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_INIT == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_DEINIT == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETBAUDRATE == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_GETCONTROLLERMODE == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETCONTROLLERMODE == 4U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_MANUAL_BUSOFF_RECOVERY == 5U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_GETSTATUS == 6U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETFILTER == 7U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETADVANCEDFILTER == 8U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETFILTERENABLESTATUS == 9U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_REMOVE_FILTER == 10U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_GETFWVERSION == 11U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_INIT_PLATFORM == 12U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_INIT_PLATFORM_COMMON == 13U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_DEINIT_PLATFORM == 14U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_INIT_PFE == 15U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_INIT_PFE_EXT_RING_BUF == 16U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_INIT_HSE == 17U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_CREATE_AF_DESTINATION == 18U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_ABORT_MB == 19U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_CUSTOM == 20U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETAUXFILTER == 21U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETFILTER_AT_ADDRESS == 22U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETCHANNELROUTINGOUTPUTSTATE == 23U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETCAN2ETHSTATE == 24U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETETH2CANFORMATSTATE == 25U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETADVANCEDFILTER_AT_ADDRESS == 26U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETCAN2PCIESTATE == 27U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SHUTDOWN == 28U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_REMOVE_AF_DESTINATION == 29U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_EXTENDED == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_STANDARD == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_MIXED == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_T_STOP == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_T_START == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_UNINIT_CTRL == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_UNINIT_CTRL_PENDING == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_STOP_PENDING == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_BUSOFF_PENDING == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_STOPPED == 4U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_START_PENDING == 5U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_STARTED == 6U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_IDLE == 7U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_UNINIT_PLATFORM == 8U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_TX == 101U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_RX == 102U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_DTE == 103U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_FRPE == 104U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN2CAN_TX == 105U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN2CAN_RX == 106U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN2CAN_FRPE == 107U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_ETH_TX == 108U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_ETH_RX == 109U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_ETH_FRPE == 110U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_HSE_TX == 111U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_HSE_RX == 112U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_HSE_FRPE == 113U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_TX == 114U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_RX == 115U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_FRPE == 116U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_LOGGING_DISABLED == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_LOGGING_ENABLED == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_HOSTRECEIVE_DISABLED == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_HOSTRECEIVE_ENABLED == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_AUTHENTICATION_DISABLED == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_AUTHENTICATION_ENABLED == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_AUTHENTICATION_NOT_SUPPORTED == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CUSTOMPROCESSING_DISABLED == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CUSTOMPROCESSING_ENABLED == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_ENTRY_EXACT_MATCH == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_ENTRY_CFG_MASKED == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_ENTRY_CFG_RANGED == 2U);
LLCE_INTERFACE_STATIC_ASSERT(CAN_AF_CAN2CAN == 0U);
LLCE_INTERFACE_STATIC_ASSERT(CAN_AF_CAN2ETH == 1U);
LLCE_INTERFACE_STATIC_ASSERT(CAN_AF_CAN2PCIE == 2U);
LLCE_INTERFACE_STATIC_ASSERT(CAN_AF_CAN2HSE == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CAN2AVTP_NTSCF_BRIEF == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CAN2AVTP_NTSCF_FULL == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CAN2AVTP_TSCF_BRIEF == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CAN2AVTP_TSCF_FULL == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CAN2UDP == 4U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CAN2UDP_B == 5U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CAN2ETH_FORMAT_MAX == 6U);
LLCE_INTERFACE_STATIC_ASSERT(INITIALIZED == 1U);
LLCE_INTERFACE_STATIC_ASSERT(UNINITIALIZED == 2U);
LLCE_INTERFACE_STATIC_ASSERT(IGNORE == 1U);
LLCE_INTERFACE_STATIC_ASSERT(NOTIF_FIFO0 == 2U);
LLCE_INTERFACE_STATIC_ASSERT(NOTIF_FIFO1 == 3U);
LLCE_INTERFACE_STATIC_ASSERT(ABORT_ONLY_ONE_MB == 0U);
LLCE_INTERFACE_STATIC_ASSERT(ABORT_ALL_MB == 1U);
LLCE_INTERFACE_STATIC_ASSERT(USE_LONG_MB == 0U);
LLCE_INTERFACE_STATIC_ASSERT(USE_SHORT_MB == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_FALSE == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_TRUE == 1U);

#endif /*DISABLE_MEM_LAYOUT_CHECK*/

#endif /*LLCE_INTERFACEMEMLAYOUTCHECK_H*/

/** @} */


===== 文件 [77/112]: include\Llce_RegAccess.h =====
/**
 *   @file    Llce_RegAccess.h
 *
 *   @brief   This file contains functions used for reading and writing
 *            registers
 *   @details This file contains functions used for reading and writing
 *            registers
 *
 *   @addtogroup LLCE_CAN_firmware_interface LLCE CAN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_REGACCESS_H
#define LLCE_REGACCESS_H

#ifdef __cplusplus
extern "C" {
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
/**
 * @file        Llce_RegAccess.h
 * @brief Include platform types
 */
#include "PlatformTypes.h"

/*==================================================================================================
 *                               SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                           CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                       DEFINES AND MACROS
 ==================================================================================================*/
 #if defined(LDRA) || defined(__DOXYGEN__)
     /* Workaround for Doxygen and LDRA tools not to see packed keyword */
      #define LLCE__PACKED
 #else
     #define LLCE__PACKED __attribute__((packed))
 #endif

 #if defined(__DOXYGEN__)
     /* Workaround for Doxygen not to see attribute keyword */
      #define LLCE__ALIGNED__PACKED

     /* Common defines for standard version. Meant to be used by Doxygen*/
     #define S32G2 ON
  
     #define CANETH_ENABLE ON
 
     #define CAN2CAN_ENABLE ON

     #define LIN_ENABLE ON

     #define CANHSE_ENABLE ON

     #define LOGGING_ENABLE ON

     #define AF_ENABLE ON
 #else
     #define LLCE__ALIGNED__PACKED __attribute__((aligned(4), packed))
 #endif
/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/*==================================================================================================
 *                                 STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/

/*==================================================================================================
 *                                 STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/

/*==================================================================================================
 *                                     FUNCTION PROTOTYPES
 ==================================================================================================*/

/**
 * @brief 8 bits memory write function
 */
static inline void Reg_Write8(uint32 address, uint8 value)
{
    *(volatile uint8 *)(address) = value;
}

/**
 * @brief 16 bits memory write function.
 */
static inline void Reg_Write16(uint32 address, uint16 value)
{
    *(volatile uint16 *)(address) = value;
}

/**
 * @brief 32 bits memory write function.
 */
static inline void Reg_Write32(uint32 address, uint32 value)
{
    *(volatile uint32 *)(address) = value;
}

/**
 * @brief 8 bits memory read function.
 */
static inline uint8 Reg_Read8(uint32 address)
{
    return (*(volatile uint8 *)(address));
}

/**
 * @brief 16 bits memory read function.
 */
static inline uint16 Reg_Read16(uint32 address)
{
    return (*(volatile uint16 *)(address));
}

/**
 * @brief 32 bits memory read function.
 */
static inline uint32 Reg_Read32(uint32 address)
{
    return (*(volatile uint32 *)(address));
}

/**
 * @brief 8 bits indexed memory write function.
 * Index i must have the data type uint32.
 */
static inline void Reg_Awrite8(uint32 address, uint32 i, uint8 value)
{
    *(volatile uint8 *)(address + i) = value;
}

/**
 * @brief 16 bits indexed memory write function.
 * Index i must have the data type uint32.
 */
static inline void Reg_Awrite16(uint32 address, uint32 i, uint16 value)
{
    *(volatile uint16 *)(address + i) = value;
}

/**
 * @brief 32 bits indexed memory write function.
 * Index i must have the data type uint32.
 */
static inline void Reg_Awrite32(uint32 address, uint32 i, uint32 value)
{
    *(volatile uint32 *)(address + i) = value;
}

/**
 * @brief 8 bits indexed memory read function.
 * Index i must have the data type uint32.
 */
static inline uint8 Reg_Aread8(uint32 address, uint32 i)
{
    return (*(volatile uint8 *)(address + i));
}

/**
 * @brief 16 bits indexed memory read function.
 * Index i must have the data type uint32.
 */
static inline uint16 Reg_Aread16(uint32 address, uint32 i)
{
    return (*(volatile uint16 *)(address + ((uint32)(i << 1U))));
}

/**
 * @brief 32 bits indexed memory read function.
 * Index i must have the data type uint32.
 */
static inline uint32 Reg_Aread32(uint32 address, uint32 i)
{
    return (*(volatile uint32 *)(address + ((uint32)(i << 2U))));
}

/**
 * @brief 8 bits bits clearing function.
 */
static inline void Reg_Bit_Clear8(uint32 address, uint8 mask)
{
    (*(volatile uint8 *)(address)) &= (~(mask));
}

/**
 * @brief 16 bits bits clearing function.
 */
static inline void Reg_Bit_Clear16(uint32 address, uint16 mask)
{
    (*(volatile uint16 *)(address)) &= (~(mask));
}

/**
 * @brief 32 bits bits clearing function.
 */
static inline void Reg_Bit_Clear32(uint32 address, uint32 mask)
{
    (*(volatile uint32 *)(address)) &= (~(mask));
}

/**
 * @brief 8 bits bits getting function.
 */
static inline uint8 Reg_Bit_Get8(uint32 address, uint8 mask)
{
    return ((*(volatile uint8 *)(address)) & (mask));
}

/**
 * @brief 16 bits bits getting function.
 */
static inline uint16 Reg_Bit_Get16(uint32 address, uint16 mask)
{
    return ((*(volatile uint16 *)(address)) & (mask));
}

/**
 * @brief 32 bits bits getting function.
 */
static inline uint32 Reg_Bit_Get32(uint32 address, uint32 mask)
{
    return ((*(volatile uint32 *)(address)) & (mask));
}

/**
 * @brief 8 bits bits setting function.
 */
static inline void Reg_Bit_Set8(uint32 address, uint8 mask)
{
    *(volatile uint8 *)(address) |= mask;
}

/**
 * @brief 16 bits bits setting function.
 */
static inline void Reg_Bit_Set16(uint32 address, uint16 mask)
{
    *(volatile uint16 *)(address) |= mask;
}

/**
 * @brief 32 bits bits setting function.
 */
static inline void Reg_Bit_Set32(uint32 address, uint32 mask)
{
    *(volatile uint32 *)(address) |= mask;
}

/**
 * @brief 8 bit clear bits and set with new value
 * @note In the current implementation, it is caller's (user's) responsibility
 *       to make sure that value has only "mask" bits set - (value&~mask)==0
 */
static inline void Reg_Rmw8(uint32 address, uint8 mask, uint8 value)
{
    *(volatile uint8 *)(address) =
        (*(volatile uint8 *)(address) & ((uint8) ~(mask))) | value;
}

/**
 * @brief 16 bit clear bits and set with new value
 * @note In the current implementation, it is caller's (user's) responsibility
 *       to make sure that value has only "mask" bits set - (value&~mask)==0
 */
static inline void Reg_Rmw16(uint32 address, uint16 mask, uint16 value)
{
    *(volatile uint16 *)(address) =
        (*(volatile uint16 *)(address) & ((uint16) ~(mask))) | value;
}

/**
 * @brief 32 bit clear bits and set with new value
 * @note In the current implementation, it is caller's (user's) responsibility
 *       to make sure that value has only "mask" bits set - (value&~mask)==0
 */
static inline void Reg_Rmw32(uint32 address, uint32 mask, uint32 value)
{
    *(volatile uint32 *)(address) =
        (*(volatile uint32 *)(address) & ((uint32) ~(mask))) | value;
}

#ifdef __cplusplus
}
#endif

#endif /* #ifndef LLCE_REGACCESS_H */

/** @} */


===== 文件 [78/112]: include\Llce_Sema42.h =====
/**
*   @addtogroup LLCE_IP_Drivers
*   @{
*   @addtogroup LLCE_SEMA42
*   @{
*   
*   @brief   Semaphores2 (SEMA42) module data structures and defines
*   @details This file contains the Semaphores2 (SEMA42) data structures, defines and function declarations.
*
*/
/*==================================================================================================
*
* Copyright 2018-2023 NXP 
* 
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in 
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#ifndef LLCE_SEMA42_H
#define LLCE_SEMA42_H

#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

#ifdef CHECK_ABI_COMPATIBILITY
#pragma ABICHECK start
#endif
/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/
#define LLCE_SEMA42_BASEADDR            ((uint32)0x43C20000UL)
#define LLCE_SEMA42_GR(gate)            ((uint32)(LLCE_SEMA42_BASEADDR + (uint32)(((uint32)(gate) & 0x3FU))))

#define LLCE_SEMA42_GR_GTFSM_0          (0x0U)
#define LLCE_SEMA42_GR_GTFSM_1          (0x1U)
#define LLCE_SEMA42_GR_GTFSM_2          (0x2U)
#define LLCE_SEMA42_GR_GTFSM_3          (0x3U)
#define LLCE_SEMA42_GR_GTFSM_4          (0x4U)
#define LLCE_SEMA42_GR_GTFSM_5          (0x5U)
#define LLCE_SEMA42_GR_GTFSM_6          (0x6U)
#define LLCE_SEMA42_GR_GTFSM_7          (0x7U)
#define LLCE_SEMA42_GR_GTFSM_8          (0x8U)
#define LLCE_SEMA42_GR_GTFSM_9          (0x9U)
#define LLCE_SEMA42_GR_GTFSM_10         (0xAU)
#define LLCE_SEMA42_GR_GTFSM_11         (0xBU)
#define LLCE_SEMA42_GR_GTFSM_12         (0xCU)
#define LLCE_SEMA42_GR_GTFSM_13         (0xDU)
#define LLCE_SEMA42_GR_GTFSM_14         (0xEU)
#define LLCE_SEMA42_GR_GTFSM_15         (0xFU)
/*==================================================================================================
*                                      Interrupts
==================================================================================================*/

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/   
/** @brief    Gate numbers used by sema42 module to lock and unlock gates.
 *  @details  Gate numbers used by sema42 module to lock and unlock gates.
 **/
typedef enum LLCE__PACKED
{
    LLCE_SEMA42_GATE0   =  0UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE1   =  1UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE2   =  2UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE3   =  3UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE4   =  4UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE5   =  5UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE6   =  6UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE7   =  7UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE8   =  8UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE9   =  9UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE10  =  10UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE11  =  11UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE12  =  12UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE13  =  13UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE14  =  14UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE15  =  15UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE16  =  16UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE17  =  17UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE18  =  18UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE19  =  19UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE20  =  20UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE21  =  21UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE22  =  22UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE23  =  23UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE24  =  24UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE25  =  25UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE26  =  26UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE27  =  27UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE28  =  28UL,         /**< @brief Sema42 Gate *//*free*/
    LLCE_SEMA42_GATE29  =  29UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE30  =  30UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE31  =  31UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE32  =  32UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE33  =  33UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE34  =  34UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE35  =  35UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE36  =  36UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE37  =  37UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE38  =  38UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE39  =  39UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE40  =  40UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE41  =  41UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE42  =  42UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE43  =  43UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE44  =  44UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE45  =  45UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE46  =  46UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE47  =  47UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE48  =  48UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE49  =  49UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE50  =  50UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE51  =  51UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE52  =  52UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE53  =  53UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE54  =  54UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE55  =  55UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE56  =  56UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE57  =  57UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE58  =  58UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE59  =  59UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE60  =  60UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE61  =  61UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE62  =  62UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE63  =  63UL,         /**< @brief Sema42 Gate */    

} Llce_Sema42_GateType;

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

#ifdef CHECK_ABI_COMPATIBILITY
#pragma ABICHECK stop
#endif
/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/
  
/*==================================================================================================
*                                     INLINE FUNCTION
==================================================================================================*/
/*================================================================================================*/
/** 
* @brief Lock Sema42 gate
* @details The function locks specific sema42 gate.
*/
/*================================================================================================*/
static inline void Llce_Sema42_Lock(Llce_Sema42_GateType eGate, uint8 u8Domain)
{
    /* Lock the semaphore */
    do
    {
        Reg_Write8(LLCE_SEMA42_GR(eGate), u8Domain);
    } while (u8Domain != Reg_Read8(LLCE_SEMA42_GR(eGate)));    

}

/*================================================================================================*/
/** 
* @brief Unlock Sema42 gate
* @details The function unlocks specific sema42 gate.
*/
/*================================================================================================*/
static inline void Llce_Sema42_Unlock(Llce_Sema42_GateType eGate)
{
    /* Unlock the semaphore */
    Reg_Write8(LLCE_SEMA42_GR(eGate), LLCE_SEMA42_GR_GTFSM_0);
}


#ifdef __cplusplus
}
#endif

#endif /* LLCE_SEMA42_H */

/** @} */
/** @} */


===== 文件 [79/112]: include\Llce_SwFifo.h =====
/**
*   
*   @brief   LLCE Generic Software Fifo enums and data structures
*   @details This file contains the Generic Software Fifo data types.
*
*   @addtogroup LLCE_SwFifo
*   @{
*/
/*==================================================================================================
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifndef LLCE_SWFIFO_H
#define LLCE_SWFIFO_H


#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

#include "Llce_InterfaceCanTypes.h"
#include "StandardTypes.h"
#include "Can_43_LLCE_Cfg.h"
/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/

/*==================================================================================================
*                                      Interrupts
==================================================================================================*/

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/
#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
typedef enum 
{
    LLCE_SWFIFO_FULL,
    LLCE_SWFIFO_EMPTY, 
    LLCE_SWFIFO_OPERATIONAL
} Llce_SwFifo_StatusType;

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

typedef struct
{   
    uint8 *pu8BaseAddr;
    uint16 u16WrByteIdx;
    uint16 u16RdByteIdx;
    uint16 u16MaxNElements;
    uint8  u8ElemSize;
    Llce_SwFifo_StatusType eFifoStatus;
} Llce_SwFifo_Type;

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/

/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/
Llce_Fw_ReturnType Llce_SwFifo_Init(void *pu8BaseAddr, uint8 u8ElemSize, uint16 u16MaxNElements, Llce_SwFifo_Type *pLlce_SwFifo);

Llce_Fw_ReturnType Llce_SwFifo_Push(const void *pGenericElem, Llce_SwFifo_Type *pLlce_SwFifo);

Llce_Fw_ReturnType Llce_SwFifo_Pop(void *pGenericElem, Llce_SwFifo_Type *pLlce_SwFifo);
#endif

#ifdef __cplusplus
}
#endif

#endif /* LLCE_SWFIFO_H */

/** @} */


===== 文件 [80/112]: include\Reg_eSys_Llce.h =====
/**
*   @file    Reg_eSys_Llce.h
*   @implements Reg_eSys_Llce.h_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - S32Gxx Llce Defines and Macros Definitions.
*   @details Header file for S32Gxx Llce Defines and Macros Definitions.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*   
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/


#ifndef REG_ESYS_LLCE_H
#define REG_ESYS_LLCE_H

#ifdef __cplusplus
extern "C" {
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Llce_InterfaceCanTypes.h"
#include "Can_43_LLCE_Cfg.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/

/*==================================================================================================
                BIT MASKS FOR SHIFTING BCAN REGISTER VALUES
==================================================================================================*/
/**
* @brief Define used for Can_43_LLCE_ControllerDescriptorType.u8ControllerOffset when controller is not enabled.
*/
#define LLCE_NULL_OFFSET_U8              (0xFFU)

/**
* @brief Defines used to check specific field of the LPDU frame exchanged with upper software layers.
*/
#define CAN_LPDU_ID_MASK_U32              ((uint32)0x3FFFFFFFU)

#define CAN_LPDU_IDE_U32                  ((uint32)0x80000000U)

#define CAN_LPDU_FD_U32                   ((uint32)0x40000000)       

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/


/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/

#ifdef __cplusplus
}
#endif

#endif /*TEMPLATE_H*/

/** @} */


===== 文件 [81/112]: source&include\include\Can_43_LLCE.h =====
/**
*   @internal
*   @file    Can_43_LLCE.h
*   @implements Can.h_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface.
*   @details API header for CAN driver.
*
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/


#ifndef CAN_43_LLCE_H
#define CAN_43_LLCE_H

#ifdef __cplusplus
extern "C"{
#endif

/*
(CAN043) The file Can_43_LLCE.h contains the declaration of the Can module API.
(CAN037) The file Can_43_LLCE.h only contains 'extern' declarations of constants, global data, type definitions and services
            that are specified in the Can module SWS.
*/

/**
* @file           Can_43_LLCE.h
*/



/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
/**
* @file           Can_43_LLCE.h
*/
#include "ComStackTypes.h"
#include "Can_43_LLCE_Cfg.h"
#include "Can_GeneralTypes.h"
#include "Can_Llce_Types.h"
#include "Soc_Ips.h"
#include "Llce_FwVersion.h"
#include "Llce_InterfaceCanTypes.h"
#include "Mcal.h"


/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/*
    Internal micro-dependent versioning. Check of AUTOSAR & Vendor specification version.
*/
/**
* @{
* @file           Can_43_LLCE.h
*/
#define CAN_43_LLCE_VENDOR_ID                   43
#define CAN_43_LLCE_MODULE_ID                   80
#define CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION    4
#define CAN_43_LLCE_AR_RELEASE_MINOR_VERSION    4
#define CAN_43_LLCE_AR_RELEASE_REVISION_VERSION 0
#define CAN_43_LLCE_SW_MAJOR_VERSION            1
#define CAN_43_LLCE_SW_MINOR_VERSION            0
#define CAN_43_LLCE_SW_PATCH_VERSION            10
/**@}*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/
/* Check if current file and Can configuration header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID != CAN_43_LLCE_VENDOR_ID_CFG_H)
#error "Can_43_LLCE.h and Can_43_LLCE_Cfg.h have different vendor ids"
#endif
/* Check if current file and Can configuration header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION != CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION != CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION != CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_CFG_H))
  #error "AutoSar Version Numbers of Can_43_LLCE.h and Can_43_LLCE_Cfg.h are different"
#endif

/* Check if current file and CAN configuration header file are of the same software version */
#if ((CAN_43_LLCE_SW_MAJOR_VERSION != CAN_43_LLCE_SW_MAJOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_SW_MINOR_VERSION != CAN_43_LLCE_SW_MINOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_SW_PATCH_VERSION != CAN_43_LLCE_SW_PATCH_VERSION_CFG_H))
  #error "Software Version Numbers of Can_43_LLCE.h and Can_43_LLCE_Cfg.h are different"
#endif
/* Check if current file and CAN configuration header file are of the same software version */
#ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION != COMTYPE_AR_RELEASE_MAJOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION != COMTYPE_AR_RELEASE_MINOR_VERSION) )
  #error "Software Version Numbers of Can_43_LLCE.h and ComStackTypes.h are different"
#endif
#endif


/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/**
* @brief          Can_43_LLCE_ObjType
* @details        Used for value received by Tressos interface configuration.
*                 Describes the HOH configuration.
*
*/
typedef enum
    {
        CAN_43_LLCE_RECEIVE = 0U,    /**< @brief Regular Receive */
        CAN_43_LLCE_RECEIVE_AF,      /**< @brief Receive with Advanced Features*/
        CAN_43_LLCE_TRANSMIT    /**< @brief Transmit MB */
    } Can_43_LLCE_ObjType;


    
/**
* @brief          Can_43_LLCE_StatusType
* @details        CAN Driver status used for checking and preventing double driver initialization.
*                 CAN_43_LLCE_UNINIT = The CAN controller is not initialized. The CAN Controller is not participating on the CAN bus.
*                              All registers belonging to the CAN module are in reset state, CAN interrupts are disabled.
*                 CAN_43_LLCE_READY = Controller has initialized: static variables, including flags;
*                             Common setting for the complete CAN HW unit; CAN controller specific settings for each CAN controller.
*
*/
typedef enum
    {
        CAN_43_LLCE_UNINIT = 0U, /**< @brief Driver not initialized */
        CAN_43_LLCE_READY       /**< @brief Driver ready */
    } Can_43_LLCE_StatusType;



/**
* @brief          Can_43_LLCE_FilterStateType
* @details        Used for enabling or disabling filters at runtime.
*
*/
typedef enum
    {
        CAN_43_LLCE_FILTERSTATE_DISABLED = 0U, /**< @brief Filter disabled at runtime */
        CAN_43_LLCE_FILTERSTATE_ENABLED        /**< @brief Filter enabled at runtime */
    } Can_43_LLCE_FilterStateType;

/**
* @brief          Can_43_LLCE_ChannelStateType
* @details        Used for enabling or disabling channels in multicast routing configuration.
*
*/
typedef enum
    {
        CAN_43_LLCE_CHANNELSTATE_DISABLED = 0U, /**< @brief Channel disabled */
        CAN_43_LLCE_CHANNELSTATE_ENABLED        /**< @brief Channel enabled */
    } Can_43_LLCE_ChannelStateType;
/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/**
* @brief          Configuration of BCAN controller.
* @details        This structure is initialized by Tresos considering user settings.
*                 Used by Can_43_LLCE_SetBaudrate() API to set the default baudrate after initialization.
*                 and to change the baudrate when the BCAN is in stopped mode.
*
*/
typedef struct
    {
        const Llce_Can_SetBaudrateCmdType baudrateConfig;

#if (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON)
        const uint16 u16ControllerBaudRateConfigID;
#endif
    } Can_43_LLCE_ControllerBaudrateConfigType;


/**
* @brief          Can_43_LLCE_HOHType
* @details        Type for storing information about hardware objects.
*                 Used by Can_43_LLCE_MBConfigContainerType.
*
*/
typedef struct
    {
        Can_43_LLCE_ObjType eMBType; /**< @brief Receive/ Receive AF / Transmit */

        const uint16 u16MbCount; /**< @brief Maximum number of message buffers for this HOH */

        const uint8 u8ControllerId; /**< @brief Controller ID (index into controller address array containing Can_ControllerPtrType). */

        uint8 u8FdPaddingValue; /**< @brief Padding value for MB > 8 bytes */

        const uint8 u8CanMainFuncRWPeriodRef; /**< @brief read write period reference */

        const uint8 u8RWInterface; /**< @brief Rx/Ack interface. Specifies which interface to be used for current HOH. */

        const uint8 u8EnableTxFrameMac; /**< @brief The parameter is used to enable adding of MAC code to transmitted frames.*/

        const uint32 u32TxHseKeyHandle; /**< @brief The parameter is used to add the key handle for generation of MAC code to transmitted frames.*/

#if (CAN_43_LLCE_TRIGGER_TRANSMIT_EN == STD_ON)
        const boolean CanTriggerTransmitEnable; /**< @brief The parameter is used to detect the MB which run with trigger transmit feature*/
#endif
#if (CAN_43_LLCE_DUMMY_HRH_EN == STD_ON)
        const boolean bDummyHRH; /**< @brief True for dummy HRH */
#endif
    } Can_43_LLCE_HOHType;

/**
* @brief          Structure for describing individual BCAN controllers on the chip.
* @details        HRH = Hardware Receive Handle (HRH) is defined and provided by the CAN driver.
*                       Each HRH represents exactly one hardware object.
*                       The HRH can be used to optimize software filtering.
*                 HTH = The Hardware Transmit Handle (HTH) is defined and provided by the CAN driver.
*                       Each HTH represents one or several hardware objects, that are
*                       configured as hardware transmit pool.
*
*/
typedef struct
    {
        const uint8 u8MaxBaudRateCount; /**< @brief Max BaudRate number. */
        const uint8 u8DefaultBaudRateIndex; /**< @brief Default baudrate index. */
        const Can_43_LLCE_ControllerBaudrateConfigType * const pControllerBaudrateConfigsPtr; /**< @brief Pointer to the Configuration of Baudrate timing parameter for BCAN baudrate controller ( CTRL value register). */
        const uint32 u32CoreId;  /**< @brief ID of the application core this is assigned to */ 
        const uint8 u8HwCtrl; /**< @brief Hardware ID for BCAN controller */
    } Can_43_LLCE_ControllerDescriptorType;

/**
* @brief          Structure for describing individual Hardware controllers.
* @details        This structure is initialized by Tresos/Design Studio considering user settings. It generates an array (HwControllerDescriptors_PB) that is indexed
*                 using the Hardware ID of the BCAN controller. 
*                 The structure contains data needed by the driver (Event Trigger Mode / CanIf ID).
*
*/
typedef struct
    {
        const uint32 u32DrvControllerOptions; /*< @brief Variable used only by driver. Event Trigger Mode TxProcessing/RxProcessing/BusoffProcessing. */
        const uint8 u8CanIfCtrlId; /**< @brief Controller ID defined by CanIf */
        const uint8 u8FifoInterface; /**< @brief LLCE FIFO Interface used for interrupt processing. Default is 1 to 1 mapped with Can Hardware Channel. */
    }Can_43_LLCE_HwControllerDescriptorType;

/**
* @brief          Top Level structure containing all Driver configuration.
* @details        A pointer to this structure is transmitted to Can_43_LLCE_Init() to initialize the driver at startup.
*                 The application selects one of the configurations by using a pointer to one of the elements
*                 of this array as a parameter of the Can_43_LLCE_Init function.
*
*/
typedef struct
    {

        const Llce_Can_InitPlatformCmdType * const pPlatfInitConfig; /**< @brief Configuration used by platform init command.(e.g Maximum number of filters or MB/channel) */

        const Llce_Can_InitCmdType * const pChannelInitConfig; /**< @brief Configuration used by channel init command. */

        Llce_Can_ReceiveFilterType** paReceiveFilters;
        
        Llce_Can_AdvancedFilterType** paAdvancedFilters;

        Llce_Can_AuxFilterType** paAuxFilters; /**< @brief Pointer to the list of auxilliary filters */

        uint16* paLlce_MaxAuxilliaryFilterCount; /**< @brief Pointer to an array with the number of auxilliary filters per controller */

        const Can_43_LLCE_HOHType * const aHohList; /**< @brief Pointer to the list of hardware objects */

        const Can_43_LLCE_ControllerDescriptorType * const aControllerDescriptors; /**< @brief Pointer to the first BCAN Controller description. */

        const Can_43_LLCE_HwControllerDescriptorType * const aHwControllerDescriptors; /**< @brief Pointer to the Hardware Controller description. */

        const uint32* CanFilterId2CustomIdx; /**< @brief Mapping array CanObjectId <-> CustomProcessingIndex */

        const boolean bHeadlessModeEnabled; /**< @brief True when LLCE is started in headless mode */

        const uint32 u32CoreId; /** @brief Configuration Core ID */

        const uint8 u8ActiveHif;  /**< @brief LLCE Host interface used by this driver instance */

        const uint8 u8DefaultController;  /**< @brief Controller used when sending generic commands to LLCE */
    } Can_43_LLCE_ConfigType;

/**
* @brief          Structure containing filter configuration data.
* @details        
*
*/
typedef struct
    {
        uint32 uMessageId; /**< @brief Configuration used by platform init command.(e.g Maximum number of filters or MB/channel) */

        uint32 uIdMask; /**< @brief Mask to use (for Mask filter) or Range End */

        uint16 u16MbCount; /**< @brief Number of message buffers to allocate to new filter */

        Can_HwHandleType Hrh; /**< @brief HRH to which to attach the filter */

        uint8 u8RWInterface; /**< @brief Rx interface for current filter. First 16 interfaces (0-15) are reserved for interrupt processing, next 6 interfaces (16-21) are for polling classes. */

        Llce_Can_IdLengthType eIdType; /**< @brief Standard or Extended Can ID */

        Llce_Can_EntryType eFilterType; /**< @brief Filter type (Exact Match, Mask or Range) */

        Llce_CanRx_MbLengthType eFilterMbLength; /**< @brief Message buffer payload length: 8 or 64 bytes */
    } Can_SetFilterType;

/**
* @brief          Structure containing advanced filter configuration data.
*/
typedef struct
{
    Can_SetFilterType Filter;
    Llce_Can_AdvancedFeatureType AdvancedFeature;
} Can_SetAfFilterType;

/**
* @brief          CanErrorNotification callback input type.
* @details        
*
*/
typedef struct
    {
        volatile Llce_Can_ErrorNotifType* ErrorInfo; /**< @brief Error description */

        uint8 u8CanIfCtrlId; /**< @brief Controller Id */

        Llce_Can_NotificationIdType eNotifId; /**< @brief Error type */
    } CanErrorNotificationType;

/**
* @brief          Structure containing the baudrate index.
* @details        
*
*/
typedef struct 
    {
        uint8 u8CurrentBaudRateIndex; /*< @brief Current controller baud rate */
    }Can_43_LLCE_ControllerBaudRate;

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_VAR_INIT_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

/*
    Holds current status/run-time of CAN driver: CAN_43_LLCE_UNINIT or CAN_43_LLCE_READY (declared as global variable in "Can_43_LLCE.c" file).
    (CAN103) After power-up/reset, the Can module shall be in the state CAN_43_LLCE_UNINIT.
    Covers CAN103
*/
extern Can_43_LLCE_StatusType Can_43_LLCE_eDriverStatus[CAN_43_LLCE_MAX_PARTITIONS];

/*
    Holds the baudrate index of every configured controller. Declared as a global variable in Can_IPW.c file.
*/
extern Can_43_LLCE_ControllerBaudRate   Can_43_LLCE_ControllerBaudRateIndexes[CAN_43_LLCE_MAXCTRL_CONFIGURED];

/* Pointer to the current Driver Configuration (passed to the driver during initialization). Initialized by Can_43_LLCE_Init(). */
extern const Can_43_LLCE_ConfigType * Can_43_LLCE_pCurrentConfig[CAN_43_LLCE_MAX_PARTITIONS];

#define CAN_43_LLCE_STOP_SEC_VAR_INIT_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

#define CAN_43_LLCE_START_SEC_CONFIG_DATA_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

/* Export Driver configuration */
CAN_43_LLCE_CONFIG_EXT

#define CAN_43_LLCE_STOP_SEC_CONFIG_DATA_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

#define CAN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

extern volatile uint16 Can_au16TransmitHwObjectCnt[CAN_43_LLCE_MAXHTH_CONFIGURED];

#define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"
/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/

#define CAN_43_LLCE_START_SEC_CODE
#include "Can_43_LLCE_MemMap.h"
/*================================================================================================*/
/**
* @brief         This service obtains the error state of the CAN controller.
* @details       This service shall read the error state register of Can Controller and shall return the error status to upper layer.
*
* @param[in]     Controller - Abstracted CanIf ControllerId which is assigned to a CAN controller, which is requested for ErrorState.
* @param[out]    ErrorStatePtr - Pointer to a memory location, where the error state of the CAN controller will be stored.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Driver must be initialized.
*
* @implements     Can_GetControllerErrorState_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerErrorState( uint8 Controller,
                                                Can_ErrorStateType * ErrorStatePtr
                                              );

/*================================================================================================*/
/**
* @brief         This service obtains the number of RX errors of the CAN controller.
* @details       This service shall read the error state register of Can Controller and shall return the number of rx errors to upper layer.
*
* @param[in]     ControllerId - Abstracted CanIf ControllerId which is assigned to a CAN controller, which is requested for rx error counter.
* @param[out]    RxErrorCounterPtr - Pointer to a memory location, where the rx error counter of the CAN controller will be stored.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Driver must be initialized.
* @implements    Can_GetControllerRxErrorCounter_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerRxErrorCounter ( uint8 ControllerId, uint8 * RxErrorCounterPtr );

/*================================================================================================*/
/**
* @brief         This service obtains the number of Tx errors of the CAN controller.
* @details       This service shall read the error state register of Can Controller and shall return the number of Tx errors to upper layer.
*
* @param[in]     ControllerId - Abstracted CanIf ControllerId which is assigned to a CAN controller, which is requested for rx error counter.
* @param[out]    TxErrorCounterPtr - Pointer to a memory location, where the tx error counter of the CAN controller will be stored.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Driver must be initialized.
* @implements    Can_GetControllerTxErrorCounter_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerTxErrorCounter ( uint8 ControllerId, uint8 * TxErrorCounterPtr);

/*================================================================================================*/
/**
* @brief         This service obtains the Llce Can controller status.
* @details       This service obtains a structure containing values from HW registers of the specified channel.
*
* @param[in]     component - The component to be queried.
* @param[out]    value - The version of the fw component.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Llce firmware must be loaded.
*   
*/
Std_ReturnType Can_43_LLCE_GetControllerStatus( uint8 ControllerId, Llce_Can_GetStatusCmdType * StatusPtr);

/*================================================================================================*/
/**
* @brief          Initialize the CAN driver. SID is 0x00.
* @details        Initialize all the controllers.
*                 The CAN module shall be initialized by Can_43_LLCE_Init(<&Can_Configuration>) service call during the start-up.
*                 This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      pxConfig Pointer to driver configuration.
*
* @return         void
*
*
* @pre            Can_43_LLCE_Init shall be called at most once during runtime.
* @post           Can_43_LLCE_Init shall initialize all the controllers and set the driver in READY state.
*
* @implements     Can_Init_Activity
*/
void Can_43_LLCE_Init( const Can_43_LLCE_ConfigType * pxConfig);

/*================================================================================================*/
/**
* @brief          De-initialize the CAN driver. SID is 0x10.
* @details        De-initialize all the controllers.
*                 The CAN module shall be de-initialized by Can_DeInit() service call during the start-up.
*                 This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      None
*
* @return         void
*
*
* @pre            Before controller de-initialization, the driver must be initialized and the controllers must be not in Start state.
* @post           Can_DeInit shall de-initialize all the controllers and set the driver in UNINIT state.
*
* @implements     Can_DeInit_Activity
*/
void Can_43_LLCE_DeInit(void);

/*================================================================================================*/
/**
* @brief          Shut down LLCE
* @details        Send the shutdown command to LLCE.
*                 Can only be called if both HIFs are deinitialized. LLCE becomes unusable until reset.
*
* @param[in]      None
*
* @return         E_OK if command accepted, E_NOT_OK otherwise
*
*
* @pre            Both LLCE HIFs must be uninitialized 
* @post           LLCE is disabled
*
*/
Std_ReturnType Can_43_LLCE_Shutdown(void);

/*================================================================================================*/
/**
* @brief          Reports about the current status of the requested CAN controller. SID is 0x12
* @details        This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller: CAN controller for which the status shall be requested.
*
* @param[out]     ControllerModePtr: Pointer to a memory location, where the current mode of the CAN controller will be stored.
*
* @retval         E_OK : Controller mode request has been accepted.
* @retval         E_NOT_OK : Controller mode request has not been accepted.
*
* @pre            Controller is initialized
* @post           The host has got the current controller state.
*
* @implements     Can_GetControllerMode_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerMode( uint8 Controller, Can_ControllerStateType * ControllerModePtr);

#if (CAN_43_LLCE_VERSION_INFO_API == STD_ON)
/**
* @brief          Returns the version information of this module. SID is 0x07
* @details        This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      versioninfo A pointer to location to store version info
*                             Must be omitted if the function does not have parameters.
*
* @return         void
*
*
* @pre            The CAN_43_LLCE_VERSION_INFO_API define must be configured on.
* @post           The version information is return if the parameter versionInfo is not a null pointer.
*
* @implements     Can_GetVersionInfo_Activity
*/
void Can_43_LLCE_GetVersionInfo( Std_VersionInfoType * versioninfo);
#endif /* (CAN_43_LLCE_VERSION_INFO_API == STD_ON) */

#if (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON)
/*================================================================================================*/
/**
* @brief         This function set baudrate
* @details       This routine is called by an upper layer.
*
* @param[in]     Controller controller ID
* @param[in]     BaudRateConfigID baudrateID selection
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Switch baudrate operation was ok.
* @retval        E_NOT_OK  Switch baudrate operation was not ok.
*
* @pre           Driver must be initialized.
* @implements    Can_SetBaudrate_Activity
*/
Std_ReturnType Can_43_LLCE_SetBaudrate( uint8 Controller,
                                                       const uint16 BaudRateConfigID
                                                     );
#endif /* (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON) */

/*================================================================================================*/
/**
* @brief          Put the controller into a required state. SID is 0x03.
* @details        Switch the controller from one state to another.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller - Can controller for which the status shall be changed - based on configuration order list (CanControllerId).
* @param[in]      Transition - Possible transitions (CAN_CS_STOPPED , CAN_CS_STARTED , CAN_CS_SLEEP , CAN_T_WAKEUP)
* @return         Std_ReturnType  Result of the transition.
* @retval         E_OK   Transition initiated.
* @retval         E_NOT_OK  Development or production error.
*
*
* @pre            Before changing the controller state the driver must be initialized.
* @post           After the transition to the new state the interrupts required for that state must be enabled.
*
* @implements     Can_SetControllerMode_Activity
*/
Std_ReturnType Can_43_LLCE_SetControllerMode( uint8 Controller,
                                                             Can_ControllerStateType Transition
                                                           );

/*================================================================================================*/
/**
* @brief          Disable INTs. SID is 0x04.
* @details        Switch OFF the controller's interrupts.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller Can controller for which interrupts shall be disabled - based on configuration order list (CanControllerId).
*
* @return         void
*
*
* @pre            Driver must be initalzied before changing the interrupts state (en or dis).
* @post           Controller must not respond to any interrupt assertion.
*
* @implements     Can_DisableControllerInterrupts_Activity
*/
void Can_43_LLCE_DisableControllerInterrupts( uint8 Controller);

/*================================================================================================*/
/**
* @brief          Enable INTs. SID is 0x05.
* @details        Switch ON the controller's interrupts.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller Can controller for which interrupts shall be disabled - based on configuration order list (CanControllerId).
*
* @return         void
*
*
* @pre            Driver must be initalzied before changing the interrupts state (en or dis).
* @post           Controller must respond to interrupt assertion.
*
* @implements     Can_EnableControllerInterrupts_Activity
*/
void Can_43_LLCE_EnableControllerInterrupts( uint8 Controller);

/*================================================================================================*/
/**
* @brief          Transmit information on CAN bus. SID is 0x06.
* @details        Can_43_LLCE_Write checks if hardware transmit object that is identified by the HTH is free.
*                    Can_43_LLCE_Write checks if another Can_43_LLCE_Write is ongoing for the same HTH.
*                     a) hardware transmit object is free:
*                         The mutex for that HTH is set to 'signaled' the ID, DLC and SDU are put in a format appropriate for
*                           the hardware (if necessary) and copied in the appropriate hardware registers or buffers.
*                        All necessary control operations to initiate the transmit are done.
*                         The mutex for that HTH is released. The function returns with E_OK.
*                    b) hardware transmit object is busy with another transmit request.
*                         The function returns with CAN_BUSY.
*                     c) A preemptive call of Can_43_LLCE_Write has been issued, that could not be handled reentrant (i.e. a call with the same HTH).
*                        The function returns with CAN_BUSY the function is non blocking
*                     d) The hardware transmit object is busy with another transmit request for an L-PDU that has lower priority than that for the current request
*                        The transmission of the previous L-PDU is cancelled (asynchronously).
*                        The function returns with CAN_BUSY.
*                   This routine is called by:
*                   - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Hth Information which HW-transmit handle shall be used for transmit.
*                 Implicitly this is also the information about the controller to use because the Hth numbers are unique inside one hardware unit.
* @param[in]      PduInfo Pointer to SDU user memory, DLC and Identifier.
* @return         Std_ReturnType   Result of the write operation.
* @retval         E_OK   Write command has been accepted.
* @retval         E_NOT_OK  Development error occurred.
* @retval         CAN_BUSY   No of TX hardware buffer available or preemtive call of Can_43_LLCE_Write() that can't be implemented reentrant.
*
*
* @pre            Driver must be initialized and MB must be configured for Tx.
* @post           The data can be transmitted or rejected because of another data with a higher priority.
*
* @implements     Can_Write_Activity
*/
Std_ReturnType Can_43_LLCE_Write( Can_HwHandleType Hth,
                                                 const Can_PduType * PduInfo
                                               );

/*================================================================================================*/
/**
* @brief          Process check of WakeUp condition. SID is 0x0B.
* @details        This service shall evaluate the WakeupSource parameter to get the information,
*                 which dedicate wakeup source needs to be checked, either a CAN transceiver or controller device.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      controller Can controller ID - based on configuration order list (CanControllerId).
* @return         Std_ReturnType Result of the wakeup verification.
* @retval         E_OK  Wakeup was detected for the given controller.
* @retval         E_NOT_OK  No wakeup was detected for the given controller.
*
*
* @pre            Driver must be initialized.
* @post           Return the Wakeup event occurrence.
* Compiler_Warning: This warning is thrown because it doesn't exist hardware support for Wakeup, and parameter "controller" it is not used.
*
* @implements     Can_CheckWakeup_Activity
*/
Std_ReturnType Can_43_LLCE_CheckWakeup( uint8 controller);

/*================================================================================================*/
/**
* @brief         This service obtains the Llce firmware version.
* @details       This service obtains a string which encapsulates all of the components versions for the Llce firmware.
*
* @param[out]    pVersionString - The string with all the components versions for the Llce firmware. 
* @param[out]    pStringLength - Length of the string.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Llce firmware must be loaded.
* @implements    Can_GetFwVersion_Activity
*/
Std_ReturnType Can_43_LLCE_GetFwVersion( const uint8 ** pVersionString, \
                                                                                  uint8 * pStringLength);

/*================================================================================================*/
/**
* @brief         This service set a single standard filter.
* @details       This service set a single standard filter.
*
* @param[in]     pCanFilter - parameter of Can_SetFilterType, containing filter type and message buffer related configuration data
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetFilter_Activity
*/
Std_ReturnType Can_43_LLCE_SetFilter(const Can_SetFilterType * pCanFilter);

/*================================================================================================*/
/**
* @brief         This service set a single standard filter.
* @details       This service set a single standard filter.
*
* @param[in]     pCanFilter - parameter of Can_SetFilterType, containing filter type and message buffer related configuration data
* @param[in]     u16FilterAddr - address returned by the RemoveFilter function
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetFilter_Activity
*/
Std_ReturnType Can_43_LLCE_SetFilterAtAddress(const Can_SetFilterType * pCanFilter, const uint16 u16FilterAddr);

/*================================================================================================*/
/**
* @brief         This service set a single advanced filter at a given address.
* @details       This service set a single advanced filter at a given address.
*
* @param[in]     pAfFilter - parameter of Can_SetAfFilterType, containing filter type and message buffer related configuration data along with routing rules and other advanced features
* @param[in]     u16FilterAddr - address returned by the RemoveFilter function
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetAfFilterAtAddress_Activity
*/
Std_ReturnType Can_43_LLCE_SetAfFilterAtAddress(const Can_SetAfFilterType * pAfFilter, const uint16 u16FilterAddr);

/*================================================================================================*/
/**
* @brief         This service set a single advanced filter.
* @details       This service set a single advanced filter.
*
* @param[in]     pAfFilter - parameter of Can_SetAfFilterType, containing advanced filter type and message buffer related configuration data
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetAfFilter_Activity
*/
Std_ReturnType Can_43_LLCE_SetAfFilter(const Can_SetAfFilterType * pAfFilter);

/*================================================================================================*/
/**
* @brief         This service a new destination for advanced features
* @details       This service a new destination for advanced features
**
* @param[in]      destRule - The destination to add to the LLCE destination list
* @param[out]     pu8RuleIdx - The index of the new destination in the LLCE list. Needed for SetAdvancedFilter.
*
* @return        Std_ReturnType. Result of the request.
* @retval        E_OK  Destination created
* @retval        E_NOT_OK  Error
*
* @pre           Llce firmware must be loaded and the controller initialized
*/
Std_ReturnType Can_43_LLCE_CreateAfDestination(const Can_Af_DestRulesType destRule, uint8* pu8RuleIdx);

/*================================================================================================*/
/**
* @brief         This service removes an existing destination for advanced features
* @details       This service removes an existing destination for advanced features
*
* @param[in]     u8RuleIdx - The index of the destination to be removed from the LLCE list.
*
* @return        Std_ReturnType. Result of the request.
* @retval        E_OK  Destination removed
* @retval        E_NOT_OK  Error
*
* @pre           Llce firmware must be loaded and the controller initialized
*/
Std_ReturnType Can_43_LLCE_RemoveAfDestination(uint8 u8RuleIdx);

/*================================================================================================*/
/**
* @brief         This service removes a single standard filter.
* @details       This service removes a single standard filter.
*
* @param[in]     Hrh - HRH to which the filter is attached.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_RemoveFilter_Activity
*/
Std_ReturnType Can_43_LLCE_RemoveFilter(Can_HwHandleType Hrh, uint16 *u16FilterAddr);

/*================================================================================================*/
/**
* @brief         This service enables or disables a single standard filter.
* @details       This service enables or disables a single standard filter.
*
* @param[in]     Hrh - HRH to which the filter is attached.
* @param[in]     Enabled - Logical value to select if filter is enabled or disabled
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully enabled/disabled.
* @retval        E_NOT_OK  filter was not successfully enabled/disabled.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetFilterState_Activity
*/
Std_ReturnType Can_43_LLCE_SetFilterState(Can_HwHandleType Hrh, Can_43_LLCE_FilterStateType eState);

/*================================================================================================*/
/**
* @brief         This service sets the state of controller in a multicast routing configuration.
* @details       
*
* @param[in]     ControllerId - hardware controller to be enabled or disabled.
* @param[in]     eChannelStatus - enable or disable channel
*
* @return        Std_ReturnType.  Result of the command.
* @retval        E_OK  channel was successfully enabled/disabled.
* @retval        E_NOT_OK  channel was not successfully enabled/disabled.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetChannelRoutingOutputState_Activity
*/
Std_ReturnType Can_43_LLCE_SetChannelRoutingOutputState(uint8 ControllerId, Can_43_LLCE_ChannelStateType eChannelStatus);

/*================================================================================================*/
/**
* @brief         This service forces a deinit of the driver
* @details       When LLCE is not responding and must be reset, this service may be used to allow another init call. 
*
*/
void Can_43_LLCE_ForceDeInit(void);

/*================================================================================================*/

#if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)
    /**
    * @brief          Function called at fixed cyclic time. SID is 0x01.
    * @details        Service for performs the polling of TX confirmation and TX cancellation confirmation when CAN_TX_PROCESSING is set to POLLING.
    *                 This routine is called by:
    *                 - CanIf or an upper layer according to Autosar requirements.
    *
    *
    * @pre            Driver must be initialized.
    * @post           Send the data from that MB that is configured for Tx.
    *
    * @implements     Can_MainFunction_Multiple_Write_Activity
    */
void Can_43_LLCE_MainFunction_Multiple_Write( uint8 writepoll);
#endif /* (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON) */

#if (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON)
    /**
    * @brief          Function called at fixed cyclic time.  SID is 0x08.
    * @details        Service for performs the polling of RX indications when CAN_RX_PROCESSING is set to POLLING.
    *                 This routine is called by:
    *                 - CanIf or an upper layer according to Autosar requirements.
    *
    *
    * @pre            Driver must be initialized.
    * @post           Receive the data from that MB that is configured for Rx.
    *
    * @implements     Can_MainFunction_Multiple_Read_Activity
    */
void Can_43_LLCE_MainFunction_Multiple_Read( uint8 readpoll);
#endif /* (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON) */

#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
/**
* @brief          Function called at fixed cyclic time.
* @details        This Service performs the polling of Error notifications that are configured as 'to be polled'.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
*
* @pre            Driver must be initialized.
* @post           Handle the Error notifications in polling.
*
* @implements     Can_MainFunction_ErrorNotification_Activity
*/
void Can_43_LLCE_MainFunction_ErrorNotification(void);
#endif /* (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON) */

#if (CAN_43_LLCE_API_ENABLE_ABORT_MB == STD_ON)
/**
* @brief          Process a pending transmission abort
* @details        This function requests aborting of the lowest priority pending transmission
*                 of controller ControllerId and returns the hardware transmis handler Hth which
*                 has been freed along with the message tracking information swPduHandle
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      ControllerId - Logical Id of the hardware controller 
* @param[out]     Hth - HW-transmit handler
* @param[out]     swPduHandle - tracking information of the aborted MB
*
* @return         Std_ReturnType.  Result of the abort lowest priority MB service.
* @retval         E_OK  Lowest Priority Message Buffer has been discarded
* @retval         E_NOT_OK  Lowest Priority Message Buffer has not been discarded
*
* @pre            Driver must be initialized; Hardware channel of ControllerId must be started
*
* @note           Not AUTOSAR required. This is user implementation.
* @implements     Can_AbortMb_Activity
*/
Std_ReturnType Can_43_LLCE_AbortMb( Can_HwHandleType Hth);
#endif

#if (CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY == STD_ON)
Std_ReturnType Can_43_LLCE_ManualBusOffRecovery( uint8 ControllerId );
#endif

/* Function used to read the ID of the core currently in use */
static inline uint32 Can_43_LLCE_GetCoreID(void)
{
    uint32 u32CoreId;

    #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) 
        u32CoreId = (uint32)OsIf_GetCoreID();

        /* Check if the CoreId is within range and send 0 if not */
        if(u32CoreId >= CAN_43_LLCE_MAX_PARTITIONS)
        {
            u32CoreId = 0U;
        }
    #else
        u32CoreId = (uint32)0U;
    #endif

    return u32CoreId;
}

/* Utility function to handle reading the global configuration */
static inline const Can_43_LLCE_ConfigType* Can_43_LLCE_GetCurrentConfig(void)
{
    const Can_43_LLCE_ConfigType* pxTempCurrentConfig;
    
    pxTempCurrentConfig = Can_43_LLCE_pCurrentConfig[Can_43_LLCE_GetCoreID()];
    
    return pxTempCurrentConfig;
}

#define CAN_43_LLCE_STOP_SEC_CODE
#include "Can_43_LLCE_MemMap.h"

#ifdef __cplusplus
}
#endif

#endif /* CAN_43_LLCE_H */

/** @} */


===== 文件 [82/112]: source&include\include\Can_43_LLCE_IPW.h =====
/**
*   @file    Can_43_LLCE_IPW.h
*   @implements Can_IPW.h_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Main header file - can include different IPV models.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifndef CAN_43_LLCE_IPW_H
#define CAN_43_LLCE_IPW_H

#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Can_Llce.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/**
* @{
* @file           Can_43_LLCE_IPW.h
*/
#define CAN_IPW_VENDOR_ID_H                    43
#define CAN_IPW_AR_RELEASE_MAJOR_VERSION_H     4
#define CAN_IPW_AR_RELEASE_MINOR_VERSION_H     4
#define CAN_IPW_AR_RELEASE_REVISION_VERSION_H  0
#define CAN_IPW_SW_MAJOR_VERSION_H             1
#define CAN_IPW_SW_MINOR_VERSION_H             0
#define CAN_IPW_SW_PATCH_VERSION_H             10
/**@}*/


/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/


/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/
    #define     CAN_43_LLCE_NULL_OFFSET      (LLCE_NULL_OFFSET_U8)

    #define         Can_43_LLCE_IPW_DeInitPlatform()                                            (Can_Llce_DeInitPlatform())

Llce_Fw_ReturnType Can_43_LLCE_IPW_SetCachedCtrlState(uint8 u8HwCtrl);

#if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)
    #if (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE == STD_OFF)
        #define         Can_43_LLCE_IPW_MainFunctionWrite()                                     (Can_Llce_MainFunctionWrite())
    #else
        #define         Can_43_LLCE_IPW_MainFunctionMultipleWritePoll(writepoll)                (Can_Llce_MainFunctionMultipleWritePoll(writepoll))
    #endif
#endif
    
#if (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON)
    #if (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ == STD_OFF)
        #define         Can_43_LLCE_IPW_MainFunctionRead()                                      (Can_Llce_MainFunctionRead())
    #else
        #define         Can_43_LLCE_IPW_MainFunctionMultipleReadPoll(readpoll)                  (Can_Llce_MainFunctionMultipleReadPoll(readpoll))
    #endif 
#endif

#if (CAN_43_LLCE_BUSOFFPOLL_SUPPORTED == STD_ON)
    #define         Can_43_LLCE_IPW_ProcessBusOffPoll(void)                                     (Can_Llce_ProcessBusOffNotification(void))
#endif    

#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
    #define         Can_43_LLCE_IPW_ProcessErrorNotification(void)                              (Can_Llce_ProcessErrorNotification(void))
#endif    

    #define         Can_43_LLCE_IPW_GetFwVersion(pVersionString, u8StringLength) \
                                    (Can_Llce_GetFwVersion(pVersionString, u8StringLength))
                            
    #define         Can_43_LLCE_IPW_SetFilter(pCanFilter)                                       (Can_Llce_SetFilter(pCanFilter))
    
    #define         Can_43_LLCE_IPW_SetFilterAtAddress(pCanFilter, u16FilterAddr)               (Can_Llce_SetFilterAtAddress(pCanFilter, u16FilterAddr))

    #define         Can_43_LLCE_IPW_SetAfFilterAtAddress(pAfFilter, u16FilterAddr)              (Can_Llce_SetAfFilterAtAddress(pAfFilter, u16FilterAddr))

    #define         Can_43_LLCE_IPW_SetAfFilter(pAfFilter)                                      (Can_Llce_SetAfFilter(pAfFilter))

    #define         Can_43_LLCE_IPW_CreateAfDestination(destRule, pu8RuleIdx)                   (Can_Llce_CreateAfDestination(destRule, pu8RuleIdx))

    #define         Can_43_LLCE_IPW_RemoveAfDestination(u8RuleIdx)                              (Can_Llce_RemoveAfDestination(u8RuleIdx))

    #define         Can_43_LLCE_IPW_RemoveFilter(Hrh, u16FilterAddr)                            (Can_Llce_RemoveFilter(Hrh, u16FilterAddr))

    #define         Can_43_LLCE_IPW_SetFilterState(Hrh, eState)                                 (Can_Llce_SetFilterState(Hrh, eState))

    #define         Can_43_LLCE_IPW_EnableNotifInterrupt(u8ActiveHif)                           (Can_Llce_EnableNotifInterrupt(u8ActiveHif))

    #define         Can_43_LLCE_IPW_Shutdown()                                                  (Can_Llce_Shutdown())

#if (CAN_43_LLCE_API_ENABLE_ABORT_MB == STD_ON)
    #define         Can_43_LLCE_Ipw_AborMb(Hth)                    (Can_Llce_AbortMb(Hth))
#endif

#if (CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY == STD_ON)
Std_ReturnType Can_43_LLCE_Ipw_ManualBusOffRecovery(uint8 ControllerId);
#endif

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/

/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/

Llce_Fw_ReturnType Can_43_LLCE_IPW_Init(const Can_43_LLCE_ConfigType * pxCurrentConfig);
Std_ReturnType Can_43_LLCE_IPW_DeInitController(uint8 Controller);
Std_ReturnType Can_43_LLCE_IPW_GetControllerMode(uint8 Controller, Can_ControllerStateType* ControllerModePtr);
Std_ReturnType Can_43_LLCE_IPW_SetControllerMode( uint8 Controller, Can_ControllerStateType Transition);
Std_ReturnType Can_43_LLCE_IPW_GetControllerStatus(uint8 Controller, Llce_Can_GetStatusCmdType* StatusPtr);
Std_ReturnType Can_43_LLCE_IPW_GetControllerErrorState(uint8 Controller,Can_ErrorStateType* ErrorStatePtr);
Std_ReturnType Can_43_LLCE_IPW_GetControllerRxErrorCounter(uint8 Controller, uint8* RxErrorCounterPtr);
Std_ReturnType Can_43_LLCE_IPW_GetControllerTxErrorCounter(uint8 Controller, uint8* TxErrorCounterPtr);
Std_ReturnType Can_43_LLCE_IPW_Write (Can_HwHandleType Hth, const Can_PduType * PduInfo, PduInfoType PduInfoTriggerTransmit);
Std_ReturnType Can_43_LLCE_IPW_ChangeBaudrate(uint8 Controller, uint8 u8BaudrateIndex);
Std_ReturnType Can_43_LLCE_IPW_SetChannelRoutingOutputState(uint8 ControllerId, Can_43_LLCE_ChannelStateType eChannelStatus);
void Can_43_LLCE_IPW_DisableControllerInterrupts(uint8 Controller);
void Can_43_LLCE_IPW_EnableControllerInterrupts(uint8 Controller);
void Can_43_LLCE_IPW_MainFunctionMode(uint8 Controller);

#ifdef __cplusplus
}
#endif

#endif /* CAN_43_LLCE_IPW_H */

/** @} */


===== 文件 [83/112]: source&include\include\Can_43_LLCE_IrqConfig.h =====
/**
*   @file    Can_IrqConfig.h
*   
*   @version 1.0.0
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Header file used to map ISRs to specific hardware FIFOs.It shall be synchronised also with the LLCE firmware configuration.
*
*   @addtogroup CAN_LLCE
*   @{
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifndef CAN_43_LLCE_IRQCONFIG_H
#define CAN_43_LLCE_IRQCONFIG_H


#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Llce_RegAccess.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/
#define LLCE_FIFO_TXACK_00_EN   (STD_ON)
#define LLCE_FIFO_TXACK_01_EN   (STD_ON)
#define LLCE_FIFO_TXACK_02_EN   (STD_ON)
#define LLCE_FIFO_TXACK_03_EN   (STD_ON)
#define LLCE_FIFO_TXACK_04_EN   (STD_ON)
#define LLCE_FIFO_TXACK_05_EN   (STD_ON)
#define LLCE_FIFO_TXACK_06_EN   (STD_ON)
#define LLCE_FIFO_TXACK_07_EN   (STD_ON)
#define LLCE_FIFO_TXACK_08_EN   (STD_ON)
#define LLCE_FIFO_TXACK_09_EN   (STD_ON)
#define LLCE_FIFO_TXACK_10_EN   (STD_ON)
#define LLCE_FIFO_TXACK_11_EN   (STD_ON)
#define LLCE_FIFO_TXACK_12_EN   (STD_ON)
#define LLCE_FIFO_TXACK_13_EN   (STD_ON)
#define LLCE_FIFO_TXACK_14_EN   (STD_ON)
#define LLCE_FIFO_TXACK_15_EN   (STD_ON)


#define LLCE_FIFO_RXOUT_00_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_01_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_02_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_03_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_04_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_05_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_06_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_07_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_08_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_09_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_10_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_11_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_12_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_13_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_14_EN   (STD_ON)
#define LLCE_FIFO_RXOUT_15_EN   (STD_ON)


#define LLCE_FIFO_RXIN_00_EN    (STD_ON)
#define LLCE_FIFO_RXIN_01_EN    (STD_OFF) /* It used without interrupt service routine.*/
#define LLCE_FIFO_RXIN_02_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_03_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_04_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_05_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_06_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_07_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_08_EN    (STD_ON)
#define LLCE_FIFO_RXIN_09_EN    (STD_OFF) /* It used without interrupt service routine.*/
#define LLCE_FIFO_RXIN_10_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_11_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_12_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_13_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_14_EN    (STD_OFF)
#define LLCE_FIFO_RXIN_15_EN    (STD_OFF)


#define LLCE_FIFO_TXACK_00_ISR() Can_Llce_ProcessTx(0)
#define LLCE_FIFO_TXACK_01_ISR() Can_Llce_ProcessTx(1)
#define LLCE_FIFO_TXACK_02_ISR() Can_Llce_ProcessTx(2)
#define LLCE_FIFO_TXACK_03_ISR() Can_Llce_ProcessTx(3)
#define LLCE_FIFO_TXACK_04_ISR() Can_Llce_ProcessTx(4)
#define LLCE_FIFO_TXACK_05_ISR() Can_Llce_ProcessTx(5)
#define LLCE_FIFO_TXACK_06_ISR() Can_Llce_ProcessTx(6)
#define LLCE_FIFO_TXACK_07_ISR() Can_Llce_ProcessTx(7)
#define LLCE_FIFO_TXACK_08_ISR() Can_Llce_ProcessTx(8)
#define LLCE_FIFO_TXACK_09_ISR() Can_Llce_ProcessTx(9)
#define LLCE_FIFO_TXACK_10_ISR() Can_Llce_ProcessTx(10)
#define LLCE_FIFO_TXACK_11_ISR() Can_Llce_ProcessTx(11)
#define LLCE_FIFO_TXACK_12_ISR() Can_Llce_ProcessTx(12)
#define LLCE_FIFO_TXACK_13_ISR() Can_Llce_ProcessTx(13)
#define LLCE_FIFO_TXACK_14_ISR() Can_Llce_ProcessTx(14)
#define LLCE_FIFO_TXACK_15_ISR() Can_Llce_ProcessTx(15)


#define LLCE_FIFO_RXOUT_00_ISR() Can_Llce_ProcessRx(0)
#define LLCE_FIFO_RXOUT_01_ISR() Can_Llce_ProcessRx(1)
#define LLCE_FIFO_RXOUT_02_ISR() Can_Llce_ProcessRx(2)
#define LLCE_FIFO_RXOUT_03_ISR() Can_Llce_ProcessRx(3)
#define LLCE_FIFO_RXOUT_04_ISR() Can_Llce_ProcessRx(4)
#define LLCE_FIFO_RXOUT_05_ISR() Can_Llce_ProcessRx(5)
#define LLCE_FIFO_RXOUT_06_ISR() Can_Llce_ProcessRx(6)
#define LLCE_FIFO_RXOUT_07_ISR() Can_Llce_ProcessRx(7)
#define LLCE_FIFO_RXOUT_08_ISR() Can_Llce_ProcessRx(8)
#define LLCE_FIFO_RXOUT_09_ISR() Can_Llce_ProcessRx(9)
#define LLCE_FIFO_RXOUT_10_ISR() Can_Llce_ProcessRx(10)
#define LLCE_FIFO_RXOUT_11_ISR() Can_Llce_ProcessRx(11)
#define LLCE_FIFO_RXOUT_12_ISR() Can_Llce_ProcessRx(12)
#define LLCE_FIFO_RXOUT_13_ISR() Can_Llce_ProcessRx(13)
#define LLCE_FIFO_RXOUT_14_ISR() Can_Llce_ProcessRx(14)
#define LLCE_FIFO_RXOUT_15_ISR() Can_Llce_ProcessRx(15)


#define LLCE_FIFO_RXIN_00_ISR() Can_Llce_ProcessNotificationISR()
#define LLCE_FIFO_RXIN_01_ISR() 
#define LLCE_FIFO_RXIN_02_ISR() 
#define LLCE_FIFO_RXIN_03_ISR() 
#define LLCE_FIFO_RXIN_04_ISR() 
#define LLCE_FIFO_RXIN_05_ISR() 
#define LLCE_FIFO_RXIN_06_ISR() 
#define LLCE_FIFO_RXIN_07_ISR() 
#define LLCE_FIFO_RXIN_08_ISR() Can_Llce_ProcessNotificationISR()
#define LLCE_FIFO_RXIN_09_ISR() 
#define LLCE_FIFO_RXIN_10_ISR() 
#define LLCE_FIFO_RXIN_11_ISR() 
#define LLCE_FIFO_RXIN_12_ISR() 
#define LLCE_FIFO_RXIN_13_ISR() 
#define LLCE_FIFO_RXIN_14_ISR() 
#define LLCE_FIFO_RXIN_15_ISR() 

/*==================================================================================================
*                                      Interrupts
==================================================================================================*/

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/   
   
/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/
  
/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/


#ifdef __cplusplus
}
#endif

#endif /* CAN_43_LLCE_IRQCONFIG_H */

/** @} */


===== 文件 [84/112]: source&include\include\Can_Callback.h =====
/**
*   @file    Can_Callback.h
*   @version 1.0.10
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifndef CAN_43_LLCE_CALLBACK_H
#define CAN_43_LLCE_CALLBACK_H

#include "Can_43_LLCE_Cfg.h"
#if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
    #include "Can_43_LLCE.h"
    #include "CanIf_Can.h"

#endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
#include "Reg_eSys_Llce.h"


void Can_43_LLCE_ReportError(uint8 sid , uint8 eTransition);
void Can_43_LLCE_ReportRuntimeError(uint8 sid , uint8 eTransition);
void Can_43_LLCE_TxConfirmation(uint16 tag);
void Can_43_LLCE_RxIndication(uint32 u32MbMessageId, uint16 u16FilterId, uint8* u8FramePayload, uint8 u8MbDataLength);
void Can_43_LLCE_ControllerBusOff(uint8 u8HwCtrl);
void Can_43_LLCE_ControllerModeIndication(uint8 u8HwCtrl, Can_ControllerStateType ctrlState);
void Can_Hth_FreeTxObject(uint16 Hth, uint8 freeObjCount);





#endif /* CAN_43_LLCE_CALLBACK_H */


===== 文件 [85/112]: source&include\include\Can_Llce.h =====
/**
*   @file    Can_Llce.h
*   @implements Can_Llce.h_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - LLD module interface.
*   @details Low Level Driver header file for IPV = Llce.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/



#ifndef CAN_LLCE_H
#define CAN_LLCE_H


#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

/*  (CAN222) Imported types: Dem_Types.h, CanIf_Types.h, Std_Types.h, ComStackTypes.h */
/*
* @file           Can_Llce.h
*/


#include "Llce_RegAccess.h"
#include "Reg_eSys_Llce.h"
#include "Can_GeneralTypes.h"
#include "ComStackTypes.h"
#include "CanIf_Can.h"
#include "Mcal.h"
#include "Can_43_LLCE.h"
#include "Can_43_LLCE_AFcfg.h"
#include "Llce_InterfaceCanTypes.h"


/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/**
* @file           Can_Llce.h
*/
#define CAN_LLCE_VENDOR_ID_H                    43
#define CAN_LLCE_AR_RELEASE_MAJOR_VERSION_H     4
#define CAN_LLCE_AR_RELEASE_MINOR_VERSION_H     4
#define CAN_LLCE_AR_RELEASE_REVISION_VERSION_H  0
#define CAN_LLCE_SW_MAJOR_VERSION_H             1
#define CAN_LLCE_SW_MINOR_VERSION_H             0
#define CAN_LLCE_SW_PATCH_VERSION_H             10

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/

/** @brief   STM timer used for performance measurements. */
#ifdef CAN_43_LLCE_STM_MEASUREMENT_ENABLE
    #define LLCE_STM_BASEADDR          ((uint32)0x43C1A000UL)
    #define LLCE_STM_CR                 (LLCE_STM_BASEADDR)
    #define LLCE_STM_CNT                (LLCE_STM_BASEADDR + 4 )
#endif

#if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U)
#define CAN_LLCE_FILTER_DEFAULT_EMPTY_ADDRESS_U16   ((uint16)0xFFFF)
#endif

#define LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32   ((uint32)0x00000200U) /**< @brief   Enable interrupt on receive.*/
#define LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32   ((uint32)0x00000100U) /**< @brief   Enable interrupt on transmit.*/
#define LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32   ((uint32)0x00001000U) /**< @brief   Enable interrupt mode for Bus off.*/
#define LLCE_CAN_REFERENCE_NOT_USED              ((uint8)0xFFU)  /**< @brief   R/W period reference not used */

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/**
* @brief          CAN Interrupts state.
* @details        CAN Interrupts state.
*
*/
typedef enum
{
    CAN_INTERRUPT_DISABLED = 0U,  /*< @brief Interrupts disabled */
    CAN_INTERRUPT_ENABLED         /*< @brief Interrupts enabled */
} Can_InterruptStateType;

#if(LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0)
/**
* @brief          Can2Eth state type
*
*/
typedef enum
{
    CAN_LLCE_CAN2ETH_DISABLED = 0U,
    CAN_LLCE_CAN2ETH_ENABLED
} Can_Llce_Can2EthStateType;
#endif

#if(LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON)
/**
* @brief          Eth2Can state type
*
*/
typedef enum
{
    CAN_LLCE_ETH2CAN_DISABLED = 0U,
    CAN_LLCE_ETH2CAN_ENABLED
} Can_Llce_Eth2CanStateType;
#endif

#if LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0
/**
* @brief          Can2Pcie state type
*
*/
typedef enum
{
    CAN_LLCE_CAN2PCIE_DISABLED = 0U,
    CAN_LLCE_CAN2PCIE_ENABLED
} Can_Llce_Can2PcieStateType;
#endif
/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/
    
/**
* @brief          Records the status of a CAN Controller during runtime.
* @details        Records the status of a CAN Controller during runtime.
*
* @note           This structure is not configured by Tresos.
*/
typedef struct
    {
        uint8 u8IntDisableLevel; /*< @brief Storage space for Can_43_LLCE_DisableControllerInterrupts nesting level */
        
        Can_InterruptStateType eInterruptMode; /*< @brief Global interrupt authorization state */
        
        Can_ControllerStateType eCachedControllerState; /*< @brief Local copy of controller state */

        Can_InterruptStateType eSetIntEnRequest;   /*< @brief Interrupt Enable Request for given controller */

    } Can_43_LLCE_ControllerStatusType;


/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/

/*==================================================================================================
*                                           MACROS
=====================================================================================================*/
    
/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_CODE

#include "Can_43_LLCE_MemMap.h"

Llce_Fw_ReturnType Can_Llce_Init( const Can_43_LLCE_ConfigType * pxCurrentConfig);

#if((LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON))
Std_ReturnType Can_Llce_Init_PfeIf( uint8 Hif);
Std_ReturnType Can_Llce_Start_PfeIf(void);
#endif

#if(LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0)
Std_ReturnType Can_Llce_SetCan2EthState(Can_Llce_Can2EthStateType eState);
#endif

#if (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON)
Llce_Fw_ReturnType Can_Llce_SetEth2CanFormatState(Llce_Can_EthEncapsulationFormat eFormat, Can_Llce_Eth2CanStateType eState);
#endif 

#if LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0
Std_ReturnType Can_Llce_SetCan2PcieState(Can_Llce_Can2PcieStateType eState);
#endif

Std_ReturnType Can_Llce_DeInitController(uint8 u8HwCtrl);

Std_ReturnType Can_Llce_DeInitPlatform(void);

Std_ReturnType Can_Llce_Shutdown(void);

Std_ReturnType Can_Llce_ChangeBaudrate(uint8 u8HwCtrl, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr);

Std_ReturnType Can_Llce_GetControllerMode(uint8 u8HwCtrl, Can_ControllerStateType * ControllerModePtr);

Std_ReturnType Can_Llce_SetControllerMode(uint8 u8HwCtrl, Can_ControllerStateType Transition, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr);

void Can_Llce_DisableControllerInterrupts(uint8 u8HwCtrl);
void Can_Llce_EnableControllerInterrupts(uint8 u8HwCtrl);

void Can_Llce_EnableNotifInterrupt(uint8 u8ActiveHif);
void Can_Llce_DisableNotifInterrupt(uint8 u8ActiveHif);

Std_ReturnType Can_Llce_Write(uint8 u8HwCtrl, Can_43_LLCE_TxFrameInfoType* TxFrameInfo);

void Can_Llce_ProcessTx(const uint8 u8AckInterface );

#if (CAN_43_LLCE_BUSOFFPOLL_SUPPORTED == STD_ON)
void Can_Llce_ProcessBusOffNotification(void);
#endif /* (CAN_43_LLCE_BUSOFFPOLL_SUPPORTED == STD_ON) */

#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
void Can_Llce_ProcessErrorNotification(void);
#endif /* (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON) */

void Can_Llce_ProcessNotificationISR(void);

void Can_Llce_ProcessRx(const uint8 u8RxInterface);

#if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)

void Can_Llce_MainFunctionWrite(void);

void Can_Llce_MainFunctionMultipleWritePoll(uint8 writepoll);

#endif /* (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON) */

#if (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON)

void Can_Llce_MainFunctionRead(void);

void Can_Llce_MainFunctionMultipleReadPoll(uint8 readpoll);

#endif /* (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON) */

void Can_Llce_MainFunctionMode(uint8 u8HwCtrl);
Std_ReturnType Can_Llce_GetControllerErrorState(uint8 u8HwCtrl, Can_ErrorStateType * ErrorStatePtr);
Std_ReturnType Can_Llce_GetControllerRxErrorCounter(uint8 u8HwCtrl, uint8 * RxErrorCounterPtr);
Std_ReturnType Can_Llce_GetControllerTxErrorCounter(uint8 u8HwCtrl, uint8 * TxErrorCounterPtr);
Std_ReturnType Can_Llce_GetControllerStatus(uint8 u8HwCtrl, Llce_Can_GetStatusCmdType * StatusPtr);

Std_ReturnType Can_Llce_GetFwVersion(const uint8 ** pVersionString, uint8 * pStringLength);
Std_ReturnType Can_Llce_SetFilter(const Can_SetFilterType * pCanFilter);
Std_ReturnType Can_Llce_SetFilterAtAddress(const Can_SetFilterType * pCanFilter, const uint16 u16FilterAddr);
Std_ReturnType Can_Llce_SetAfFilterAtAddress(const Can_SetAfFilterType * pAfFilter, const uint16 u16FilterAddr);
Std_ReturnType Can_Llce_CreateAfDestination(Can_Af_DestRulesType destRule, uint8* pu8RuleIdx);
Std_ReturnType Can_Llce_RemoveAfDestination(uint8 u8RuleIdx);
Std_ReturnType Can_Llce_SetAfFilter(const Can_SetAfFilterType * pAfFilter);
Std_ReturnType Can_Llce_RemoveFilter(Can_HwHandleType Hrh, uint16* u16FilterAddr);
Std_ReturnType Can_Llce_SetFilterState(Can_HwHandleType Hrh, Can_43_LLCE_FilterStateType eState);
Std_ReturnType Can_Llce_SetChannelRoutingOutputState(uint8 u8HwCtrl, Can_43_LLCE_ChannelStateType eChannelStatus);

Std_ReturnType Can_Llce_ExecuteCustomCommand(const void* const argument);

#if (CAN_43_LLCE_API_ENABLE_ABORT_MB == STD_ON)
Std_ReturnType Can_Llce_AbortMb(Can_HwHandleType Hth);
#endif

#if (CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY == STD_ON)
Std_ReturnType Can_Llce_ManualBusOffRecovery(uint8 u8HwCtrl);
#endif

#define CAN_43_LLCE_STOP_SEC_CODE

#include "Can_43_LLCE_MemMap.h"

#ifdef __cplusplus
}
#endif

#endif /* CAN_LLCE_H */

/** @} */


===== 文件 [86/112]: source&include\include\Can_Llce_Types.h =====
/**
*   @file    Can_Llce_Types.h
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface.
*   @details API header for CAN driver.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/


#ifndef CAN_LLCE_TYPES_H
#define CAN_LLCE_TYPES_H

#ifdef __cplusplus
extern "C"{
#endif



/**
* @file           Can_Llce_Types.h
*/

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

#include "Can_43_LLCE_Cfg.h"
#include "Llce_InterfaceCanTypes.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/
/**
* @{
* @brief          Development errors.
* @details        (CAN104) The Can module shall be able to detect the following errors and exceptions depending on its configuration (development/production).
*                 (CAN026) Development Errors shall indicate errors that are caused by erroneous usage of the Can module API. This covers API
*                   parameter checks and call sequence errors.
*                 (CAN080) Development error values are of type uint8.
*
*/
#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)

    #define CAN_43_LLCE_E_PARAM_POINTER      ((uint8)0x01U)
    #define CAN_43_LLCE_E_PARAM_HANDLE       ((uint8)0x02U)
    #define CAN_43_LLCE_E_PARAM_DATA_LENGTH  ((uint8)0x03U)
    #define CAN_43_LLCE_E_PARAM_CONTROLLER   ((uint8)0x04U)
    #define CAN_43_LLCE_E_UNINIT             ((uint8)0x05U)

#endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

#define CAN_43_LLCE_E_TRANSITION         ((uint8)0x06U)

#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)

#if (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON)
    #define CAN_43_LLCE_E_PARAM_BAUDRATE     ((uint8)0x07U)
#endif

    #define CAN_43_LLCE_E_PARAM_CONFIG       ((uint8)0x08U)

    #define CAN_43_LLCE_E_INIT_FAILED        ((uint8)0x09U)

    #define CAN_43_LLCE_E_LLCE_FAILED        ((uint8)0x0AU) /* FIFO Interface communication failed. 1 TX token is lost. Requires controller restart. */

#endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

/**@}*/

/**
* @{
* @brief          Runtime errors.
*
*/
#define CAN_43_LLCE_E_DATALOST           ((uint8)0x01U)

/**@}*/

/**
* @{
* @brief          Service ID (APIs) for Det reporting
*
*/
#define CAN_43_LLCE_SID_INIT                          ((uint8)0x00U)
#define CAN_43_LLCE_SID_CREATE_DESTINATION            ((uint8)0x01U)
#define CAN_43_LLCE_SID_SET_CONTROLLER_MODE           ((uint8)0x03U)

#define CAN_43_LLCE_SID_DISABLE_CONTROLLER_INTERRUPTS ((uint8)0x04U)
#define CAN_43_LLCE_SID_ENABLE_CONTROLLER_INTERRUPTS  ((uint8)0x05U)
#define CAN_43_LLCE_SID_WRITE                         ((uint8)0x06U)

#if (CAN_43_LLCE_VERSION_INFO_API == STD_ON)
#define CAN_43_LLCE_SID_GET_VERSION_INFO              ((uint8)0x07U)
#endif

#define CAN_43_LLCE_SID_CBK_CHECK_WAKEUP              ((uint8)0x0BU)

#if (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON)
#define CAN_43_LLCE_SID_SET_BAUDRATE                  ((uint8)0x0FU)
#endif

#define CAN_43_LLCE_SID_DEINIT                            ((uint8)0x10U)
#define CAN_43_LLCE_SID_GETCONTROLLERERRORSTATE           ((uint8)0x11U)
#define CAN_43_LLCE_SID_GETCONTROLLERMODE                 ((uint8)0x12U)
#define CAN_43_LLCE_SID_GET_CTRL_RX_ERROR_COUNTER         ((uint8)0x13U)
#define CAN_43_LLCE_SID_GET_CTRL_TX_ERROR_COUNTER         ((uint8)0x14U)

#define CAN_43_LLCE_SID_PROCESS_NOTIFICATION_ISR          ((uint8)0x15U)
#define CAN_43_LLCE_SID_REMOVE_DESTINATION                ((uint8)0x16U)
#define CAN_43_LLCE_SID_SET_FILTER                        ((uint8)0x17U)
#define CAN_43_LLCE_SID_REMOVE_FILTER                     ((uint8)0x18U)
#define CAN_43_LLCE_SID_SET_FILTER_ENABLE_STATE           ((uint8)0x1AU)
#define CAN_43_LLCE_SID_SETCHANNEL_ROUTING_OUTPUTSTATE    ((uint8)0x1BU)

#if (CAN_43_LLCE_API_ENABLE_ABORT_MB == STD_ON)
#define CAN_43_LLCE_SID_ABORT_LOWEST_PRIO_MB          ((uint8)0x19U)
#endif

#if (CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY == STD_ON)
#define CAN_43_LLCE_SID_MANUAL_BUSOFF_RECOVERY        ((uint8)0x20U)
#endif


/*==================================================================================================
                                 STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/
typedef struct 
{
    uint32 u32MessageId;
    uint32 u32TxHseKeyHandle;
    uint32 u32SduLength;
    uint16 u16FrameTag1;
    uint16 u16FrameTag2;
    uint16 u16MbFrameIdx;
    uint8 u8AckInterface;
    uint8 u8EnableTxFrameMac;    
    uint8 u8FdEnabled;
    uint8 u8FdPaddingValue;
    const uint8* u8SduDataPtr;
    
}Can_43_LLCE_TxFrameInfoType;



#ifdef __cplusplus
}
#endif

#endif /* CAN_LLCE_TYPES_H */

/** @} */


===== 文件 [87/112]: source&include\include\Llce_FwVersion.h =====
/**
 *   @file    Llce_FwVersion.h
 *
 *   @brief   LLCE Version module data structures and defines
 *   @details This file contains the LLCE Version data structures, defines and
 *            function declarations to specify the version information included
 *            in the binaries.
 *
 *   @addtogroup LLCE_version LLCE firmware version
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_FW_VERSION_H
#define LLCE_FW_VERSION_H

#ifdef __cplusplus
extern "C" {
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
#include "Llce_RegAccess.h"

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/
#define LLCE_VERSION_MAX_LENGTH 50

/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/
/**
 * @brief Firmware version datatype.
 * It contains the versionString which encodes the 
 * firmware image characteristics, such as: build time,
 * target derivative and the versions of each feature
 **/
typedef struct
{
    /** @brief OUTPUT: LLCE FW version string actual length. */
    uint8 stringLength;
    /** @brief OUTPUT: LLCE FW version string. */
    uint8 versionString[LLCE_VERSION_MAX_LENGTH];
} LLCE__ALIGNED__PACKED Llce_Fw_VersionType;

/*==================================================================================================
 *                                GLOBAL VARIABLE DECLARATIONS
 ==================================================================================================*/

#ifdef __cplusplus
}
#endif

#endif /* LLCE_FW_VERSION_H*/

/** @} */


===== 文件 [88/112]: source&include\include\Llce_InterfaceCanConfig.h =====
/**
 *   @file    Llce_InterfaceCanConfig.h
 *
 *   @brief LLCE defines used to configure the LLCE firmware and interface
 *   @details LLCE  defines used to configure the LLCE firmware and interface.
 *                  Those configuration parameters are used both by LLCE
 *                  firmware and host software.
 *
 *
 *   @addtogroup Llce_configuration LLCE precompile configuration parameters
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_INTERFACECONFIG_H
#define LLCE_INTERFACECONFIG_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __DOXYGEN__
/**
 *
 * @page misra_violations MISRA-C:2012 violations
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 2.5, A project should not contain unused
 * macro declarations Some macros are used either in FW or driver, or provided
 * as API
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 2.3, A project should not contain unused
 * type declarations. Some type declarations are used either in FW or driver, or
 * provided as API
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.1, Identifiers (internal and external)
 * shall not rely on the significance of more than 31 characters. The used
 * compilers use more than 31 chars for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.2, Identifiers declared in the same scope
 * and name space shall be distinct. The used compilers use more than 31 chars
 * for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.4, Macro identifiers shall be distinct.
 * The used compilers use more than 31 chars for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.5, Identifiers shall be distinct from
 * macro names. The identifier clash is between macro identifiers. Therefore,
 * this rule is incorrectly reported by the tool.
 */
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
#include "Llce_RegAccess.h"
#include "Llce_InterfaceFwMgr.h"
#include "Llce_Sema42.h"

/*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/

/* LLCE configuration parameters.*/
/**
 * @brief Default controller ID needed by the host 0 interface in order to
 * transmit INIT_PLATFORM and DEINIT_PLATFORM commands from host to LLCE.
 */
#define LLCE_CAN_CONFIG_DEFAULT_CAN_CTRL_HOST0_U8 ((uint8)0U)
/**
 * @brief Default controller ID needed by the host 1 interface in order to
 * transmit INIT_PLATFORM and DEINIT_PLATFORM commands from host to LLCE.
 */
#define LLCE_CAN_CONFIG_DEFAULT_CAN_CTRL_HOST1_U8 ((uint8)8U)

/**
 * @brief Maximum number of notifications which can be reported by LLCE
 * to host.
 */
#define LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE (17U)
/**
 * @brief Maximum buffer size used to store the CAN FD frame payload.
 * See \link Llce_Can_MbType \endlink
 */
#define LLCE_CAN_CONFIG_PAYLOAD_MAX_SIZE (64U)
/**
 * @brief Maximum buffer size used to store the short CAN FD frame payload.
 * See \link Llce_Can_ShortMbType \endlink
 */
#define LLCE_CAN_CONFIG_SHORT_PAYLOAD_MAX_SIZE (8U)
/**
 * @brief Maximum number of hardware controllers usable inside LLCE.
 * See \link Llce_Can_InitCmdType \endlink
 */
#define LLCE_CAN_CONFIG_MAXCTRL_COUNT (16U)
/**
 * @brief Maximum number of polling classes usable inside LLCE.
 * A polling class is used to tie together multiple filters which
 * report the received frames in polling.
 * See \link Llce_Can_InitCmdType \endlink
 */
#define LLCE_CAN_MAX_POLLING_CLASSES (6U)

/**
 * @brief Maximum number of transmission message buffers.
 * See \link Llce_Can_TxMbDescriptorType \endlink
 */
#define LLCE_CAN_CONFIG_MAXTXMB (256U)
/**
 * @brief Maximum number of 64B reception message buffers.
 * Note: 32 from those are reserved
 * for internal usage and are not available to the host.
 * See \link Llce_Can_RxMbDescriptorType \endlink
 */
#define LLCE_CAN_CONFIG_MAXRXMB (1732U)

/**
 * @brief Maximum number of 8B reception message buffers.
 * for internal usage and are not available to the host.
 * See \link Llce_Can_RxMbDescriptorType \endlink
 */
#define LLCE_CAN_CONFIG_MAX_SHORTRXMB (2396U)


/**
 * @brief Number of AF descriptors reserved for each
 * internal path within LLCE frame routing
*/
#define LLCE_CAN_CONFIG_MAXAFRXMB (256U)
#define LLCE_CAN_CONFIG_MAXAFTXMB (256U)
#define LLCE_CAN_CONFIG_MAXAFFRMB (256U)

/**
 * @brief Maximum number of standard filters which can be configured using
 * using a single command. Multiple commands can be executed when more filters
 * are needed.
 * See \link Llce_Can_ReceiveFilterType \endlink
 */
#define LLCE_CAN_CONFIG_MAX_FILTERS_COUNT ((uint16)20U)
/**
 * @brief Number of entries of the circular buffer used to send ack information
 * from TX core to host core. There is 1 extra buffer for each interface for
 * consistency purpose.
 */
#define LLCE_CAN_CONFIG_MAX_TXACKINFO ((uint16)(512U + LLCE_CAN_RX_TX_INTERFACES))
/**
 * @brief Mask used to get the right data from FIFOs.
 * See FMR config register of FIFO.
 */
#define LLCE_CAN_CONFIG_FIFO_FIXED_MASK_U32 ((uint32)0x0007FFFF)
/**
 * @brief Maximum number of advanced filters which can be configured using a
 * single command. Multiple commands can be executed when more filters are
 * needed.
 * See \link Llce_Can_AdvancedFilterType \endlink
 */
#define LLCE_CAN_CONFIG_ADVANCED_FILTERS_COUNT (8U)
/**
 * @brief Shared memory size allocated for each channel for
 * commands exchange.
 */
#define LLCE_CAN_CONFIG_CTRL_SHARED_MEMORY_SIZE ((uint32)0x400)
/**
 * @brief Reserved value in order to detect if an advanced filter entry
 * is not used.
 */
#define LLCE_CAN_ADVANCED_FILTER_NOT_USED (0xFFU)
/** @brief Interface ID used by different hosts for multihost scenarios. */
#define LLCE_CAN_HIF0 (0U)
/** @brief Interface ID used by different hosts for multihost scenarios. */
#define LLCE_CAN_HIF1 (1U)
/** @brief Number of interfaces which can be used by host cores. */
#define LLCE_CAN_CONFIG_HIF_COUNT (2U)
/** @brief Number of semaphores for each HIF. */
#define LLCE_CAN_CONFIG_IER_SEMA4_COUNT   (2U)
/** @brief Index of FIFO_RXOUT inside Can_Sema4_Ier array. */
#define LLCE_FIFO_RXOUT_INDEX             (0U)
/** @brief Index of FIFO_TXACK inside Can_Sema4_Ier array. */
#define LLCE_FIFO_TXACK_INDEX             (1U)
/** @brief Number of FIFOs used by first HIF. */
#define LLCE_CAN_HIF0_FIFO_CNT            (8U)
/** @brief Semaphore core domain */
#define LLCE_HOST_CORE_SEMA42_DOMAIN         (LLCE_SEMA42_GR_GTFSM_9)
/** @brief No result from RxLut2 */
#define LLCE_RXLUT2_NO_RESULT             ((uint16)0xFFFFU)


/* LIN defines */
/** @brief Maximum buffer size used to store the LIN frame payload */
#define LLCE_LIN_CONFIG_PAYLOAD_MAX_SIZE (8U)
/** @brief Maximum number of LIN transmission buffers */
#define LLCE_LIN_CONFIG_MAXTXBUFF (64U)
/** @brief Maximum number of LIN reception buffers */
#define LLCE_LIN_CONFIG_MAXRXBUFF (64U)

/*==================================================================================================
 *                                      Interrupts
 ==================================================================================================*/

/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/*==================================================================================================
 *                                STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/

/*==================================================================================================
 *                                GLOBAL VARIABLE DECLARATIONS
 ==================================================================================================*/

/*==================================================================================================
 *                                    FUNCTION PROTOTYPES
 ==================================================================================================*/
 
void DisableFifoInterrupts (uint8 u8FifoInterface, uint8 u8Hif);
void EnableFifoInterrupts (uint8 u8FifoInterface, uint8 u8Hif);

#ifdef __cplusplus
}
#endif

#endif /* LLCE_FIFO_H */

/** @} */


===== 文件 [89/112]: source&include\include\Llce_InterfaceCanTypes.h =====
/**
 *   @file    Llce_InterfaceCanTypes.h
 *
 *   @brief   LLCE data structures used to implement the LLCE interface
 *   @details This file contains data structures used to implement the LLCE
 *            interface
 *
 *   @addtogroup LLCE_CAN_firmware_interface LLCE CAN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/
#ifndef LLCE_INTERFACECANTYPES_H
#define LLCE_INTERFACECANTYPES_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __DOXYGEN__
/**
 *
 * @page misra_violations MISRA-C:2012 violations
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 2.3, A project should not contain unused
 * type declarations Some types are used either in FW or driver, or provided as
 * API
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 2.5, A project should not contain unused
 * macro declarations Some macros are used either in FW or driver, or provided
 * as API
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.1, Identifiers (internal and external)
 * shall not rely on the significance of more than 31 characters. The used
 * compilers use more than 31 chars for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.2, Identifiers declared in the same scope
 * and name space shall be distinct. The used compilers use more than 31 chars
 * for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.4, Macro identifiers shall be distinct.
 * The used compilers use more than 31 chars for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.5, Identifiers shall be distinct from
 * macro names. The identifier clash is between macro identifiers. Therefore,
 * this rule is incorrectly reported by the tool.
 *
 * @section Llce_InterfaceCanTypes_h_REF_1
 * Violates MISRA 2012 Required Rule 21.1, #define and #undef shall not be used
 * on a reserved identifier or reserved macro name. The #define is enabled only
 * when PC-LINT analyses the code as a workaround for a bug in the tool (it
 * doesn't recognize structure name when __attribute__ keyword prefixes it).
 *
 * @section Llce_InterfaceCanTypes_h_REF_2
 * Violates MISRA 2012 Advisory Rule 4.9, A function should be used in
 * preference to a function-like macro where they are interchangeable. The
 * #define is enabled only when PC-LINT analyses the code as a workaround for a
 * bug in the tool (it doesn't recognize structure name when __attribute__
 * keyword prefixes it).
 */
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
#ifdef CHECK_ABI_COMPATIBILITY
#pragma ABICHECK stop
#endif

#include "Llce_RegAccess.h"
#include "Llce_InterfaceCanConfig.h"
#include "Llce_FwVersion.h"
#include "Llce_InterfaceFwMgr.h"

#ifdef CHECK_ABI_COMPATIBILITY
#pragma ABICHECK start
#endif
/*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/
/**
 * @{
 * @brief Offset bits for NCBT register
 */
#define LLCE_NCBT_NPRESDIV_SHIFT_U8 ((uint8)23U)
#define LLCE_NCBT_NRJW_SHIFT_U8 ((uint8)16U)
#define LLCE_NCBT_NTSEG2_SHIFT_U8 ((uint8)9U)
/**@}*/

/**
 * @{
 * @brief Offset bits for DCBT register
 */
#define LLCE_DCBT_DPRESDIV_SHIFT_U8 ((uint8)23U)
#define LLCE_DCBT_DRJW_SHIFT_U8 ((uint8)16U)
#define LLCE_DCBT_DTSEG2_SHIFT_U8 ((uint8)9U)
/**@}*/

/*==================================================================================================
 *                                CONTROLLER OPTIONS
 ==================================================================================================*/
/**
 * @brief Controller option used by the initialization command in order to
 * inform LLCE firmware that a specific controller shall be initialized.
 * See \link Llce_Can_InitCmdType \endlink
 */
#define LLCE_CAN_CONTROLLERCONFIG_CTRL_EN_U32 ((uint32)0x10000000U)
/**
 * @brief CAN controller option used to enable reporting of the Protocol
 * Exception errors.
 * See \link Llce_Can_GetStatusCmdType \endlink
 */
#define LLCE_CAN_CONTROLLERCONFIG_PE_EN_U32 ((uint32)0x00040000U)
/** @brief CAN controller option used to enable Timestamp feature. */
#define LLCE_CAN_CONTROLLERCONFIG_TST_END_U32 ((uint32)0x00080000U)
/**
 * @brief CAN controller option used to enable Timestamp feature at the start
 * of the CAN frame.
 */
#define LLCE_CAN_CONTROLLERCONFIG_TST_START_U32 ((uint32)0x00000080U)
/**
 * @brief CAN controller option used to enable Timestamp feature in the start of
 * frame for classical CAN frames and in the res bit for CAN FD frames.
 */
#define LLCE_CAN_CONTROLLERCONFIG_TST_FD_U32 ((uint32)0x00000040U)
/** @brief CAN controller option used to enable Listen-Only mode. */
#define LLCE_CAN_CONTROLLERCONFIG_LOM_EN_U32 ((uint32)0x00100000U)
/** @brief CAN controller option used to enable internal LoopBack mode. */
#define LLCE_CAN_CONTROLLERCONFIG_LPB_EN_U32 ((uint32)0x00200000U)
/** @brief CAN controller option used to enable self-reception mode. */
#define LLCE_CAN_CONTROLLERCONFIG_SRX_EN_U32 ((uint32)0x00400000U)
/**< @brief   CAN controller option used to enable automatic bus-off recovery. */
#define LLCE_CAN_CONTROLLERCONFIG_ABR_EN_U32  ((uint32)0x00000001U) 
/**< @brief   CAN controller option used to enable TX FIFO mode. */
#define LLCE_CAN_CONTROLLERCONFIG_TXFIFO_EN_U32  ((uint32)0x00000002U) 
/**< @brief   CAN controller option used to enable manual bus-off recovery. */
#define LLCE_CAN_CONTROLLERCONFIG_MBR_EN_U32  ((uint32)0x00000004U) 
/**
 * @brief Number of interfaces used for interrupt reporting
 * (one per channel) + number of polling classes.
 */
#define LLCE_CAN_RX_TX_INTERFACES                                              \
    ((uint8)(LLCE_CAN_CONFIG_MAXCTRL_COUNT + LLCE_CAN_MAX_POLLING_CLASSES))
/**
 * @brief Default value in the transmission request informing LLCE that tx
 * confirmation is not needed for that frame.
 */
#define LLCE_CAN_ACK_DISABLED ((uint8)0xADU)
#define LLCE_CAN_PARAM_NOT_USED ((uint8)0xFFU)

/*==================================================================================================
                 DEFINES SHARED BETWEEN HOST AND LLCE
==================================================================================================*/
/** @brief Frame DLC field mask. */
#define LLCE_CAN_MB_DLC_MASK_U32 ((uint32)0x0000000FU)
/** @brief Frame ID field mask. */
#define LLCE_CAN_MB_ID_MASK_U32 ((uint32)0x1FFFFFFFU)
/** @brief Frame FDF field mask. */
#define LLCE_CAN_MB_FDF_U32 ((uint32)0x00008000U)
/** @brief Frame BRS field mask. */
#define LLCE_CAN_MB_BRS_U32 ((uint32)0x00010000U)
/** @brief Frame ESI field mask. */
#define LLCE_CAN_MB_ESI_U32 ((uint32)0x00020000U)
/** @brief Frame IDE field mask. */
#define LLCE_CAN_MB_IDE_U32 ((uint32)0x40000000U)
/** @brief Frame RTR field mask. */
#define LLCE_CAN_MB_RTR_U32 ((uint32)0x80000000U)
/** @brief Frame standard ID field mask. */
#define LLCE_CAN_MB_IDSTD_MASK_U32 ((uint32)0x1FFC0000U)
/** @brief Frame extended ID field mask. */
#define LLCE_CAN_MB_IDEXT_MASK_U32 ((uint32)0x0003FFFFU)
/** @brief Routing feature default configuration. */
#define LLCE_CAN_ROUTING_OPTION_DEFAULT_CONFIG ((uint32)0x00000000U)
/** @brief Routing feature mask for non-converting frame. */
#define LLCE_CAN_ROUTING_NOCHANGE ((uint32)0x00000001U)
/** @brief Routing feature mask for converting frame (CANFD->CAN). */
#define LLCE_CAN_ROUTING_CAN ((uint32)0x00000002U)
/** @brief Routing feature mask for converting frame (CAN->CANFD). */
#define LLCE_CAN_ROUTING_CANFD ((uint32)0x00000004U)
/** @brief Routing feature mask for id remapping. */
#define LLCE_CAN_ROUTING_ID_REMAPPING_EN ((uint32)0x00000008U)

/** @brief Shift value for extracting FD flag  from CAN frame. */
#define LLCE_CAN_MB_FDF_SHIFT_U32 ((uint32)15U)
/** @brief Shift value for extracting Baud Rate Switch flag from CAN frame. */
#define LLCE_CAN_MB_BRS_SHIFT_U32 ((uint32)16U)
/** @brief Shift value for extracting ESI flag feature from CAN frame. */
#define LLCE_CAN_MB_ESI_SHIFT_U32 ((uint32)17U)
/** @brief Shift value for extracting frame ID from CAN frame. */
#define LLCE_CAN_MB_IDSTD_SHIFT_U32 ((uint32)18U)
/** @brief Shift value for extracting IDE flag from CAN frame. */
#define LLCE_CAN_MB_IDE_SHIFT_U32 ((uint32)30U)
/** @brief Shift value for extracting RTR flag from CAN frame. */
#define LLCE_CAN_MB_RTR_SHIFT_U32 ((uint32)31U)

/** @brief Shift value for extracting precalculated length from CAN frame. */
#define LLCE_CAN_MB_PRECALC_LEN_SHIFT_U32 ((uint32)24U)

/** @brief Constant used to identify a reserved mask id. */
#define LLCE_CAN_FULLCAN_MASK_U32 ((uint32)0xFFFFFFFFU)

/*=========================================================
              DEFINES FOR INTERACTING WITH PFE
=========================================================*/
#define LLCE_CAN2ETH_PFE_EMAC0          (0x0001U)
#define LLCE_CAN2ETH_PFE_EMAC1          (0x0002U)
#define LLCE_CAN2ETH_PFE_EMAC2          (0x0004U)
#define LLCE_CAN2ETH_PFE_HIF0           (0x0008U)
#define LLCE_CAN2ETH_PFE_HIF1           (0x0010U)
#define LLCE_CAN2ETH_PFE_HIF2           (0x0020U)
#define LLCE_CAN2ETH_PFE_HIF3           (0x0040U)
#define LLCE_CAN2ETH_PFE_HIFNOCPY       (0x0080U)
#define LLCE_CAN2ETH_PFE_AUX            (0x0100U)

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/**
 * @brief Notification IDs used to interface with LLCE.
 *
 * Notifications send by LLCE to host core.
 **/
typedef enum LLCE__PACKED
{
    /** @brief No error. */
    LLCE_CAN_NOTIF_NOERROR = 0U,
    /** @brief Error related to the common platform area. */
    LLCE_CAN_NOTIF_PLATFORMERROR,
    /** @brief Error related to a specific channel.*/
    LLCE_CAN_NOTIF_CHANNELERROR,
    /** @brief Notification related to changing CAN controller mode.*/
    LLCE_CAN_NOTIF_CTRLMODE,
} Llce_Can_NotificationIdType;

/**
 * @brief Command IDs used to interface with LLCE.
 *
 * Some of those commands are sent by the host to LLCE module and others are
 * sent by LLCE module to the host.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Host initializes LLCE module. */
    LLCE_CAN_CMD_INIT = 0U,
    /** @brief Host deinitializes a specific CAN controller. */
    LLCE_CAN_CMD_DEINIT,
    /** @brief Host sets a baud rate for a specific CAN controller.*/
    LLCE_CAN_CMD_SETBAUDRATE,
    /** @brief Host checks the state for a specific CAN controller.*/
    LLCE_CAN_CMD_GETCONTROLLERMODE,
    /** @brief Host changes the state for a specific CAN controller.*/
    LLCE_CAN_CMD_SETCONTROLLERMODE,
    /**
     * @brief Host requests the recovery from bus-off state
     * transmission of a specific CAN controller.
     */
    LLCE_CAN_CMD_MANUAL_BUSOFF_RECOVERY,
    /**
     * @brief LLCE delivers to the host the content of all status registers
     * of the CAN controller.
     */
    LLCE_CAN_CMD_GETSTATUS,
    /** @brief The host configures multiple filters on the reception side.*/
    LLCE_CAN_CMD_SETFILTER,
    /** @brief The host configures multiple advanced feature filters on reception side*/
    LLCE_CAN_CMD_SETADVANCEDFILTER,
    /** @brief The host enables/disables the already set filter. */
    LLCE_CAN_CMD_SETFILTERENABLESTATUS,
    /** @brief The host invalidates a specific filter.*/
    LLCE_CAN_CMD_REMOVE_FILTER,
    /** @brief Request version string from FW.*/
    LLCE_CAN_CMD_GETFWVERSION,
    /** @brief Host request for platform initialization.*/
    LLCE_CAN_CMD_INIT_PLATFORM,
    /**
     * @brief LLCE internal command request for initialization of
     * common resources.
     */
    LLCE_CAN_CMD_INIT_PLATFORM_COMMON,
    /** @brief Host request for platform deinitialization.*/
    LLCE_CAN_CMD_DEINIT_PLATFORM,
    /**
     * @brief Host request for platform initialization regarding
     * CAN2ETH-ETH2CAN use case.
     */
    LLCE_CAN_CMD_INIT_PFE,
        /**
     * @brief Host request for platform initialization regarding
     * CAN2ETH-ETH2CAN use case using ring buffers generated on host side.
     */
    LLCE_CAN_CMD_INIT_PFE_EXT_RING_BUF,
    /**
     * @brief Host request for platform initialization regarding
     * HSE bridge use case.
     */
    LLCE_CAN_CMD_INIT_HSE,
    /**
     * @brief Host creates a destination to be used by the advanced
     * routing filters.
     */
    LLCE_CAN_CMD_CREATE_AF_DESTINATION,
    /**
     * @brief Host requests the abortion of the lowest priority pending
     * transmission of a specific CAN controller.
     */
    LLCE_CAN_CMD_ABORT_MB,
    /** @brief Custom command to be implemented by user in FDK */
    LLCE_CAN_CMD_CUSTOM,
    /** @brief The host configures multiple filters on the reception side for rxlut2 on g3.*/
    LLCE_CAN_CMD_SETAUXFILTER,
    /** @brief The host requests the addition of a new filter by specifying filter address.*/
    LLCE_CAN_CMD_SETFILTER_AT_ADDRESS,
    /** @brief The host enables or disables a channel in a routing multicast configuration.*/
    LLCE_CAN_CMD_SETCHANNELROUTINGOUTPUTSTATE,
    /** @brief The host enables or disables Can2Eth processing entirely.*/
    LLCE_CAN_CMD_SETCAN2ETHSTATE,
    /** @brief The host enables or disables Eth2Can processing for a format.*/
    LLCE_CAN_CMD_SETETH2CANFORMATSTATE,
    /** @brief The host requests the addition of a new advanced filter by specifying filter address.*/
    LLCE_CAN_CMD_SETADVANCEDFILTER_AT_ADDRESS,
    /** @brief The host enables or disables Can2Pcie processing entirely.*/
    LLCE_CAN_CMD_SETCAN2PCIESTATE,
    /** @brief The host requests all LLCE cores to execute WFI and shut down.*/
    LLCE_CAN_CMD_SHUTDOWN,
    /** @brief Host removes a destination which is used by the advanced routing filters. Stored data of this destination will be lost. */
    LLCE_CAN_CMD_REMOVE_AF_DESTINATION
} Llce_Can_CommandIdType;

/**
 * @brief CAN frame ID type.
 *
 * Specifies the CAN frame ID type based on it's length as it is
 * defined by the CAN specification.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Extended ID (29 bits) */
    LLCE_CAN_EXTENDED = 0U,
    /** @brief Standard ID (11 bits) */
    LLCE_CAN_STANDARD,
    /** @brief Mixed ID (29 bits) */
    LLCE_CAN_MIXED
} Llce_Can_IdLengthType;

/**
 * @brief Requested transitions of a CAN controller.
 *
 * These controller state transitions are requested by the host in a specific
 * order.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Request transition from START state into STOP state. */
    LLCE_CAN_T_STOP = 0U,
    /** @brief Request transition from STOP state into START state. */
    LLCE_CAN_T_START,
} Llce_Can_StateTransitionType;

/**
 * @brief CAN controller states.
 *
 * CAN controller states as they are reported by the LLCE firmware as a result
 * of state transition requests.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Controller is uninitialised (default) */
    LLCE_CAN_UNINIT_CTRL = 0U,
    /**
     * @brief Controller is in a pending state of unitialization, waiting
     * for the resources to be restored (e.g Rx tokens)
     */
    LLCE_CAN_UNINIT_CTRL_PENDING,
    /** @brief Controller is stopping, but not offline yet */
    LLCE_CAN_STOP_PENDING,
    /**
     * @brief Controller is in the BUSOFF_PENDING state which means that it
     * does not do any bus transactions.
     */
    LLCE_CAN_BUSOFF_PENDING,
    /**
     * @brief Controller is in the STOPPED state which means that it does
     * not do any bus transactions.
     */
    LLCE_CAN_STOPPED,
    /** @brief Controller is starting, but cannot do bus transactions yet.*/
    LLCE_CAN_START_PENDING,
    /**
     * @brief Controller is in the STARTED state which means that it do bus
     * transactions.
     */
    LLCE_CAN_STARTED,
    /**
     * @brief Controller is in the IDLE state. This state is not used
     * by LLCE module.
     */
    LLCE_CAN_IDLE,
    /**
     * @brief Controller is in state when the common components of the
     * platform are not initialized.
     */
    LLCE_CAN_UNINIT_PLATFORM
} Llce_Can_CtrlStateType;

/**
 * @brief CAN firmware components IDs.
 *
 * CAN firmware components IDs used to identify the component which generated a
 * specific error.
 **/
typedef enum LLCE__PACKED
{
    /** @brief CAN TX firmware component. */
    LLCE_TX = 101U,
    /** @brief CAN RX firmware component. */
    LLCE_RX,
    /** @brief CAN DTE firmware component. */
    LLCE_DTE,
    /** @brief CAN FRPE firmware component. */
    LLCE_FRPE,
    /** @brief CAN2CAN TX firmware component. */
    LLCE_CAN2CAN_TX,
    /** @brief CAN2CAN RX firmware component. */
    LLCE_CAN2CAN_RX,
    /** @brief CAN2CAN FRPE firmware component. */
    LLCE_CAN2CAN_FRPE,
    /** @brief AF ETH2CAN TX firmware component. */
    LLCE_AF_ETH_TX,
    /** @brief AF CAN2ETH RX firmware component. */
    LLCE_AF_ETH_RX,
    /** @brief AF CAN2ETH or ETH2CAN FRPE firmware component. */
    LLCE_AF_ETH_FRPE,
    /** @brief HSE TX firmware component. */
    LLCE_AF_HSE_TX,
    /** @brief HSE RX firmware component. */
    LLCE_AF_HSE_RX,
    /** @brief HSE FRPE firmware component. */
    LLCE_AF_HSE_FRPE,
    /** @brief AF TX  firmware component. */
    LLCE_AF_TX,
    /** @brief AF RX  firmware component. */
    LLCE_AF_RX,
    /** @brief AF FRPE firmware component. */
    LLCE_AF_FRPE
} Llce_Can_ModuleType;

/**
 * @brief CAN Logging options.
 *
 * CAN options for logging frames feature.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Logging of CAN frame is disabled.*/
    LLCE_AF_LOGGING_DISABLED = 1U,
    /** @brief Logging of CAN frame is enabled.*/
    LLCE_AF_LOGGING_ENABLED
} Llce_Af_LoggingOptionsType;

typedef enum LLCE__PACKED
{
    /** @brief Reception of the CAN frame by the host is disabled.*/
    LLCE_AF_HOSTRECEIVE_DISABLED = 1U,
    /** @brief Reception of the CAN frame by the host is enabled.*/
    LLCE_AF_HOSTRECEIVE_ENABLED
} Llce_Can_HostReceiveOptionsType;

typedef enum LLCE__PACKED
{
    /** @brief Authentication of CAN frame is disabled.*/
    LLCE_AF_AUTHENTICATION_DISABLED = 1U,
    /** @brief Authentication of CAN frame is enabled.*/
    LLCE_AF_AUTHENTICATION_ENABLED,
    LLCE_AF_AUTHENTICATION_NOT_SUPPORTED
} Llce_Af_AuthenticationOptionsType;

typedef enum LLCE__PACKED
{
    /** @brief Custom processing of CAN frame is disabled.*/
    LLCE_AF_CUSTOMPROCESSING_DISABLED = 1U,
    /** @brief Custom processing of CAN frame is enabled.*/
    LLCE_AF_CUSTOMPROCESSING_ENABLED,
} Llce_Af_CustomProcessingOptionsType;

/**
 * @brief RXLUT entries type
 *
 * Specifies the type of entry in the table.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Exact match entry type. */
    LLCE_CAN_ENTRY_EXACT_MATCH = 0U,
    /** @brief Masked match entry type. */
    LLCE_CAN_ENTRY_CFG_MASKED,
    /** @brief Range match entry type. */
    LLCE_CAN_ENTRY_CFG_RANGED,
} Llce_Can_EntryType;

/**
 * @brief Type of Advanced Feature(AF) rule.
 *
 * Specifies the type of entry in the destination rule table.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Destination rule type used for Can2Can use case. */
    CAN_AF_CAN2CAN = 0U,
    /** @brief Destination rule type used for Can2Eth use case. */
    CAN_AF_CAN2ETH,
    /** @brief Destination rule type used for Can2Pcie use case. */
    CAN_AF_CAN2PCIE,
    /** @brief Destination rule type used for Can2Hse use case. */
    CAN_AF_CAN2HSE
} Llce_Af_RuleIdType;

/**
 * @brief Type of Can2Eth routing
 *
 * Speccifies the type of packing to apply for Can2Eth
 **/
typedef enum LLCE__PACKED
{
    /** @brief IEEE1722-2016 AVPT non-time-synchronous CAN brief format */
    LLCE_AF_CAN2AVTP_NTSCF_BRIEF = 0U,
    /** @brief IEEE1722-2016 AVPT non-time-synchronous CAN regular format */
    LLCE_AF_CAN2AVTP_NTSCF_FULL,
    /** @brief IEEE1722-2016 AVPT time-synchronous CAN brief format */
    LLCE_AF_CAN2AVTP_TSCF_BRIEF,
    /** @brief IEEE1722-2016 AVPT time-synchronous CAN regular format */
    LLCE_AF_CAN2AVTP_TSCF_FULL,
    /** @brief UDP format */
    LLCE_AF_CAN2UDP,
    /** @brief UDP format, type B */
    LLCE_AF_CAN2UDP_B,
    /** @brief Placeholder for maximum value */
    LLCE_AF_CAN2ETH_FORMAT_MAX

} Llce_Can_EthEncapsulationFormat;
/**
 * @brief Initialization status of the controllers.
 *
 * Initialization status of the controllers.
 * See \link Llce_Can_InitPlatformCmdType \endlink.
 **/
typedef enum LLCE__PACKED
{
    /** @brief Entity is initialised */
    INITIALIZED = 1U,
    /** @brief Entity is uninitialised (default) */
    UNINITIALIZED = 2U
} Llce_Can_StatusType;

/**
 * @brief Processing type of a specific error
 *
 * Processing type of a specific error.
 * See \link Llce_Can_InitPlatformCmdType \endlink.
 **/
typedef enum LLCE__PACKED
{
    /** @brief LLCE Firmware does not report the error */
    IGNORE = 1U,
    /**
     * @brief LLCE Firmware reports the error through the notification table
     * corresponding to processing type configured by host
     */
    NOTIF_FIFO0,
    /**
     * @brief LLCE Firmware reports the error through the notification table
     * corresponding to processing type configured by host
     */
    NOTIF_FIFO1,
} Llce_Can_ErrorProcessingType;

/**
 * @brief AbortMB Type
 *
 * Specifies the type of AbortMB command. It can be either Single MB
 * abort or All MBs abort
 **/
typedef enum LLCE__PACKED
{
    /** @brief Request aborting of a single MB with a specific MB tag. */
    ABORT_ONLY_ONE_MB = 0U,
    /** @brief Request aborting of all the MBs with a specific MB tag. */
    ABORT_ALL_MB
} Llce_Can_AbortMbType;

/** @brief    MB length accepted by a filter
 *  @details  MB length (8/64 bytes) configured to be accepted by a filter.
 *            No mixed mode available. 
 *
 **/  
typedef enum LLCE__PACKED
{
    /** @brief Opt for 64 bytes MB size accepted by a filter */
    USE_LONG_MB = 0U,
    /** @brief Opt for 8 bytes MB size accepted by a filter */
    USE_SHORT_MB,
} Llce_CanRx_MbLengthType;

/**
 * @brief Generic binary type
 *
 * Logical binary type. Redefined for consistency.
 **/
typedef enum LLCE__PACKED
{
    LLCE_FALSE = 0,
    LLCE_TRUE
} Llce_Can_BinaryValueType;


/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*
 * These structure must be kept as they are because BCAN is
 * sending data in this format !
 */
/**
 * @brief CAN message buffer.
 *
 * CAN message buffer is a memory area placed in the shared memory
 * which is used by the LLCE firmware to receive/transmit from/to BCAN
 * controller. LLCE firmware transmit/receive the frame in a word by word way so
 * the content of the 4 structure fields contains the frame fields as they are
 * described in the picture from below. For the reception process the LLCE
 * firmware store inside message buffer frame the time stamp read from the
 * hardware CAN controller.
 *
 * \image latex rx_mb.JPG "LLCE message buffer structure." width=17cm
 *
 * @pre Before to use any message buffer it is needed to initialize, configure
 * and start a CAN controller
 **/
typedef struct
{
    /**
     * @brief INPUT/OUTPUT: The first word of a frame as it is
     * expected/provided by the CAN controller.
     */
    uint32 u32Word0;
    /**
     * @brief INPUT/OUTPUT: The second word of a frame as it is
     * expected/provided by the CAN controller.
     */
    uint32 u32Word1;
    /**
     * @brief INPUT/OUTPUT: Frame payload needed for the maximum
     * payload size case.
     */
    uint8 u8Payload[LLCE_CAN_CONFIG_PAYLOAD_MAX_SIZE];
    /**
     * @brief INPUT: Time stamp of the received frames.It is not used
     * for the transmitted frames.
     */
    uint32 u32Timestamp;


} LLCE__ALIGNED__PACKED Llce_Can_MbType;

typedef struct
{
    /**
     * @brief INPUT/OUTPUT: The first word of a frame as it is
     * expected/provided by the CAN controller.
     */
    uint32 u32Word0;
    /**
     * @brief INPUT/OUTPUT: The second word of a frame as it is
     * expected/provided by the CAN controller.
     */
    uint32 u32Word1;
    /**
     * @brief INPUT/OUTPUT: Frame payload needed for the short
     * payload size case.
     */
    uint8 u8Payload[LLCE_CAN_CONFIG_SHORT_PAYLOAD_MAX_SIZE];
    /**
     * @brief INPUT: Time stamp of the received frames.It is not used
     * for the transmitted frames.
     */
    uint32 u32Timestamp;

} LLCE__ALIGNED__PACKED Llce_Can_ShortMbType;


/**
 * @brief Reception message buffer descriptor.
 *
 * Reception message buffer descriptor is a memory area placed in the shared
 * memory which is written by the LLCE firmware with the specific runtime info
 * needed by the host software.(e.g.matching filter ID ). Also it includes an
 * index to a CAN message buffer allocated during initialization to each
 * descriptor. After reception, the host shall copy the content of the reception
 * message buffer descriptor and the referred message buffer by this descriptor
 * from the shared memory into the host memory in order to be processed later by
 * the host software and to allow the current message buffer descriptor to be
 * used by LLCE firmware for the reception of a new frame.
 *
 * @pre Before to use any receive message buffer descriptor it is needed to
 * initialize, configure and start a CAN controller
 **/
typedef struct
{
    /**
     * @brief OUTPUT: Filter identifier resulted at the end of filtering
     * process.
     *
     * This field is completed by the LLCE filtering mechanism with a value
     * which was configured during initialization time.
     * It is used in order to map a received frame to a specific filter
     * defined by the host.
     */
    uint16 u16FilterId;
    /**
     * @brief OUTPUT: Result of RxLut2 filtering.
     * See \link Llce_Can_MbType \endlink
     */
    uint16 u16AuxSearchResult;
} LLCE__ALIGNED__PACKED Llce_Can_RxMbDescriptorType;

/**
 * @brief Transmission message buffer descriptor.
 *
 * Transmission message buffer descriptor is a memory area placed in the shared
 * memory which is written by the host software with other additional info
 * (e.g. frame tag IDs) which is sent back to the host by the LLCE firmware as
 * acknowledge information. Those internal tags are not changed/used by the
 * LLCE firmware.
 *
 * @pre Before to use any transmission message buffer descriptor it is needed
 * to initialize, configure and start a CAN controller
 **/
typedef struct
{
    /**
     * @brief INPUT: Host defined tag used to track a specific frame.
     *
     * This field is not changed by the LLCE firmware and is returned
     * back to the host as it is.
     * See \link Llce_Can_Tx2HostAckInfoType \endlink
     */
    uint16 u16FrameTag1;
    /**
     * @brief INPUT: Host defined tag used to track a specific frame.
     *
     * This field is not changed by the LLCE firmware and is returned back
     * to the host as it is.
     * See \link Llce_Can_Tx2HostAckInfoType \endlink
     */
    uint16 u16FrameTag2;
    /**
     * @brief OUTPUT: Index to the frame message buffer.
     * See \link Llce_Can_MbType \endlink
     */
    uint16 u16MbFrameIdx;
    /**
     * @brief INPUT: Host defined interface used to select the acknowledge
     * interface of a specific frame.
     *
     * This field is not changed by the LLCE firmware.
     */
    uint8 u8AckInterface;
    /**
     * @brief INPUT: Request firmware to add MAC code to the transmitted
     * frame payload.
     */
    uint8 u8EnableTxFrameMac;
} LLCE__ALIGNED__PACKED Llce_Can_TxMbDescriptorType;

/**
 * @brief Acknowledge transmission information send from LLCE to host.
 *
 * It is used in order to send from LLCE to host needed information in order to
 * identify and confirm that a specific frame was transmitted on the CAN bus.
 * This data structure type is used in order to implement a circular buffer for
 * each channel which is accessed by using indexes transferred from LLCE to host
 * by using TXACK FIFOs.
 * This approach allows usage of existing hardware FIFOs even the size of the
 * transferred data is higher than the FIFO element width size.
 *
 * @pre Before to read any acknowledge information, it is needed to do a
 * transmission request.
 **/
typedef struct
{
    /** @brief OUTPUT: Transmission time stamp.*/
    uint32 u32TxTimestamp;
    /**
     * @brief OUTPUT: Host defined tag used to track a specific frame.
     * This field is not changed by the LLCE firmware and is returned back
     * to the host as it is.
     * See \link Llce_Can_TxMbDescriptorType \endlink
     */
    uint16 u16FrameTag1;
    /**
     * @brief OUTPUT: Host defined tag used to track a specific frame.
     * This field is not changed by the LLCE firmware and is returned back
     * to the host as it is.
     * See \link Llce_Can_TxMbDescriptorType \endlink
     */
    uint16 u16FrameTag2;
} LLCE__ALIGNED__PACKED Llce_Can_Tx2HostAckInfoType;

/**
 * @brief Command for polling of controller state .
 * @details  It is sent from host to LLCE to query it for the controller state.
 *
 **/
typedef struct
{
    /** @brief OUTPUT: Current state of the CAN controller. */
    Llce_Can_CtrlStateType eControllerState;
} LLCE__ALIGNED__PACKED  Llce_Can_GetControllerModeCmdType;

/**
 * @brief Set controller mode command.
 *
 * It is sent from host to LLCE module in order request changing the state of a
 * CAN controller. Currently it allows only to start and stop a controller.
 * When a controller is started it allows to transmit and receive frames from
 * the bus. When the controller is stopped it ignores all frames from the bus
 * and it doesn't transmit any frame.
 *
 * @pre Before changing the controller state it must be initialized.
 **/
typedef struct
{
    /** @brief INPUT: The new state which is requested. */
    Llce_Can_StateTransitionType eTransition;
} LLCE__ALIGNED__PACKED Llce_Can_SetControllerModeCmdType;

/**
 * @brief Data baud rate settings for a CAN FD controller.
 *
 * It is used to configure the CAN FD settings including baud rate used during
 * data phase.
 **/
typedef struct
{
    /**
     * @brief INPUT: Configuration of data phase baud rate:
     * - Prescaler divisor: (bit 23-27)
     * - Resynchronization Jump Width: (bit 16-19)
     * - Time Segment 2: (bit 9-12)
     * - Time Segment 1: (bit 0-4)
     *
     * Each parameter value shall be decreased by 1 when it is written into
     * this data structure field.
     */
    uint32 u32DataBaudrateConfig;
    /**
     * @brief INPUT: Enable or disable FD related features of the CAN
     * controller.
     */
    uint8 u8FdEnable;
    /**
     * @brief INPUT: Enable or disable baud rate switch (BRS) at the level
     * of CAN controller.
     */
    uint8 u8ControllerTxBitRateSwitch;
    /**
     * @brief INPUT: Enable or disable Transceiver Delay Compensation:
     * - TRUE: enabled
     * - FALSE: disabled.
     */
    uint8 u8TrcvDelayCompEnable;
    /**
     * @brief INPUT: Enable or disable Transceiver Delay Measurement:
     * - TRUE: enabled
     * - FALSE: disabled.
     *
     * When it is enabled, the secondary sample point is determined by the
     * sum of the transceiver delay measurement plus transceiver delay
     * compensation offset. When it is disabled, the secondary sample point
     * is determined only by the transceiver delay compensation offset.
     */
    uint8 u8TrcvDelayMeasEnable;
    /** @brief INPUT: Value of Transceiver Delay Compensation Offset*/
    uint8 u8TrcvDelayCompOffset;
} LLCE__ALIGNED__PACKED Llce_Can_ControllerFdConfigType;

/**
 * @brief Set baud rate command.
 *
 * It is sent from host to LLCE module in order to configure baud rate
 * parameters for arbitration phase.
 **/
typedef struct
{
    /**
     * @brief INPUT: Configuration parameters for nominal baud rate:
     * - Prescaler divisor: (bit 23-31)
     * - Resynchronization Jump Width (bit 16-22)
     * - Time Segment 2 (bit 9-15)
     * - Time Segment 1 (bit 0-7)
     *
     * Each parameter value shall be decreased by 1 when it is written into
     * this data structure field.
     */
    uint32 u32NominalBaudrateConfig;
    /**
     * @brief INPUT: Configuration parameters for data baud rate of the
     * CAN controller.
     */
    Llce_Can_ControllerFdConfigType ControllerFD;
} LLCE__ALIGNED__PACKED Llce_Can_SetBaudrateCmdType;

/**
 * @brief Filter element settings.
 *
 * It is used to define a specific filter.Current filtering process suppose to
 * accept a frame if it's frame ID match the filter ID masked with the mask
 * value. At the end of filtering process an internal filter ID is mapped to
 * the accepted frame in order to track it later by the host software.
 * A maximum number of frames accepted by a specific filter can be managed
 * by LLCE at each point in time.
 **/
typedef struct
{
    /**
     * @brief INPUT:
     * - For MASK filters: Frame id mask value. Bit fields containing
     * \b 0 means don't care.
     * - For RANGE filters: Maximum accepted id value.
     * - For EXACT MATCH: not used.
     *
     * Set LLCE_CAN_MB_IDE_U32 to match only standard/extended, unset for mixed
     */
    uint32 uIdMask;
    /**
     * @brief INPUT:
     * - For MASK filters: CAN frame ID value.
     * - For RANGE filters: Minimum accepted id value.
     * - For EXACT MATCH: id value
     *
     * Bit LLCE_CAN_MB_IDE_U32 controls extended/standard if enabled in mask.
     */
    uint32 uMessageId;
    /**
     * @brief INPUT: Filter identifier used to track frames after filtering
     * process on the reception side.
     * See also \link Llce_Can_RxMbDescriptorType \endlink
     */
    uint16 u16FilterId;
    /**
     * @brief INPUT: Maximum number of message buffers which can be used to
     * store frames accepted by this filter at each specific point in time.
     * When the maximum value is reached the firmware will begin to drop the
     * received frames accepted by that filter.It is used also in order to
     * prevent that the frames accepted by a specific filter do not overload
     * the LLCE internal hardware resources (e.g. message buffers, FIFOs).
     */
    uint16 u16MbCount;
    /**
     * @brief OUTPUT: Filter address inside hardware filtering accelerator
     * where the filter fields are stored.
     *
     * Host side application can use this to track used filter entries.
     * The search operation start from low filter addresses and continue to
     * the high filter addresses.
     */
    uint16 u16FilterAddr;
    /**
     * @brief INPUT: Reception interface id used to deliver frames accepted
     * by that filter to the host.
     */
    uint8 u8RxDestInterface;
    /** @brief INPUT: Filter entry type: mask, range, exact match */
    Llce_Can_EntryType eEntryType;
    /** @brief INPUT: Message buffer payload length: 8 or 64 bytes */
    Llce_CanRx_MbLengthType eFilterMbLength;

} LLCE__ALIGNED__PACKED Llce_Can_ReceiveFilterType;

/**
 * @brief Filter element settings for RxLut2.
 *
 * It is used to define a specific filter.Current filtering process supposes to
 * accept a frame if its frame ID matches the filter ID masked with the mask
 * value. At the end of the filtering process, an internal filter ID is mapped to
 * the accepted frame in order to track it later by the host software.
 * A maximum number of frames accepted by a specific filter can be managed
 * by LLCE at each point in time.
 **/
typedef struct
{
    /**
     * @brief INPUT:
     * - For MASK filters: Frame id mask value. Bit fields containing
     * \b 0 means don't care.
     * - For RANGE filters: Maximum accepted id value.
     * - For EXACT MATCH: not used.
     *
     * Set LLCE_CAN_MB_IDE_U32 to match only standard/extended, unset for mixed
     */
    uint32 uIdMask;
    /**
     * @brief INPUT:
     * - For MASK filters: CAN frame ID value.
     * - For RANGE filters: Minimum accepted id value.
     * - For EXACT MATCH: id value
     *
     * Bit LLCE_CAN_MB_IDE_U32 controls extended/standard if enabled in mask.
     */
    uint32 uMessageId;
    /**
     * @brief INPUT: Custom value configured by the user.
     */
    uint16 u16AuxSearchResult;
    /** @brief INPUT: Filter entry type: mask, range, exact match */
    Llce_Can_EntryType eEntryType;
} LLCE__ALIGNED__PACKED Llce_Can_AuxFilterType;

/**
 * @brief Set filter command.
 *
 * It is sent by the host to LLCE in order to configure one or more reception
 * filters inside LLCE.
 **/
typedef struct
{
    /**
     * @brief INPUT: Array containing configuration for reception
     * filters.
     */
    Llce_Can_ReceiveFilterType aRxFilters[LLCE_CAN_CONFIG_MAX_FILTERS_COUNT];
    /** @brief INPUT: Number of configured filters. */
    uint16 u16RxFiltersCount;
} LLCE__ALIGNED__PACKED Llce_Can_SetFilterCmdType;

/**
 * @brief Set filter command.
 *
 * It is sent by the host to LLCE in order to configure one or more auxiliary reception
 * filters inside LLCE.
 **/
typedef struct
{
    /**
     * @brief INPUT: Array containing configuration for reception
     * filters.
     */
    Llce_Can_AuxFilterType aRxAuxFilters[LLCE_CAN_CONFIG_MAX_FILTERS_COUNT];
    /** @brief INPUT: Number of configured filters. */
    uint16 u16RxAuxFiltersCount;
} LLCE__ALIGNED__PACKED Llce_Can_SetAuxFilterCmdType;

/**
 * @brief CAN to CAN routing filter configuration.
 *
 * It is used to define a specific routing filter. Current routing
 * implementation suppose to accept a received frame for a specific
 * ID and ID mask combination, then route that frame to one or more transmission
 * channels.
 **/
typedef struct
{
    /** @brief INPUT: Special options for advanced routing. See
    \link LLCE_CAN_ROUTING_OPTION_DEFAULT_CONFIG \endlink
    \link LLCE_CAN_ROUTING_NOCHANGE \endlink
    \link LLCE_CAN_ROUTING_CAN \endlink
    \link LLCE_CAN_ROUTING_CANFD \endlink
    \link LLCE_CAN_ROUTING_ID_REMAPPING_EN \endlink*/
    uint32 u32Can2CanRoutingOptions;
    /** @brief INPUT: Can Id Remap Value.
     * Copied into u32Word0 of outgoing frame, except RTR flag. See \link Llce_Can_MbType \endlink.
     */
    uint32 u32CanIdRemapValue;
    /**
     * @brief INPUT: List of destination CAN controllers for the
     * accepted frame.
     */
    uint8 u8DestHwChList[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
    /** @brief INPUT: Length of the destination CAN controller list.*/
    uint8 u8DestHwChListCount;
} LLCE__ALIGNED__PACKED Llce_Can_Can2CanRoutingTableType;

/**
 * @brief Data structure type containing CAN to Ethernet destination rule
 * configuration.
 *
 * It is used to define a specific destination rule for Can2Eth internal
 * routing.
 **/
typedef struct
{
    /** @brief   INPUT: Base address of the buffer area for this destination */
    uint32 pu8Can2EthBuffAddr;
    /** @brief   INPUT: Size of each buffer for this destination */
    uint16 u16Can2EthBuffSize;
    /** @brief   INPUT: Number of buffers of size u16Can2EthBuffSize for this destination */
    uint8  u8Can2EthBuffCount;
    /** @brief   INPUT: Type of encapsulation */
    Llce_Can_EthEncapsulationFormat eFormat;
    /** @brief INPUT: Ethernet MAC destination address */
    uint8 u8Can2EthDestMac[6];
    /** @brief INPUT: Ethernet MAC source address */
    uint8 u8Can2EthSrcMac[6];
    /** @brief INPUT: Destination IP address (UDP only) */
    uint8 u8Can2EthDstIp[4];
    /** @brief INPUT: Source IP address (UDP only) */
    uint8 u8Can2EthSrcIp[4];
    /** @brief INPUT: Destination port (UDP only) */
    uint16 u8Can2EthDstPort;
    /** @brief INPUT: Source port (UDP only) */
    uint16 u8Can2EthSrcPort;
    /** @brief INPUT: Ethernet physical interface (bit list) - see LLCE_CAN2ETH_PFE_* */
    uint16 u16Can2EthPhyIfList;
} LLCE__ALIGNED__PACKED Llce_Can_Can2EthRoutingTableType;

/**
 * @brief Data structure type containing CAN to PCIe destination rule
 * configuration.
 *
 * It is used to define a specific destination rule for Can2Pcie routing.
 **/
typedef struct
{
    /** @brief   INPUT: Base address of the buffer area on the RC side*/
    uint64 u64Can2PcieRcBuffAddr;
    /** @brief   INPUT: Base address of the local buffer area for this destination */
    uint32 pu8Can2PcieBuffAddr;
    /** @brief   INPUT: Size of each buffer for this destination */
    uint16 u16Can2PcieBuffSize;
    /** @brief   INPUT: Number of buffers of size u16Can2PcieBuffSize for this destination */
    uint8  u8Can2PcieBuffCount;
    /** @brief   INPUT: PCIe controller used */
    uint8  u8Can2PcieController;
    /** @brief   INPUT: PCIe DMA channel used */
    uint8  u8Can2PcieDmaChannel;
    /** @brief   INPUT: MSI to trigger on transmission; 0xFF to disable */
    uint8  u8Can2PcieMsiId;
} LLCE__ALIGNED__PACKED Llce_Can_Can2PcieRoutingTableType;

/**
 * @brief Data structure type containing CAN to HSE destination rule
 * configuration.
 *
 * It is used to define a specific destination rule for Can2Hse routing.
 **/
typedef struct 
{
    /** @brief   INPUT: Key handle required to compute key on HSE side */
    uint32 u32Can2HseKeyHandle;
}LLCE__ALIGNED__PACKED Llce_Can_Can2HseRoutingTableType;


/**
 * @brief Data structure type representing  destination rule used by Advanced
 * Features(AF)
 *
 * Used to hold a generic type of AF destination rule
 **/
typedef struct
{
    /** @brief Destination rule content.*/
    union {
        /**
         * @brief INPUT: Destination rule for Can2Can internal routing
         * use case.
         */
        Llce_Can_Can2CanRoutingTableType Can2Can;
        /** @brief INPUT: Destination rule for Can2Eth use case.*/
        Llce_Can_Can2EthRoutingTableType Can2Eth;
        /** @brief INPUT: Destination rule for Can2Pcie use case.*/
        Llce_Can_Can2PcieRoutingTableType Can2Pcie;
        /** @brief INPUT: Destination rule for Can2Hse use case.*/
        Llce_Can_Can2HseRoutingTableType Can2Hse;
    } AfDest;
    /** @brief INPUT: Destination rule type.*/
    Llce_Af_RuleIdType eAfDestId;
} LLCE__ALIGNED__PACKED Can_Af_DestRulesType;

/**
 * @brief Advanced filter configuration.
 *
 * It is used to define an advanced filter. It contains references to the
 * individual features configured by the host.
 **/
typedef struct
{
    /** @brief INPUT: Option for frame authentication feature. */
    Llce_Af_AuthenticationOptionsType eCanAuthenticationFeature;
    /** @brief INPUT: Option for host receive feature. */
    Llce_Can_HostReceiveOptionsType eHostReceive;
    /** @brief INPUT: Option for logging feature. */
    Llce_Af_LoggingOptionsType eCanLoggingFeature;
    /** @brief INPUT: Option for custom processing. */
    Llce_Af_CustomProcessingOptionsType eCanCustomProcessing;
    /**
     * @brief INPUT: CAN2CAN routing table index.
     * Reference to the routing table rule.
     * See \link Llce_Can_Can2CanRoutingTableType \endlink
     */
    uint8 u8Can2CanRoutingTableIdx;
    /**
     * @brief INPUT: CAN2ETH routing table index.
     * Reference to the routing table rule.
     * See \link Llce_Can_Can2EthRoutingTableType \endlink
     */
    uint8 u8Can2EthRoutingTableIdx;
    /**
     * @brief INPUT: Other destination routing table index.
     * Reference to a routing table rule.
     */
    uint8 u8OtherRoutingTableIdx;
} LLCE__ALIGNED__PACKED Llce_Can_AdvancedFeatureType;

/**
 * @brief Advanced filter element configuration.
 *
 * It is used to define a specific filter. Current filtering suppose to accept
 * a frame for processing if it's frame ID match the filter ID masked with the
 * mask value. At the end of filtering process the frame is processed according
 * to the advanced configuration of the filter.
 **/
typedef struct
{
    /** @brief INPUT: Standard filter configuration. */
    Llce_Can_ReceiveFilterType Llce_Can_RxFilter;
    /** @brief INPUT: Can advanced features used by the filter. */
    Llce_Can_AdvancedFeatureType Llce_Can_AdvancedFeature;
} LLCE__ALIGNED__PACKED Llce_Can_AdvancedFilterType;

/**
 * @brief Set advanced filter command.
 *
 * It is sent by the host to LLCE in order to set one or more advanced filters.
 **/
typedef struct
{
    /**
     * @brief INPUT: Array containing configuration for one or
     * more filters.
     */
    Llce_Can_AdvancedFilterType aAdvancedFilters[LLCE_CAN_CONFIG_ADVANCED_FILTERS_COUNT];
    /** @brief INPUT: Number of configured filters. */
    uint16 u16RxFiltersCount;
} LLCE__ALIGNED__PACKED Llce_Can_SetAdvancedFilterCmdType;

/**
 * @brief Configurable errors that LLCE Firmware handles.
 *
 * Configurable errors that LLCE Firmware handles using different types of
 * processing.It is part of platform initialization command.
 * Only BusOff processing type is selectable per channel.
 **/
typedef struct
{
    /** @brief CAN Protocol errors supported by CAN controller. */
    Llce_Can_ErrorProcessingType eCanProtocolErr;
    /** @brief DATALOST event as described by Autosar standard */
    Llce_Can_ErrorProcessingType eDataLostErr;
    /**
     * @brief Initialization errors, like resources overflow, bad commands
     * flow, bad command parameters, invalid indexes or any other errors
     * caused by bad usage or a malicious host.
     */
    Llce_Can_ErrorProcessingType eInitErr;
    /** @brief Internal errors, like timeouts. */
    Llce_Can_ErrorProcessingType eInternalErr;
    /** @brief BusOff processing is selectable per channel */
    Llce_Can_ErrorProcessingType eBusOffErr[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
    /** @brief Passive state + TX/RX WRN. */
    Llce_Can_ErrorProcessingType eCanProtocolWarn;
} LLCE__ALIGNED__PACKED Llce_Can_ErrorCategoryType;

/**
 * @brief Platform initialization command.
 *
 * It is sent by the host to LLCE in order to configure the platform related
 * parameters. It is the first command which shall be send to LLCE module after
 * booting in order to configure common LLCE components.
 * Most important operations done by LLCE firmware at platform initialization
 * are:
 * - initializes all common internal LLCE components (hardware and software).
 * - prepare filter management data structures
 **/
typedef struct
{
    /**
     * @brief INPUT: Array containing the initialization status of the
     * controllers
     */
    Llce_Can_StatusType eCtrlInitStatus[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
    /**
     * @brief INPUT: Array containing maximum number of regular filters per
     * channel.
     * See \link LLCE_CAN_CONTROLLERCONFIG_CTRL_EN_U32 \endlink as a
     * controller option example
     */
    uint16 au16MaxRegularFilterCount[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
    /**
     * @brief INPUT: Array containing maximum number of advanced filters
     * per channel.
     * See \link LLCE_CAN_CONTROLLERCONFIG_CTRL_EN_U32 \endlink as a
     * controller option example
     */
    uint16 au16MaxAdvancedFilterCount[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
    /**
     * @brief INPUT: Array containing maximum number of RX message buffers
     * per output interface, considering interrupt processing.
     */
    uint16 au16MaxIntMbCount[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
    /**
     * @brief INPUT: Array containing maximum number of RX message buffers
     * per polling class, considering polling processing.
     * There are a number of \link LLCE_CAN_MAX_POLLING_CLASSES \endlink
     * provided.
     */
    uint16 au16MaxPollMbCount[LLCE_CAN_MAX_POLLING_CLASSES];
    /**
     * @brief INPUT: Array containing maximum number of reserved TX confirmation
     * buffers per output interface, considering interrupt processing.
     */
    uint16 au16MaxIntTxAckCount[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
    /**
     * @brief INPUT: Array containing maximum number of reserved TX
     * confirmation buffers per polling class, considering polling
     * processing.
     * There are a number of \link LLCE_CAN_MAX_POLLING_CLASSES \endlink
     * provided.
     */
    uint16 au16MaxPollTxAckCount[LLCE_CAN_MAX_POLLING_CLASSES];
    /**
     * @brief INPUT: Structure describing the way of processing each errors
     * category. This can be: INTERRUPT, POLLING or IGNORE.
     */
    Llce_Can_ErrorCategoryType CanErrorReporting;
} LLCE__ALIGNED__PACKED Llce_Can_InitPlatformCmdType;

/**
 * @brief Initialization command.
 *
 * It is sent by the host to LLCE in order to load and configure all needed
 * parameters inside LLCE. 
 * Most important operations done by LLCE firmware at initialization are:
 * - when this command is executed for the first CAN channel it initialize also
 * all internal LLCE components.
 * - configure the hardware features of a CAN controller.
 * - set a CAN controller in the stop state.
 **/
typedef struct
{
    /**
     * @brief INPUT: Configuration options for a hardware CAN controller.
     * See \link LLCE_CAN_CONTROLLERCONFIG_CTRL_EN_U32 \endlink as a
     * controller  option example
     */
    uint32 u32CtrlConfig;
    /**
     * @brief INPUT: Number of transmission message buffer descriptors used
     * for transmissions initialized by the host.The remaining elements are
     * used for internal routing scenarios.
     */
    uint8 u8TxMbCount;
} LLCE__ALIGNED__PACKED Llce_Can_InitCmdType;

/**
 * @brief LLCE-PFE Initialization command.
 *
 * It is sent by the host to LLCE in order to activate the LLCE-PFE interface,
 * and obtain the addresses of the relevant data structures.
 * @note Use uint32 instead of void*, for portability
 **/
typedef struct
{
    /** @brief OUTPUT: Address of the PFE RX Ring in LLCE memory */
    uint32 pRxRing;
    /** @brief OUTPUT: Address of the PFE RX Writeback Ring in LLCE memory */
    uint32 pRxWbRing;
    /** @brief OUTPUT: Address of the PFE TX Ring in LLCE memory */
    uint32 pTxRing;
    /** @brief OUTPUT: Address of the PFE TX Writeback Ring in LLCE memory */
    uint32 pTxWbRing;
     /** @brief INPUT: Pointer to the buffers used for RX */
    uint32 pRxBuffers;
    /** @brief INPUT: Size of the buffers used for RX */
    uint16 u16RxBufSize;
    /** @brief INPUT: Number of buffers used for RX */
    uint8 u8RxBufCount;
    /** @brief INPUT: Index of the PFE HIF to use in LLCE */
    uint8 u8Hif;
} LLCE__ALIGNED__PACKED Llce_Can_InitPfeCmdType;

/**
 * @brief LLCE-PFE Configurable Ring Initialization command.
 *
 * It is sent by the host to LLCE in order to activate the LLCE-PFE interface,
 * use the addresses of the relevant data structures provided by the host.
 * @note Use uint32 instead of void*, for portability
 **/
typedef struct
{
    /** @brief INPUT: Address of the PFE RX Ring in LLCE memory */
    uint32 pRxRing;
    /** @brief INPUT: Address of the PFE RX Writeback Ring in LLCE memory */
    uint32 pRxWbRing;
    /** @brief INPUT: Address of the PFE TX Ring in LLCE memory */
    uint32 pTxRing;
    /** @brief INPUT: Address of the PFE TX Writeback Ring in LLCE memory */
    uint32 pTxWbRing;
     /** @brief INPUT: Pointer to the buffers used for RX */
    uint32 pRxBuffers;
    /** @brief INPUT: Ring size of the PFE Rx Ring */
    uint32 u32RingSize;
    /** @brief INPUT: Pointer to the header */
    uint32 pHeader;
    /** @brief INPUT: Size of the buffers used for RX */
    uint16 u16RxBufSize;
    /** @brief INPUT: Number of buffers used for RX */
    uint8 u8RxBufCount;
    /** @brief INPUT: Size of the header */
    uint8 u8HeaderSize;
    /** @brief INPUT: Index of the PFE HIF to use in LLCE */
    uint8 u8Hif;    
} LLCE__ALIGNED__PACKED Llce_Can_InitPfeWithExternRingCmdType;

/**
 * @brief Get status command.
 *
 * It is sent by the host to LLCE in order to get the content of all status
 * registers of a specific CAN controller. This command makes only a read
 * operation on the status registers of CAN controller.
 *
 \image latex bcan_ecr.jpg "LLCE BCAN ECR." width=14cm
 \image html bcan_ecr.jpg "LLCE BCAN ECR."
 \image docbook bcan_ecr.jpg "LLCE BCAN ECR."
 \image rtf bcan_ecr.jpg "LLCE BCAN ECR."
 *
 \image latex bcan_crc.jpg "LLCE BCAN CRC." width=14cm
 \image html bcan_crc.jpg "LLCE BCAN CRC."
 \image docbook bcan_crc.jpg "LLCE BCAN CRC."
 \image rtf bcan_crc.jpg "LLCE BCAN CRC."
 *
 \image latex bcan_isr.jpg "LLCE BCAN ISR." width=14cm
 \image html bcan_isr.jpg "LLCE BCAN ISR."
 \image docbook bcan_isr.jpg "LLCE BCAN ISR."
 \image rtf bcan_isr.jpg "LLCE BCAN ISR."
 *
 \image latex bcan_sr.jpg "LLCE BCAN SR." width=14cm
 \image html bcan_sr.jpg "LLCE BCAN SR."
 \image docbook bcan_sr.jpg "LLCE BCAN SR."
 \image rtf bcan_sr.jpg "LLCE BCAN SR."
 *
 \image latex bcan_sr_2.jpg "LLCE BCAN SR-2." width=14cm
 \image html bcan_sr_2.jpg "LLCE BCAN SR-2."
 \image docbook bcan_sr_2.jpg "LLCE BCAN SR-2."
 \image rtf bcan_sr_2.jpg "LLCE BCAN SR-2."
 *
 **/
typedef struct
{
    /** @brief OUTPUT: Register ECR of CAN controller. */
    uint32 u32ECR;
    /** @brief OUTPUT: Register ISR of CAN controller. */
    uint32 u32ISR;
    /** @brief OUTPUT: Register SR of CAN controller. */
    uint32 u32SR;
    /** @brief OUTPUT: Register CRC of CAN controller. */
    uint32 u32CRC;
} LLCE__ALIGNED__PACKED Llce_Can_GetStatusCmdType;

/**
 * @brief Get firmware version command.
 *
 * It is sent by the host to LLCE in order to get the firmware version string.
 * It is copied in the response.
 **/
typedef Llce_Fw_VersionType Llce_Can_GetFwVersionType;

/**
 * @brief Filter address identifier
 *
 * It is sent by the host to LLCE in order to disable/enable a specific filter,
 * identified by its address
* <TABLE>
* <TR><TD>Type</TD><TD>Direction</TD><TD>Name</TD><TD>Disable filter</TD><TD>Enable filter</TD></TR>
* <TR><TD>uint8</TD><TD>in</TD><TD>u8FilterEnabled</TD><TD>0U</TD><TD>1U</TD></TR>
* </TABLE>
 **/
typedef struct
{
    /**
     * @brief INPUT: Address of the filter which shall be
     * removed/disabled/enabled.
     */
    uint16 u16FilterAddr;
    /** @brief INPUT: Request new state (0 - disable filter / 1 - enable filter) 
     *  of the filter when using SetFilterEnableStatus command. */
    uint8 u8FilterEnabled;
} LLCE__ALIGNED__PACKED Llce_Can_ChangeFilterType;

/**
 * @brief Add AF destination command structure.
 *
 * It is sent by the host to LLCE in order add a destination to be used by AF
 **/
typedef struct
{
    /** @brief INPUT: Destination to add to the list */
    Can_Af_DestRulesType rule;
    /** @brief OUTPUT: Index in LLCE list where destination was inserted */
    uint8 u8Idx;
} LLCE__ALIGNED__PACKED Llce_Can_CreateAfDestination;

/**
 * @brief Remove AF destination command.
 *
 * It is sent by the host to LLCE in order remove a destination used by AF. It is the index in LLCE list of destination to be removed.
 **/
typedef uint8 Llce_Can_RemoveAfDestination;



/**
 * @brief Abort MB command structure
 *
 * It is sent by the host to LLCE in order to abort the lowest priority pending
 * transmission of a specific controller.
 **/
typedef struct
{
    /**
     * @brief INPUT: Host defined tag used to track a specific frame.
     * See \link Llce_Can_TxMbDescriptorType \endlink
     */
    uint16 u16FrameTag;
    /** @brief   OUTPUT: Number of Tx pending transmissions aborted */
    uint8 u8AbortedFrameCnt;
    /** @brief INPUT: Specifies the type of AbortMB command. */
    Llce_Can_AbortMbType eAbortMbType;
} LLCE__ALIGNED__PACKED Llce_Can_AbortMbCmdType;

/**
 * @brief Set Eth2Can decapsulation state.
 *
 * It is sent by the host to LLCE in order to turn on or off decapsulation
 * for a given format.
 **/
typedef struct
{
    /** @brief INPUT: Encapsulation format */
    Llce_Can_EthEncapsulationFormat eFormat;
    /** @brief INPUT: State to set */
    Llce_Can_BinaryValueType eState;
} LLCE__ALIGNED__PACKED Llce_Can_SetEth2CanFormatStateCmdType;


/**
 * @brief List of commands used by host.
 *
 * It is used in order to use the same memory area for all commands send from
 * host to LLCE.
 **/
typedef union {
    /** @brief Command for initializing a specific CAN channel. */
    Llce_Can_InitCmdType Init;
    /**
     * @brief Command for getting the hardware status information for a
     * specific CAN controller.
     */
    Llce_Can_GetStatusCmdType GetStatus;
    /**
     * @brief Command for configuring filters for a specific CAN controller
     * in order to deliver frames to the host.
     */
    Llce_Can_SetFilterCmdType SetFilter;
    /**
     * @brief Command for configuring filters in order to route frames to
     * other destinations than host.
     */
    Llce_Can_SetAdvancedFilterCmdType SetAdvancedFilter;
    /** @brief Hardware address of filter to disable/enable/remove. */
    Llce_Can_ChangeFilterType ChangeFilter;
    /**
     * @brief Command for configuring baud rate parameters for a specific
     * CAN controller.
     */
    Llce_Can_SetBaudrateCmdType SetBaudrate;
    /**
     * @brief Command for getting the status of a specific CAN controller.
     */
    Llce_Can_GetControllerModeCmdType GetControllerMode;
    /**
     * @brief Command for changing the status of a specific CAN controller.
     */
    Llce_Can_SetControllerModeCmdType SetControllerMode;
    /** @brief Command for getting the firmware version. */
    Llce_Can_GetFwVersionType GetFwVersion;
    /**
     * @brief Command for configuring platform related parameters and common
     * HW components used by all CAN channels
     */
    Llce_Can_InitPlatformCmdType InitPlatform;
    /**
     * @brief Command for initializing the LLCE-PFE interface and getting
     * buffer locations
     */
    Llce_Can_InitPfeCmdType InitPfe;
    /**
     * @brief Command for initializing the LLCE-PFE interface using user's
     * ring buffer input
     */
    Llce_Can_InitPfeWithExternRingCmdType InitPfeWithExternRing;
    /** @brief Command for creating a destination for AF */
    Llce_Can_CreateAfDestination CreateAfDest;
    /** @brief Command for removing a destination for AF */
    Llce_Can_RemoveAfDestination RemoveAfDest;
    /**
     * @brief Command for aborting either the lowest priority message buffer
     * or all the message buffers with a specific tag.
     */
    Llce_Can_AbortMbCmdType AbortMb;
    /** @brief Pointer to argument for custom command */
    uint32 pCustomCmdArg;
    /**
     * @brief Command for configuring custom filters for a specific CAN controller
     * in order to deliver frames to the host.
     */
    Llce_Can_SetAuxFilterCmdType SetAuxFilter;
    /**
     * @brief Generic argument for binary values
     */
    Llce_Can_BinaryValueType eBinaryValue;
    /**
     * @brief Command for turning Eth2Can on or off for a certain format
     */
    Llce_Can_SetEth2CanFormatStateCmdType SetEth2CanFormatState;
} Llce_Can_CommandListType;

/**
 * @brief Command used by host.
 *
 * It is used in order to send commands from host to LLCE using shared memory.
 **/
typedef struct
{
    /** @brief INPUT: Command parameters. */
    Llce_Can_CommandListType CmdList;
    /** @brief INPUT: Command ID. */
    Llce_Can_CommandIdType eCmdId;
    /** @brief OUTPUT: Return status code after command completion.*/
    Llce_Fw_ReturnType eReturnValue;
} LLCE__ALIGNED__PACKED Llce_Can_CommandType;

/**
 * @brief Set controller mode notification.
 *
 * Notification send from LLCE to host in order to inform about a specific
 * controller state change.
 **/
typedef struct
{
    /**
     * @brief OUTPUT: Current state of the CAN controller.
     * See also \link Llce_Can_CtrlStateType \endlink
     */
    Llce_Can_CtrlStateType eControllerState;
    /** @brief OUTPUT: CAN controller id. */
    uint8 u8HwCtrl;
} LLCE__ALIGNED__PACKED Llce_Can_CtrlModeNotifType;

/**
 * @brief Platform specific error.
 *
 * Platform error details send to host in order to report an internal
 * LLCE error.
 **/
typedef struct
{
    /**
     * @brief OUTPUT: LLCE firmware component id.
     * See also \link Llce_Can_ModuleType \endlink
     */
    Llce_Can_ModuleType eModuleId;
    /**
     * @brief OUTPUT: LLCE error code.
     * See also \link Llce_Fw_ReturnType \endlink
     */
    Llce_Fw_ReturnType eErrorCode;
    /** @brief OUTPUT: Number of occurrences of the last error. */
    uint16 u16ErrorCount;
} LLCE__ALIGNED__PACKED Llce_Can_ErrorNotifType;

/** @brief Channel specific error.
 *
 * Channel error details send to host in order to report an internal LLCE error.
 **/
typedef struct
{
    Llce_Can_ErrorNotifType ErrorInfo;
    /** @brief OUTPUT: Controller ID. */
    uint8 u8HwCtrl;
} LLCE__ALIGNED__PACKED Llce_Can_ChannelErrorNotifType;

/**
 * List of notifications send by LLCE to host, used by host.
 *
 * It is used by LLCE to notify host about specific events inside LLCE.
 **/
typedef union {
    /**
     * @brief OUTPUT: Notification parameters for controller state changes.
     * See also \link Llce_Can_CtrlModeNotifType \endlink
     */
    Llce_Can_CtrlModeNotifType CtrlMode;
    /**
     * @brief OUTPUT: Notification parameters for platform errors.
     * See also \link Llce_Can_ErrorNotifType \endlink
     */
    Llce_Can_ErrorNotifType PlatformError;
    /**
     * @brief OUTPUT: Notification parameters for channel errors.
     * See also \link Llce_Can_ChannelErrorNotifType \endlink
     */
    Llce_Can_ChannelErrorNotifType ChannelError;
} Llce_Can_NotificationListType;

/**
 * @brief Notifications used by LLCE.
 *
 * It is used in order to send notifications from LLCE to host by using shared
 * memory.
 **/
typedef struct
{
    /**
     * @brief OUTPUT: Notification parameters.
     * See also \link Llce_Can_NotificationListType \endlink
     */
    Llce_Can_NotificationListType NotifList;
    /**
     * @brief OUTPUT: Notification ID.
     * See also \link Llce_Can_NotificationIdType \endlink
     */
    Llce_Can_NotificationIdType eNotifId;
} LLCE__ALIGNED__PACKED Llce_Can_NotificationType;

/**
 * @brief Notification tables.
 *
 * Notification tables used to store the details of the notifications.
 * The index of entries are sent to host cores.The two tables are related to
 * reporting method:interrupt or polling.
 **/
typedef struct
{
    /**
     * @brief OUTPUT: Table used to report notifications in interrupt mode.
     * See also \link Llce_Can_NotificationType \endlink
     */
    Llce_Can_NotificationType
        Can_aNotif0_Table[LLCE_CAN_CONFIG_HIF_COUNT]
                         [LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE];
    /**
     * @brief OUTPUT: Table used to report notifications in polling mode.
     * See also \link Llce_Can_NotificationType \endlink
     */
    Llce_Can_NotificationType
        Can_aNotif1_Table[LLCE_CAN_CONFIG_HIF_COUNT]
                         [LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE];
} LLCE__ALIGNED__PACKED Llce_Can_NotificationTableType;

/**
 * @brief Shared memory structure
 *
 * Structure that encapsulates all the shared memory with LLCE on the CAN side.
 **/
typedef struct
{
    /** @brief Receive message buffer descriptors. */
    Llce_Can_RxMbDescriptorType Can_Rx_aMbDesc[LLCE_CAN_CONFIG_MAXRXMB + LLCE_CAN_CONFIG_MAX_SHORTRXMB];
    /** @brief Transmit message buffer descriptors. */
    Llce_Can_TxMbDescriptorType Can_Tx_aMbDesc[LLCE_CAN_CONFIG_MAXTXMB];
    /** @brief Shared memory used to store the LONG CAN message buffers (64B). */
    Llce_Can_MbType Can_aMb[LLCE_CAN_CONFIG_MAXRXMB + LLCE_CAN_CONFIG_MAXTXMB +
                            LLCE_CAN_CONFIG_MAXAFFRMB];

    /** @brief Shared memory used to store the SHORT CAN message buffers (8B). */
    Llce_Can_ShortMbType Can_aSMb[LLCE_CAN_CONFIG_MAX_SHORTRXMB];

    /** @brief Shared memory used to send commands from Host to LLCE . */
    Llce_Can_CommandType aCanCmd[LLCE_CAN_CONFIG_HIF_COUNT];
    /** @brief Shared memory used to store notifications from LLCE to host.
     */
    Llce_Can_NotificationTableType Can_NotificationTable;
    /**
     * @brief Circular buffer used to send ACK info from TX core to HOST
     * core. Reserved 1 extra buffer for each interface for consistency
     * purposes.
     */
    Llce_Can_Tx2HostAckInfoType Can_Tx_aAckInfo[LLCE_CAN_CONFIG_MAX_TXACKINFO];
} LLCE__ALIGNED__PACKED Llce_Can_SharedMemoryType;

typedef struct
{
    /** @brief Shows the number of CAN frames received by each controller */
    uint32 u32GeneralRxCount;
    /** @brief Shows the number of CAN frames sent by each controller and acknowledged on the bus */
    uint32 u32GeneralTxCount;
    /** @brief All CAN frames received by the controller from other controllers via CAN */
    uint32 u32Can2CanInCount;
    /** @brief All CAN frames sent by the controller to other controller via CAN */
    uint32 u32Can2CanOutCount;
    /** @brief All CAN frames received by controller to be encapsulated in Ethernet format and sent to PFE for transmission over ethernet */
    uint32 u32Can2EthCount;
    /** @brief All Ethernet frames transfered from PFE to LLCE controller for decoding and transmission over CAN */
    uint32 u32Eth2CanCount;
    /** @brief Reserved for future use */
    uint32 u32ReservedCount1;
    /** @brief Reserved for future use */
    uint32 u32ReservedCount2;
    /** @brief Reserved for future use */
    uint32 u32ReservedCount3;
    /** @brief Reserved for future use */
    uint32 u32ReservedCount4;
} LLCE__ALIGNED__PACKED Llce_Can_RxTxCountType;

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/

/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/

#ifdef __cplusplus
}
#endif

#endif /*LLCE_INTERFACECANTYPES_H*/

/** @} */


===== 文件 [90/112]: source&include\include\Llce_InterfaceCanUtils.h =====
/**
 *   @file    Llce_InterfaceCanUtils.h
 *
 *   @brief   LLCE data structures and functions for ease of use of LLCE interface
 *   @details This file contains auxiliary data structures and functions wrapped onto the LLCE
 *            interface
 *
 *   @addtogroup LLCE_CAN_firmware_interface LLCE CAN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/
#ifndef LLCE_INTERFACECANUTILS_H
#define LLCE_INTERFACECANUTILS_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __DOXYGEN__
/**
 *
 * @page misra_violations MISRA-C:2012 violations
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.1, Identifiers (internal and external)
 * shall not rely on the significance of more than 31 characters. The used
 * compilers use more than 31 chars for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.2, Identifiers declared in the same scope
 * and name space shall be distinct. The used compilers use more than 31 chars
 * for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.4, Macro identifiers shall be distinct.
 * The used compilers use more than 31 chars for identifiers.
 *
 * @section [global]
 * Violates MISRA 2012 Required Rule 5.5, Identifiers shall be distinct from
 * macro names. The identifier clash is between macro identifiers. Therefore,
 * this rule is incorrectly reported by the tool.
 * 
 */
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
#include "Llce_InterfaceCanTypes.h"

 /*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/
 /* Masks used for un-shifted values, for checking user input */
 /** @brief Frame RTR field mask unpacked. */
 #define LLCE_CAN_MB_RTR_UNPACKED_U32                   ((uint32)0x00000001U)
 /** @brief Frame IDE field mask unpacked. */
 #define LLCE_CAN_MB_IDE_UNPACKED_U32                   ((uint32)0x00000001U)
 /** @brief Frame standard ID field mask unpacked. */
 #define LLCE_CAN_MB_IDSTD_MASK_UNPACKED_U32            ((uint32)0x0000007FF)
 /** @brief Frame BRS field mask unpacked. */
 #define LLCE_CAN_MB_BRS_UNPACKED_U32                   ((uint32)0x00000001U)
 /** @brief Frame FDF field mask unpacked. */
 #define LLCE_CAN_MB_FDF_UNPACKED_U32                   ((uint32)0x00000001U)
 /** @brief Frame ESI field mask unpacked. */
 #define LLCE_CAN_MB_ESI_UNPACKED_U32                   ((uint32)0x00000001U)
/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/
/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/
/**
 * @brief Word0 of a CAN frame.
 *
 * It contains the message ID and related configurations.
 **/
typedef struct
{
    /**
     * @brief INPUT/OUTPUT: Can frame Standard or Extended ID field.
     * In base frame format, only the 11 most significant bits (28-18)
     * are used for frame identification. The 18 least significant bits are ignored.
     * 
     * In extended frame format, all bits (0-28) are used for frame  identification.
     */
    uint32 u32Id;
    /**
     * @brief INPUT/OUTPUT: Can frame Remote Transmission Request field.
     * 
     * If BCAN transmits this bit as one (recessive) and receives it as zero
     * (dominant), it is interpreted as an arbitration 
     * loss. If this bit is transmitted as zero (dominant), then if it 
     * is received as one (recessive), BCAN treats it as a bit error. 
     * If the value received matches the value transmitted, it is considered
     *  a successful bit transmission.
     */
    uint8 u8Rtr;
    /**
     * @brief INPUT/OUTPUT: Can frame Identifier Extension field.
     * 
     * This field identifies whether the frame format is base (standard ID) 
     * or extended.
     */
    uint8 u8Ide;
}LLCE__ALIGNED__PACKED Llce_Can_Word0;

/**
 * @brief Word1 of a CAN frame.
 *
 * It contains CAN frame format and bit rate related configurations.
 **/
typedef struct
{
    /**
     * @brief INPUT/OUTPUT: Can frame Data Length Code field.
     * 
     * This 4-bit field defines the number of bytes in the data field 
     * of a CAN frame (DATA BYTE 0 to DATA BYTE 63). 
     * When RTR = 1, the frame is a remote request and does not include
     * the data field, regardless of the DLC field.
     */
    uint8 u8Dlc;
    /**
     * @brief INPUT/OUTPUT: Can frame FD Format Indicator field.
     * 
     * This bit distinguishes between classical CAN format and CAN FD format frames.
     */
    uint8 u8Fdf;
    /**
     * @brief INPUT/OUTPUT: Can frame Bit Rate Switch field. 
     * 
     * This bit defines whether the bit rate is switched inside a CAN FD frame.
     * This bit is meaningful only if FDF = 1, otherwise it is not used by BCAN.
     */
    uint8 u8Brs;
    /**
     * @brief INPUT/OUTPUT: Can frame Error State Indicator field.
     * 
     * This bit indicates if the transmitting node is error active or error passive.
     * This bit is meaningful only if FDF = 1, otherwise it is not used by BCAN.
     */
    uint8 u8Esi;
}LLCE__ALIGNED__PACKED Llce_Can_Word1;


/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/
/**
 * @brief              Pack members of Llce_Can_Word0 struct into CAN frame format.
 * 
 * @details            This is a helper function abstracts the CAN frame layout away
 *                     from the user when building a CAN frame.
 * 
 * @param Word0*       - pointer to struct holding fields of Word0 part from CAN frame.
 *                       The result is to be copied into u32Word0 field of Llce_Can_MbType struct.
 */
static inline uint32 Llce_Can_Pack_Word0(const Llce_Can_Word0* Word0)
{
    uint32 u32Word0_Temp = 0U;

    u32Word0_Temp |= ((Word0->u8Rtr & LLCE_CAN_MB_RTR_UNPACKED_U32) << LLCE_CAN_MB_RTR_SHIFT_U32);
    u32Word0_Temp |= ((Word0->u8Ide & LLCE_CAN_MB_IDE_UNPACKED_U32) << LLCE_CAN_MB_IDE_SHIFT_U32);
    if(LLCE_CAN_MB_IDE_UNPACKED_U32 == (Word0->u8Ide & LLCE_CAN_MB_IDE_UNPACKED_U32))
    {
        /* Extended Id */
        u32Word0_Temp |= (Word0->u32Id & LLCE_CAN_MB_ID_MASK_U32);
    }
    else
    {
        /* Standard Id */
        u32Word0_Temp |= ((Word0->u32Id & LLCE_CAN_MB_IDSTD_MASK_UNPACKED_U32) << LLCE_CAN_MB_IDSTD_SHIFT_U32);
    }

    return u32Word0_Temp;
}

/**
 * @brief              Pack members of Llce_Can_Word1 struct into CAN frame format.
 * 
 * @details            This is a helper function abstracts the CAN frame layout away
 *                     from the user when building a CAN frame. 
 * 
 * @param Word1*       - pointer to struct holding fields of Word1 part from CAN frame.
 *                       The result is to be copied into u32Word1 field of Llce_Can_MbType struct.
 */
static inline uint32 Llce_Can_Pack_Word1(const Llce_Can_Word1* Word1)
{
    uint32 Word1_temp = 0U;

    Word1_temp |= ((Word1->u8Brs & LLCE_CAN_MB_BRS_UNPACKED_U32) << LLCE_CAN_MB_BRS_SHIFT_U32);
    Word1_temp |= ((Word1->u8Fdf & LLCE_CAN_MB_FDF_UNPACKED_U32) << LLCE_CAN_MB_FDF_SHIFT_U32);
    Word1_temp |= ((Word1->u8Esi & LLCE_CAN_MB_ESI_UNPACKED_U32) << LLCE_CAN_MB_ESI_SHIFT_U32);
    Word1_temp |= (Word1->u8Dlc & LLCE_CAN_MB_DLC_MASK_U32);

    return Word1_temp;
}

/**
 * @brief              Unpack fields from CAN frame into Llce_Can_Word0 struct.
 * 
 * @details            This is a helper function which extracts the fields of Word0
 *                     from a CAN frame and populates the fields of Llce_Can_Word0 struct.
 *                     
 * @param u32Word0     - Word0 part of CAN frame with fields that match CAN layout.
 *                       The input parameter is u32Word0 field of Llce_Can_MbType struct.
 */
static inline Llce_Can_Word0 Llce_Can_Unpack_Word0(uint32 u32Word0)
{
    Llce_Can_Word0 Word0;

    Word0.u8Rtr = (uint8)((u32Word0 & LLCE_CAN_MB_RTR_U32) >> LLCE_CAN_MB_RTR_SHIFT_U32);
    Word0.u8Ide = (uint8)((u32Word0 & LLCE_CAN_MB_IDE_U32) >> LLCE_CAN_MB_IDE_SHIFT_U32);
    if(LLCE_CAN_MB_IDE_UNPACKED_U32 == (Word0.u8Ide & LLCE_CAN_MB_IDE_UNPACKED_U32))
    {
        /* Extended Id */
        Word0.u32Id = u32Word0 & LLCE_CAN_MB_ID_MASK_U32;
    }
    else
    {
        /* Standard Id */
        Word0.u32Id = ((u32Word0 & LLCE_CAN_MB_IDSTD_MASK_U32) >> LLCE_CAN_MB_IDSTD_SHIFT_U32);
    }

    return Word0;
}

/**
 * @brief              Unpack fields from CAN frame into Llce_Can_Word1 struct.
 * 
 * @details            This is a helper function which extracts the fields of Word1
 *                     from a CAN frame and populates the fields of Llce_Can_Word1 struct.
 * 
 * @param u32Word1     - Word1 part of CAN frame with fields that match CAN layout.
 *                       The input parameter is u32Word1 field of Llce_Can_MbType struct.
 */
static inline Llce_Can_Word1 Llce_Can_Unpack_Word1(uint32 u32Word1)
{
    Llce_Can_Word1 Word1;

    Word1.u8Esi = (uint8)((u32Word1 & LLCE_CAN_MB_ESI_U32) >> LLCE_CAN_MB_ESI_SHIFT_U32);
    Word1.u8Brs = (uint8)((u32Word1 & LLCE_CAN_MB_BRS_U32) >> LLCE_CAN_MB_BRS_SHIFT_U32);
    Word1.u8Fdf = (uint8)((u32Word1 & LLCE_CAN_MB_FDF_U32) >> LLCE_CAN_MB_FDF_SHIFT_U32);
    Word1.u8Dlc = (uint8)(u32Word1 & LLCE_CAN_MB_DLC_MASK_U32);

    return Word1;
}

/**
 * @brief              Retrieve message buffer from shared memory based on rx descriptor index and 
 *                     unpack fields from the message buffer.
 * 
 * @details            This is a helper function which takes a descriptor as input
 *                     and returns the corresponding message buffer, which can be either a long (64 bytes) or short (8bytes) one.
 *                     It also retrieves the relevant fields from the message buffer.
 *                     The lower indexes correspond to long message buffers, followed by the short ones 
 *                     in the rx descriptor array, Llce_Can_RxMbDescriptorType Can_Rx_aMbDesc.
 * 
 * @param pCan_SharedMemory   - Pointer to shared memory.
.* @param u16RxMbDescIdx      - Rx message buffer descriptor index.
 * @param u32Word0            - Word0 field of message buffer.
 * @param u32Word1            - Word1 field of message buffer.
 * @param u8Payload           - Payload - either long or short.
 * @param u32Timestamp        - Timestamp from a clock source.
 */
static inline void Llce_Can_GetMbData(volatile Llce_Can_SharedMemoryType* pCan_SharedMemory, uint16 u16RxMbDescIdx, uint32* u32Word0, uint32* u32Word1, uint8** u8Payload, uint32* u32Timestamp)
{   
    /* Decide whether it's a 64B frame or a 8B frame (Short frame) */
    if (u16RxMbDescIdx < LLCE_CAN_CONFIG_MAXRXMB)
    {
        *u32Word0 = pCan_SharedMemory->Can_aMb[u16RxMbDescIdx].u32Word0;
        *u32Word1 =  pCan_SharedMemory->Can_aMb[u16RxMbDescIdx].u32Word1;
        *u8Payload = (uint8*)pCan_SharedMemory->Can_aMb[u16RxMbDescIdx].u8Payload;
        *u32Timestamp = pCan_SharedMemory->Can_aMb[u16RxMbDescIdx].u32Timestamp;
    }
    else
    {
        *u32Word0 = pCan_SharedMemory->Can_aSMb[u16RxMbDescIdx - LLCE_CAN_CONFIG_MAXRXMB].u32Word0;
        *u32Word1 = pCan_SharedMemory->Can_aSMb[u16RxMbDescIdx - LLCE_CAN_CONFIG_MAXRXMB].u32Word1;
        *u8Payload = (uint8*)pCan_SharedMemory->Can_aSMb[u16RxMbDescIdx - LLCE_CAN_CONFIG_MAXRXMB].u8Payload;
        *u32Timestamp = pCan_SharedMemory->Can_aSMb[u16RxMbDescIdx - LLCE_CAN_CONFIG_MAXRXMB].u32Timestamp;
    }

}

/**
* @brief          Retrieve the SEMA42_GATE corresponding to a given FIFO group idx (RXOUT/TXACK) 
*                 and a given HIF (Host Interface)
* @details        The SEMA42_GATE is used to lock the access to the FIFO IER register which is
*                 handled by LLCE and host. 
*
* @param[in]      u8FifoIdx FIFO group idx (RXOUT/TXACK)
* @param[in]      u8Hif Host Interface
*
* <TABLE>
* <TR><TD>Type</TD><TD>Direction</TD><TD>Name</TD><TD>Value Range</TD></TR>
* <TR><TD>uint8</TD><TD>in</TD><TD>u8FifoIdx</TD><TD>LLCE_FIFO_RXOUT_INDEX-LLCE_FIFO_TXACK_INDEX</TD></TR>
* <TR><TD>uint8</TD><TD>in</TD><TD>u8Hif</TD><TD>LLCE_CAN_HIF0-LLCE_CAN_HIF1</TD></TR>
* </TABLE>
* 
* @return         Llce_Sema42_GateType
*
*/
static inline Llce_Sema42_GateType Llce_GetSema42Gate (uint8 u8FifoIdx, uint8 u8Hif)
{
    /** @brief   Semaphore used to protect access to the FIFO IER register shared between
     *           LLCE and host on interrupt enable/disable. */
    static const Llce_Sema42_GateType Can_Sema4_Ier[LLCE_CAN_CONFIG_IER_SEMA4_COUNT][LLCE_CAN_CONFIG_HIF_COUNT] = 
    {
        {LLCE_SEMA42_GATE20, LLCE_SEMA42_GATE21}, 
        {LLCE_SEMA42_GATE22, LLCE_SEMA42_GATE23}
    };

    return Can_Sema4_Ier[u8FifoIdx][u8Hif];
}

#ifdef __cplusplus
}
#endif

#endif /*LLCE_INTERFACECANUTILS_H*/

/** @} */


===== 文件 [91/112]: source&include\include\Llce_InterfaceFifo.h =====
/**
 *   @file    Llce_InterfaceFifo.h
 *
 *   @brief   This file contains defines used for accessing LLCE FIFO hw module
 *   @details This file contains defines used for accessing LLCE FIFO hw module
 *
 *   @addtogroup LLCE_CAN_firmware_interface LLCE CAN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_FIFOINTERFACE_H
#define LLCE_FIFOINTERFACE_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __DOXYGEN__
/**
 * @page misra_violations MISRA-C:2012 violations
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 4.9, A function should be used in
 * preference to a function-like macro where they are interchangeable. Function
 * like macro are used to reduce code complexity
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 2.5, A project should not contain unused
 * macro declarations Some macros are used either in FW or driver, or provided
 * as API
 *
 */
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
#include "Llce_RegAccess.h"
#include "Llce_InterfaceCanConfig.h"
/*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

extern const uint32 Llce_Can_u32BlrinBaseAddress[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
extern const uint32 Llce_Can_u32BlroutBaseAddress[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
extern const uint32 Llce_Can_u32TxackBaseAddress[LLCE_CAN_CONFIG_MAXCTRL_COUNT +
                                                 LLCE_CAN_MAX_POLLING_CLASSES];
extern const uint32 Llce_Can_u32RxoutBaseAddress[LLCE_CAN_CONFIG_MAXCTRL_COUNT +
                                                 LLCE_CAN_MAX_POLLING_CLASSES];

extern const uint32 Llce_Can_u32NotifFifo0BaseAddress[LLCE_CAN_CONFIG_HIF_COUNT];
extern const uint32 Llce_Can_u32NotifFifo1BaseAddress[LLCE_CAN_CONFIG_HIF_COUNT];

extern const uint32 Llce_Can_u32RxinBaseAddress[LLCE_CAN_CONFIG_HIF_COUNT];
extern const uint32 Llce_Can_u32CmdBaseAddress[LLCE_CAN_CONFIG_HIF_COUNT];

extern const uint32 Llce_Can_u32RxinLogBaseAddress[1];
extern const uint32 Llce_Can_u32RxoutLogBaseAddress[1];
/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/
 /* LLCE base addresses*/
/** @brief Base address for Generic FIFO 0. */
#define LLCE_GENERIC_FIFO_BASEADDR ((uint32)0x43A12000UL)
/** @brief Base address for the interrupt concentrator registers. */
#define LLCE_ICSR_BASEADDR ((uint32)0x43A14000UL)

#define LLCE_CONFIG_FIFO_DEPTH_U8 ((uint8)16U)

#define LLCE_FIFO_FFULLD_U32 ((uint32)0x00000001U)
#define LLCE_FIFO_FEMTYD_U32 ((uint32)0x00000002U)
#define LLCE_FIFO_SR_QCOUNT_SHIFT_U8 ((uint8)24U)

#define LLCE_FIFO_FCR_FIFOEN_U32 ((uint32)0x00000001U)
#define LLCE_FIFO_FCR_FLENOWEN_U32 ((uint32)0x00000002U)
#define LLCE_FIFO_FCR_POPEN_U32 ((uint32)0x00000004U)
#define LLCE_FIFO_FCR_PUSHEN_U32 ((uint32)0x00000008U)
#define LLCE_FIFO_FCR_FLUSH_U32 ((uint32)0x00000010U)

#define LLCE_FIFO_FCR_RESET_U32 ((uint32)0x0U)

/*Generic defines used to access STATUS, ILR and IER registers of FIFOs.*/
#define LLCE_FIFO_FFULL_U32    ((uint32)0x00000100U)
#define LLCE_FIFO_FNFULL_U32   ((uint32)0x00000200U)
#define LLCE_FIFO_FEMTY_U32    ((uint32)0x00000400U)
#define LLCE_FIFO_FNEMTY_U32   ((uint32)0x00000800U)
#define LLCE_FIFO_POPEVT_U32   ((uint32)0x00001000U)
#define LLCE_FIFO_WMKFL_U32    ((uint32)0x00002000U)
#define LLCE_FIFO_WMKEM_U32    ((uint32)0x00004000U)
#define LLCE_FIFO_POPUND_U32   ((uint32)0x00008000U)
#define LLCE_FIFO_PUSHOVR_U32  ((uint32)0x00010000U)
#define LLCE_FIFO_MSBNOMT_U32  ((uint32)0x00020000U)

/* Default value returned when popping an empty fifo */
#define LLCE_FIFO_NULL_VALUE ((uint32)0xFFFFFFFFU)

#define LLCE_FIFO_0_BASE_ADDRESS            (0x43A00000UL)
#define LLCE_FIFO_1_BASE_ADDRESS            (0x43A00400UL)
#define LLCE_FIFO_2_BASE_ADDRESS            (0x43A00800UL)
#define LLCE_FIFO_3_BASE_ADDRESS            (0x43A00C00UL)
#define LLCE_FIFO_4_BASE_ADDRESS            (0x43A01000UL)
#define LLCE_FIFO_5_BASE_ADDRESS            (0x43A01400UL)
#define LLCE_FIFO_6_BASE_ADDRESS            (0x43A01800UL)
#define LLCE_FIFO_7_BASE_ADDRESS            (0x43A01C00UL)
#define LLCE_FIFO_8_BASE_ADDRESS            (0x43A02000UL)
#define LLCE_FIFO_9_BASE_ADDRESS            (0x43A02400UL)
#define LLCE_FIFO_10_BASE_ADDRESS           (0x43A02800UL)
#define LLCE_FIFO_11_BASE_ADDRESS           (0x43A02C00UL)
#define LLCE_FIFO_12_BASE_ADDRESS           (0x43A03000UL)
#define LLCE_FIFO_13_BASE_ADDRESS           (0x43A03400UL)
#define LLCE_FIFO_14_BASE_ADDRESS           (0x43A03800UL)
#define LLCE_FIFO_15_BASE_ADDRESS           (0x43A03C00UL)
#define LLCE_FIFO_16_BASE_ADDRESS           (0x43A04000UL)
#define LLCE_FIFO_17_BASE_ADDRESS           (0x43A04400UL)
#define LLCE_FIFO_18_BASE_ADDRESS           (0x43A04800UL)
#define LLCE_FIFO_19_BASE_ADDRESS           (0x43A04C00UL)
#define LLCE_FIFO_20_BASE_ADDRESS           (0x43A05000UL)
#define LLCE_FIFO_21_BASE_ADDRESS           (0x43A08000UL)
#define LLCE_FIFO_22_BASE_ADDRESS           (0x43A08400UL)
#define LLCE_FIFO_23_BASE_ADDRESS           (0x43A08800UL)
#define LLCE_FIFO_24_BASE_ADDRESS           (0x43A08C00UL)
#define LLCE_FIFO_25_BASE_ADDRESS           (0x43A09000UL)
#define LLCE_FIFO_26_BASE_ADDRESS           (0x43A09400UL)
#define LLCE_FIFO_27_BASE_ADDRESS           (0x43A09800UL)
#define LLCE_FIFO_28_BASE_ADDRESS           (0x43A09C00UL)
#define LLCE_FIFO_29_BASE_ADDRESS           (0x43A0A000UL)
#define LLCE_FIFO_30_BASE_ADDRESS           (0x43A0A400UL)
#define LLCE_FIFO_31_BASE_ADDRESS           (0x43A0A800UL)
#define LLCE_FIFO_32_BASE_ADDRESS           (0x43A0AC00UL)
#define LLCE_FIFO_33_BASE_ADDRESS           (0x43A0B000UL)
#define LLCE_FIFO_34_BASE_ADDRESS           (0x43A0B400UL)
#define LLCE_FIFO_35_BASE_ADDRESS           (0x43A0B800UL)
#define LLCE_FIFO_36_BASE_ADDRESS           (0x43A0BC00UL)
#define LLCE_FIFO_37_BASE_ADDRESS           (0x43A0C000UL)
#define LLCE_FIFO_38_BASE_ADDRESS           (0x43A0C400UL)
#define LLCE_FIFO_39_BASE_ADDRESS           (0x43A0C800UL)
#define LLCE_FIFO_40_BASE_ADDRESS           (0x43A0CC00UL)
#define LLCE_FIFO_41_BASE_ADDRESS           (0x43A0D000UL)
#define LLCE_FIFO_42_BASE_ADDRESS           (0x43B00000UL)
#define LLCE_FIFO_43_BASE_ADDRESS           (0x43B00400UL)
#define LLCE_FIFO_44_BASE_ADDRESS           (0x43B00800UL)
#define LLCE_FIFO_45_BASE_ADDRESS           (0x43B00C00UL)
#define LLCE_FIFO_46_BASE_ADDRESS           (0x43B01000UL)
#define LLCE_FIFO_47_BASE_ADDRESS           (0x43B01400UL)
#define LLCE_FIFO_48_BASE_ADDRESS           (0x43B01800UL)
#define LLCE_FIFO_49_BASE_ADDRESS           (0x43B01C00UL)
#define LLCE_FIFO_50_BASE_ADDRESS           (0x43B02000UL)
#define LLCE_FIFO_51_BASE_ADDRESS           (0x43B02400UL)
#define LLCE_FIFO_52_BASE_ADDRESS           (0x43B02800UL)
#define LLCE_FIFO_53_BASE_ADDRESS           (0x43B02C00UL)
#define LLCE_FIFO_54_BASE_ADDRESS           (0x43B03000UL)
#define LLCE_FIFO_55_BASE_ADDRESS           (0x43B03400UL)
#define LLCE_FIFO_56_BASE_ADDRESS           (0x43B03800UL)
#define LLCE_FIFO_57_BASE_ADDRESS           (0x43B03C00UL)
#define LLCE_FIFO_58_BASE_ADDRESS           (0x43B04000UL)
#define LLCE_FIFO_59_BASE_ADDRESS           (0x43B04400UL)
#define LLCE_FIFO_60_BASE_ADDRESS           (0x43B04800UL)
#define LLCE_FIFO_61_BASE_ADDRESS           (0x43B04C00UL)
#define LLCE_FIFO_62_BASE_ADDRESS           (0x43B05000UL)
#define LLCE_FIFO_63_BASE_ADDRESS           (0x43B08000UL)
#define LLCE_FIFO_64_BASE_ADDRESS           (0x43B08400UL)
#define LLCE_FIFO_65_BASE_ADDRESS           (0x43B08800UL)
#define LLCE_FIFO_66_BASE_ADDRESS           (0x43B08C00UL)
#define LLCE_FIFO_67_BASE_ADDRESS           (0x43B09000UL)
#define LLCE_FIFO_68_BASE_ADDRESS           (0x43B09400UL)
#define LLCE_FIFO_69_BASE_ADDRESS           (0x43B09800UL)
#define LLCE_FIFO_70_BASE_ADDRESS           (0x43B09C00UL)
#define LLCE_FIFO_71_BASE_ADDRESS           (0x43B0A000UL)
#define LLCE_FIFO_72_BASE_ADDRESS           (0x43B0A400UL)
#define LLCE_FIFO_35_BASE_ADDRESS           (0x43A0B800UL)
#define LLCE_FIFO_36_BASE_ADDRESS           (0x43A0BC00UL)
#define LLCE_FIFO_37_BASE_ADDRESS           (0x43A0C000UL)
#define LLCE_FIFO_38_BASE_ADDRESS           (0x43A0C400UL)
#define LLCE_FIFO_39_BASE_ADDRESS           (0x43A0C800UL)
#define LLCE_FIFO_40_BASE_ADDRESS           (0x43A0CC00UL)
#define LLCE_FIFO_41_BASE_ADDRESS           (0x43A0D000UL)
#define LLCE_FIFO_42_BASE_ADDRESS           (0x43B00000UL)
#define LLCE_FIFO_43_BASE_ADDRESS           (0x43B00400UL)
#define LLCE_FIFO_44_BASE_ADDRESS           (0x43B00800UL)
#define LLCE_FIFO_45_BASE_ADDRESS           (0x43B00C00UL)
#define LLCE_FIFO_46_BASE_ADDRESS           (0x43B01000UL)
#define LLCE_FIFO_47_BASE_ADDRESS           (0x43B01400UL)
#define LLCE_FIFO_48_BASE_ADDRESS           (0x43B01800UL)
#define LLCE_FIFO_49_BASE_ADDRESS           (0x43B01C00UL)
#define LLCE_FIFO_50_BASE_ADDRESS           (0x43B02000UL)
#define LLCE_FIFO_51_BASE_ADDRESS           (0x43B02400UL)
#define LLCE_FIFO_52_BASE_ADDRESS           (0x43B02800UL)
#define LLCE_FIFO_53_BASE_ADDRESS           (0x43B02C00UL)
#define LLCE_FIFO_54_BASE_ADDRESS           (0x43B03000UL)
#define LLCE_FIFO_55_BASE_ADDRESS           (0x43B03400UL)
#define LLCE_FIFO_56_BASE_ADDRESS           (0x43B03800UL)
#define LLCE_FIFO_57_BASE_ADDRESS           (0x43B03C00UL)
#define LLCE_FIFO_58_BASE_ADDRESS           (0x43B04000UL)
#define LLCE_FIFO_59_BASE_ADDRESS           (0x43B04400UL)
#define LLCE_FIFO_60_BASE_ADDRESS           (0x43B04800UL)
#define LLCE_FIFO_61_BASE_ADDRESS           (0x43B04C00UL)
#define LLCE_FIFO_62_BASE_ADDRESS           (0x43B05000UL)
#define LLCE_FIFO_63_BASE_ADDRESS           (0x43B08000UL)
#define LLCE_FIFO_64_BASE_ADDRESS           (0x43B08400UL)
#define LLCE_FIFO_65_BASE_ADDRESS           (0x43B08800UL)
#define LLCE_FIFO_66_BASE_ADDRESS           (0x43B08C00UL)
#define LLCE_FIFO_67_BASE_ADDRESS           (0x43B09000UL)
#define LLCE_FIFO_68_BASE_ADDRESS           (0x43B09400UL)
#define LLCE_FIFO_69_BASE_ADDRESS           (0x43B09800UL)
#define LLCE_FIFO_70_BASE_ADDRESS           (0x43B09C00UL)
#define LLCE_FIFO_71_BASE_ADDRESS           (0x43B0A000UL)
#define LLCE_FIFO_72_BASE_ADDRESS           (0x43B0A400UL)
#define LLCE_FIFO_73_BASE_ADDRESS           (0x43B0A800UL)
#define LLCE_FIFO_74_BASE_ADDRESS           (0x43B0AC00UL)
#define LLCE_FIFO_75_BASE_ADDRESS           (0x43B0B000UL)
#define LLCE_FIFO_76_BASE_ADDRESS           (0x43B0B400UL)
#define LLCE_FIFO_77_BASE_ADDRESS           (0x43B0B800UL)
#define LLCE_FIFO_78_BASE_ADDRESS           (0x43B0BC00UL)
#define LLCE_FIFO_79_BASE_ADDRESS           (0x43B0C000UL)
#define LLCE_FIFO_80_BASE_ADDRESS           (0x43B0C400UL)
#define LLCE_FIFO_81_BASE_ADDRESS           (0x43B0C800UL)
#define LLCE_FIFO_82_BASE_ADDRESS           (0x43B0CC00UL)
#define LLCE_FIFO_83_BASE_ADDRESS           (0x43B0D000UL)
#define LLCE_FIFO_84_BASE_ADDRESS           (0x43B10000UL)
#define LLCE_FIFO_85_BASE_ADDRESS           (0x43B10400UL)
#define LLCE_FIFO_86_BASE_ADDRESS           (0x43B10800UL)
#define LLCE_FIFO_87_BASE_ADDRESS           (0x43B10C00UL)
#define LLCE_FIFO_88_BASE_ADDRESS           (0x43B11000UL)
#define LLCE_FIFO_89_BASE_ADDRESS           (0x43B11400UL)
#define LLCE_FIFO_90_BASE_ADDRESS           (0x43B11800UL)
#define LLCE_FIFO_91_BASE_ADDRESS           (0x43B11C00UL)
#define LLCE_FIFO_92_BASE_ADDRESS           (0x43B12000UL)
#define LLCE_FIFO_93_BASE_ADDRESS           (0x43B12400UL)
#define LLCE_FIFO_94_BASE_ADDRESS           (0x43B12800UL)
#define LLCE_FIFO_95_BASE_ADDRESS           (0x43B12C00UL)
#define LLCE_FIFO_96_BASE_ADDRESS           (0x43B13000UL)
#define LLCE_FIFO_97_BASE_ADDRESS           (0x43B13400UL)
#define LLCE_FIFO_98_BASE_ADDRESS           (0x43B13800UL)
#define LLCE_FIFO_99_BASE_ADDRESS           (0x43B13C00UL)
#define LLCE_FIFO_100_BASE_ADDRESS          (0x43B14000UL)
#define LLCE_FIFO_101_BASE_ADDRESS          (0x43B14400UL)
#define LLCE_FIFO_102_BASE_ADDRESS          (0x43B14800UL)
#define LLCE_FIFO_103_BASE_ADDRESS          (0x43B14C00UL)
#define LLCE_FIFO_104_BASE_ADDRESS          (0x43B15000UL)
#define LLCE_GENERIC_FIFO_0_BASE_ADDRESS    (0x43A12000UL)
#define LLCE_GENERIC_FIFO_1_BASE_ADDRESS    (0x43A12400UL)
#define LLCE_GENERIC_FIFO_2_BASE_ADDRESS    (0x43A12800UL)
#define LLCE_GENERIC_FIFO_3_BASE_ADDRESS    (0x43A12C00UL)


/* Specific FIFOs base address calculation macros. */
#define LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo)                           \
    ((uint32)(LLCE_GENERIC_FIFO_BASEADDR +                                     \
              ((uint32)(u8GenFfo) * (uint32)0x400U))) 

#define LLCE_GENERIC_FIFO_CONFIG(u8GenFfo)                                     \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo)))
#define LLCE_GENERIC_FIFO_STATUS0(u8GenFfo)                                    \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo) + 0x04U))
#define LLCE_GENERIC_FIFO_STATUS1(u8GenFfo)                                    \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo) + 0x08U))
#define LLCE_GENERIC_FIFO_IER(u8GenFfo)                                        \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo) + 0x0CU))
#define LLCE_GENERIC_FIFO_ILR(u8GenFfo)                                        \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo) + 0x10U))
#define LLCE_GENERIC_FIFO_PUSH0(u8GenFfo)                                      \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo) + 0x14U))
#define LLCE_GENERIC_FIFO_POP0(u8GenFfo)                                       \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo) + 0x24U))
#define LLCE_GENERIC_FIFO_FMR(u8GenFfo)                                        \
    ((uint32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(u8GenFfo) + 0x34U))

#define LLCE_FIFO_CONFIG(u32BaseAddr) ((uint32)(u32BaseAddr))
#define LLCE_FIFO_STATUS0(u32BaseAddr) ((uint32)(u32BaseAddr + 0x04U))
#define LLCE_FIFO_STATUS1(u32BaseAddr) ((uint32)(u32BaseAddr + 0x08U))
#define LLCE_FIFO_IER(u32BaseAddr) ((uint32)(u32BaseAddr + 0x0CU))
#define LLCE_FIFO_ILR(u32BaseAddr) ((uint32)(u32BaseAddr + 0x10U))
#define LLCE_FIFO_PUSH0(u32BaseAddr) ((uint32)(u32BaseAddr + 0x14U))
#define LLCE_FIFO_POP0(u32BaseAddr) ((uint32)(u32BaseAddr + 0x24U))
#define LLCE_FIFO_FMR(u32BaseAddr) ((uint32)(u32BaseAddr + 0x34U))

#define LLCE_FIFO_BLRIN_BASE_ADDRESS(u8HwCtrl)                                 \
    (Llce_Can_u32BlrinBaseAddress[u8HwCtrl])
#define LLCE_FIFO_RXOUT_BASE_ADDRESS(u8HwCtrl)                                 \
    (Llce_Can_u32RxoutBaseAddress[u8HwCtrl])
#define LLCE_FIFO_TXACK_BASE_ADDRESS(u8HwCtrl)                                 \
    (Llce_Can_u32TxackBaseAddress[u8HwCtrl])
#define LLCE_FIFO_BLROUT_BASE_ADDRESS(u8HwCtrl)                                \
    (Llce_Can_u32BlroutBaseAddress[u8HwCtrl])

#define LLCE_NOTIF_FIFO0_BASE_ADDRESS(u8HostCore)                              \
    (Llce_Can_u32NotifFifo0BaseAddress[u8HostCore])
#define LLCE_NOTIF_FIFO1_BASE_ADDRESS(u8HostCore)                              \
    (Llce_Can_u32NotifFifo1BaseAddress[u8HostCore])

#define LLCE_FIFO_RXIN_BASE_ADDRESS(u8HostCore)                                \
    (Llce_Can_u32RxinBaseAddress[u8HostCore])
#define LLCE_FIFO_CMD_BASE_ADDRESS(u8HostCore)                                 \
    (Llce_Can_u32CmdBaseAddress[u8HostCore])

#define LLCE_FIFO_RXINLOG_BASE_ADDRESS() (Llce_Can_u32RxinLogBaseAddress[0])
#define LLCE_FIFO_RXOUTLOG_BASE_ADDRESS() (Llce_Can_u32RxoutLogBaseAddress[0])

/*==================================================================================================
 *                                      Interrupts
 ==================================================================================================*/

/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/*==================================================================================================
 *                                STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/

/*==================================================================================================
 *                                GLOBAL VARIABLE DECLARATIONS
 ==================================================================================================*/

/*==================================================================================================
 *                                    FUNCTION PROTOTYPES
 ==================================================================================================*/

#ifdef __cplusplus
}
#endif

#endif /* LLCE_FIFOINTERFACE_H */

/** @} */


===== 文件 [92/112]: source&include\include\Llce_InterfaceFwMgr.h =====
/**
 *   @file    Llce_InterfaceFwMgr.h
 *
 *   @brief   LLCE defines used to configure the LLCE firmware and interface
 *   @details LLCE defines used to configure the LLCE firmware and interface.
 *            Those configuration parameters are used both by LLCE firmware and
 *            host software.
 *
 *   @addtogroup Llce_configuration LLCE precompile configuration parameters
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_INTERFACEFWMGR_H
#define LLCE_INTERFACEFWMGR_H

#ifdef __cplusplus
extern "C" {
#endif

/**
* @page misra_violations MISRA-C:2012 violations
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.1, Identifiers (internal and external) shall not rely
* on the significance of more than 31 characters.
* The used compilers use more than 31 chars for identifiers.
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.4, Macro identifiers shall be distinct.
* This violation is due to the AUTOSAR requirement [SWS_BSW_00036] (perform inter module checks).
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.2, Identifiers declared in the same scope and name space shall be distinct.
* This rule does not apply if either identifier is a macro identifier, because this case is covered
* by Rule 5.4 and Rule 5.5.
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.5, Identifiers shall be distinct from macro names.
* The identifier clash is between macro identifiers. Therefore, this rule is incorrectly reported by the tool.
*
* @section Llce_InterfaceFwMgr_h_REF_1
* Violates MISRA 2012 Required Rule 21.1, #define and #undef shall not be used on a reserved identifier or
* reserved macro name.
* Certain keywords are not recognized by tools such as PC-LINT and LDRA.
*
* @section Llce_InterfaceFwMgr_h_REF_2
* Violates MISRA 2012 Advisory Rule 4.9, A function should be used in
* preference to a function-like macro where they are interchangeable. Function
* like macro are used to reduce code complexity
*
* @section Llce_InterfaceFwMgr_h_REF_3
* Violates MISRA 2012 Advisory Rule 2.3, A project should not contain unused type declarations.
* False detection by lint tool.
*
*/

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/


#include "Llce_RegAccess.h"

#ifdef CHECK_ABI_COMPATIBILITY
#pragma ABICHECK start
#endif
#include "Llce_FwVersion.h"

/*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/

/*==================================================================================================
 *                                      Interrupts
 ==================================================================================================*/

/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/**
 * @brief CAN firmware notification categories.
 * @details Contains the notification categories of the values returned by the LLCE Firmware.
 * @see Llce_Fw_ReturnType
 **/
typedef enum LLCE__PACKED
{
    LLCE_NOTIFCAT_CAN_PROTOCOL = 1U,
    LLCE_NOTIFCAT_DATA_LOST,
    LLCE_NOTIFCAT_CONFIGURATION,
    LLCE_NOTIFCAT_INTERNAL,
    LLCE_NOTIFCAT_BUSOFF,
    LLCE_NOTIFCAT_FW_STATUS,
    LLCE_NOTIFCAT_CAN_PROTOCOL_CRITICAL_STATE

} Llce_Fw_Notification_Category;

/**
 * @brief CAN firmware error values.
 *
 * CAN error values as they are reported by the LLCE firmware. Some of them are
 * channel related and other are platform related.
 **/
typedef enum LLCE__PACKED
{
    /** @brief CAN firmware error: BOTH SW AND HW TXACK FIFOS are full. */
    LLCE_ERROR_TXACK_FIFO_FULL = 1U,
    /** @brief CAN firmware error: RXOUT SW FIFO is full. */
    LLCE_ERROR_RXOUT_FIFO_FULL,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_0,
    /** @brief CAN firmware error: The system lost indexes or HW FIFO was not cleared and it is full. */
    LLCE_ERROR_HW_FIFO_FULL,
    /** @brief CAN firmware error: There was an attempt to perform a pop operation on an empty SW FIFO. */
    LLCE_ERROR_SW_FIFO_EMPTY,
    /** @brief CAN firmware error: There was an attempt to perform a push operation on a full SW FIFO.*/
    LLCE_ERROR_SW_FIFO_FULL,
    /** @brief CAN firmware error: The maximum hardware object count on the reception side was reached. */
    LLCE_ERROR_MB_NOTAVAILABLE,
    /** @brief CAN firmware error: Short Message buffer is configured but a long frame is received. */
    LLCE_ERROR_SHORT_MB_NOTAVAILABLE,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_BCAN_FRZ_EXIT,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_BCAN_SYNC,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_BCAN_FRZ_ENTER,
    /**
     * @brief CAN firmware error: CAN protocol error due to inability to
     * enter in low-power mode.
     */
    LLCE_ERROR_BCAN_LPM_EXIT,
    /**
     * @brief CAN firmware error: CAN protocol error due to inability to
     * enter in soft reset.
     */
    LLCE_ERROR_BCAN_SRT_ENTER,
    /**
     * @brief CAN firmware error: An error callback was called, but no error code matches : unknown CAN protocol error 
     */
    LLCE_ERROR_BCAN_UNKNOWN_ERROR,
    /**
     * @brief CAN firmware error: ACKERR indicates that an acknowledge error
     * has been detected by the transmitter node.
     */
    LLCE_ERROR_BCAN_ACKERR,
    /**
     * @brief CAN firmware error: CRCERR indicates that a CRC error has been
     * detected by the receiver node in a CAN frame.
     */
    LLCE_ERROR_BCAN_CRCERR,
    /**
     * @brief CAN firmware error: BIT0ERR indicates when an inconsistency
     * occurs between the transmitted and the received bit in a CAN frame.
     */
    LLCE_ERROR_BCAN_BIT0ERR,
    /**
     * @brief CAN firmware error: BIT1ERR indicates when an inconsistency
     * occurs between the transmitted and the received bit in a CAN frame.
     */
    LLCE_ERROR_BCAN_BIT1ERR,
    /**
     * @brief CAN firmware error: DPBIT1ERR indicates when an inconsistency
     * occurs between the transmitted and the received bit in the data phase
     * of a CAN-FD frame.
     */
    LLCE_ERROR_BCAN_DPBIT1ERR,
    /**
     * @brief CAN firmware error: DPBIT0ERR indicates when an inconsistency
     * occurs between the transmitted and the received bit in the data phase
     * of a CAN-FD frame.
     */
    LLCE_ERROR_BCAN_DPBIT0ERR,
    /**
     * @brief CAN firmware error: DPSTFERR indicates that a stuffing error has
     * been detected by the receiver node in the data phase of a CAN-FD frame.
     */
    LLCE_ERROR_BCAN_DPSTFERR,
    /**
     * @brief CAN firmware error: DPFRMERR indicates that a form error has
     * been detected by the receiver node in the data phase of a CAN-FD frame
     * - a fixed-form bit field contains at least one illegal bit.
     */
    LLCE_ERROR_BCAN_DPFRMERR,
    /**
     * @brief CAN firmware error: DPCRCERR indicates that a CRC error has been
     * detected by the receiver node in the data phase of a CAN-FD frame
     */
    LLCE_ERROR_BCAN_DPCRCERR,
    /**
     * @brief CAN firmware error: FRMERR indicates that a form error has
     * been detected by the receiver node in a CAN frame - a fixed-form bit
     * field contains at least one illegal bit.
     */
    LLCE_ERROR_BCAN_FRMERR,
    /**
     * @brief CAN firmware error: STFERR indicates that a stuffing error has
     * been detected by the receiver node in a CAN frame.
     */
    LLCE_ERROR_BCAN_STFERR,
    /**
     * @brief CAN firmware error: TDC mechanism is out of range, 
     * unable to compensate the transceiver's loop delay.
     */
    LLCE_ERROR_BCAN_TDCFAIL,
    /**
     * @brief CAN firmware error: DataLost event caused by BCAN RX Fifo
     * Overrun.
     */
    LLCE_ERROR_BCAN_RXFIFO_OVERRUN,
    /**
     * @brief CAN firmware error: Reports data lost event due to resources
     * exceeded after the frame was received
     */
    LLCE_ERROR_DATA_LOST,
    /** @brief CAN firmware error: The number of Message Buffers available for transmission arbitration was exceeded or the status register indicates that the TXLUT accelerator is full. */
    LLCE_ERROR_TXLUT_FULL,
    /** @brief CAN firmware error: A command with an unknown id was issued or the current host tried to overlap the other host's resources at initialization. */
    LLCE_ERROR_CMD_PROCESSING,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_1,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read or write operation on RXLUT registers. */
    LLCE_ERROR_RXLUT_ACCESS_MODE,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read or write operation on RXLUT registers. */
    LLCE_ERROR_RXLUT_SEARCH_MODE,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read on RXLUT registers and no value was obtained within a configured timeout. */
    LLCE_ERROR_RXLUT_SLOW_OPERATION,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read on the RXLUT status register during search operation and no value was obtained within a configured timeout. */
    LLCE_ERROR_RXLUT_INCOMPLETE_OP,
    /** @brief CAN firmware error: Indicates hardware malfunction when trying to perform a read on the RXLUT status register during flush operation and no value was obtained within a configured timeout. */
    LLCE_ERROR_RXLUT_OPERATING_MODE,
    /** @brief CAN firmware error: Failed to configure the filter entry address and issue write command. */
    LLCE_ERROR_RXLUT_INIT_SLOW_OP,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_2,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_3,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_4,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_5,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_6,
    /** @brief CAN firmware error: Controller is not started or bus-off event has occured. */
    LLCE_ERROR_CTRL_NOT_READY,
    /** @brief CAN firmware error: A bus off event was triggered.
     * This notification is skipped in case of auto-recovery.
     */
    LLCE_ERROR_BUSOFF,
    /** @brief CAN firmware error: Logging FIFO is full. */
    LLCE_ERROR_FIFO_LOG_FULL,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_7,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_8,
    /**
     * @brief CAN firmware error: Error reported due to the rx core not
     * responding.
     */
    LLCE_ERROR_COMMAND_RXPPE_NORESPONSE,
    /**
     * @brief CAN firmware error: Error reported due to frpe core not
     * responding.
     */
    LLCE_ERROR_COMMAND_AF_NORESPONSE,
    /**
     * @brief CAN firmware error: Error reported because the controller is
     * not stopped.
     */
    LLCE_ERROR_COMMAND_DEINIT_NOTSTOP,
    /**
     * @brief CAN firmware error: Error reported because the host didn't
     * read all the RX tokens (indexes in fifos). LLCE waits for indexes
     * to be read and returned.
     */
    LLCE_ERROR_RXTOKENS_UNRETURNED,
    /**
     * @brief CAN firmware error: Error reported because the host didn't
     * read all the ACKs (indexes in fifos). LLCE waits for indexes to be
     * read.
     */
    LLCE_ERROR_TXACK_NOT_READ,
    /**
     * @brief CAN firmware error: Error reported because the requested
     * command is not in the list of supported commands.
     */
    LLCE_ERROR_COMMAND_NOTSUPPORTED,
    /**
     * @brief CAN firmware error: Error reported because command is not
     * validated by the command flow.
     */
    LLCE_ERROR_COMMAND_NOTVALIDATED,
    /**
     * @brief CAN firmware error: Error reported because the requested
     * command is correct but it not accepted.
     */
    LLCE_ERROR_COMMAND_NOTACCEPTED,
    /**
     * @brief CAN firmware error: Error reported because the requested
     * command parameters are invalid.
     */
    LLCE_ERROR_COMMAND_INVALID_PARAMS,
    /** @brief CAN firmware error: Reserved for future use. */
    LLCE_ERROR_CODE_RESERVED_9,
    /**
     * @brief CAN firmware error: Reports frame accepted, but not delivered
     * to host because of filters misconfiguration.
     */
    LLCE_ERROR_FRAME_NOT_DELIVERED,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_10,
    /**
     * @brief CAN firmware error: Reports frame accepted, but not delivered
     * to host due to lack of descriptors in software FIFO.
     */
    LLCE_ERROR_FRAME_NOT_DELIVERED_TO_HOST,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_12,
    /**
     * @brief CAN firmware error: Error reported because there are no
     * filters available to be set for a specific controller.
     */
    LLCE_ERROR_FILTERS_FULL,
    /**
     * @brief CAN firmware error: The filter pointed by the related address
     * is not used by the related controller.
     */
    LLCE_ERROR_FILTERS_NOTEXIST,
    /** @brief CAN firmware error: There are no free configuration filters.
     */
    LLCE_ERROR_FILTERS_MASK_EMPTY,
    /** @brief CAN firmware error: There are no free configuration filters.
     */
    LLCE_ERROR_FILTERS_RANGE_EMPTY,
    /** @brief CAN firmware error: There are no free exact match filters. */
    LLCE_ERROR_FILTERS_EM_EMPTY,
    /** @brief CAN firmware error: The index returned by host is not valid, possibly a duplicate index. */
    LLCE_ERROR_IDX_NOT_VALID_HOST,
    /** @brief CAN firmware error: The index returned by logging is not valid, the associated destination didn't match.
     */
    LLCE_ERROR_IDX_NOT_VALID_LOG,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_13,
    /**
     * @brief CAN firmware error: Reserved for future use.
     * to HSE because of full FIFO.
     */
    LLCE_ERROR_CODE_RESERVED_14,
    /**
     * @brief CAN firmware error: Tx frame was dropped because MAC generation failed.
     */
    LLCE_ERROR_TXFRAME_MAC_GEN_ERROR,
    /**
     * @brief CAN firmware error: Rx frame was dropped because it is not
     * authentic.
     */
    LLCE_ERROR_RXFRAME_AUTH_ERROR,
    /**
     * @brief CAN firmware error: Reserved for future use.
     * TX core.
     */
    LLCE_ERROR_CODE_RESERVED_16,
    /**
     * @brief CAN firmware error: Reserved for future use.
     */
    LLCE_ERROR_CODE_RESERVED_17,
    /** @brief CAN firmware error: RX Software FIFO is empty. */
    LLCE_ERROR_RX_SW_FIFO_EMPTY,
    /** @brief AF error : error communicating with PFE due to PFE internal error*/
    LLCE_ERROR_PFEIF,
    /** @brief AF error : error communicating with HSE due to HSE internal error*/
    LLCE_ERROR_HSEIF,
    /**
     * @brief Generic firmware code: Command was executed successfully by
     * LLCE Firmware.
     */
    LLCE_FW_SUCCESS,
    /**
     * @brief Generic firmware error: During command execution
     * an error condition was detected.
     */
    LLCE_FW_ERROR,
    /**
     * @brief Generic firmware code: Default value of command return
     * status, set by the host before to send it to LLCE firmware.
     */
    LLCE_FW_NOTRUN,
    /**
     * @brief CAN firmware error: Internal Descriptor was not returned
     * to the source.
     */
    LLCE_ERROR_INTERNALDESC_NOT_RETURNED,
    /**
     * @brief CAN firmware error: Internal Descriptor was not delivered
     * to the destination.
     */
    LLCE_ERROR_INTERNALDESC_NOT_DELIVERED,
    /**
     * @brief CAN firmware error: Internal Descriptor is not available because 
     * the internal LLCE software FIFO is empty.
     */
    LLCE_ERROR_INTERNALDESC_NOTAVAIL,
    /**
     * @brief CAN firmware error: Internal Descriptor software FIFO is full.
     */
    LLCE_ERROR_INTERNALDESC_FIFO_FULL,
    /** @brief CAN firmware error: Message Buffer is not available.
     * the internal message buffer software FIFO is empty.
     */
    LLCE_ERROR_MB_NOTAVAIL,
    /** @brief CAN firmware error: Message Buffer software FIFO is full. */
    LLCE_ERROR_MB_FIFO_FULL,
    /**
     * @brief CAN firmware error: Maximum number of Tx MB per controller for
     * AF is reached.
     */
    LLCE_ERROR_NO_MB_AVAILABLE,
    /** @brief CAN firmware error: The source of the request did not match any of the LLCE cores ids. */
    LLCE_ERROR_UNKNOWN_SRC,
    /** @brief CAN firmware error: Unknown destination of the request : it's neither a CAN or ETHERNET channel, nor the host. */
    LLCE_ERROR_UNKNOWN_DEST,
    /** @brief CAN firmware error: Unknown request in intercore communication. */
    LLCE_ERROR_UNKNOWN_REQUEST,
    /** @brief CAN firmware error: Issued for frames with DLC greater than 8 where destination is not FD . */
    LLCE_ERROR_CONVERSION,
    /**
     * @brief CAN firmware error: AbortMB request failed due to no pending
     * transmission that can be aborted.
     */
    LLCE_ERROR_NO_MB_TO_ABORT,
    /**
     * @brief CAN firmware error: Index not recovered from DTE after Stop
     * or busoff event.
     */
    LLCE_ERROR_INDEX_NOT_RECOVERED,
    /** @brief CAN firmware error: The controller did not exit from freeze mode within a conifgured timeout. */
    LLCE_ERROR_RESET_PENDING,
    /** @brief CAN firmware fatal error: core has entered an error state and is not recoverable. */
    LLCE_ERROR_FATAL,
    /** @brief CAN firmware notification: BCAN is ready to leave bus-off
     * state after the automatic recovery procedure
     */
    LLCE_NOTIF_BUSOFF_DONE,
    /** @brief CAN firmware error: TXWRN is set when the Tx error counter ECR[TEC] reached 96. */
    LLCE_ERROR_BCAN_TXWRN,
    /** @brief CAN firmware error: RXWRN is set when the Rx error counter ECR[REC] reached 96. */
    LLCE_ERROR_BCAN_RXWRN,
    /** @brief CAN firmware error: PASSERR is set when BCAN enters Passive state. */
    LLCE_ERROR_BCAN_PASSERR,
    /** @brief CAN firmware notification: BCAN exits Passive state. */
    LLCE_NOTIF_BCAN_EXIT_PASSIVE_STATE,
    /** @brief CAN firmware notification: There was an attempt to perform routing to a disabled destination. */
    LLCE_ERROR_ROUTINGCHANNEL_DISABLED,
    /** @brief CAN firmware notification: Shutdown request received from host. */
    LLCE_SHUTDOWN_REQUESTED,
    /** @brief CAN firmware notification: Core has entered shutdown state. */
    LLCE_SHUTDOWN_ENTERED,
    /** @brief CAN firmware notification: Core has received an unexpected event during shutdown and
     * is halted but awake */
    LLCE_SHUTDOWN_FAILED,
    /** @brief Number of enum elements. It must be kept as the last member of the list. */
    LLCE_FW_RETURNTYPE_COUNT

} Llce_Fw_ReturnType;

/*==================================================================================================
 *                                STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/
/**
 * @brief Boot sequence data type.
 *
 * Data type used to access shared memory area for managing LLCE boot sequence
 **/

typedef struct
{
    /**
     * @brief OUTPUT: Boot Status of TXPPE. This can be NOTRUN, SUCCESS, or
     * a specific ERROR information
     */
    Llce_Fw_ReturnType eTxBootStatus;
    /**
     * @brief OUTPUT: Boot Status of RXPPE. This can be NOTRUN, SUCCESS, or
     * a specific ERROR information
     */
    Llce_Fw_ReturnType eRxBootStatus;
    /**
     * @brief OUTPUT: Boot Status of RXPPE. This can be NOTRUN, SUCCESS, or
     * a specific ERROR information
     */
    Llce_Fw_ReturnType eDteBootStatus;
    /**
     * @brief OUTPUT: Boot Status of RXPPE. This can be NOTRUN, SUCCESS, or
     * a specific ERROR information
     */
    Llce_Fw_ReturnType eFrpeBootStatus;
    /** @brief OUTPUT: LLCE FW version structure. */
    Llce_Fw_VersionType LlceFwVersion;

} LLCE__ALIGNED__PACKED Llce_Mgr_StatusType;

/**
 * @brief Structure for the timestamps of cores 1, 2, and 3
 * 
 * Structure contains the timestamps for the cores 1, 2, and 3 and shall be 
 * read by host in order to verify if a crash, or high delay has occurred or not.
 **/
typedef struct
{
    /** @brief Timestamp for Core 1. */
    uint32 timeStampCore1;
    /** @brief Timestamp for Core 2. */
    uint32 timeStampCore2;
    /** @brief Timestamp for Core 3. */
    uint32 timeStampCore3;
} LLCE__ALIGNED__PACKED Llce_Mgr_TimeStampCoresType;


#ifdef CHECK_ABI_COMPATIBILITY
#pragma ABICHECK stop
#endif
/*==================================================================================================
 *                                GLOBAL VARIABLE DECLARATIONS
 ==================================================================================================*/

/*==================================================================================================
 *                                    FUNCTION PROTOTYPES
 ==================================================================================================*/

 /** @brief   Helper function that returns the category of a value returned by the LLCE FW.
 *   @details Determines the category of a value returned by the LLCE Firmware.
 *            It can take as input errors, notifications and status values (see Llce_Fw_ReturnType).
 *            It will return the category that value belongs to.
 *   @param[in] eNotificationCode CAN error, notification or status values as they are reported by the LLCE firmware.
 *   @return CAN firmware notification category.
 */
static inline Llce_Fw_Notification_Category Llce_GetNotificationCategory(Llce_Fw_ReturnType eNotificationCode)
{
    Llce_Fw_Notification_Category eNotifCategory;

    switch(eNotificationCode)
    {
        case LLCE_ERROR_BUSOFF:
        case LLCE_NOTIF_BUSOFF_DONE:
            eNotifCategory = LLCE_NOTIFCAT_BUSOFF;
            break;

        /* Treat all the cases leading to DATA_LOST which should be reported to the host */
        case LLCE_ERROR_RXOUT_FIFO_FULL:
        case LLCE_ERROR_MB_NOTAVAILABLE:
        case LLCE_ERROR_BCAN_RXFIFO_OVERRUN:
            eNotifCategory = LLCE_NOTIFCAT_DATA_LOST;
            break;

        /* Can protocol errors */
        case LLCE_ERROR_BCAN_TDCFAIL:
        case LLCE_ERROR_BCAN_ACKERR:
        case LLCE_ERROR_BCAN_CRCERR:
        case LLCE_ERROR_BCAN_BIT0ERR:
        case LLCE_ERROR_BCAN_BIT1ERR:
        case LLCE_ERROR_BCAN_DPBIT0ERR:
        case LLCE_ERROR_BCAN_DPBIT1ERR:
        case LLCE_ERROR_BCAN_STFERR:
        case LLCE_ERROR_BCAN_FRMERR:
        case LLCE_ERROR_BCAN_DPSTFERR:
        case LLCE_ERROR_BCAN_DPFRMERR:
        case LLCE_ERROR_BCAN_DPCRCERR:
        case LLCE_ERROR_BCAN_UNKNOWN_ERROR:
        case LLCE_ERROR_BCAN_FRZ_EXIT:
        case LLCE_ERROR_BCAN_SYNC:
        case LLCE_ERROR_BCAN_FRZ_ENTER:
        case LLCE_ERROR_BCAN_LPM_EXIT:
        case LLCE_ERROR_BCAN_SRT_ENTER:
        case LLCE_NOTIF_BCAN_EXIT_PASSIVE_STATE:
            eNotifCategory = LLCE_NOTIFCAT_CAN_PROTOCOL;
            break;
        case LLCE_ERROR_BCAN_TXWRN:
        case LLCE_ERROR_BCAN_RXWRN:
        case LLCE_ERROR_BCAN_PASSERR:
            eNotifCategory = LLCE_NOTIFCAT_CAN_PROTOCOL_CRITICAL_STATE;
            break;

        /* Initialization errors. This category contains errors caused by bad usage or a
           malicious host (eg initialization errors, bad cmd parameters, invalid indexes etc). */
        case LLCE_ERROR_COMMAND_NOTSUPPORTED:
        case LLCE_ERROR_COMMAND_NOTACCEPTED:
        case LLCE_ERROR_COMMAND_INVALID_PARAMS:
        case LLCE_ERROR_RXTOKENS_UNRETURNED:
        case LLCE_ERROR_FILTERS_NOTEXIST:
        case LLCE_ERROR_FILTERS_FULL:
        case LLCE_ERROR_CMD_PROCESSING:
        case LLCE_ERROR_TXACK_NOT_READ:
        case LLCE_ERROR_COMMAND_DEINIT_NOTSTOP:
            eNotifCategory = LLCE_NOTIFCAT_CONFIGURATION;
            break;

        /* Values that are neither errors nor notifications. */
        case LLCE_FW_SUCCESS:
        case LLCE_FW_ERROR:
        case LLCE_FW_NOTRUN:
            eNotifCategory = LLCE_NOTIFCAT_FW_STATUS;
            break;

        default:
            eNotifCategory = LLCE_NOTIFCAT_INTERNAL;
            break;
    }

    return eNotifCategory;
}


#ifdef __cplusplus
}
#endif

#endif /* LLCE_INTERFACEFWMGR_H */

/** @} */


===== 文件 [93/112]: source&include\include\Llce_InterfaceIcsr.h =====
/**
 *   @file    Llce_InterfaceIcsr.h
 *
 *   @brief   This file contains defines used for accessing ICSR hw module
 *   @details This file contains defines used for accessing ICSR hw module
 *
 *   @addtogroup LLCE_CAN_firmware_interface LLCE CAN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_INTERFACEICSR_H
#define LLCE_INTERFACEICSR_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __DOXYGEN__
/**
 * @page misra_violations MISRA-C:2012 violations
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 4.9, A function should be used in
 * preference to a function-like macro where they are interchangeable. Function
 * like macro are used to reduce code complexity
 *
 * @section [global]
 * Violates MISRA 2012 Advisory Rule 2.5, A project should not contain unused
 * macro declarations Some macros are used either in FW or driver, or provided
 * as API
 *
 */
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/

/*==================================================================================================
 *                              SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                     FILE VERSION CHECKS
 ==================================================================================================*/

/*==================================================================================================
 *                                          CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                      DEFINES AND MACROS
 ==================================================================================================*/

/*==================================================================================================
                  INTERRUPT CONCENTRATOR DEFINES AND ADDRESS
 CALCULATION MACROS
 =================================================================================================*/
#define LLCE_ICSR_ADDR(u8RegNo)                                                \
    ((uint32)LLCE_ICSR_BASEADDR + ((uint32)(u8RegNo) * (uint32)4U))
#define LLCE_ICSR_RIFA16_U32 ((uint32)0x00000001U)
#define LLCE_ICSR_ROFA16_U32 ((uint32)0x00000010U)
#define LLCE_ICSR_TAFA16_U32 ((uint32)0x00000001U)

#define LLCE_ICSR_GF0AINT_U32 ((uint32)0x00000001U)
#define LLCE_ICSR_GF1AINT_U32 ((uint32)0x00000002U)
#define LLCE_ICSR_GF2AINT_U32 ((uint32)0x00000004U)
#define LLCE_ICSR_GF3AINT_U32 ((uint32)0x00000008U)
#define LLCE_ICSR_GF0BINT_U32 ((uint32)0x00000010U)
#define LLCE_ICSR_GF1BINT_U32 ((uint32)0x00000020U)
#define LLCE_ICSR_GF2BINT_U32 ((uint32)0x00000040U)
#define LLCE_ICSR_GF3BINT_U32 ((uint32)0x00000080U)

#define LLCE_ICSR_INTFLAG_00 (0x01U)
#define LLCE_ICSR_INTFLAG_01 (0x02U)
#define LLCE_ICSR_INTFLAG_02 (0x04U)
#define LLCE_ICSR_INTFLAG_03 (0x08U)
#define LLCE_ICSR_INTFLAG_04 (0x10U)
#define LLCE_ICSR_INTFLAG_05 (0x20U)
#define LLCE_ICSR_INTFLAG_06 (0x40U)
#define LLCE_ICSR_INTFLAG_07 (0x80U)

/*==================================================================================================
 *                                      Interrupts
 ==================================================================================================*/

/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/*==================================================================================================
 *                                STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/

/*==================================================================================================
 *                                GLOBAL VARIABLE DECLARATIONS
 ==================================================================================================*/

/*==================================================================================================
 *                                    FUNCTION PROTOTYPES
 ==================================================================================================*/

#ifdef __cplusplus
}
#endif

#endif /* LLCE_INTERFACEICSR_H */

/** @} */


===== 文件 [94/112]: source&include\include\Llce_InterfaceMemLayoutCheck.h =====

/**
 *   @file    Llce_InterfaceMemLayoutCheck.h
 *
 *   @brief   LLCE defines provided to cross check memory layout
 *   @details This file contains defines meant to cross check
 *              the memory layout by using compile-time operators sizeof and offsetof.
 *              If the size or offset of any member in a structure/union does not correspond
 *              to the expected precalculated value, the compiling process of host
 *              application which integrates Llce_Interface*.h fails. 
 *
 *   @addtogroup LLCE_CAN_firmware_interface LLCE CAN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2021-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/
#ifndef LLCE_INTERFACEMEMLAYOUTCHECK_H
#define LLCE_INTERFACEMEMLAYOUTCHECK_H

#ifndef DISABLE_MEM_LAYOUT_CHECK

#include <stddef.h>
#include "Llce_InterfaceCanTypes.h"

/**
 * @brief This macro extracts the member from a structure
*/
#define MEMBER_OF(type,member) (((type *)(void *)0)->member)

/**
 * @brief LLCE_INTERFACE_STATIC_ASSERT macro produces error when the compiler generated size for a datatype 
    does not match the expected value. This makes the datatypes size compatible with the firmware binary image.
*/
#define LLCE_INTERFACE_STATIC_ASSERT(condition) extern uint8 LLCE_CHECK_TYPE_SIZE[(condition) ? 1 : -1]


LLCE_INTERFACE_STATIC_ASSERT(sizeof(Can_Af_DestRulesType) == 40U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Can_Af_DestRulesType,AfDest)) == 36U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Can_Af_DestRulesType,AfDest) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Can_Af_DestRulesType,eAfDestId)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Can_Af_DestRulesType,eAfDestId) == 36U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_AbortMbCmdType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AbortMbCmdType,u16FrameTag)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AbortMbCmdType,u16FrameTag) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AbortMbCmdType,u8AbortedFrameCnt)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AbortMbCmdType,u8AbortedFrameCnt) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AbortMbCmdType,eAbortMbType)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AbortMbCmdType,eAbortMbType) == 3U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_AdvancedFeatureType) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFeatureType,eCanAuthenticationFeature)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFeatureType,eCanAuthenticationFeature) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFeatureType,eHostReceive)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFeatureType,eHostReceive) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFeatureType,eCanLoggingFeature)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFeatureType,eCanLoggingFeature) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFeatureType,eCanCustomProcessing)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFeatureType,eCanCustomProcessing) == 3U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFeatureType,u8Can2CanRoutingTableIdx)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFeatureType,u8Can2CanRoutingTableIdx) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFeatureType,u8Can2EthRoutingTableIdx)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFeatureType,u8Can2EthRoutingTableIdx) == 5U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFeatureType,u8OtherRoutingTableIdx)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFeatureType,u8OtherRoutingTableIdx) == 6U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_AdvancedFilterType) == 28U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFilterType,Llce_Can_RxFilter)) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFilterType,Llce_Can_RxFilter) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AdvancedFilterType,Llce_Can_AdvancedFeature)) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AdvancedFilterType,Llce_Can_AdvancedFeature) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_AuxFilterType) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AuxFilterType,uIdMask)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AuxFilterType,uIdMask) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AuxFilterType,uMessageId)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AuxFilterType,uMessageId) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AuxFilterType,u16AuxSearchResult)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AuxFilterType,u16AuxSearchResult) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_AuxFilterType,eEntryType)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_AuxFilterType,eEntryType) == 10U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_Can2CanRoutingTableType) == 28U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2CanRoutingTableType,u32Can2CanRoutingOptions)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2CanRoutingTableType,u32Can2CanRoutingOptions) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2CanRoutingTableType,u32CanIdRemapValue)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2CanRoutingTableType,u32CanIdRemapValue) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2CanRoutingTableType,u8DestHwChList)) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2CanRoutingTableType,u8DestHwChList) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2CanRoutingTableType,u8DestHwChListCount)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2CanRoutingTableType,u8DestHwChListCount) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_Can2EthRoutingTableType) == 36U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,pu8Can2EthBuffAddr)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,pu8Can2EthBuffAddr) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u16Can2EthBuffSize)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u16Can2EthBuffSize) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u8Can2EthBuffCount)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u8Can2EthBuffCount) == 6U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,eFormat)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,eFormat) == 7U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u8Can2EthDestMac)) == 6U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u8Can2EthDestMac) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u8Can2EthSrcMac)) == 6U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u8Can2EthSrcMac) == 14U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u8Can2EthDstIp)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u8Can2EthDstIp) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u8Can2EthSrcIp)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u8Can2EthSrcIp) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u8Can2EthDstPort)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u8Can2EthDstPort) == 28U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u8Can2EthSrcPort)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u8Can2EthSrcPort) == 30U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2EthRoutingTableType,u16Can2EthPhyIfList)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2EthRoutingTableType,u16Can2EthPhyIfList) == 32U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_Can2HseRoutingTableType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2HseRoutingTableType,u32Can2HseKeyHandle)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2HseRoutingTableType,u32Can2HseKeyHandle) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_Can2PcieRoutingTableType) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2PcieRoutingTableType,u64Can2PcieRcBuffAddr)) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2PcieRoutingTableType,u64Can2PcieRcBuffAddr) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2PcieRoutingTableType,pu8Can2PcieBuffAddr)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2PcieRoutingTableType,pu8Can2PcieBuffAddr) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2PcieRoutingTableType,u16Can2PcieBuffSize)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2PcieRoutingTableType,u16Can2PcieBuffSize) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieBuffCount)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieBuffCount) == 14U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieController)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieController) == 15U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieDmaChannel)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieDmaChannel) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieMsiId)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Can2PcieRoutingTableType,u8Can2PcieMsiId) == 17U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_ChangeFilterType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ChangeFilterType,u16FilterAddr)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ChangeFilterType,u16FilterAddr) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ChangeFilterType,u8FilterEnabled)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ChangeFilterType,u8FilterEnabled) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_ChannelErrorNotifType) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ChannelErrorNotifType,ErrorInfo)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ChannelErrorNotifType,ErrorInfo) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ChannelErrorNotifType,u8HwCtrl)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ChannelErrorNotifType,u8HwCtrl) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_CommandListType) == 404U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,Init)) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,Init) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,GetStatus)) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,GetStatus) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,SetFilter)) == 404U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,SetFilter) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,SetAdvancedFilter)) == 228U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,SetAdvancedFilter) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,ChangeFilter)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,ChangeFilter) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,SetBaudrate)) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,SetBaudrate) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,GetControllerMode)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,GetControllerMode) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,SetControllerMode)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,SetControllerMode) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,GetFwVersion)) == 52U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,GetFwVersion) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,InitPlatform)) == 192U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,InitPlatform) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,InitPfe)) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,InitPfe) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,InitPfeWithExternRing)) == 36U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,InitPfeWithExternRing) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,CreateAfDest)) == 44U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,CreateAfDest) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,RemoveAfDest)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,RemoveAfDest) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,AbortMb)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,AbortMb) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,pCustomCmdArg)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,pCustomCmdArg) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,SetAuxFilter)) == 244U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,SetAuxFilter) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,eBinaryValue)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,eBinaryValue) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandListType,SetEth2CanFormatState)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandListType,SetEth2CanFormatState) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_CommandType) == 408U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandType,CmdList)) == 404U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandType,CmdList) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandType,eCmdId)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandType,eCmdId) == 404U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CommandType,eReturnValue)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CommandType,eReturnValue) == 405U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_ControllerFdConfigType) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ControllerFdConfigType,u32DataBaudrateConfig)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ControllerFdConfigType,u32DataBaudrateConfig) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ControllerFdConfigType,u8FdEnable)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ControllerFdConfigType,u8FdEnable) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ControllerFdConfigType,u8ControllerTxBitRateSwitch)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ControllerFdConfigType,u8ControllerTxBitRateSwitch) == 5U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ControllerFdConfigType,u8TrcvDelayCompEnable)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ControllerFdConfigType,u8TrcvDelayCompEnable) == 6U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ControllerFdConfigType,u8TrcvDelayMeasEnable)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ControllerFdConfigType,u8TrcvDelayMeasEnable) == 7U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ControllerFdConfigType,u8TrcvDelayCompOffset)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ControllerFdConfigType,u8TrcvDelayCompOffset) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_CreateAfDestination) == 44U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CreateAfDestination,rule)) == 40U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CreateAfDestination,rule) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CreateAfDestination,u8Idx)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CreateAfDestination,u8Idx) == 40U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_CtrlModeNotifType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CtrlModeNotifType,eControllerState)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CtrlModeNotifType,eControllerState) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_CtrlModeNotifType,u8HwCtrl)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_CtrlModeNotifType,u8HwCtrl) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_ErrorCategoryType) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorCategoryType,eCanProtocolErr)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorCategoryType,eCanProtocolErr) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorCategoryType,eDataLostErr)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorCategoryType,eDataLostErr) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorCategoryType,eInitErr)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorCategoryType,eInitErr) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorCategoryType,eInternalErr)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorCategoryType,eInternalErr) == 3U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorCategoryType,eBusOffErr)) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorCategoryType,eBusOffErr) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorCategoryType,eCanProtocolWarn)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorCategoryType,eCanProtocolWarn) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_ErrorNotifType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorNotifType,eModuleId)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorNotifType,eModuleId) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorNotifType,eErrorCode)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorNotifType,eErrorCode) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ErrorNotifType,u16ErrorCount)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ErrorNotifType,u16ErrorCount) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_GetControllerModeCmdType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_GetControllerModeCmdType,eControllerState)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_GetControllerModeCmdType,eControllerState) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_GetStatusCmdType) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_GetStatusCmdType,u32ECR)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_GetStatusCmdType,u32ECR) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_GetStatusCmdType,u32ISR)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_GetStatusCmdType,u32ISR) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_GetStatusCmdType,u32SR)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_GetStatusCmdType,u32SR) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_GetStatusCmdType,u32CRC)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_GetStatusCmdType,u32CRC) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_InitCmdType) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitCmdType,u32CtrlConfig)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitCmdType,u32CtrlConfig) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitCmdType,u8TxMbCount)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitCmdType,u8TxMbCount) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_InitPfeCmdType) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,pRxRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,pRxRing) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,pRxWbRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,pRxWbRing) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,pTxRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,pTxRing) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,pTxWbRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,pTxWbRing) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,pRxBuffers)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,pRxBuffers) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,u16RxBufSize)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,u16RxBufSize) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,u8RxBufCount)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,u8RxBufCount) == 22U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeCmdType,u8Hif)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeCmdType,u8Hif) == 23U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_InitPfeWithExternRingCmdType) == 36U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,pRxRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,pRxRing) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,pRxWbRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,pRxWbRing) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,pTxRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,pTxRing) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,pTxWbRing)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,pTxWbRing) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,pRxBuffers)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,pRxBuffers) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,u32RingSize)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,u32RingSize) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,pHeader)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,pHeader) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,u16RxBufSize)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,u16RxBufSize) == 28U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,u8RxBufCount)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,u8RxBufCount) == 30U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,u8HeaderSize)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,u8HeaderSize) == 31U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPfeWithExternRingCmdType,u8Hif)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPfeWithExternRingCmdType,u8Hif) == 32U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_InitPlatformCmdType) == 192U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,eCtrlInitStatus)) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,eCtrlInitStatus) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,au16MaxRegularFilterCount)) == 32U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,au16MaxRegularFilterCount) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,au16MaxAdvancedFilterCount)) == 32U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,au16MaxAdvancedFilterCount) == 48U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,au16MaxIntMbCount)) == 32U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,au16MaxIntMbCount) == 80U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,au16MaxPollMbCount)) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,au16MaxPollMbCount) == 112U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,au16MaxIntTxAckCount)) == 32U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,au16MaxIntTxAckCount) == 124U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,au16MaxPollTxAckCount)) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,au16MaxPollTxAckCount) == 156U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_InitPlatformCmdType,CanErrorReporting)) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_InitPlatformCmdType,CanErrorReporting) == 168U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_MbType) == 76U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_MbType,u32Word0)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_MbType,u32Word0) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_MbType,u32Word1)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_MbType,u32Word1) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_MbType,u8Payload)) == 64U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_MbType,u8Payload) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_MbType,u32Timestamp)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_MbType,u32Timestamp) == 72U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_NotificationListType) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_NotificationListType,CtrlMode)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_NotificationListType,CtrlMode) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_NotificationListType,PlatformError)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_NotificationListType,PlatformError) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_NotificationListType,ChannelError)) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_NotificationListType,ChannelError) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_NotificationTableType) == 816U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_NotificationTableType,Can_aNotif0_Table)) == 408U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_NotificationTableType,Can_aNotif0_Table) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_NotificationTableType,Can_aNotif1_Table)) == 408U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_NotificationTableType,Can_aNotif1_Table) == 408U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_NotificationType) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_NotificationType,NotifList)) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_NotificationType,NotifList) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_NotificationType,eNotifId)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_NotificationType,eNotifId) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_ReceiveFilterType) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,uIdMask)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,uIdMask) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,uMessageId)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,uMessageId) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,u16FilterId)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,u16FilterId) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,u16MbCount)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,u16MbCount) == 10U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,u16FilterAddr)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,u16FilterAddr) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,u8RxDestInterface)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,u8RxDestInterface) == 14U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,eEntryType)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,eEntryType) == 15U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ReceiveFilterType,eFilterMbLength)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ReceiveFilterType,eFilterMbLength) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_RxMbDescriptorType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxMbDescriptorType,u16FilterId)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxMbDescriptorType,u16FilterId) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxMbDescriptorType,u16AuxSearchResult)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxMbDescriptorType,u16AuxSearchResult) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_RxTxCountType) == 40U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32GeneralRxCount)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32GeneralRxCount) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32GeneralTxCount)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32GeneralTxCount) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32Can2CanInCount)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32Can2CanInCount) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32Can2CanOutCount)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32Can2CanOutCount) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32Can2EthCount)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32Can2EthCount) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32Eth2CanCount)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32Eth2CanCount) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32ReservedCount1)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32ReservedCount1) == 24U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32ReservedCount2)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32ReservedCount2) == 28U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32ReservedCount3)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32ReservedCount3) == 32U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_RxTxCountType,u32ReservedCount4)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_RxTxCountType,u32ReservedCount4) == 36U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_SetAdvancedFilterCmdType) == 228U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetAdvancedFilterCmdType,aAdvancedFilters)) == 224U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetAdvancedFilterCmdType,aAdvancedFilters) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetAdvancedFilterCmdType,u16RxFiltersCount)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetAdvancedFilterCmdType,u16RxFiltersCount) == 224U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_SetAuxFilterCmdType) == 244U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetAuxFilterCmdType,aRxAuxFilters)) == 240U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetAuxFilterCmdType,aRxAuxFilters) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetAuxFilterCmdType,u16RxAuxFiltersCount)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetAuxFilterCmdType,u16RxAuxFiltersCount) == 240U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_SetBaudrateCmdType) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetBaudrateCmdType,u32NominalBaudrateConfig)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetBaudrateCmdType,u32NominalBaudrateConfig) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetBaudrateCmdType,ControllerFD)) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetBaudrateCmdType,ControllerFD) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_SetControllerModeCmdType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetControllerModeCmdType,eTransition)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetControllerModeCmdType,eTransition) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_SetEth2CanFormatStateCmdType) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetEth2CanFormatStateCmdType,eFormat)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetEth2CanFormatStateCmdType,eFormat) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetEth2CanFormatStateCmdType,eState)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetEth2CanFormatStateCmdType,eState) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_SetFilterCmdType) == 404U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetFilterCmdType,aRxFilters)) == 400U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetFilterCmdType,aRxFilters) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SetFilterCmdType,u16RxFiltersCount)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SetFilterCmdType,u16RxFiltersCount) == 400U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_SharedMemoryType) == 242928U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SharedMemoryType,Can_Rx_aMbDesc)) == 16512U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SharedMemoryType,Can_Rx_aMbDesc) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SharedMemoryType,Can_Tx_aMbDesc)) == 2048U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SharedMemoryType,Can_Tx_aMbDesc) == 16512U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SharedMemoryType,Can_aMb)) == 170544U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SharedMemoryType,Can_aMb) == 18560U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SharedMemoryType,Can_aSMb)) == 47920U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SharedMemoryType,Can_aSMb) == 189104U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SharedMemoryType,aCanCmd)) == 816U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SharedMemoryType,aCanCmd) == 237024U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SharedMemoryType,Can_NotificationTable)) == 816U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SharedMemoryType,Can_NotificationTable) == 237840U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_SharedMemoryType,Can_Tx_aAckInfo)) == 4272U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_SharedMemoryType,Can_Tx_aAckInfo) == 238656U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_ShortMbType) == 20U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ShortMbType,u32Word0)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ShortMbType,u32Word0) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ShortMbType,u32Word1)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ShortMbType,u32Word1) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ShortMbType,u8Payload)) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ShortMbType,u8Payload) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_ShortMbType,u32Timestamp)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_ShortMbType,u32Timestamp) == 16U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_Tx2HostAckInfoType) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Tx2HostAckInfoType,u32TxTimestamp)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Tx2HostAckInfoType,u32TxTimestamp) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Tx2HostAckInfoType,u16FrameTag1)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Tx2HostAckInfoType,u16FrameTag1) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_Tx2HostAckInfoType,u16FrameTag2)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_Tx2HostAckInfoType,u16FrameTag2) == 6U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Can_TxMbDescriptorType) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_TxMbDescriptorType,u16FrameTag1)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_TxMbDescriptorType,u16FrameTag1) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_TxMbDescriptorType,u16FrameTag2)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_TxMbDescriptorType,u16FrameTag2) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_TxMbDescriptorType,u16MbFrameIdx)) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_TxMbDescriptorType,u16MbFrameIdx) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_TxMbDescriptorType,u8AckInterface)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_TxMbDescriptorType,u8AckInterface) == 6U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Can_TxMbDescriptorType,u8EnableTxFrameMac)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Can_TxMbDescriptorType,u8EnableTxFrameMac) == 7U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Fw_VersionType) == 52U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Fw_VersionType,stringLength)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Fw_VersionType,stringLength) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Fw_VersionType,versionString)) == 50U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Fw_VersionType,versionString) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Mgr_StatusType) == 56U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_StatusType,eTxBootStatus)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_StatusType,eTxBootStatus) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_StatusType,eRxBootStatus)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_StatusType,eRxBootStatus) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_StatusType,eDteBootStatus)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_StatusType,eDteBootStatus) == 2U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_StatusType,eFrpeBootStatus)) == 1U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_StatusType,eFrpeBootStatus) == 3U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_StatusType,LlceFwVersion)) == 52U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_StatusType,LlceFwVersion) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(Llce_Mgr_TimeStampCoresType) == 12U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_TimeStampCoresType,timeStampCore1)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_TimeStampCoresType,timeStampCore1) == 0U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_TimeStampCoresType,timeStampCore2)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_TimeStampCoresType,timeStampCore2) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(sizeof(MEMBER_OF(Llce_Mgr_TimeStampCoresType,timeStampCore3)) == 4U);
LLCE_INTERFACE_STATIC_ASSERT(offsetof(Llce_Mgr_TimeStampCoresType,timeStampCore3) == 8U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIFCAT_CAN_PROTOCOL == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIFCAT_DATA_LOST == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIFCAT_CONFIGURATION == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIFCAT_INTERNAL == 4U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIFCAT_BUSOFF == 5U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIFCAT_FW_STATUS == 6U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIFCAT_CAN_PROTOCOL_CRITICAL_STATE == 7U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_TXACK_FIFO_FULL == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXOUT_FIFO_FULL == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_0 == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_HW_FIFO_FULL == 4U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_SW_FIFO_EMPTY == 5U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_SW_FIFO_FULL == 6U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_MB_NOTAVAILABLE == 7U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_SHORT_MB_NOTAVAILABLE == 8U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_FRZ_EXIT == 9U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_SYNC == 10U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_FRZ_ENTER == 11U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_LPM_EXIT == 12U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_SRT_ENTER == 13U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_UNKNOWN_ERROR == 14U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_ACKERR == 15U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_CRCERR == 16U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_BIT0ERR == 17U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_BIT1ERR == 18U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_DPBIT1ERR == 19U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_DPBIT0ERR == 20U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_DPSTFERR == 21U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_DPFRMERR == 22U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_DPCRCERR == 23U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_FRMERR == 24U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_STFERR == 25U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_TDCFAIL == 26U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_RXFIFO_OVERRUN == 27U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_DATA_LOST == 28U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_TXLUT_FULL == 29U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CMD_PROCESSING == 30U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_1 == 31U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXLUT_ACCESS_MODE == 32U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXLUT_SEARCH_MODE == 33U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXLUT_SLOW_OPERATION == 34U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXLUT_INCOMPLETE_OP == 35U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXLUT_OPERATING_MODE == 36U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXLUT_INIT_SLOW_OP == 37U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_2 == 38U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_3 == 39U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_4 == 40U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_5 == 41U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_6 == 42U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CTRL_NOT_READY == 43U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BUSOFF == 44U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FIFO_LOG_FULL == 45U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_7 == 46U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_8 == 47U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_COMMAND_RXPPE_NORESPONSE == 48U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_COMMAND_AF_NORESPONSE == 49U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_COMMAND_DEINIT_NOTSTOP == 50U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXTOKENS_UNRETURNED == 51U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_TXACK_NOT_READ == 52U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_COMMAND_NOTSUPPORTED == 53U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_COMMAND_NOTVALIDATED == 54U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_COMMAND_NOTACCEPTED == 55U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_COMMAND_INVALID_PARAMS == 56U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_9 == 57U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FRAME_NOT_DELIVERED == 58U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_10 == 59U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FRAME_NOT_DELIVERED_TO_HOST == 60U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_12 == 61U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FILTERS_FULL == 62U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FILTERS_NOTEXIST == 63U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FILTERS_MASK_EMPTY == 64U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FILTERS_RANGE_EMPTY == 65U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FILTERS_EM_EMPTY == 66U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_IDX_NOT_VALID_HOST == 67U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_IDX_NOT_VALID_LOG == 68U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_13 == 69U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_14 == 70U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_TXFRAME_MAC_GEN_ERROR == 71U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RXFRAME_AUTH_ERROR == 72U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_16 == 73U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CODE_RESERVED_17 == 74U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RX_SW_FIFO_EMPTY == 75U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_PFEIF == 76U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_HSEIF == 77U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_FW_SUCCESS == 78U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_FW_ERROR == 79U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_FW_NOTRUN == 80U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_INTERNALDESC_NOT_RETURNED == 81U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_INTERNALDESC_NOT_DELIVERED == 82U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_INTERNALDESC_NOTAVAIL == 83U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_INTERNALDESC_FIFO_FULL == 84U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_MB_NOTAVAIL == 85U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_MB_FIFO_FULL == 86U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_NO_MB_AVAILABLE == 87U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_UNKNOWN_SRC == 88U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_UNKNOWN_DEST == 89U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_UNKNOWN_REQUEST == 90U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_CONVERSION == 91U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_NO_MB_TO_ABORT == 92U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_INDEX_NOT_RECOVERED == 93U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_RESET_PENDING == 94U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_FATAL == 95U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIF_BUSOFF_DONE == 96U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_TXWRN == 97U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_RXWRN == 98U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_BCAN_PASSERR == 99U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_NOTIF_BCAN_EXIT_PASSIVE_STATE == 100U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_ERROR_ROUTINGCHANNEL_DISABLED == 101U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SHUTDOWN_REQUESTED == 102U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SHUTDOWN_ENTERED == 103U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SHUTDOWN_FAILED == 104U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_FW_RETURNTYPE_COUNT == 105U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE0 == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE1 == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE2 == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE3 == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE4 == 4U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE5 == 5U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE6 == 6U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE7 == 7U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE8 == 8U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE9 == 9U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE10 == 10U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE11 == 11U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE12 == 12U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE13 == 13U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE14 == 14U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE15 == 15U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE16 == 16U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE17 == 17U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE18 == 18U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE19 == 19U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE20 == 20U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE21 == 21U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE22 == 22U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE23 == 23U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE24 == 24U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE25 == 25U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE26 == 26U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE27 == 27U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE28 == 28U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE29 == 29U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE30 == 30U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE31 == 31U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE32 == 32U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE33 == 33U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE34 == 34U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE35 == 35U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE36 == 36U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE37 == 37U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE38 == 38U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE39 == 39U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE40 == 40U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE41 == 41U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE42 == 42U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE43 == 43U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE44 == 44U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE45 == 45U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE46 == 46U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE47 == 47U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE48 == 48U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE49 == 49U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE50 == 50U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE51 == 51U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE52 == 52U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE53 == 53U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE54 == 54U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE55 == 55U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE56 == 56U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE57 == 57U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE58 == 58U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE59 == 59U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE60 == 60U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE61 == 61U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE62 == 62U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_SEMA42_GATE63 == 63U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_NOTIF_NOERROR == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_NOTIF_PLATFORMERROR == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_NOTIF_CHANNELERROR == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_NOTIF_CTRLMODE == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_INIT == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_DEINIT == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETBAUDRATE == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_GETCONTROLLERMODE == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETCONTROLLERMODE == 4U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_MANUAL_BUSOFF_RECOVERY == 5U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_GETSTATUS == 6U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETFILTER == 7U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETADVANCEDFILTER == 8U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETFILTERENABLESTATUS == 9U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_REMOVE_FILTER == 10U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_GETFWVERSION == 11U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_INIT_PLATFORM == 12U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_INIT_PLATFORM_COMMON == 13U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_DEINIT_PLATFORM == 14U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_INIT_PFE == 15U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_INIT_PFE_EXT_RING_BUF == 16U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_INIT_HSE == 17U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_CREATE_AF_DESTINATION == 18U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_ABORT_MB == 19U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_CUSTOM == 20U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETAUXFILTER == 21U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETFILTER_AT_ADDRESS == 22U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETCHANNELROUTINGOUTPUTSTATE == 23U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETCAN2ETHSTATE == 24U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETETH2CANFORMATSTATE == 25U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETADVANCEDFILTER_AT_ADDRESS == 26U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SETCAN2PCIESTATE == 27U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_SHUTDOWN == 28U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_CMD_REMOVE_AF_DESTINATION == 29U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_EXTENDED == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_STANDARD == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_MIXED == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_T_STOP == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_T_START == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_UNINIT_CTRL == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_UNINIT_CTRL_PENDING == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_STOP_PENDING == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_BUSOFF_PENDING == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_STOPPED == 4U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_START_PENDING == 5U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_STARTED == 6U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_IDLE == 7U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_UNINIT_PLATFORM == 8U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_TX == 101U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_RX == 102U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_DTE == 103U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_FRPE == 104U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN2CAN_TX == 105U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN2CAN_RX == 106U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN2CAN_FRPE == 107U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_ETH_TX == 108U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_ETH_RX == 109U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_ETH_FRPE == 110U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_HSE_TX == 111U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_HSE_RX == 112U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_HSE_FRPE == 113U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_TX == 114U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_RX == 115U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_FRPE == 116U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_LOGGING_DISABLED == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_LOGGING_ENABLED == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_HOSTRECEIVE_DISABLED == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_HOSTRECEIVE_ENABLED == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_AUTHENTICATION_DISABLED == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_AUTHENTICATION_ENABLED == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_AUTHENTICATION_NOT_SUPPORTED == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CUSTOMPROCESSING_DISABLED == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CUSTOMPROCESSING_ENABLED == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_ENTRY_EXACT_MATCH == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_ENTRY_CFG_MASKED == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_CAN_ENTRY_CFG_RANGED == 2U);
LLCE_INTERFACE_STATIC_ASSERT(CAN_AF_CAN2CAN == 0U);
LLCE_INTERFACE_STATIC_ASSERT(CAN_AF_CAN2ETH == 1U);
LLCE_INTERFACE_STATIC_ASSERT(CAN_AF_CAN2PCIE == 2U);
LLCE_INTERFACE_STATIC_ASSERT(CAN_AF_CAN2HSE == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CAN2AVTP_NTSCF_BRIEF == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CAN2AVTP_NTSCF_FULL == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CAN2AVTP_TSCF_BRIEF == 2U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CAN2AVTP_TSCF_FULL == 3U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CAN2UDP == 4U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CAN2UDP_B == 5U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_AF_CAN2ETH_FORMAT_MAX == 6U);
LLCE_INTERFACE_STATIC_ASSERT(INITIALIZED == 1U);
LLCE_INTERFACE_STATIC_ASSERT(UNINITIALIZED == 2U);
LLCE_INTERFACE_STATIC_ASSERT(IGNORE == 1U);
LLCE_INTERFACE_STATIC_ASSERT(NOTIF_FIFO0 == 2U);
LLCE_INTERFACE_STATIC_ASSERT(NOTIF_FIFO1 == 3U);
LLCE_INTERFACE_STATIC_ASSERT(ABORT_ONLY_ONE_MB == 0U);
LLCE_INTERFACE_STATIC_ASSERT(ABORT_ALL_MB == 1U);
LLCE_INTERFACE_STATIC_ASSERT(USE_LONG_MB == 0U);
LLCE_INTERFACE_STATIC_ASSERT(USE_SHORT_MB == 1U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_FALSE == 0U);
LLCE_INTERFACE_STATIC_ASSERT(LLCE_TRUE == 1U);

#endif /*DISABLE_MEM_LAYOUT_CHECK*/

#endif /*LLCE_INTERFACEMEMLAYOUTCHECK_H*/

/** @} */


===== 文件 [95/112]: source&include\include\Llce_RegAccess.h =====
/**
 *   @file    Llce_RegAccess.h
 *
 *   @brief   This file contains functions used for reading and writing
 *            registers
 *   @details This file contains functions used for reading and writing
 *            registers
 *
 *   @addtogroup LLCE_CAN_firmware_interface LLCE CAN firmware interface
 *   @{
 */
/*==================================================================================================
 *
 * Copyright 2018-2023 NXP
 *
 * NXP Confidential. This software is owned or controlled by NXP and may only be
 * used strictly in accordance with the applicable license terms. By expressly
 * accepting such terms or by downloading, installing, activating and/or
 * otherwise using the software, you are agreeing that you have read, and that
 * you agree to comply with and are bound by, such license terms.  If you do not
 * agree to be bound by the applicable license terms, then you may not retain,
 * install, activate or otherwise use the software.
 ==================================================================================================*/

#ifndef LLCE_REGACCESS_H
#define LLCE_REGACCESS_H

#ifdef __cplusplus
extern "C" {
#endif

/*==================================================================================================
 *                                        INCLUDE FILES
 * 1) system and project includes
 * 2) needed interfaces from external units
 * 3) internal and external interfaces from this unit
 ==================================================================================================*/
/**
 * @file        Llce_RegAccess.h
 * @brief Include platform types
 */
#include "PlatformTypes.h"

/*==================================================================================================
 *                               SOURCE FILE VERSION INFORMATION
 ==================================================================================================*/

/*==================================================================================================
 *                                           CONSTANTS
 ==================================================================================================*/

/*==================================================================================================
 *                                       DEFINES AND MACROS
 ==================================================================================================*/
 #if defined(LDRA) || defined(__DOXYGEN__)
     /* Workaround for Doxygen and LDRA tools not to see packed keyword */
      #define LLCE__PACKED
 #else
     #define LLCE__PACKED __attribute__((packed))
 #endif

 #if defined(__DOXYGEN__)
     /* Workaround for Doxygen not to see attribute keyword */
      #define LLCE__ALIGNED__PACKED

     /* Common defines for standard version. Meant to be used by Doxygen*/
     #define S32G2 ON
  
     #define CANETH_ENABLE ON
 
     #define CAN2CAN_ENABLE ON

     #define LIN_ENABLE ON

     #define CANHSE_ENABLE ON

     #define LOGGING_ENABLE ON

     #define AF_ENABLE ON
 #else
     #define LLCE__ALIGNED__PACKED __attribute__((aligned(4), packed))
 #endif
/*==================================================================================================
 *                                             ENUMS
 ==================================================================================================*/

/*==================================================================================================
 *                                 STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/

/*==================================================================================================
 *                                 STRUCTURES AND OTHER TYPEDEFS
 ==================================================================================================*/

/*==================================================================================================
 *                                     FUNCTION PROTOTYPES
 ==================================================================================================*/

/**
 * @brief 8 bits memory write function
 */
static inline void Reg_Write8(uint32 address, uint8 value)
{
    *(volatile uint8 *)(address) = value;
}

/**
 * @brief 16 bits memory write function.
 */
static inline void Reg_Write16(uint32 address, uint16 value)
{
    *(volatile uint16 *)(address) = value;
}

/**
 * @brief 32 bits memory write function.
 */
static inline void Reg_Write32(uint32 address, uint32 value)
{
    *(volatile uint32 *)(address) = value;
}

/**
 * @brief 8 bits memory read function.
 */
static inline uint8 Reg_Read8(uint32 address)
{
    return (*(volatile uint8 *)(address));
}

/**
 * @brief 16 bits memory read function.
 */
static inline uint16 Reg_Read16(uint32 address)
{
    return (*(volatile uint16 *)(address));
}

/**
 * @brief 32 bits memory read function.
 */
static inline uint32 Reg_Read32(uint32 address)
{
    return (*(volatile uint32 *)(address));
}

/**
 * @brief 8 bits indexed memory write function.
 * Index i must have the data type uint32.
 */
static inline void Reg_Awrite8(uint32 address, uint32 i, uint8 value)
{
    *(volatile uint8 *)(address + i) = value;
}

/**
 * @brief 16 bits indexed memory write function.
 * Index i must have the data type uint32.
 */
static inline void Reg_Awrite16(uint32 address, uint32 i, uint16 value)
{
    *(volatile uint16 *)(address + i) = value;
}

/**
 * @brief 32 bits indexed memory write function.
 * Index i must have the data type uint32.
 */
static inline void Reg_Awrite32(uint32 address, uint32 i, uint32 value)
{
    *(volatile uint32 *)(address + i) = value;
}

/**
 * @brief 8 bits indexed memory read function.
 * Index i must have the data type uint32.
 */
static inline uint8 Reg_Aread8(uint32 address, uint32 i)
{
    return (*(volatile uint8 *)(address + i));
}

/**
 * @brief 16 bits indexed memory read function.
 * Index i must have the data type uint32.
 */
static inline uint16 Reg_Aread16(uint32 address, uint32 i)
{
    return (*(volatile uint16 *)(address + ((uint32)(i << 1U))));
}

/**
 * @brief 32 bits indexed memory read function.
 * Index i must have the data type uint32.
 */
static inline uint32 Reg_Aread32(uint32 address, uint32 i)
{
    return (*(volatile uint32 *)(address + ((uint32)(i << 2U))));
}

/**
 * @brief 8 bits bits clearing function.
 */
static inline void Reg_Bit_Clear8(uint32 address, uint8 mask)
{
    (*(volatile uint8 *)(address)) &= (~(mask));
}

/**
 * @brief 16 bits bits clearing function.
 */
static inline void Reg_Bit_Clear16(uint32 address, uint16 mask)
{
    (*(volatile uint16 *)(address)) &= (~(mask));
}

/**
 * @brief 32 bits bits clearing function.
 */
static inline void Reg_Bit_Clear32(uint32 address, uint32 mask)
{
    (*(volatile uint32 *)(address)) &= (~(mask));
}

/**
 * @brief 8 bits bits getting function.
 */
static inline uint8 Reg_Bit_Get8(uint32 address, uint8 mask)
{
    return ((*(volatile uint8 *)(address)) & (mask));
}

/**
 * @brief 16 bits bits getting function.
 */
static inline uint16 Reg_Bit_Get16(uint32 address, uint16 mask)
{
    return ((*(volatile uint16 *)(address)) & (mask));
}

/**
 * @brief 32 bits bits getting function.
 */
static inline uint32 Reg_Bit_Get32(uint32 address, uint32 mask)
{
    return ((*(volatile uint32 *)(address)) & (mask));
}

/**
 * @brief 8 bits bits setting function.
 */
static inline void Reg_Bit_Set8(uint32 address, uint8 mask)
{
    *(volatile uint8 *)(address) |= mask;
}

/**
 * @brief 16 bits bits setting function.
 */
static inline void Reg_Bit_Set16(uint32 address, uint16 mask)
{
    *(volatile uint16 *)(address) |= mask;
}

/**
 * @brief 32 bits bits setting function.
 */
static inline void Reg_Bit_Set32(uint32 address, uint32 mask)
{
    *(volatile uint32 *)(address) |= mask;
}

/**
 * @brief 8 bit clear bits and set with new value
 * @note In the current implementation, it is caller's (user's) responsibility
 *       to make sure that value has only "mask" bits set - (value&~mask)==0
 */
static inline void Reg_Rmw8(uint32 address, uint8 mask, uint8 value)
{
    *(volatile uint8 *)(address) =
        (*(volatile uint8 *)(address) & ((uint8) ~(mask))) | value;
}

/**
 * @brief 16 bit clear bits and set with new value
 * @note In the current implementation, it is caller's (user's) responsibility
 *       to make sure that value has only "mask" bits set - (value&~mask)==0
 */
static inline void Reg_Rmw16(uint32 address, uint16 mask, uint16 value)
{
    *(volatile uint16 *)(address) =
        (*(volatile uint16 *)(address) & ((uint16) ~(mask))) | value;
}

/**
 * @brief 32 bit clear bits and set with new value
 * @note In the current implementation, it is caller's (user's) responsibility
 *       to make sure that value has only "mask" bits set - (value&~mask)==0
 */
static inline void Reg_Rmw32(uint32 address, uint32 mask, uint32 value)
{
    *(volatile uint32 *)(address) =
        (*(volatile uint32 *)(address) & ((uint32) ~(mask))) | value;
}

#ifdef __cplusplus
}
#endif

#endif /* #ifndef LLCE_REGACCESS_H */

/** @} */


===== 文件 [96/112]: source&include\include\Llce_Sema42.h =====
/**
*   @addtogroup LLCE_IP_Drivers
*   @{
*   @addtogroup LLCE_SEMA42
*   @{
*   
*   @brief   Semaphores2 (SEMA42) module data structures and defines
*   @details This file contains the Semaphores2 (SEMA42) data structures, defines and function declarations.
*
*/
/*==================================================================================================
*
* Copyright 2018-2023 NXP 
* 
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in 
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/

#ifndef LLCE_SEMA42_H
#define LLCE_SEMA42_H

#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

#ifdef CHECK_ABI_COMPATIBILITY
#pragma ABICHECK start
#endif
/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/
#define LLCE_SEMA42_BASEADDR            ((uint32)0x43C20000UL)
#define LLCE_SEMA42_GR(gate)            ((uint32)(LLCE_SEMA42_BASEADDR + (uint32)(((uint32)(gate) & 0x3FU))))

#define LLCE_SEMA42_GR_GTFSM_0          (0x0U)
#define LLCE_SEMA42_GR_GTFSM_1          (0x1U)
#define LLCE_SEMA42_GR_GTFSM_2          (0x2U)
#define LLCE_SEMA42_GR_GTFSM_3          (0x3U)
#define LLCE_SEMA42_GR_GTFSM_4          (0x4U)
#define LLCE_SEMA42_GR_GTFSM_5          (0x5U)
#define LLCE_SEMA42_GR_GTFSM_6          (0x6U)
#define LLCE_SEMA42_GR_GTFSM_7          (0x7U)
#define LLCE_SEMA42_GR_GTFSM_8          (0x8U)
#define LLCE_SEMA42_GR_GTFSM_9          (0x9U)
#define LLCE_SEMA42_GR_GTFSM_10         (0xAU)
#define LLCE_SEMA42_GR_GTFSM_11         (0xBU)
#define LLCE_SEMA42_GR_GTFSM_12         (0xCU)
#define LLCE_SEMA42_GR_GTFSM_13         (0xDU)
#define LLCE_SEMA42_GR_GTFSM_14         (0xEU)
#define LLCE_SEMA42_GR_GTFSM_15         (0xFU)
/*==================================================================================================
*                                      Interrupts
==================================================================================================*/

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/   
/** @brief    Gate numbers used by sema42 module to lock and unlock gates.
 *  @details  Gate numbers used by sema42 module to lock and unlock gates.
 **/
typedef enum LLCE__PACKED
{
    LLCE_SEMA42_GATE0   =  0UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE1   =  1UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE2   =  2UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE3   =  3UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE4   =  4UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE5   =  5UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE6   =  6UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE7   =  7UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE8   =  8UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE9   =  9UL,          /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE10  =  10UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE11  =  11UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE12  =  12UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE13  =  13UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE14  =  14UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE15  =  15UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE16  =  16UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE17  =  17UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE18  =  18UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE19  =  19UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE20  =  20UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE21  =  21UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE22  =  22UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE23  =  23UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE24  =  24UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE25  =  25UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE26  =  26UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE27  =  27UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE28  =  28UL,         /**< @brief Sema42 Gate *//*free*/
    LLCE_SEMA42_GATE29  =  29UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE30  =  30UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE31  =  31UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE32  =  32UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE33  =  33UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE34  =  34UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE35  =  35UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE36  =  36UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE37  =  37UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE38  =  38UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE39  =  39UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE40  =  40UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE41  =  41UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE42  =  42UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE43  =  43UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE44  =  44UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE45  =  45UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE46  =  46UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE47  =  47UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE48  =  48UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE49  =  49UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE50  =  50UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE51  =  51UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE52  =  52UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE53  =  53UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE54  =  54UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE55  =  55UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE56  =  56UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE57  =  57UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE58  =  58UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE59  =  59UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE60  =  60UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE61  =  61UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE62  =  62UL,         /**< @brief Sema42 Gate */
    LLCE_SEMA42_GATE63  =  63UL,         /**< @brief Sema42 Gate */    

} Llce_Sema42_GateType;

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

#ifdef CHECK_ABI_COMPATIBILITY
#pragma ABICHECK stop
#endif
/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/
  
/*==================================================================================================
*                                     INLINE FUNCTION
==================================================================================================*/
/*================================================================================================*/
/** 
* @brief Lock Sema42 gate
* @details The function locks specific sema42 gate.
*/
/*================================================================================================*/
static inline void Llce_Sema42_Lock(Llce_Sema42_GateType eGate, uint8 u8Domain)
{
    /* Lock the semaphore */
    do
    {
        Reg_Write8(LLCE_SEMA42_GR(eGate), u8Domain);
    } while (u8Domain != Reg_Read8(LLCE_SEMA42_GR(eGate)));    

}

/*================================================================================================*/
/** 
* @brief Unlock Sema42 gate
* @details The function unlocks specific sema42 gate.
*/
/*================================================================================================*/
static inline void Llce_Sema42_Unlock(Llce_Sema42_GateType eGate)
{
    /* Unlock the semaphore */
    Reg_Write8(LLCE_SEMA42_GR(eGate), LLCE_SEMA42_GR_GTFSM_0);
}


#ifdef __cplusplus
}
#endif

#endif /* LLCE_SEMA42_H */

/** @} */
/** @} */


===== 文件 [97/112]: source&include\include\Llce_SwFifo.h =====
/**
*   
*   @brief   LLCE Generic Software Fifo enums and data structures
*   @details This file contains the Generic Software Fifo data types.
*
*   @addtogroup LLCE_SwFifo
*   @{
*/
/*==================================================================================================
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifndef LLCE_SWFIFO_H
#define LLCE_SWFIFO_H


#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

#include "Llce_InterfaceCanTypes.h"
#include "StandardTypes.h"
#include "Can_43_LLCE_Cfg.h"
/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/

/*==================================================================================================
*                                      Interrupts
==================================================================================================*/

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/
#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
typedef enum 
{
    LLCE_SWFIFO_FULL,
    LLCE_SWFIFO_EMPTY, 
    LLCE_SWFIFO_OPERATIONAL
} Llce_SwFifo_StatusType;

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

typedef struct
{   
    uint8 *pu8BaseAddr;
    uint16 u16WrByteIdx;
    uint16 u16RdByteIdx;
    uint16 u16MaxNElements;
    uint8  u8ElemSize;
    Llce_SwFifo_StatusType eFifoStatus;
} Llce_SwFifo_Type;

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/

/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/
Llce_Fw_ReturnType Llce_SwFifo_Init(void *pu8BaseAddr, uint8 u8ElemSize, uint16 u16MaxNElements, Llce_SwFifo_Type *pLlce_SwFifo);

Llce_Fw_ReturnType Llce_SwFifo_Push(const void *pGenericElem, Llce_SwFifo_Type *pLlce_SwFifo);

Llce_Fw_ReturnType Llce_SwFifo_Pop(void *pGenericElem, Llce_SwFifo_Type *pLlce_SwFifo);
#endif

#ifdef __cplusplus
}
#endif

#endif /* LLCE_SWFIFO_H */

/** @} */


===== 文件 [98/112]: source&include\include\Reg_eSys_Llce.h =====
/**
*   @file    Reg_eSys_Llce.h
*   @implements Reg_eSys_Llce.h_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - S32Gxx Llce Defines and Macros Definitions.
*   @details Header file for S32Gxx Llce Defines and Macros Definitions.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*   
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/


#ifndef REG_ESYS_LLCE_H
#define REG_ESYS_LLCE_H

#ifdef __cplusplus
extern "C" {
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Llce_InterfaceCanTypes.h"
#include "Can_43_LLCE_Cfg.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/

/*==================================================================================================
                BIT MASKS FOR SHIFTING BCAN REGISTER VALUES
==================================================================================================*/
/**
* @brief Define used for Can_43_LLCE_ControllerDescriptorType.u8ControllerOffset when controller is not enabled.
*/
#define LLCE_NULL_OFFSET_U8              (0xFFU)

/**
* @brief Defines used to check specific field of the LPDU frame exchanged with upper software layers.
*/
#define CAN_LPDU_ID_MASK_U32              ((uint32)0x3FFFFFFFU)

#define CAN_LPDU_IDE_U32                  ((uint32)0x80000000U)

#define CAN_LPDU_FD_U32                   ((uint32)0x40000000)       

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/


/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/

#ifdef __cplusplus
}
#endif

#endif /*TEMPLATE_H*/

/** @} */


===== 文件 [99/112]: source&include\src\Can_43_LLCE.c =====
/**
*   @internal
*   @file    Can_43_LLCE.c
*   @implements Can.c_Artifact
*   @version 1.0.10
*   @file    Can_43_LLCE.c
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details API implementation for CAN driver.
*
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/


#ifdef __cplusplus
extern "C"{
#endif


/*
Driver Limitations:
    1. The maximum number of Can_43_LLCE_DisableControllerInterrupts levels of nesting is 255.
    2. This file contains 2 types of functions: first are the Autosar APIs and then are some user defined functions.
*/


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
/*
* @file           Can_43_LLCE.c
*/
#include "Can_43_LLCE.h"
#include "Can_43_LLCE_IPW.h"
#include "CanIf_Can.h"
#include "CanIf.h"
#include "Std_Types.h"

#include "SchM_Can_43_LLCE.h"

#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
#include "Det.h"
#endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/*  (CAN111) Can_43_LLCE.c shall check if the correct version of Can_43_LLCE.h is included.
            This shall be done by a preprocessor check of the version numbers CAN_43_LLCE_SW_MAJOR_VERSION, CAN_43_LLCE_SW_MINOR_VERSION and CAN_43_LLCE_SW_PATCH_VERSION.
*/
/**
* @file           Can_43_LLCE.c
*/
#define CAN_43_LLCE_VENDOR_ID_C                      43
#define CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C       4
#define CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_C       4
#define CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_C    0
#define CAN_SW_MAJOR_VERSION_C               1
#define CAN_SW_MINOR_VERSION_C               0
#define CAN_SW_PATCH_VERSION_C               10


/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/
/* Check if current file and CAN header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID_C != CAN_43_LLCE_VENDOR_ID)
    #error "Can_43_LLCE.c and Can_43_LLCE.h have different vendor ids"
#endif
/* Check if current file and CAN header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C    != CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_C    != CAN_43_LLCE_AR_RELEASE_MINOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_C != CAN_43_LLCE_AR_RELEASE_REVISION_VERSION))
    #error "AutoSar Version Numbers of Can_43_LLCE.c and Can_43_LLCE.h are different"
#endif
/* Check if current file and CAN header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_C != CAN_43_LLCE_SW_MAJOR_VERSION) || \
     (CAN_SW_MINOR_VERSION_C != CAN_43_LLCE_SW_MINOR_VERSION) || \
     (CAN_SW_PATCH_VERSION_C != CAN_43_LLCE_SW_PATCH_VERSION))
    #error "Software Version Numbers of Can_43_LLCE.c and Can_43_LLCE.h are different"
#endif


/* Check if current file and CAN_IPW header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID_C != CAN_IPW_VENDOR_ID_H)
    #error "Can_43_LLCE.c and Can_43_LLCE_IPW.h have different vendor ids"
#endif
/* Check if current file and CAN_IPW header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C    != CAN_IPW_AR_RELEASE_MAJOR_VERSION_H) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_C    != CAN_IPW_AR_RELEASE_MINOR_VERSION_H) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_C != CAN_IPW_AR_RELEASE_REVISION_VERSION_H))
    #error "AutoSar Version Numbers of Can_43_LLCE.c and Can_43_LLCE_IPW.h are different"
#endif
/* Check if current file and CAN_IPW header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_C != CAN_IPW_SW_MAJOR_VERSION_H) || \
     (CAN_SW_MINOR_VERSION_C != CAN_IPW_SW_MINOR_VERSION_H) || \
     (CAN_SW_PATCH_VERSION_C != CAN_IPW_SW_PATCH_VERSION_H))
    #error "Software Version Numbers of Can_43_LLCE.c and Can_43_LLCE_IPW.h are different"
#endif

/* Check if current file and DET header file are of the same version */
#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
  #ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
    #if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C != DET_AR_RELEASE_MAJOR_VERSION) || \
         (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_C != DET_AR_RELEASE_MINOR_VERSION))
        #error "AutoSar Version Numbers of Can_43_LLCE.c and Det.h are different"
    #endif
  #endif
#endif

/* Check if current file and CANIF_CBK header file are of the same version */
#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
  #ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
    #if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C != CANIF_CAN_AR_RELEASE_MAJOR_VERSION) || \
         (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_C != CANIF_CAN_AR_RELEASE_MINOR_VERSION))
        #error "AutoSar Version Numbers of Can_43_LLCE.c and CanIf_Can.h are different"
    #endif
  #endif
#endif

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/
#if (STD_ON == CAN_43_LLCE_PRECOMPILE_SUPPORT)
#define CAN_43_LLCE_START_SEC_CONFIG_DATA_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

#define CAN_43_LLCE_STOP_SEC_CONFIG_DATA_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"
#endif /* (STD_ON == CAN_43_LLCE_PRECOMPILE_SUPPORT) */

#define CAN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

volatile uint16 Can_au16TransmitHwObjectCnt[CAN_43_LLCE_MAXHTH_CONFIGURED];

#define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

#define CAN_43_LLCE_START_SEC_VAR_INIT_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"


/**
* @brief          This variable holds the state of the driver.
* @details        This variable holds the state of the driver. After reset is UNINIT. The output of Can_43_LLCE_Init() function
*                 (only to first call) should set this variable into READY state.
*                  CAN_43_LLCE_UNINIT = The CAN controller is not initialized. All registers belonging to the CAN module are in reset state, CAN interrupts are disabled.
*                  The CAN Controller is not participating on the CAN bus.
*                  The Can module must only implement a variable for the module state, when the development error tracing is switched on.
*                  When the development error tracing is switched off, the Can module does not need to implement this 'state machine',
*                  because the state information is only needed to check if Can_43_LLCE_Init was called prior to any Can module function.
*
*/
Can_43_LLCE_StatusType Can_43_LLCE_eDriverStatus[CAN_43_LLCE_MAX_PARTITIONS];

/* Pointer to the current Driver Configuration (passed to the driver during initialization). Initialized by Can_43_LLCE_Init(). */
const Can_43_LLCE_ConfigType * Can_43_LLCE_pCurrentConfig[CAN_43_LLCE_MAX_PARTITIONS];

#define CAN_43_LLCE_STOP_SEC_VAR_INIT_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"


/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/
#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
static boolean Can_ValidateController(uint8 u8Controller, uint8 u8Sid);
#endif

static Std_ReturnType Can_43_LLCE_SendWriteCmd(Can_HwHandleType Hth, const Can_PduType * PduInfo);

#ifdef CAN_43_LLCE_SET_BAUDRATE_API
#if (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON)
static Std_ReturnType Can_43_LLCE_SendSetBaudrateCmd(uint8 Controller, const uint16 BaudRateConfigID);
#endif
#endif

static void Can_43_LLCE_InitializeControllers(const uint32* u32CoreId);

/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_CODE
#include "Can_43_LLCE_MemMap.h"

static boolean Can_ValidateController(uint8 u8Controller, uint8 u8Sid)
{
    boolean bValid = TRUE;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

#if (CAN_43_LLCE_DEV_ERROR_DETECT != STD_ON)
    /* Suppress warning */
    (void)u8Sid;
#endif

    /* Check if the driver was initialised */
    if (CAN_43_LLCE_UNINIT == Can_43_LLCE_eDriverStatus[u32CoreId] )
    {
        /*
        (CAN089) The Can module environment shall indicate development errors only in the return values of a function of the Can module when DET
                 is switched on and the function provides a return value. The returned value is E_NOT_OK.
        */
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /*
           (CAN198) If development error detection for the Can module is enabled: if the module is not yet initialized, the
                   function Can_43_LLCE_SetControllerMode shall raise development error CAN_43_LLCE_E_UNINIT and return E_NOT_OK.
        */

        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, u8Sid, (uint8)CAN_43_LLCE_E_UNINIT);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

        bValid = FALSE;
    }
    else if ( (u8Controller >= CAN_43_LLCE_MAXCTRL_CONFIGURED) ||
             (CAN_43_LLCE_NULL_OFFSET == (Can_43_LLCE_pCurrentConfig[u32CoreId]->aControllerDescriptors[u8Controller].u8HwCtrl)))
        /* Controller ID must be within range and the selected Controller must be configured for use in the config tool. */
    {
        /*
           (CAN199) If development error detection for the Can module is enabled: if the parameter Controller is out of range,
                   the function Can_43_LLCE_SetControllerMode shall raise development error CAN_43_LLCE_E_PARAM_CONTROLLER and return E_NOT_OK.
        */
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, u8Sid, (uint8)CAN_43_LLCE_E_PARAM_CONTROLLER);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

        bValid = FALSE;
    }
    #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
    else if(Can_43_LLCE_pCurrentConfig[u32CoreId]->aControllerDescriptors[u8Controller].u32CoreId != u32CoreId)
    {
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, u8Sid, (uint8)CAN_43_LLCE_E_PARAM_CONFIG);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

        bValid = FALSE;
    }
    #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
    else
    {
        ;/* Do nothing */
    }
    
    return bValid;
}

static void Can_43_LLCE_InitializeControllers(const uint32* u32CoreId)
{
    /* Variable for indexing the controllers. */
    uint8 can_controller;
    /* Status variable for platform init. */
    Llce_Fw_ReturnType eReturnValue;
                
    eReturnValue = Can_43_LLCE_IPW_Init(Can_43_LLCE_pCurrentConfig[*(u32CoreId)]);

    if(LLCE_FW_SUCCESS == eReturnValue)
    {
        /* Loop through all Can controllers configured based CanControllerId parameter. */
        for (can_controller = 0U; can_controller < CAN_43_LLCE_MAXCTRL_CONFIGURED; can_controller++)
        {
          #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
          if(Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->aControllerDescriptors[can_controller].u32CoreId == *(u32CoreId))
          {
          #endif
            /* The initialization is skipped for the controllers that are not enabled. */
            if (CAN_43_LLCE_NULL_OFFSET != (Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->aControllerDescriptors[can_controller].u8HwCtrl))
            {
                /*
                (CAN250) The function Can_43_LLCE_Init shall initialize: static variables, including flags, Common setting for the
                         complete CAN HW unit, CAN controller specific settings for each CAN controller.
                (CAN245) The function Can_43_LLCE_Init shall initialize all CAN controllers according to their configuration.
                (CAN053) Can module/controller initialization - registers of CAN controller hardware resources that are not used.
                */
                (void)Can_43_LLCE_IPW_ChangeBaudrate( can_controller, Can_43_LLCE_ControllerBaudRateIndexes[can_controller].u8CurrentBaudRateIndex);
            }
          #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
          }
          #endif
        }
        /*
        (CAN246) After initializing all controllers inside the HW Unit, the function Can_43_LLCE_Init shall change the module state to CAN_43_LLCE_READY.
        */
        Can_43_LLCE_eDriverStatus[*(u32CoreId)] = CAN_43_LLCE_READY;

        /*If any of the Error reporting category is set to interrupt, then turn on the unique Interrupt Notif Fifo*/
        if ((NOTIF_FIFO0 == Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->pPlatfInitConfig->CanErrorReporting.eCanProtocolErr) || 
            (NOTIF_FIFO0 == Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->pPlatfInitConfig->CanErrorReporting.eDataLostErr) || 
            (NOTIF_FIFO0 == Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->pPlatfInitConfig->CanErrorReporting.eInitErr) || 
            (NOTIF_FIFO0 == Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->pPlatfInitConfig->CanErrorReporting.eInternalErr) || 
            (NOTIF_FIFO0 == Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->pPlatfInitConfig->CanErrorReporting.eCanProtocolWarn))
        {
            /*Enable the Notif FIFO interrupt after fw initializes the FIFO*/
            Can_43_LLCE_IPW_EnableNotifInterrupt(Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->u8ActiveHif);
        }
    }
}

/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/


/*================================================================================================*/


/*
(CAN252) The function Can_43_LLCE_GetVersionInfo shall be pre compile time configurable (ON/Off) by the configuration parameter: CanVersionInfoApi
*/

#if (CAN_43_LLCE_VERSION_INFO_API == STD_ON)
/**
* @brief          Returns the version information of this module. SID is 0x07
* @details        This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      versioninfo A pointer to location to store version info
*                             Must be omitted if the function does not have parameters.
*
* @return         void
*
*
* @pre            The CAN_43_LLCE_VERSION_INFO_API define must be configured on.
* @post           The version information is return if the parameter versionInfo is not a null pointer.
*
* @implements     Can_GetVersionInfo_Activity
*/
void Can_43_LLCE_GetVersionInfo(Std_VersionInfoType * versioninfo)
{
    if (NULL_PTR == versioninfo)
    {
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /*
        (CAN177) If development error detection for the Can module is enabled: The function Can_43_LLCE_GetVersionInfo shall
                    raise the error CAN_43_LLCE_E_PARAM_POINTER if the parameter versionInfo is a null pointer.
        */
        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_GET_VERSION_INFO, (uint8)CAN_43_LLCE_E_PARAM_POINTER);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

    }
    else
    {
        /*
        (CAN105) The function Can_43_LLCE_GetVersionInfo shall return the version information of this module. The version information
                     includes: Module Id, Vendor Id, Vendor specific version numbers.
        */
        versioninfo->vendorID         = (uint16)CAN_43_LLCE_VENDOR_ID;
        versioninfo->moduleID         = (uint16)CAN_43_LLCE_MODULE_ID;
        versioninfo->sw_major_version = (uint8)CAN_43_LLCE_SW_MAJOR_VERSION;
        versioninfo->sw_minor_version = (uint8)CAN_43_LLCE_SW_MINOR_VERSION;
        versioninfo->sw_patch_version = (uint8)CAN_43_LLCE_SW_PATCH_VERSION;
    }
}
#endif /* (CAN_43_LLCE_VERSION_INFO_API == STD_ON) */

/*================================================================================================*/
/**
* @brief          Initialize the CAN driver. SID is 0x00.
* @details        Initialize all the controllers.
*                 The CAN module shall be initialized by Can_43_LLCE_Init(<&Can_Configuration>) service call during the start-up.
*                 This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      pxConfig Pointer to driver configuration.
*
* @return         void
*
*
* @pre            Can_43_LLCE_Init shall be called at most once during runtime.
* @post           Can_43_LLCE_Init shall initialize all the controllers and set the driver in READY state.
*
* @implements     Can_Init_Activity
*/
void Can_43_LLCE_Init(const Can_43_LLCE_ConfigType * pxConfig)
{

#if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
    boolean bCoreValid = FALSE;
#endif 

    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    if (CAN_43_LLCE_READY == Can_43_LLCE_eDriverStatus[u32CoreId])
    {    
        /*
        (CAN027) Detected development errors shall be reported to the Det_ReportError service of the Development Error Tracer (DET)
                 if the pre-processor switch CanDevErrorDetect is set.
        (CAN083) If the CanDevErrorDetect switch is enabled API parameter checking is enabled.
        (CAN028)Development Errors call the Development Error Tracer when DET is switched on and the Can module detects an error.

        */
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /*
        (CAN247) The Can module environment shall call Can_43_LLCE_Init at most once during runtime.
        (CAN091) After return of the DET the Can module function that raised the development error shall return immediately.
        (CAN174) If development error detection for the Can module is enabled: The function Can_43_LLCE_Init shall raise the
                   error CAN_43_LLCE_E_TRANSITION if the driver is not in 'uninitialized' state.
        (CAN248) The function Can_43_LLCE_Init shall report the error CAN_43_LLCE_E_UNINIT, if Can_43_LLCE_Init was called prior to any Can module function.
        */

        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_INIT, (uint8)CAN_43_LLCE_E_TRANSITION);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
    }
    else
    {
#if (CAN_43_LLCE_PRECOMPILE_SUPPORT == STD_ON)
        if (NULL_PTR != pxConfig)
#else
        if (NULL_PTR == pxConfig)
#endif /* CAN_43_LLCE_PRECOMPILE_SUPPORT */
        {
            #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_INIT, (uint8)CAN_43_LLCE_E_INIT_FAILED);
            #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        }
        else
        {

#if (CAN_43_LLCE_PRECOMPILE_SUPPORT == STD_ON)
    #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            /* Sanity check for Ecuc definitions */
            if(u32CoreId < CAN_43_LLCE_MAX_PARTITIONS)
            {
                /* Update config pointer with default configuration if precompile support on. */
                Can_43_LLCE_pCurrentConfig[u32CoreId] = Can_43_LLCE_Config[u32CoreId];
                bCoreValid = TRUE;
            }
    #else
            /* Update config pointer with default configuration if precompile support on. */
            Can_43_LLCE_pCurrentConfig[u32CoreId] = &Can_43_LLCE_Config;
    #endif /*  (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
            /* Suppress "unused argument" warning */
            (void)pxConfig;
#else
    #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            if((u32CoreId < CAN_43_LLCE_MAX_PARTITIONS) && (pxConfig->u32CoreId == u32CoreId))
            {
    #endif /*  (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
              /* Copy pointer to current Can Driver configuration. */
              Can_43_LLCE_pCurrentConfig[u32CoreId] = pxConfig;
    #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
              bCoreValid = TRUE;
            }
    #endif /*  (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */

#endif /* CAN_43_LLCE_PRECOMPILE_SUPPORT */
    #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            if(TRUE == bCoreValid)
            {
    #endif /*  (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
                /*
                   (CAN239) The function Can_43_LLCE_Init shall initialize all on-chip hardware resources that are used by the CAN controller.
                */
               Can_43_LLCE_InitializeControllers(&u32CoreId);

    #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            }
            else
            {
            #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_INIT, (uint8)CAN_43_LLCE_E_PARAM_CONFIG);
            #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
            }
    #endif /*  (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
        }
    }
}


/*================================================================================================*/
/**
* @brief          De-initialize the CAN driver. SID is 0x10.
* @details        De-initialize all the controllers.
*                 The CAN module shall be de-initialized by Can_DeInit() service call during the start-up.
*                 This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      None
*
* @return         void
*
*
* @pre            Before controller de-initialization, the driver must be initialized and the controllers must be not in Start state.
* @post           Can_DeInit shall de-initialize all the controllers and set the driver in UNINIT state.
*
* @implements     Can_DeInit_Activity
*/
void Can_43_LLCE_DeInit(void)
{
    /* Variable for indexing the controllers. */
    uint8 can_controller = 0U;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    /* Returns the result of CAN APIs */
    Std_ReturnType eReturnGetCtrlModeValue;
    Can_ControllerStateType eCtrlState = CAN_CS_UNINIT;
    
    /* The flag of checking of Can Controller status */
    boolean bIsCanCtrlBusy = FALSE;
    /* Return status */
    Std_ReturnType  eReturnValue;
       
    if (CAN_43_LLCE_READY != Can_43_LLCE_eDriverStatus[u32CoreId])
    {
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /* 
            (SWS_Can_91011) If development error detection for the Can module is enabled: The function Can_DeInit shall raise the error CAN_E_TRANSITION 
            if the driver is not in state CAN_READY.
        */
        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_DEINIT, (uint8)CAN_43_LLCE_E_TRANSITION);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */           
    }
    else
    {
        /* Loop through all Can controllers configured based CanControllerId parameter. */
        for (can_controller = 0U; can_controller < CAN_43_LLCE_MAXCTRL_CONFIGURED; can_controller++)
        {
        #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            if(Can_43_LLCE_pCurrentConfig[u32CoreId]->aControllerDescriptors[can_controller].u32CoreId == u32CoreId)
            {
        #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
                /* Skipping controllers that are not configured. */
                if (CAN_43_LLCE_NULL_OFFSET != (Can_43_LLCE_pCurrentConfig[u32CoreId]->aControllerDescriptors[can_controller].u8HwCtrl))
                {      
                    eReturnGetCtrlModeValue = Can_43_LLCE_IPW_GetControllerMode(can_controller, &eCtrlState);

                    if (((uint8)E_OK == eReturnGetCtrlModeValue) && ( CAN_CS_STARTED == eCtrlState ))
                    {
                        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                        /* 
                            (SWS_Can_91012) If development error detection for the Can module is enabled: The function Can_DeInit shall raise the error CAN_E_TRANSITION 
                            if any of the CAN controllers is in state STARTED.
                        */
                        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_DEINIT, (uint8)CAN_43_LLCE_E_TRANSITION);
                        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */           
                        
                        /* Controller is busy */
                        bIsCanCtrlBusy =  TRUE;

                        /* Skipping the loop if any of Can Controller is in state STARTED */
                        break;
                    }
                }
        #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            }
        #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
        }
        /* No controller is busy */
        if (FALSE == bIsCanCtrlBusy)
        {
            /* Update state of Can driver */
            /* [SWS_Can_ 91009] The function Can_DeInit shall change the module state to
                CAN_UNINIT before de-initializing all controllers inside the HW unit */
            Can_43_LLCE_eDriverStatus[u32CoreId] = CAN_43_LLCE_UNINIT;
            eReturnValue = (Std_ReturnType)E_OK;
            /* Loop through all Can controllers configured based CanControllerId parameter. */
            for ( can_controller = 0U; can_controller < CAN_43_LLCE_MAXCTRL_CONFIGURED; can_controller++)
            {
            #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
                if(Can_43_LLCE_pCurrentConfig[u32CoreId]->aControllerDescriptors[can_controller].u32CoreId == u32CoreId)
                {
            #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
                    /* Skipping controllers that are not configured. */
                    if (((Std_ReturnType)E_OK == eReturnValue) && ( CAN_43_LLCE_NULL_OFFSET != (Can_43_LLCE_pCurrentConfig[u32CoreId]->aControllerDescriptors[can_controller].u8HwCtrl)))
                    {
                            eReturnValue = Can_43_LLCE_IPW_DeInitController(can_controller);
                    }
            #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
                }
            #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
            }
            
            if ((Std_ReturnType)E_OK == eReturnValue)
            {   
                /*Ignore the fw status since the DeInit must be always performed*/
                (void)Can_43_LLCE_IPW_DeInitPlatform();
               
                Can_43_LLCE_pCurrentConfig[u32CoreId] = NULL_PTR;
            }
        }
    }
}

/*================================================================================================*/
/**
* @brief          Shut down LLCE
* @details        Send the shutdown command to LLCE.
*                 Can only be called if both HIFs are deinitialized. LLCE becomes unusable until reset.
*
* @param[in]      None
*
* @return         void
*
*
* @pre            Both LLCE HIFs must be uninitialized 
* @post           LLCE is disabled
*
* @implements     Can_ShutDown_Activity
*/
Std_ReturnType Can_43_LLCE_Shutdown(void)
{
    Std_ReturnType eReturnValue = E_NOT_OK;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    /* It is only possible to check state of current driver */
    /* LLCE will reject the command if the other HIF is active */
    if(CAN_43_LLCE_UNINIT == Can_43_LLCE_eDriverStatus[u32CoreId])
    {
        eReturnValue = Can_43_LLCE_IPW_Shutdown();
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief          Put the controller into a required state. SID is 0x03.
* @details        Switch the controller from one state to another.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller - Can controller for which the status shall be changed - based on configuration order list (CanControllerId).
* @param[in]      Transition - Possible transitions (CAN_CS_STOPPED , CAN_CS_STARTED , CAN_CS_SLEEP , CAN_T_WAKEUP)
* @return         Std_ReturnType  Result of the transition.
* @retval         E_OK   Transition initiated.
* @retval         E_NOT_OK  Development or production error.
*
*
* @pre            Before changing the controller state the driver must be initialized.
* @post           After the transition to the new state the interrupts required for that state must be enabled.
*
* @implements     Can_SetControllerMode_Activity
*/
Std_ReturnType Can_43_LLCE_SetControllerMode(uint8 Controller, Can_ControllerStateType Transition)
{
    /* Returns the result of transition mode. */
    Std_ReturnType  eReturnValue = E_NOT_OK;
    uint8           u8HthIndex = 0U;
    uint8           u8CtrlId = 0U;

    if(TRUE == Can_ValidateController(Controller, (uint8)CAN_43_LLCE_SID_SET_CONTROLLER_MODE))
    {
        if (CAN_CS_STARTED == Transition)
        {
            /* Reset the hw obj count for HTH of  Controller */
            for (u8HthIndex = 0U; u8HthIndex < (uint8)CAN_43_LLCE_MAXHTH_CONFIGURED; u8HthIndex++ )
            {
                u8CtrlId = Can_43_LLCE_GetCurrentConfig()->aHohList[CAN_43_LLCE_FIRST_HTH_CONFIGURED + u8HthIndex].u8ControllerId;
                
                if (Controller == u8CtrlId)
                {
                    /* Copy the number of MB of each HTH. The HTHs are always grouped after the HRHs. */
                    Can_au16TransmitHwObjectCnt[u8HthIndex] = Can_43_LLCE_GetCurrentConfig()->aHohList[CAN_43_LLCE_FIRST_HTH_CONFIGURED + u8HthIndex].u16MbCount;
                }
            }
        }

        /* Call the IPW function for transition execution. */
        eReturnValue = (Std_ReturnType)Can_43_LLCE_IPW_SetControllerMode(Controller, Transition);
    }

    return (eReturnValue);
}

/*================================================================================================*/
/**
* @brief          Reports about the current status of the requested CAN controller. SID is 0x12
* @details        This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller: CAN controller for which the status shall be requested.
*
* @param[out]     ControllerModePtr: Pointer to a memory location, where the current mode of the CAN controller will be stored.
*
* @retval         E_OK : Controller mode request has been accepted.
* @retval         E_NOT_OK : Controller mode request has not been accepted.
*
* @pre            Controller is initialized
* @post           The host has got the current controller state.
*
* @implements     Can_GetControllerMode_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerMode(uint8 Controller, Can_ControllerStateType * ControllerModePtr)
{
    /* Return the result of GetControllerMode */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;

    if(TRUE == Can_ValidateController(Controller, (uint8)CAN_43_LLCE_SID_GETCONTROLLERMODE))
    {
        if (NULL_PTR == ControllerModePtr)
        {
            #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /* 
            [SWS_Can_91018] If parameter ControllerModePtr of Can_GetControllerMode() has an null pointer, 
            the CanDrv shall report development error code CAN_E_PARAM_POINTER to the Det_ReportError service of the DET.
            */
            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_GETCONTROLLERMODE, (uint8)CAN_43_LLCE_E_PARAM_POINTER);
            #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        }
        else
        {
            eReturnValue = Can_43_LLCE_IPW_GetControllerMode(Controller, ControllerModePtr);
        }
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief          Disable INTs. SID is 0x04.
* @details        Switch OFF the controller's interrupts.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller Can controller for which interrupts shall be disabled - based on configuration order list (CanControllerId).
*
* @return         void
*
*
* @pre            Driver must be initalzied before changing the interrupts state (en or dis).
* @post           Controller must not respond to any interrupt assertion.
*
* @implements     Can_DisableControllerInterrupts_Activity
*/
void Can_43_LLCE_DisableControllerInterrupts(uint8 Controller)
{
    if(TRUE == Can_ValidateController(Controller, (uint8)CAN_43_LLCE_SID_DISABLE_CONTROLLER_INTERRUPTS))
    {
        /* Call the IPW function for disabling interrupts. */
        Can_43_LLCE_IPW_DisableControllerInterrupts( Controller);
    }
}


/*================================================================================================*/
/**
* @brief          Enable INTs. SID is 0x05.
* @details        Switch ON the controller's interrupts.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller Can controller for which interrupts shall be disabled - based on configuration order list (CanControllerId).
*
* @return         void
*
*
* @pre            Driver must be initalzied before changing the interrupts state (en or dis).
* @post           Controller must respond to interrupt assertion.
*
* @implements     Can_EnableControllerInterrupts_Activity
*/
void Can_43_LLCE_EnableControllerInterrupts( uint8 Controller)
{
    if(TRUE == Can_ValidateController(Controller, (uint8)CAN_43_LLCE_SID_ENABLE_CONTROLLER_INTERRUPTS))
    {
        /* Call the IPW function for enabling interrupts. */
        Can_43_LLCE_IPW_EnableControllerInterrupts( Controller);
    }
}


/*================================================================================================*/
/**
* @brief          Transmit information on CAN bus. SID is 0x06.
* @details        Can_43_LLCE_Write checks if hardware transmit object that is identified by the HTH is free.
*                    Can_43_LLCE_Write checks if another Can_43_LLCE_Write is ongoing for the same HTH.
*                     a) hardware transmit object is free:
*                         The mutex for that HTH is set to 'signaled' the ID, DLC and SDU are put in a format appropriate for
*                           the hardware (if necessary) and copied in the appropriate hardware registers or buffers.
*                        All necessary control operations to initiate the transmit are done.
*                         The mutex for that HTH is released. The function returns with E_OK.
*                    b) hardware transmit object is busy with another transmit request.
*                         The function returns with CAN_BUSY.
*                     c) A preemptive call of Can_43_LLCE_Write has been issued, that could not be handled reentrant (i.e. a call with the same HTH).
*                        The function returns with CAN_BUSY the function is non blocking
*                     d) The hardware transmit object is busy with another transmit request for an L-PDU that has lower priority than that for the current request
*                        The transmission of the previous L-PDU is cancelled (asynchronously).
*                        The function returns with CAN_BUSY.
*                   This routine is called by:
*                   - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Hth Information which HW-transmit handle shall be used for transmit.
*                 Implicitly this is also the information about the controller to use because the Hth numbers are unique inside one hardware unit.
* @param[in]      PduInfo Pointer to SDU user memory, DLC and Identifier.
* @return         Std_ReturnType   Result of the write operation.
* @retval         E_OK   Write command has been accepted.
* @retval         E_NOT_OK  Development error occurred.
* @retval         CAN_BUSY   No of TX hardware buffer available or preemtive call of Can_43_LLCE_Write() that can't be implemented reentrant.
*
*
* @pre            Driver must be initialized and MB must be configured for Tx.
* @post           The data can be transmitted or rejected because of another data with a higher priority.
*
* @implements     Can_Write_Activity
*/
Std_ReturnType Can_43_LLCE_Write(Can_HwHandleType Hth, const Can_PduType * PduInfo)
{
    /* Variable for return status */
    Std_ReturnType  eReturnValue = E_NOT_OK;

    uint8 u8CtrlId = 0U;
    /* Used to store the FD feature enable or disable. */
    uint8 u8FdEnable;  
    uint8 u8BaudrateIndex = 0U;
    const Can_43_LLCE_ControllerDescriptorType * pxCanControllerDescriptor;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();
    
    /* If Can_43_LLCE_pCurrentConfig[u32CoreId] is NULL_PTR then the driver was not initialised yet. */
    if (CAN_43_LLCE_UNINIT == Can_43_LLCE_eDriverStatus[u32CoreId] )
    {
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /*
           (CAN216) If development error detection for the Can module is enabled: The function Can_43_LLCE_Write shall raise the error CAN_43_LLCE_E_UNINIT if
                   the driver not yet initialized.
        */

        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_WRITE, (uint8)CAN_43_LLCE_E_UNINIT);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
    }
    else
    {
        /* Hth must be below CanMaxObjectId and should be a Tx MB type. */
    #if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0)
        if ( (Hth <  CAN_43_LLCE_FIRST_HTH_CONFIGURED) ||
             (Hth >= CAN_43_LLCE_MAXHOH_CONFIGURED)
           )
    #else
        if (Hth >= CAN_43_LLCE_MAXHOH_CONFIGURED)
    #endif
        {
            #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /*
               (CAN217) If development error detection for the Can module is enabled: The function Can_43_LLCE_Write shall raise the error CAN_43_LLCE_E_PARAM_HANDLE
                       if the parameter Hth is not a configured Hardware Transmit Handle.
            */

            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_WRITE, (uint8)CAN_43_LLCE_E_PARAM_HANDLE);
            #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        }
        else
        {

        #if (CAN_43_LLCE_TRIGGER_TRANSMIT_EN == STD_ON)
            /* Report Error if Protocol Data Unit information pointer is NULL. */
            if ( (NULL_PTR == PduInfo) )
        #else
            if ( (NULL_PTR == PduInfo) || (NULL_PTR == PduInfo->sdu) )
        #endif
            {
                #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                /*
                (CAN219) If development error detection for the Can module is enabled: The function Can_43_LLCE_Write shall raise the
                        error CAN_43_LLCE_E_PARAM_POINTER if the parameter PduInfo or the SDU pointer inside PduInfo is a null-pointer.
                */

                (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_WRITE, CAN_43_LLCE_E_PARAM_POINTER);
                #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
            }
            else
            {
                u8CtrlId = Can_43_LLCE_GetCurrentConfig()->aHohList[Hth].u8ControllerId;

                pxCanControllerDescriptor = &(Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[u8CtrlId]);

                #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
                if(pxCanControllerDescriptor->u32CoreId != u32CoreId)
                {
                    #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                    (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_WRITE, (uint8)CAN_43_LLCE_E_PARAM_CONFIG);
                    #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
                }
                else
                {
                #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */


                /* Get the index of the current baud rate */
                u8BaudrateIndex = Can_43_LLCE_ControllerBaudRateIndexes[u8CtrlId].u8CurrentBaudRateIndex;

                /* Get the status of the FD feature */
                u8FdEnable = pxCanControllerDescriptor->pControllerBaudrateConfigsPtr[u8BaudrateIndex].baudrateConfig.ControllerFD.u8FdEnable;

                    /* Report error if length > 8 bytes. */
                    if ( \
                            ( (u8FdEnable == (uint8)FALSE) && ((PduInfo->length) > (uint8)8U) ) || \
                            ( (u8FdEnable == (uint8)TRUE) && ((PduInfo->length) > (uint8)64U) ) || \
                            (( (((uint32)PduInfo->id) & (uint32)CAN_LPDU_FD_U32) != CAN_LPDU_FD_U32) && ( (PduInfo->length) > (uint8)8U )) \
                    )
                    {
                        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                        
                            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_WRITE, CAN_43_LLCE_E_PARAM_DATA_LENGTH);
                        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
                    }
                    else
                    {
                        eReturnValue = Can_43_LLCE_SendWriteCmd(Hth, PduInfo);
                    }
                #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
                }
                #endif
            }
        }
    }
        
    return eReturnValue;
}

static Std_ReturnType Can_43_LLCE_SendWriteCmd(Can_HwHandleType Hth, const Can_PduType * PduInfo)
{
    /* Variable for return status */
    Std_ReturnType  eReturnValue = E_NOT_OK;

    #if (CAN_43_LLCE_TRIGGER_TRANSMIT_EN == STD_ON)
    /* Temporary buffer for Trigger Transmit */
    uint8 aTempSdu[LLCE_CAN_CONFIG_PAYLOAD_MAX_SIZE];
    #endif

    PduInfoType PduInfoTriggerTransmit;

    /* Enter into EA in order to protect access to Can_au16TransmitHwObjectCnt array */
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_02();

    /* Check if the maximum Tx objects for the current HTH has been exhausted */
    if (0U == Can_au16TransmitHwObjectCnt[Hth - CAN_43_LLCE_FIRST_HTH_CONFIGURED] )
    {
        /* No Tx object available */
        eReturnValue = CAN_BUSY;
    }
    else
    {
        /* Reserve a new MB in advance, assuming that this flows is E_OK */
        Can_au16TransmitHwObjectCnt[Hth - CAN_43_LLCE_FIRST_HTH_CONFIGURED]--;

        /* Create the PduInfoTriggerTransmit information */
        PduInfoTriggerTransmit.SduLength = PduInfo->length;
        PduInfoTriggerTransmit.SduDataPtr = (uint8 *)PduInfo->sdu;
        
        #if (CAN_43_LLCE_TRIGGER_TRANSMIT_EN == STD_ON)
        /* Check if this is a trigger transmit frame */
        if (NULL_PTR == PduInfoTriggerTransmit.SduDataPtr )
        {
            if(TRUE == Can_43_LLCE_GetCurrentConfig()->aHohList[Hth].CanTriggerTransmitEnable)
            {
                /* this HTH enables the trigger transmit feature */
                /* [SWS_CAN_00503] Can_43_LLCE_Write() shall accept a null pointer as SDU
                        (Can_PduType.Can_SduPtrType = NULL_PTR) if the trigger transmit API is enabled
                        for this hardware object (CanTriggerTransmitEnable = TRUE). */
                /* [SWS_CAN_00504] If the trigger transmit API is enabled for the hardware object, Can_43_LLCE_Write() shall interpret a null pointer as SDU
                        (Can_PduType.Can_SduPtrType = NULL_PTR) as request for using the trigger transmit interface.
                        If so and the hardware object is free, Can_43_LLCE_Write() shall call CanIf_TriggerTransmit() to acquire the PDU’s data. */
                PduInfoTriggerTransmit.SduLength = LLCE_CAN_CONFIG_PAYLOAD_MAX_SIZE;
                PduInfoTriggerTransmit.SduDataPtr = aTempSdu;

                    if ((Std_ReturnType)E_OK != CanIf_TriggerTransmit(PduInfo->swPduHandle, &PduInfoTriggerTransmit))
                    {
                        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)

                        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_WRITE, CAN_43_LLCE_E_PARAM_POINTER);
                        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
                        
                        eReturnValue = E_NOT_OK;
                    }
                    else
                    {
                        if(PduInfoTriggerTransmit.SduLength > LLCE_CAN_CONFIG_PAYLOAD_MAX_SIZE) 
                        {
                            eReturnValue = E_NOT_OK;
                        }
                        else
                        {
                            eReturnValue = E_OK;
                        }
                    }
            }
            else /* this MB do not enable the trigger transmit feature */
            {
                #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)

                (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_WRITE, CAN_43_LLCE_E_PARAM_POINTER);
                #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        
                eReturnValue = E_NOT_OK;
            }
        }
        if ((Std_ReturnType)E_OK == eReturnValue)
        {
        #endif
            /* Call the IPW function for transmitting data. */
            eReturnValue = Can_43_LLCE_IPW_Write( Hth, PduInfo, PduInfoTriggerTransmit);
        #if (CAN_43_LLCE_TRIGGER_TRANSMIT_EN == STD_ON)    
        }
        #endif

        if ((Std_ReturnType)E_OK != eReturnValue)
        {
            /* On the error case, release the buffer reserved in advance. */
            Can_au16TransmitHwObjectCnt[Hth - CAN_43_LLCE_FIRST_HTH_CONFIGURED]++;
        }

    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_02();

    return eReturnValue;
}


/*================================================================================================*/
/*================================================================================================*/
#if (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE == STD_OFF)
    /**
    * @brief          Function called at fixed cyclic time. SID is 0x01.
    * @details        Service for performs the polling of TX confirmation and TX cancellation confirmation when CAN_TX_PROCESSING is set to POLLING.
    *                 This routine is called by:
    *                 - CanIf or an upper layer according to Autosar requirements.
    *
    *
    * @pre            Driver must be initialized.
    * @post           Send the data from that MB that is configured for Tx.
    *
    * @implements     Can_MainFunction_Write_Activity
    */
    void Can_43_LLCE_MainFunction_Write(void)
    {
        #if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)
        uint32 u32CoreId = Can_43_LLCE_GetCoreID();

        /* Test whether the driver is already initialised. */
        /* As per CPR_RTD_00662, no action should be taken in case of error*/
        if (CAN_43_LLCE_UNINIT != Can_43_LLCE_eDriverStatus[u32CoreId] )
        {
            /* Poll all controllers for Tx MB statuses. */
            Can_43_LLCE_IPW_MainFunctionWrite();
        }

        #endif /*(CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)   */
    }

#else

    /**
    * @brief          Function called at fixed cyclic time. SID is 0x01.
    * @details        Service for performs the polling of TX confirmation and TX cancellation confirmation when CAN_TX_PROCESSING is set to POLLING.
    *                 This routine is called by:
    *                 - CanIf or an upper layer according to Autosar requirements.
    *
    *
    * @pre            Driver must be initialized.
    * @post           Send the data from that MB that is configured for Tx.
    *
    * @implements     Can_MainFunction_Multiple_Write_Activity
    */
        #if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)
        void Can_43_LLCE_MainFunction_Multiple_Write(uint8 writepoll)
        {
            uint32 u32CoreId = Can_43_LLCE_GetCoreID();

            /* Test whether the driver is already initialised. */
            if (CAN_43_LLCE_UNINIT != Can_43_LLCE_eDriverStatus[u32CoreId] )
            {
                /* Poll all controllers for Tx MB statuses. */
                Can_43_LLCE_IPW_MainFunctionMultipleWritePoll(writepoll);
            }
        }
        #endif /*#if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)*/

#endif /*ifdef (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE == STD_OFF)*/


/*================================================================================================*/

#if (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ == STD_OFF)
    /**
    * @brief          Function called at fixed cyclic time.  SID is 0x08.
    * @details        Service for performs the polling of RX indications when CAN_RX_PROCESSING is set to POLLING.
    *                 This routine is called by:
    *                 - CanIf or an upper layer according to Autosar requirements.
    *
    *
    * @pre            Driver must be initialized.
    * @post           Receive the data from that MB that is configured for Rx.
    *
    * @implements     Can_MainFunction_Read_Activity
    */
    void Can_43_LLCE_MainFunction_Read(void)
    {
        #if (CAN_43_LLCE_RXPOLL_SUPPORTED  == STD_ON)
            uint32 u32CoreId = Can_43_LLCE_GetCoreID();
            /* Test whether the driver is already initialised. */
            if (CAN_43_LLCE_UNINIT != Can_43_LLCE_eDriverStatus[u32CoreId] )
            {
                /* Poll all controllers for Rx MB statuses. */
                Can_43_LLCE_IPW_MainFunctionRead();
            }
        #endif /* (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON) */
    }

#else

    /**
    * @brief          Function called at fixed cyclic time.  SID is 0x08.
    * @details        Service for performs the polling of RX indications when CAN_RX_PROCESSING is set to POLLING.
    *                 This routine is called by:
    *                 - CanIf or an upper layer according to Autosar requirements.
    *
    *
    * @pre            Driver must be initialized.
    * @post           Receive the data from that MB that is configured for Rx.
    *
    * @implements     Can_MainFunction_Multiple_Read_Activity
    */
        #if (CAN_43_LLCE_RXPOLL_SUPPORTED  == STD_ON)
        void Can_43_LLCE_MainFunction_Multiple_Read(uint8 readpoll)
        {
            uint32 u32CoreId = Can_43_LLCE_GetCoreID();
            /* Test whether the driver is already initialised. */
            if ( CAN_43_LLCE_UNINIT != Can_43_LLCE_eDriverStatus[u32CoreId] )
            {
                /* Poll all controllers for Rx MB statuses. */
                Can_43_LLCE_IPW_MainFunctionMultipleReadPoll(readpoll);
            }
        }
        #endif /* #if (CAN_43_LLCE_RXPOLL_SUPPORTED  == STD_ON) */
#endif /* ifdef (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ == STD_OFF)*/



/*================================================================================================*/

/**
* @brief          Function called at fixed cyclic time. SID is 0x09.
* @details        Service for performs the polling of BusOff events that are configured statically as 'to be polled'.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
*
* @pre            Driver must be initialized.
* @post           Handle the Busoff event.
*
* @implements     Can_MainFunction_BusOff_Activity
*/
void Can_43_LLCE_MainFunction_BusOff(void)
{
#if (CAN_43_LLCE_BUSOFFPOLL_SUPPORTED == STD_ON)
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    /* Test whether the driver is already initialised. */
    if ( CAN_43_LLCE_UNINIT != Can_43_LLCE_eDriverStatus[u32CoreId] )
    {
        /*
            (CAN109) The function Can_43_LLCE_MainFunction_BusOff shall perform the polling of bus-off events that are configured statically as 'to be polled'.
                     The bus-off events are triggered by LLCE firmware only to the controllers configured statically as 'to be polled', since it has this information.
        */
        Can_43_LLCE_IPW_ProcessBusOffPoll();
        
    }

#endif /* (CAN_43_LLCE_BUSOFFPOLL_SUPPORTED == STD_ON) */
}


#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
/**
* @brief          Function called at fixed cyclic time.
* @details        This Service performs the polling of Error notifications that are configured as 'to be polled'.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
*
* @pre            Driver must be initialized.
* @post           Handle the Error notifications in polling.
*
* @implements     Can_MainFunction_ErrorNotification_Activity
*/
void Can_43_LLCE_MainFunction_ErrorNotification(void)
{
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    /* Test whether the driver is already initialised. */
    if ( CAN_43_LLCE_UNINIT != Can_43_LLCE_eDriverStatus[u32CoreId] )
    {
        Can_43_LLCE_IPW_ProcessErrorNotification();
    }
}

#endif /* (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON) */

/*================================================================================================*/
/**
* @brief          Function called at fixed cyclic time. SIDis 0x0C.
* @details        Service for performs performs the polling of CAN status register flags to detect transition of CAN Controller state
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
*
* @pre            Driver must be initialized.
* @post           Handle the transition of Can Controller state.
*
* @implements     Can_MainFunction_Mode_Activity
*/
void Can_43_LLCE_MainFunction_Mode(void)
{
    /* Variable for indexing the controllers. */
    uint8  u8CtrlIndex = 0U;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    /* Test whether the driver is already initialised. */
    if (CAN_43_LLCE_UNINIT != Can_43_LLCE_eDriverStatus[u32CoreId] )
    {
        /* Loop through all configured controller descriptors. */
        for (u8CtrlIndex = (uint8)0U; u8CtrlIndex < CAN_43_LLCE_MAXCTRL_CONFIGURED; u8CtrlIndex++)
        {
            #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            if(Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[u8CtrlIndex].u32CoreId == u32CoreId)
            {
            #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */

                /* Skipping controllers that are not configured. */
                if (CAN_43_LLCE_NULL_OFFSET != (Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[u8CtrlIndex].u8HwCtrl))
                {
                    /* Check for main function mode. */
                    Can_43_LLCE_IPW_MainFunctionMode(u8CtrlIndex);
                }
            #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            }
            #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
        }
    }
}

/*================================================================================================*/
/**
* @brief          Process check of WakeUp condition. SID is 0x0B.
* @details        This service shall evaluate the WakeupSource parameter to get the information,
*                 which dedicate wakeup source needs to be checked, either a CAN transceiver or controller device.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      controller Can controller ID - based on configuration order list (CanControllerId).
* @return         Std_ReturnType Result of the wakeup verification.
* @retval         E_OK  Wakeup was detected for the given controller.
* @retval         E_NOT_OK  No wakeup was detected for the given controller.
*
*
* @pre            Driver must be initialized.
* @post           Return the Wakeup event occurrence.
*
* @implements     Can_CheckWakeup_Activity
*/
Std_ReturnType Can_43_LLCE_CheckWakeup(uint8 controller)
{
    /* E_NOT_OK is defined as (uint8)0x01 */
    Std_ReturnType eReturnValue = E_NOT_OK;

    if(TRUE == Can_ValidateController(controller,  (uint8)CAN_43_LLCE_SID_CBK_CHECK_WAKEUP))
    {
        eReturnValue = E_NOT_OK;
    }

    return (eReturnValue);
}


#ifdef CAN_43_LLCE_SET_BAUDRATE_API
#if (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON)
/*================================================================================================*/
/**
* @brief         This function set baudrate
* @details       This routine is called by an upper layer.
*
* @param[in]     Controller controller ID
* @param[in]     BaudRateConfigID baudrateID selection
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Switch baudrate operation was ok.
* @retval        E_NOT_OK  Switch baudrate operation was not ok.
*
* @pre           Driver must be initialized.
* @implements    Can_SetBaudrate_Activity
*/
Std_ReturnType Can_43_LLCE_SetBaudrate(uint8 Controller, const uint16 BaudRateConfigID)
{
    /* Returns the result of CAN set baudrate */
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;
    Can_ControllerStateType eCtrlState = CAN_CS_UNINIT;

    if(TRUE == Can_ValidateController(Controller, (uint8)CAN_43_LLCE_SID_SET_BAUDRATE))
    {
        eReturnValue = Can_43_LLCE_IPW_GetControllerMode(Controller, &eCtrlState);

        if ((uint8)E_OK == eReturnValue)
        {
            if (CAN_CS_STOPPED != eCtrlState)
            {
                /*
                        (SWS_Can_00256) If the call of Can_SetBaudrate() would cause a re-initialization
                                of the CAN Controller and the CAN Controller is not in state STOPPED, it shall return E_NOT_OK.
                */
                eReturnValue = (uint8)E_NOT_OK;
            }
            else
            {
                eReturnValue = Can_43_LLCE_SendSetBaudrateCmd(Controller, BaudRateConfigID);
            }
        }
    }

    return eReturnValue;
}


static Std_ReturnType Can_43_LLCE_SendSetBaudrateCmd(uint8 Controller, const uint16 BaudRateConfigID)
{
    /* Returns the result of CAN set baudrate */
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;
    uint8 u8BaudrateIndex = 0U;

    /* Check the Baudrate */
    for (u8BaudrateIndex = 0U; u8BaudrateIndex < Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8MaxBaudRateCount; u8BaudrateIndex++)
    {
        /* Check the Baudrate */
        if (BaudRateConfigID == (uint16)(Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].pControllerBaudrateConfigsPtr[u8BaudrateIndex].u16ControllerBaudRateConfigID))
        {
            /* Baudrate is Valid */
            /* SWS_Can_00062 Check if a baudrate change is required */
            if (Can_43_LLCE_ControllerBaudRateIndexes[Controller].u8CurrentBaudRateIndex != u8BaudrateIndex)
            {
                /* Copy the index of Valid Baudrate into the Can_43_LLCE_ControllerBaudRateIndexes as u8CurrentBaudRateIndex */
                Can_43_LLCE_ControllerBaudRateIndexes[Controller].u8CurrentBaudRateIndex = u8BaudrateIndex;
                
                eReturnValue = Can_43_LLCE_IPW_ChangeBaudrate(Controller, u8BaudrateIndex);
            }
            else
            {
                eReturnValue = (uint8)E_OK;
            }
            break;
        }
    }

    if ((uint8)E_OK != eReturnValue )
    {
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_SET_BAUDRATE, (uint8)CAN_43_LLCE_E_PARAM_BAUDRATE);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
    }

    return eReturnValue;
}

#endif
#endif


/*================================================================================================*/
/**
* @brief         This service obtains the error state of the CAN controller.
* @details       This service shall read the error state register of Can Controller and shall return the error status to upper layer.
*
* @param[in]     Controller - Abstracted CanIf ControllerId which is assigned to a CAN controller, which is requested for ErrorState.
* @param[out]    ErrorStatePtr - Pointer to a memory location, where the error state of the CAN controller will be stored.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Driver must be initialized.
*
* @implements     Can_GetControllerErrorState_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerErrorState(uint8 Controller, Can_ErrorStateType * ErrorStatePtr)
{
    /* Returns the result of CAN GetControllerErrorState */
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Controller, (uint8)CAN_43_LLCE_SID_GETCONTROLLERERRORSTATE))
    {
        /* 
            [SWS_Can_91007] If default error detection for the Can module is enabled: if the parameter ErrorStatePtr is a null pointer, 
                    the function Can_GetControllerErrorState shall raise default error CAN_E_PARAM_POINTER and return E_NOT_OK. 
        */
        if ( NULL_PTR == ErrorStatePtr )
        {
            #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_GETCONTROLLERERRORSTATE, (uint8)CAN_43_LLCE_E_PARAM_POINTER);
            #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        }
        else
        {
            eReturnValue = Can_43_LLCE_IPW_GetControllerErrorState(Controller, ErrorStatePtr);
        }
    }

    return (eReturnValue);
}

/*================================================================================================*/
/**
* @brief         This service obtains the number of RX errors of the CAN controller.
* @details       This service shall read the error state register of Can Controller and shall return the number of rx errors to upper layer.
*
* @param[in]     ControllerId - Abstracted CanIf ControllerId which is assigned to a CAN controller, which is requested for rx error counter.
* @param[out]    RxErrorCounterPtr - Pointer to a memory location, where the rx error counter of the CAN controller will be stored.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Driver must be initialized.
* @implements    Can_GetControllerRxErrorCounter_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerRxErrorCounter (uint8 ControllerId, uint8 * RxErrorCounterPtr)
{
    /* Returns the result of CAN GetControllerRxErrorCounter */
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;
 
    if(TRUE == Can_ValidateController(ControllerId, (uint8)CAN_43_LLCE_SID_GET_CTRL_RX_ERROR_COUNTER))
    {
        if (NULL_PTR == RxErrorCounterPtr)
        {
            #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /* 
            *   [SWS_Can_00514]: If development error detection for the Can module is enabled:
            *   if the parameter RxErrorCounterPtr is a null pointer, the function Can_GetControllerRxErrorCounter shall
            *   raise development error CAN_E_PARAM_POINTER and return E_NOT_OK.
            */
            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_GET_CTRL_RX_ERROR_COUNTER, (uint8)CAN_43_LLCE_E_PARAM_POINTER);
            #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        }
        else
        {
            /* 
            *   [SWS_Can_00515]: When the API Can_GetControllerRxErrorCounter is called with
            *   Controller Id as input parameter then Can driver shall read the Rx error counter
            *   register of Can Controller and shall return the Rx error count to upper layer.
            */
            eReturnValue = Can_43_LLCE_IPW_GetControllerRxErrorCounter(ControllerId, RxErrorCounterPtr);
        }
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service obtains the number of Tx errors of the CAN controller.
* @details       This service shall read the error state register of Can Controller and shall return the number of Tx errors to upper layer.
*
* @param[in]     ControllerId - Abstracted CanIf ControllerId which is assigned to a CAN controller, which is requested for rx error counter.
* @param[out]    TxErrorCounterPtr - Pointer to a memory location, where the tx error counter of the CAN controller will be stored.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Driver must be initialized.
* @implements    Can_GetControllerTxErrorCounter_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerTxErrorCounter (uint8 ControllerId, uint8 * TxErrorCounterPtr)
{
    /* Returns the result of CAN GetControllerRxErrorCounter */
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(ControllerId, (uint8)CAN_43_LLCE_SID_GET_CTRL_TX_ERROR_COUNTER))
    {
        if (NULL_PTR == TxErrorCounterPtr)
        {
            #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /* 
            *   [SWS_Can_00519]: If development error detection for the Can module is enabled:
            *   if the parameter TxErrorCounterPtr is a null pointer, the function Can_GetControllerTxErrorCounter shall
            *   raise development error CAN_E_PARAM_POINTER and return E_NOT_OK.
            */
            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_GET_CTRL_TX_ERROR_COUNTER , (uint8)CAN_43_LLCE_E_PARAM_POINTER);
            #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        }
        else
        {
            /* 
            *   [SWS_Can_00520]: When the API Can_GetControllerTxErrorCounter is called with
            *   Controller Id as input parameter then Can driver shall read the Tx error counter
            *   register of Can Controller and shall return the Tx error count to upper layer.
            */
            eReturnValue = Can_43_LLCE_IPW_GetControllerTxErrorCounter(ControllerId, TxErrorCounterPtr);
        }
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service obtains the Llce Can controller status.
* @details       This service obtains a structure containing values from HW registers of the specified channel.
*
* @param[in]     ControllerId - Abstracted CanIf ControllerId which is assigned to a CAN controller, which is requested for status
* @param[out]    TxErrorCounterPtr - Pointer to a memory location, where the status of the CAN controller will be stored.
*
* @return        Std_ReturnType.  Result of the check.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Llce firmware must be loaded.
*   
*/
Std_ReturnType Can_43_LLCE_GetControllerStatus(uint8 ControllerId, Llce_Can_GetStatusCmdType * StatusPtr)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(ControllerId, CAN_43_LLCE_SID_GETCONTROLLERERRORSTATE))
    {
        eReturnValue = Can_43_LLCE_IPW_GetControllerStatus(ControllerId, StatusPtr);
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service obtains the Llce firmware version.
* @details       This service obtains a string which encapsulates all of the components versions for the Llce firmware.
*
* @param[out]    pVersionString - The string with all the components versions for the Llce firmware. 
* @param[out]    pStringLength - Length of the string.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Llce firmware must be loaded.
* @implements    Can_GetFwVersion_Activity
*/
Std_ReturnType Can_43_LLCE_GetFwVersion(const uint8 ** pVersionString, uint8 * pStringLength)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    eReturnValue = Can_43_LLCE_IPW_GetFwVersion(pVersionString, pStringLength);

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service set a single standard filter.
* @details       This service set a single standard filter.
*
* @param[in]     pCanFilter - parameter of Can_SetFilterType, containing filter type and message buffer related configuration data
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetFilter_Activity
*/
Std_ReturnType Can_43_LLCE_SetFilter(const Can_SetFilterType * pCanFilter)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Can_43_LLCE_GetCurrentConfig()->aHohList[pCanFilter->Hrh].u8ControllerId, (uint8)CAN_43_LLCE_SID_SET_FILTER))
    {
        /* Pass only one filter at a time, for timing concerns, hence only the first value in the filter array is used, the one with index "0U". */
        eReturnValue = Can_43_LLCE_IPW_SetFilter(pCanFilter);
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service set a single standard filter at a given address.
* @details       This service set a single standard filter at a given address.
*
* @param[in]     pCanFilter - parameter of Can_SetFilterType, containing filter type and message buffer related configuration data
* @param[in]     u16FilterAddr - Address in RxLut for filter. Must be free. 
*                An address can be freed either by calling the RemoveFilter function or leaving extra free filters via host configuration.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetFilter_Activity
*/
Std_ReturnType Can_43_LLCE_SetFilterAtAddress(const Can_SetFilterType * pCanFilter, const uint16 u16FilterAddr)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Can_43_LLCE_GetCurrentConfig()->aHohList[pCanFilter->Hrh].u8ControllerId, (uint8)CAN_43_LLCE_SID_SET_FILTER))
    {
        /* Pass only one filter at a time, for timing concerns, hence only the first value in the filter array is used, the one with index "0U". */
        eReturnValue = Can_43_LLCE_IPW_SetFilterAtAddress(pCanFilter, u16FilterAddr);
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service set a single advanced filter at a given address.
* @details       This service set a single advanced filter at a given address.
*
* @param[in]     pAfFilter - parameter of Can_SetAfFilterType, containing filter type and message buffer related configuration data along with routing rules and other advanced features
* @param[in]     u16FilterAddr - address returned by the RemoveFilter function
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetAfFilterAtAddress_Activity
*/
Std_ReturnType Can_43_LLCE_SetAfFilterAtAddress(const Can_SetAfFilterType * pAfFilter, const uint16 u16FilterAddr)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Can_43_LLCE_GetCurrentConfig()->aHohList[pAfFilter->Filter.Hrh].u8ControllerId, (uint8)CAN_43_LLCE_SID_SET_FILTER))
    {
        /* Pass only one filter at a time, for timing concerns, hence only the first value in the filter array is used, the one with index "0U". */
        eReturnValue = Can_43_LLCE_IPW_SetAfFilterAtAddress(pAfFilter, u16FilterAddr);
    }

    return eReturnValue;
}
/*================================================================================================*/
/**
* @brief         This service set a single advanced filter.
* @details       This service set a single advanced filter.
*
* @param[in]     pAfFilter - parameter of Can_SetAfFilterType, containing advanced filter type and message buffer related configuration data
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetAfFilter_Activity
*/
Std_ReturnType Can_43_LLCE_SetAfFilter(const Can_SetAfFilterType * pAfFilter)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Can_43_LLCE_GetCurrentConfig()->aHohList[pAfFilter->Filter.Hrh].u8ControllerId, (uint8)CAN_43_LLCE_SID_SET_FILTER))
    {
        /* Pass only one filter at a time, for timing concerns, hence only the first value in the filter array is used, the one with index "0U". */
        eReturnValue = Can_43_LLCE_IPW_SetAfFilter(pAfFilter);
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service a new destination for advanced features
* @details       This service a new destination for advanced features
**
* @param[in]      destRule - The destination to add to the LLCE destination list
* @param[out]     pu8RuleIdx - The index of the new destination in the LLCE list. Needed for SetAdvancedFilter.
*
* @return        Std_ReturnType. Result of the request.
* @retval        E_OK  Destination created
* @retval        E_NOT_OK  Error
*
* @pre           Llce firmware must be loaded and the controller initialized
*/
Std_ReturnType Can_43_LLCE_CreateAfDestination(const Can_Af_DestRulesType destRule, uint8* pu8RuleIdx)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    if (CAN_43_LLCE_READY != Can_43_LLCE_eDriverStatus[u32CoreId] )
    {
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_CREATE_DESTINATION, (uint8)CAN_43_LLCE_E_UNINIT);
        #endif
    }
    else
    {
        /* Pass the destination rule to be added and the pointer for the index to be returned. */
        eReturnValue = Can_43_LLCE_IPW_CreateAfDestination(destRule, pu8RuleIdx);
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service removes an existing destination for advanced features
* @details       This service removes an existing destination for advanced features
**
* @param[in]     u8RuleIdx - The index of the destination to be removed from the LLCE list.
*
* @return        Std_ReturnType. Result of the request.
* @retval        E_OK  Destination removed
* @retval        E_NOT_OK  Error
*
* @pre           Llce firmware must be loaded and the controller initialized
*/
Std_ReturnType Can_43_LLCE_RemoveAfDestination(uint8 u8RuleIdx)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    if (CAN_43_LLCE_READY != Can_43_LLCE_eDriverStatus[u32CoreId] )
    {
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_REMOVE_DESTINATION, (uint8)CAN_43_LLCE_E_UNINIT);
        #endif
    }
    else
    {
        /* Pass the index of the destination to be removed */
        eReturnValue = Can_43_LLCE_IPW_RemoveAfDestination(u8RuleIdx);
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service removes a single standard filter.
* @details       This service removes a single standard filter.
*
* @param[in]     Hrh - HRH to which the filter is attached.
* @param[in]     u16FilterAddr - address of the removed filter, to be later used by Can_43_LLCE_SetFilterAtAddress.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_RemoveFilter_Activity
*/
Std_ReturnType Can_43_LLCE_RemoveFilter(Can_HwHandleType Hrh, uint16 *u16FilterAddr)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Can_43_LLCE_GetCurrentConfig()->aHohList[Hrh].u8ControllerId, (uint8)CAN_43_LLCE_SID_REMOVE_FILTER))
    {
        eReturnValue = Can_43_LLCE_IPW_RemoveFilter(Hrh, u16FilterAddr);    
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service enables or disables a single standard filter.
* @details       This service enables or disables a single standard filter.
*
* @param[in]     Hrh - HRH to which the filter is attached.
* @param[in]     State - Logical value to select if filter is enabled or disabled
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully enabled/disabled.
* @retval        E_NOT_OK  filter was not successfully enabled/disabled.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetFilterState_Activity 
*/
Std_ReturnType Can_43_LLCE_SetFilterState(Can_HwHandleType Hrh, Can_43_LLCE_FilterStateType eState)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Can_43_LLCE_GetCurrentConfig()->aHohList[Hrh].u8ControllerId, (uint8)CAN_43_LLCE_SID_SET_FILTER_ENABLE_STATE))
    {
        eReturnValue = Can_43_LLCE_IPW_SetFilterState(Hrh, eState);    
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service sets the state of controller in a multicast routing configuration.
* @details       
*
* @param[in]     ControllerId - controller to be enabled or disabled.
* @param[in]     eChannelStatus - enable or disable channel
*
* @return        Std_ReturnType.  Result of the command.
* @retval        E_OK  channel was successfully enabled/disabled.
* @retval        E_NOT_OK  channel was not successfully enabled/disabled.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetChannelRoutingOutputState_Activity
*/
Std_ReturnType Can_43_LLCE_SetChannelRoutingOutputState(uint8 ControllerId, Can_43_LLCE_ChannelStateType eChannelStatus)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(ControllerId, (uint8)CAN_43_LLCE_SID_SETCHANNEL_ROUTING_OUTPUTSTATE))
    {
        eReturnValue = Can_43_LLCE_IPW_SetChannelRoutingOutputState(ControllerId, eChannelStatus);    
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service forces a deinit of the driver
* @details       When LLCE is not responding and must be reset, this service may be used to allow another init call. 
*
* @implements    Can_ForceDeInit_Activity
*/
void Can_43_LLCE_ForceDeInit(void)
{
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    Can_43_LLCE_eDriverStatus[u32CoreId] = CAN_43_LLCE_UNINIT;
    Can_43_LLCE_pCurrentConfig[u32CoreId] = NULL_PTR;
}


#if (CAN_43_LLCE_API_ENABLE_ABORT_MB == STD_ON)
/**
* @brief          Process a pending transmission abort
* @details        This function requests aborting of the lowest priority pending transmission
*                 of controller ControllerId and returns the hardware transmis handler Hth which
*                 has been freed along with the message tracking information swPduHandle
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      ControllerId - Logical Id of the hardware controller 
* @param[out]     Hth - HW-transmit handler
* @param[out]     swPduHandle - tracking information of the aborted MB
*
* @return         Std_ReturnType.  Result of the abort lowest priority MB service.
* @retval         E_OK  Lowest Priority Message Buffer has been discarded
* @retval         E_NOT_OK  Lowest Priority Message Buffer has not been discarded
*
* @pre            Driver must be initialized; Hardware channel of ControllerId must be started
*
* @note           Not AUTOSAR required. This is user implementation.
* @implements     Can_AbortMb_Activity
*/
Std_ReturnType Can_43_LLCE_AbortMb(Can_HwHandleType Hth)
{

    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Can_43_LLCE_GetCurrentConfig()->aHohList[Hth].u8ControllerId, (uint8)CAN_43_LLCE_SID_ABORT_LOWEST_PRIO_MB))
    {
        eReturnValue = Can_43_LLCE_Ipw_AborMb(Hth);
    }

    return eReturnValue;
}

#endif


#if (CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY == STD_ON)
/**
* @brief          Service for requesting recovery from bus-off event
* @details        This service requires preconfiguration of LLCE in bus-off recovery mode
*                 for the given ControllerId. In this mode, the bus-off event (LLCE_ERROR_BUSOFF)
*                 is not escalated to CanIf bus-off callout.
*                 The user may request the synchronization of controller on the bus after it 
*                 switched to bus-off state using this API.
*
* @param[in]      ControllerId - Logical Id of the hardware controller 
*
* @return         Std_ReturnType.
* @retval         E_OK  Command accepted by LLCE and recovery requested for the given ctrl.
* @retval         E_NOT_OK  Command not accepted due to misconfiguration.
*
* @pre            Driver must be initialized; ControllerId must be started
*                 ControllerId must be set in manual bus-off request mode.
*
* @note           Not AUTOSAR required.
*/
Std_ReturnType Can_43_LLCE_ManualBusOffRecovery(uint8 ControllerId )
{
    Std_ReturnType eReturnValue = E_NOT_OK;
    
    if(TRUE == Can_ValidateController(ControllerId, (uint8)CAN_43_LLCE_SID_MANUAL_BUSOFF_RECOVERY))
    {
        eReturnValue = Can_43_LLCE_Ipw_ManualBusOffRecovery(ControllerId);
    }

    return eReturnValue;
}

#endif

#define CAN_43_LLCE_STOP_SEC_CODE

#include "Can_43_LLCE_MemMap.h"


#ifdef __cplusplus
}
#endif


/** @} */


===== 文件 [100/112]: source&include\src\Can_43_LLCE_IPW.c =====
/**
*   @file    Can_Irq.c
*   @implements Can_Irq.c_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Interrupt routines for Can driver.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/


#ifdef __cplusplus
extern "C"{
#endif

/*
(CAN035) The module Can_Irq.c contains the implementation of interrupt frames.The implementation of the interrupt service routine shall be in Can_43_LLCE.c
*/

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
/**
* @file           Can_Irq.c
*/
#include "Can_43_LLCE.h"
#include "Can_43_LLCE_IPW.h"
#include "CanIf_Can.h"
#include "Mcal.h"


/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/* The integration of incompatible files shall be avoided. */
#define CAN_IPW_VENDOR_ID_C                    43
#define CAN_IPW_AR_RELEASE_MAJOR_VERSION_C     4
#define CAN_IPW_AR_RELEASE_MINOR_VERSION_C     4
#define CAN_IPW_AR_RELEASE_REVISION_VERSION_C  0
#define CAN_SW_MAJOR_VERSION_IPW_C             1
#define CAN_SW_MINOR_VERSION_IPW_C             0
#define CAN_SW_PATCH_VERSION_IPW_C             10



/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/* Check if current file and CAN header file are of the same vendor */
#if (CAN_IPW_VENDOR_ID_C != CAN_IPW_VENDOR_ID_H)
    #error "Can_IPW.c and Can_IPW.h have different vendor ids"
#endif
/* Check if current file and CAN header file are of the same Autosar version */
#if ((CAN_IPW_AR_RELEASE_MAJOR_VERSION_C    != CAN_IPW_AR_RELEASE_MAJOR_VERSION_H) || \
     (CAN_IPW_AR_RELEASE_MINOR_VERSION_C    != CAN_IPW_AR_RELEASE_MINOR_VERSION_H) || \
     (CAN_IPW_AR_RELEASE_REVISION_VERSION_C != CAN_IPW_AR_RELEASE_REVISION_VERSION_H))
    #error "AutoSar Version Numbers of Can_IPW.c and Can_IPW.h are different"
#endif
/* Check if current file and CAN header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_IPW_C != CAN_IPW_SW_MAJOR_VERSION_H) || \
     (CAN_SW_MINOR_VERSION_IPW_C != CAN_IPW_SW_MINOR_VERSION_H) || \
     (CAN_SW_PATCH_VERSION_IPW_C != CAN_IPW_SW_PATCH_VERSION_H))
    #error "Software Version Numbers of Can_IPW.c and Can_IPW.h are different"
#endif


/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

#define CAN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

Can_43_LLCE_ControllerBaudRate   Can_43_LLCE_ControllerBaudRateIndexes[CAN_43_LLCE_MAXCTRL_CONFIGURED];

#define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
Llce_Fw_ReturnType Can_43_LLCE_IPW_Init(const Can_43_LLCE_ConfigType * pxCurrentConfig)
{
    for (uint8 u8CtrlIndex = 0U; u8CtrlIndex < CAN_43_LLCE_MAXCTRL_CONFIGURED; u8CtrlIndex++)
    {
      #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
      if(Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[u8CtrlIndex].u32CoreId == Can_43_LLCE_GetCoreID())
      {
      #endif
        /* Set the controller current baudrate index as default */
        Can_43_LLCE_ControllerBaudRateIndexes[u8CtrlIndex].u8CurrentBaudRateIndex = (uint8)(pxCurrentConfig->aControllerDescriptors[u8CtrlIndex].u8DefaultBaudRateIndex);
      #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
      }
      #endif
    }

    return Can_Llce_Init(pxCurrentConfig);
}

Std_ReturnType Can_43_LLCE_IPW_Write (Can_HwHandleType Hth, const Can_PduType * PduInfo, PduInfoType PduInfoTriggerTransmit)
{
    uint8 u8HwCtrl = 0U;
    uint8 u8CtrlId = 0U;
    uint8 u8BaudrateIndex = 0U;
    const Can_43_LLCE_ControllerDescriptorType * pxCanControllerDescriptor;
    Can_43_LLCE_TxFrameInfoType TxFrameInfo;
    const Can_43_LLCE_HOHType * pxHth;
    const Can_43_LLCE_ConfigType* pxCurrentConfig = Can_43_LLCE_GetCurrentConfig();

    pxHth = &(pxCurrentConfig->aHohList[Hth]);
    u8CtrlId = pxHth->u8ControllerId;

    pxCanControllerDescriptor = &(pxCurrentConfig->aControllerDescriptors[u8CtrlId]);

    u8HwCtrl = pxCanControllerDescriptor->u8HwCtrl;

    /* Get the index of the current baud rate */
    u8BaudrateIndex = Can_43_LLCE_ControllerBaudRateIndexes[u8CtrlId].u8CurrentBaudRateIndex;

    /* Get the status of the FD feature */
    TxFrameInfo.u8FdEnabled = pxCanControllerDescriptor->pControllerBaudrateConfigsPtr[u8BaudrateIndex].baudrateConfig.ControllerFD.u8FdEnable;

    TxFrameInfo.u8FdPaddingValue = pxHth->u8FdPaddingValue;

    TxFrameInfo.u16FrameTag2 = PduInfo->swPduHandle;
    TxFrameInfo.u16FrameTag1 = Hth;
    TxFrameInfo.u8AckInterface = pxHth->u8RWInterface;
    TxFrameInfo.u8EnableTxFrameMac = pxHth->u8EnableTxFrameMac;
    TxFrameInfo.u32TxHseKeyHandle = pxHth->u32TxHseKeyHandle;
    TxFrameInfo.u32MessageId = (uint32)PduInfo->id;
    TxFrameInfo.u32SduLength = PduInfoTriggerTransmit.SduLength;
    TxFrameInfo.u8SduDataPtr = (uint8*)PduInfoTriggerTransmit.SduDataPtr;

    return Can_Llce_Write(u8HwCtrl, &TxFrameInfo);
}

Std_ReturnType Can_43_LLCE_IPW_GetControllerMode(uint8 Controller, Can_ControllerStateType* ControllerModePtr)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    return Can_Llce_GetControllerMode(u8HwCtrl, ControllerModePtr);
}

Std_ReturnType Can_43_LLCE_IPW_SetControllerMode( uint8 Controller, Can_ControllerStateType Transition)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;
    uint8 u8BaudrateIndex = Can_43_LLCE_ControllerBaudRateIndexes[Controller].u8CurrentBaudRateIndex;
    const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr = &(Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].pControllerBaudrateConfigsPtr[u8BaudrateIndex].baudrateConfig);

    return Can_Llce_SetControllerMode(u8HwCtrl, Transition, pxBaudrateConfigPtr);
}

void Can_43_LLCE_IPW_DisableControllerInterrupts(uint8 Controller)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    Can_Llce_DisableControllerInterrupts(u8HwCtrl);
}

void Can_43_LLCE_IPW_EnableControllerInterrupts(uint8 Controller)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    Can_Llce_EnableControllerInterrupts(u8HwCtrl);
}

Std_ReturnType Can_43_LLCE_IPW_GetControllerStatus(uint8 Controller, Llce_Can_GetStatusCmdType* StatusPtr)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    return Can_Llce_GetControllerStatus(u8HwCtrl, StatusPtr);
}

Std_ReturnType Can_43_LLCE_IPW_ChangeBaudrate(uint8 Controller, uint8 u8BaudrateIndex)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;
    const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr = &(Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].pControllerBaudrateConfigsPtr[u8BaudrateIndex].baudrateConfig);

    return Can_Llce_ChangeBaudrate(u8HwCtrl, pxBaudrateConfigPtr);
}

void Can_43_LLCE_IPW_MainFunctionMode(uint8 Controller)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    Can_Llce_MainFunctionMode(u8HwCtrl);
}

Std_ReturnType Can_43_LLCE_IPW_GetControllerErrorState(uint8 Controller,Can_ErrorStateType* ErrorStatePtr)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    return Can_Llce_GetControllerErrorState(u8HwCtrl, ErrorStatePtr);
}

Std_ReturnType Can_43_LLCE_IPW_GetControllerRxErrorCounter(uint8 Controller, uint8* RxErrorCounterPtr)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    return Can_Llce_GetControllerRxErrorCounter(u8HwCtrl, RxErrorCounterPtr);
}

Std_ReturnType Can_43_LLCE_IPW_GetControllerTxErrorCounter(uint8 Controller, uint8* TxErrorCounterPtr)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    return Can_Llce_GetControllerTxErrorCounter(u8HwCtrl, TxErrorCounterPtr);
}

Std_ReturnType Can_43_LLCE_IPW_DeInitController(uint8 Controller)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    return Can_Llce_DeInitController(u8HwCtrl);
}

Std_ReturnType Can_43_LLCE_IPW_SetChannelRoutingOutputState(uint8 ControllerId, Can_43_LLCE_ChannelStateType eChannelStatus)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[ControllerId].u8HwCtrl;

    return Can_Llce_SetChannelRoutingOutputState(u8HwCtrl, eChannelStatus);
}
#if (CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY == STD_ON)

Std_ReturnType Can_43_LLCE_Ipw_ManualBusOffRecovery(uint8 ControllerId)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[ControllerId].u8HwCtrl;
    
    return Can_Llce_ManualBusOffRecovery(u8HwCtrl);
}

#endif

/*================================================================================================*/


#define CAN_43_LLCE_START_SEC_CODE
#include "Can_43_LLCE_MemMap.h"




#define CAN_43_LLCE_STOP_SEC_CODE
#include "Can_43_LLCE_MemMap.h"
#ifdef __cplusplus
}
#endif
/** @} */


===== 文件 [101/112]: source&include\src\Can_43_LLCE_Irq.c =====
/**
*   @file    Can_Irq.c
*   @implements Can_Irq.c_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Interrupt routines for Can driver.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/


#ifdef __cplusplus
extern "C"{
#endif


/*
(CAN035) The module Can_Irq.c contains the implementation of interrupt frames.The implementation of the interrupt service routine shall be in Can_43_LLCE.c
*/

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
/**
* @file           Can_Irq.c
*/
#include "Can_43_LLCE.h"
#include "Can_43_LLCE_IPW.h"
#include "Can_43_LLCE_IrqConfig.h"
#include "CanIf_Can.h"
#include "Mcal.h"
#include "Llce_InterfaceFifo.h"
#include "Llce_InterfaceIcsr.h"





/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/* The integration of incompatible files shall be avoided. */
#define CAN_43_LLCE_VENDOR_ID_IRQ_C                      43
#define CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_IRQ_C       4
#define CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_IRQ_C       4
#define CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_IRQ_C    0
#define CAN_SW_MAJOR_VERSION_IRQ_C               1
#define CAN_SW_MINOR_VERSION_IRQ_C               0
#define CAN_SW_PATCH_VERSION_IRQ_C               10



/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/
/* Check if current file and CAN header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID_IRQ_C != CAN_43_LLCE_VENDOR_ID)
    #error "Can_Irq.c and Can_43_LLCE.h have different vendor ids"
#endif
/* Check if current file and CAN header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_IRQ_C    != CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_IRQ_C    != CAN_43_LLCE_AR_RELEASE_MINOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_IRQ_C != CAN_43_LLCE_AR_RELEASE_REVISION_VERSION))
    #error "AutoSar Version Numbers of Can_Irq.c and Can_43_LLCE.h are different"
#endif
/* Check if current file and CAN header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_IRQ_C != CAN_43_LLCE_SW_MAJOR_VERSION) || \
     (CAN_SW_MINOR_VERSION_IRQ_C != CAN_43_LLCE_SW_MINOR_VERSION) || \
     (CAN_SW_PATCH_VERSION_IRQ_C != CAN_43_LLCE_SW_PATCH_VERSION))
    #error "Software Version Numbers of Can_Irq.c and Can_43_LLCE.h are different"
#endif

/* Check if current file and DET header file are of the same version */
#ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
#include "Det.h"
    #if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_IRQ_C != DET_AR_RELEASE_MAJOR_VERSION) || \
         (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_IRQ_C != DET_AR_RELEASE_MINOR_VERSION))
        #error "AutoSar Version Numbers of Can_Irq.c and Det.h are different"
    #endif
#endif
#endif

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/
#if defined CAN_43_LLCE_MEASURE_IRQ_ACK_LATENCY || defined CAN_43_LLCE_MEASURE_IRQ_RECV_LATENCY
extern volatile uint32 Stm_Measurement;
#endif

/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/

/*================================================================================================*/
ISR(Can_FifoTxAckNotEmptyIsr_0_7);
ISR(Can_FifoTxAckNotEmptyIsr_8_15);
ISR(Can_FifoRxOutNotEmptyIsr_0_7);
ISR(Can_FifoRxOutNotEmptyIsr_8_15);
ISR(Can_FifoRxInNotEmptyIsr_0_7);
ISR(Can_FifoRxInNotEmptyIsr_8_15);

#define CAN_43_LLCE_START_SEC_CODE
#include "Can_43_LLCE_MemMap.h"
/**
* @implements     Can_Isr_X_Activity
*/
ISR(Can_FifoTxAckNotEmptyIsr_0_7)
{ 
    uint32 u32IntrStatusFlags;

    /*Read contents of interrupt concentrator register.*/
    u32IntrStatusFlags = Reg_Read32(LLCE_ICSR_ADDR(22));

    /*Check all bit fields from interrupt concentrator register. */
#ifdef CAN_43_LLCE_MEASURE_IRQ_ACK_LATENCY
        Stm_Measurement = Reg_Read32(LLCE_STM_CNT);
host_irq_ack_label:
#endif

#if (LLCE_FIFO_TXACK_00_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_00 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_00))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_00_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_01_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_01 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_01))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_01_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_02_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_02 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_02))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_02_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_03_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_03 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_03))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_03_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_04_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_04 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_04))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_04_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_05_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_05 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_05))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_05_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_06_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_06 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_06))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_06_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_07_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_07 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_07))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_07_ISR();
    }
#endif      
}

/**
* @implements     Can_Isr_X_Activity
*/
ISR(Can_FifoTxAckNotEmptyIsr_8_15)
{ 
    uint32 u32IntrStatusFlags;

    /*Read contents of interrupt concentrator register.*/
    u32IntrStatusFlags = Reg_Read32(LLCE_ICSR_ADDR(23));

    /*Check all bit fields from interrupt concentrator register. */
#if (LLCE_FIFO_TXACK_08_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_00 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_00))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_08_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_09_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_01 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_01))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_09_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_10_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_02 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_02))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_10_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_11_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_03 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_03))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_11_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_12_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_04 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_04))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_12_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_13_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_05 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_05))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_13_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_14_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_06 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_06))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_14_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_15_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_07 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_07))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_15_ISR();
    }
#endif      
}

/**
* @implements     Can_Isr_X_Activity
*/
ISR(Can_FifoRxOutNotEmptyIsr_0_7)
{ 
    uint32 u32IntrStatusFlags;

    /*Read contents of interrupt concentrator register.*/
    u32IntrStatusFlags = Reg_Read32(LLCE_ICSR_ADDR(16));

    /*Check all bit fields from interrupt concentrator register. */

#ifdef CAN_43_LLCE_MEASURE_IRQ_RECV_LATENCY
        Stm_Measurement = Reg_Read32(LLCE_STM_CNT);
host_irq_recv_label:
#endif

#if (LLCE_FIFO_RXOUT_00_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_00 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_00))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_00_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_01_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_01 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_01))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_01_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_02_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_02 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_02))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_02_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_03_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_03 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_03))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_03_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_04_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_04 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_04))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_04_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_05_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_05 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_05))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_05_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_06_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_06 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_06))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_06_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_07_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_07 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_07))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_07_ISR();
    }
#endif 
}

/**
* @implements     Can_Isr_X_Activity
*/
ISR(Can_FifoRxOutNotEmptyIsr_8_15)
{ 
    uint32 u32IntrStatusFlags;    

    /*Read contents of interrupt concentrator register.*/
    u32IntrStatusFlags = Reg_Read32(LLCE_ICSR_ADDR(17));

    /*Check all bit fields from interrupt concentrator register. */

#if (LLCE_FIFO_RXOUT_08_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_00 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_00))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_08_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_09_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_01 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_01))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_09_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_10_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_02 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_02))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_10_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_11_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_03 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_03))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_11_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_12_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_04 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_04))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_12_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_13_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_05 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_05))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_13_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_14_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_06 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_06))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_14_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_15_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_07 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_07))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_15_ISR();
    }
#endif 
}

/**
* @implements     Can_Isr_X_Activity
*/
ISR(Can_FifoRxInNotEmptyIsr_0_7)
{ 
    uint32 u32IntrStatusFlags;

    /*Read contents of interrupt concentrator register.*/
    u32IntrStatusFlags = Reg_Read32(LLCE_ICSR_ADDR(14));

    /*Check all bit fields from interrupt concentrator register. */

#if (LLCE_FIFO_RXIN_00_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_00 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_00))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_00_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_01_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_01 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_01))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_01_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_02_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_02 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_02))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_02_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_03_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_03 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_03))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_03_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_04_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_04 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_04))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_04_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_05_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_05 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_05))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_05_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_06_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_06 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_06))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_06_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_07_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_07 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_07))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_07_ISR();
    }
#endif 
}

/**
* @implements     Can_Isr_X_Activity
*/
ISR(Can_FifoRxInNotEmptyIsr_8_15)
{ 
    uint32 u32IntrStatusFlags;    

    /*Read contents of interrupt concentrator register.*/
    u32IntrStatusFlags = Reg_Read32(LLCE_ICSR_ADDR(15));

    /*Check all bit fields from interrupt concentrator register. */

#if (LLCE_FIFO_RXIN_08_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_00 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_00))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_08_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_09_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_01 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_01))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_09_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_10_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_02 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_02))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_10_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_11_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_03 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_03))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_11_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_12_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_04 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_04))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_12_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_13_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_05 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_05))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_13_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_14_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_06 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_06))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_14_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_15_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_07 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_07))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_15_ISR();
    }
#endif 
}

#define CAN_43_LLCE_STOP_SEC_CODE
#include "Can_43_LLCE_MemMap.h"
#ifdef __cplusplus
}
#endif
/** @} */


===== 文件 [102/112]: source&include\src\Can_Callback.c =====
/**
*   @file    Can_Callback.c
*   @version 1.0.10
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/
#include "Can_Callback.h"


#if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
    #include "Det.h"
    #include "Can_43_LLCE.h"
    #include "SchM_Can_43_LLCE.h"
#endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */

#if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
/**
* @brief          Implements wrapper for error report 
* @details        This routine is called by all APIs that change controller state, e.g. Can_Llce_SetControllerToStopMode:
*
* @param[in]      sid             Controller mode
*                 eTransition     Controller transition state
*
* @return         void
*
*
* @pre            The AUTOSAR_COMPATIBLE_MODE define is set to STD_ON for code generated with Tresos.
*
*/
void Can_43_LLCE_ReportError(uint8 sid , uint8 eTransition)
{
    /*In ASR context, report error through Det module - not available in non-ASR DesignStudio*/
    #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        if(((uint8)CAN_43_LLCE_E_DATALOST) != eTransition)
        {   
            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, sid, eTransition);
        }
    #else
        /* To avoid MISRA and compilation warnings */
        (void)sid;
        (void)eTransition;
    #endif
}
#else /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
void Can_43_LLCE_ReportError(uint8 sid , uint8 eTransition)
{
    /* Call custom configurable callback in NON-AUTOSAR MODE*/
    Can_43_LLCE_DevErrorDetectCallback(sid, eTransition);
}
#endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */

#if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
/**
* @brief          Implements wrapper for runtime error report 
* @details        This routine is called by Can_Llce_ProcessNotificationISR in case of overwrite or overrun
*
* @param[in]      sid             Controller mode
*                 eTransition     Controller transition state
*
* @return         void
*
*
*/
void Can_43_LLCE_ReportRuntimeError(uint8 sid , uint8 eTransition)
{
    /*In ASR context, report error through Det module - not available in non-ASR DesignStudio*/
    (void)Det_ReportRuntimeError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, sid, eTransition);
}
#else /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
void Can_43_LLCE_ReportRuntimeError(uint8 sid , uint8 eTransition)
{
    /* Call custom configurable callback in NON-AUTOSAR MODE*/
    Can_43_LLCE_DevErrorDetectCallback(sid, eTransition);
}
#endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */


#if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
/**
* @brief          Implements wrapper for configurable callback for controller state report to CanIf module in AUTOSAR MODE
* @details        This routine is called by all APIs that change controller state, e.g. Can_Llce_SetControllerToStopMode:
*
* @param[in]      u8HwCtrl      Controller id
*                 ctrlState     Controller transition state
*
* @return         void
*
*
* @pre            The AUTOSAR_COMPATIBLE_MODE define is set to STD_ON for code generated with Tresos.
*
*/
void Can_43_LLCE_ControllerModeIndication(uint8 u8HwCtrl, Can_ControllerStateType ctrlState)
{
    /* In ASR context, make call to CanIf - not available in non-ASR DesignStudio */
    CanIf_ControllerModeIndication(Can_43_LLCE_GetCurrentConfig()->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId, ctrlState);
}
#else /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
void Can_43_LLCE_ControllerModeIndication(uint8 u8HwCtrl, Can_ControllerStateType ctrlState)
{
    /* Call custom configurable callback for controller state report in NON-AUTOSAR MODE */
    Can_43_LLCE_ControllerModeIndicationCallback(u8HwCtrl, ctrlState);
}
#endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */

#if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
/**
* @brief          Implements wrapper for confirmation callback reporting to CanIf in AUTOSAR MODE
* @details        This routine is called by:
*                - Can_Llce_ProcessTxPollingClass and Can_Llce_ProcessTx
*
* @param[in]      tag             Frame tag
*
* @return         void
*
*
* @pre            The AUTOSAR_COMPATIBLE_MODE define is set to STD_ON for code generated with Tresos.
*
*/
void Can_43_LLCE_TxConfirmation(uint16 tag)
{
    /*In ASR context, make call to CanIf - not available in non-ASR DesignStudio*/
    CanIf_TxConfirmation(tag);
}
#else /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
void Can_43_LLCE_TxConfirmation(uint16 tag)
{
    /* Call custom confirmation callback in NON-AUTOSAR MODE */
    Can_43_LLCE_TxConfirmationCallback(tag);
}
#endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */

#if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
/**
* @brief          Implements wrapper for BusOff callback report to CanIf in AUTOSAR MODE
* @details        This routine is called by:
*                - Can_Llce_ControllerBusOff
*
* @param[in]      u8HwCtrl             controller id
*
* @return         void
*
*
* @pre            The AUTOSAR_COMPATIBLE_MODE define is set to STD_ON for code generated with Tresos.
*/
void Can_43_LLCE_ControllerBusOff(uint8 u8HwCtrl)
{
    /* Inform CanIf about BusOff event */
    CanIf_ControllerBusOff(Can_43_LLCE_GetCurrentConfig()->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId);
}
#else /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
void Can_43_LLCE_ControllerBusOff(uint8 u8HwCtrl)
{
    /* Call custom BusOff callback in NON-AUTOSAR MODE */
    Can_43_LLCE_ControllerBusOffCallback(u8HwCtrl);
}
#endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */


/* Wrapper for configurable callback in non-Autosar context, and CanIf callback in Autosar context. */
void Can_43_LLCE_RxIndication(uint32 u32MbMessageId, uint16 u16FilterId, uint8* u8FramePayload, uint8 u8MbDataLength)
{
    uint8 Controller;
    /* Used to store the FD feature enable or disable. */
    uint8 u8FdEnable;  
    /* Variable to hold the index of the current baudrate */
    uint8 u8BaudrateIndex;
    uint8 u8MbDataLengthCopy;
    uint8 u8HwCtrl;

    /* comply with misra Rule 17.8 A function parameter should not be modified */
    u8MbDataLengthCopy = u8MbDataLength;
    /* Identify the corresponding controller */
    Controller = Can_43_LLCE_GetCurrentConfig()->aHohList[u16FilterId].u8ControllerId;

    /* Get the hardware offset for this controller. */
    u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    u8BaudrateIndex = Can_43_LLCE_ControllerBaudRateIndexes[Controller].u8CurrentBaudRateIndex;
    u8FdEnable = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].pControllerBaudrateConfigsPtr[u8BaudrateIndex].baudrateConfig.ControllerFD.u8FdEnable;

    /* Check if the length parameter is bigger than the maximum accepted value defined by the configuration. */
    if ( (u8FdEnable == (uint8)FALSE) && (u8MbDataLengthCopy > (uint8)8U) )
    {
        /* Shrink the length parameter according to the configuration. This prevents a buffer overflow generated by a CAN bus error affecting length field. */
        u8MbDataLengthCopy = (uint8)8U;
    }
    else if ( (u8FdEnable == (uint8)TRUE) && (u8MbDataLengthCopy > (uint8)64U) )
    {
        u8MbDataLengthCopy = (uint8)64U;
    }
    else if (( (u32MbMessageId & (uint32)CAN_LPDU_FD_U32) != CAN_LPDU_FD_U32) && ( u8MbDataLengthCopy > (uint8)8U ))
    {
        u8MbDataLengthCopy = (uint8)8U;
    }
    else
    {
        /* Length ok. */
    }

    #if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
        /* Identifies the HRH and its corresponding CAN Controller. */
        Can_HwType Mailbox;
        /* Pointer to the received L-PDU. */
        PduInfoType PduInfo;

        /* Standard/Extended CAN ID of CAN L-PDU */
        Mailbox.CanId = u32MbMessageId;       
        
        /* ID of the corresponding Hardware Object Range */
        Mailbox.Hoh = u16FilterId;

        Mailbox.ControllerId = Can_43_LLCE_GetCurrentConfig()->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId;

        /* length of the SDU in bytes */
        PduInfo.SduLength = u8MbDataLengthCopy;
        
        /* pointer to the SDU (i.e. payload data) of the PDU */
        PduInfo.SduDataPtr = u8FramePayload;

        CanIf_RxIndication(&Mailbox, &PduInfo );
    #else /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
        Can_43_LLCE_RxIndicationCallback(u8HwCtrl, u16FilterId, u8FramePayload, u8MbDataLengthCopy);
    #endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
}

void Can_Hth_FreeTxObject(uint16 Hth, uint8 freeObjCount)
{
    #if (STD_ON == AUTOSAR_COMPATIBLE_MODE)

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_02();

    /* Increase the number of free Tx objects for the current HTH */
    Can_au16TransmitHwObjectCnt[Hth - CAN_43_LLCE_FIRST_HTH_CONFIGURED] += freeObjCount;
    
    if ( Can_au16TransmitHwObjectCnt[Hth - CAN_43_LLCE_FIRST_HTH_CONFIGURED] > Can_43_LLCE_GetCurrentConfig()->aHohList[Hth].u16MbCount )
    {
        Can_au16TransmitHwObjectCnt[Hth - CAN_43_LLCE_FIRST_HTH_CONFIGURED] = Can_43_LLCE_GetCurrentConfig()->aHohList[Hth].u16MbCount;
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_02();

    #endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
}


===== 文件 [103/112]: source&include\src\Can_Llce.c =====
/**
*   @file    Can_Llce.c
*   @implements Can_Llce.c_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - IP module implementation.
*   @details Low Level Driver implementation.
*
*   @internal
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/


#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Can_43_LLCE.h"
#include "Can_43_LLCE_IPW.h"
#include "Can_43_LLCE_AFcfg.h"
#include "Can_43_LLCE_Externals.h"
#include "Can_Llce_Types.h"
#include "Can_Callback.h"
#include "SchM_Can_43_LLCE.h"

#include "OsIf.h"
#include "Mcal.h"
#include "Llce_InterfaceFifo.h"
#include "Llce_FwVersion.h"
#include "Llce_SwFifo.h"
#include "Llce_InterfaceCanUtils.h"

#if ((LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON))
 /* memset */
 #include <string.h>
 /* PFE interface enabled */
 #include <pfe_minihif_drv.h>
#endif

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/**
* @file           Can_Llce.c
*/
#define CAN_LLCE_VENDOR_ID_C                    43
#define CAN_LLCE_AR_RELEASE_MAJOR_VERSION_C     4
#define CAN_LLCE_AR_RELEASE_MINOR_VERSION_C     4
#define CAN_LLCE_AR_RELEASE_REVISION_VERSION_C  0
#define CAN_LLCE_SW_MAJOR_VERSION_C             1
#define CAN_LLCE_SW_MINOR_VERSION_C             0
#define CAN_LLCE_SW_PATCH_VERSION_C             10

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/* Check if current file and CAN header file are of the same vendor */
#if (CAN_LLCE_VENDOR_ID_C != CAN_LLCE_VENDOR_ID_H)
    #error "Can_Llce.c and Can_Llce.h have different vendor ids"
#endif
/* Check if current file and CAN header file are of the same Autosar version */
#if ((CAN_LLCE_AR_RELEASE_MAJOR_VERSION_C    != CAN_LLCE_AR_RELEASE_MAJOR_VERSION_H) || \
     (CAN_LLCE_AR_RELEASE_MINOR_VERSION_C    != CAN_LLCE_AR_RELEASE_MINOR_VERSION_H) || \
     (CAN_LLCE_AR_RELEASE_REVISION_VERSION_C != CAN_LLCE_AR_RELEASE_REVISION_VERSION_H))
    #error "AutoSar Version Numbers of Can_Llce.c and Can_Llce.h are different"
#endif
/* Check if current file and CAN header file are of the same Software version */
#if ((CAN_LLCE_SW_MAJOR_VERSION_C != CAN_LLCE_SW_MAJOR_VERSION_H) || \
     (CAN_LLCE_SW_MINOR_VERSION_C != CAN_LLCE_SW_MINOR_VERSION_H) || \
     (CAN_LLCE_SW_PATCH_VERSION_C != CAN_LLCE_SW_PATCH_VERSION_H))
    #error "Software Version Numbers of Can_Llce.c and Can_Llce.h are different"
#endif


/* Check if current file and CAN_IPW header file are of the same vendor */
#if (CAN_LLCE_VENDOR_ID_C != CAN_IPW_VENDOR_ID_H)
    #error "Can_43_LLCE.c and Can_43_LLCE_IPW.h have different vendor ids"
#endif
/* Check if current file and CAN_IPW header file are of the same Autosar version */
#if ((CAN_LLCE_AR_RELEASE_MAJOR_VERSION_C    != CAN_IPW_AR_RELEASE_MAJOR_VERSION_H) || \
     (CAN_LLCE_AR_RELEASE_MINOR_VERSION_C    != CAN_IPW_AR_RELEASE_MINOR_VERSION_H) || \
     (CAN_LLCE_AR_RELEASE_REVISION_VERSION_C != CAN_IPW_AR_RELEASE_REVISION_VERSION_H))
    #error "AutoSar Version Numbers of Can_43_LLCE.c and Can_43_LLCE_IPW.h are different"
#endif
/* Check if current file and CAN_IPW header file are of the same Software version */
#if ((CAN_LLCE_SW_MAJOR_VERSION_C != CAN_IPW_SW_MAJOR_VERSION_H) || \
     (CAN_LLCE_SW_MINOR_VERSION_C != CAN_IPW_SW_MINOR_VERSION_H) || \
     (CAN_LLCE_SW_PATCH_VERSION_C != CAN_IPW_SW_PATCH_VERSION_H))
    #error "Software Version Numbers of Can_43_LLCE.c and Can_43_LLCE_IPW.h are different"
#endif

/* Check if current file and CANIF_CBK header file are of the same version */
#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
  #ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
    #if ((CAN_LLCE_AR_RELEASE_MAJOR_VERSION_C != CANIF_CAN_AR_RELEASE_MAJOR_VERSION) || \
         (CAN_LLCE_AR_RELEASE_MINOR_VERSION_C != CANIF_CAN_AR_RELEASE_MINOR_VERSION))
        #error "AutoSar Version Numbers of Can_43_LLCE.c and CanIf_Can.h are different"
    #endif
  #endif
#endif

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/
#define LLCE_BCAN_SR_FLTCONF_MASK_U32             ((uint32)0x0000000CU)
#define LLCE_BCAN_SR_FLTCONF_ERROR_ACTIVE_U32     ((uint32)0x00000000U)
#define LLCE_BCAN_SR_FLTCONF_ERROR_PASSIVE_U32    ((uint32)0x00000004U)
#define LLCE_BCAN_SR_FLTCONF_BUSOFF10_U32         ((uint32)0x00000008U)
#define LLCE_BCAN_SR_FLTCONF_BUSOFF11_U32         ((uint32)0x0000000CU)
#define LLCE_BCAN_ECR_REC_MASK_U32                ((uint32)0x000000FFU)
#define LLCE_BCAN_ECR_TEC_MASK_U32                ((uint32)0x0000FF00U)
#define LLCE_BCAN_ECR_REC_SHIFT_U8                ((uint8)0U)
#define LLCE_BCAN_ECR_TEC_SHIFT_U8                ((uint8)8U)

#define LLCE_CAN_MB_29BIT_MASK_U32                ((uint32)0x1FFFFFFFU)

#define PFE_HIF_RING_CFG_LENGTH         128U /*number of BD*/
/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/
#if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0) && ((LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0))
 #define CAN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED_NO_CACHEABLE
 #include "Can_43_LLCE_MemMap.h"

 /* Array to store mapping between destination indexes at configuration and runtime */
 static uint8 Can_au8DestinationIdxMap[LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT];
 
 
 #define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED_NO_CACHEABLE
 #include "Can_43_LLCE_MemMap.h"
#endif /*  (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0) && ((LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0)) */

#if ((LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON))
 #define CAN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED_NO_CACHEABLE
 #include "Can_43_LLCE_MemMap.h"

 /* PFE interface enabled */
 static pfe_minihif_drv_t llce_minihif;
 
 #define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED_NO_CACHEABLE
 #include "Can_43_LLCE_MemMap.h"
#endif /* ((LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON)) */

#define CAN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"
/**
* @brief          Array holding current status/run-time configuration of individual hardware controllers
* @details        Array holding current status/run-time configuration of individual hardware controllers
*                 - information like Guard bits, Pre-calculated MB INT masks, Storage space for id, INT nesting level,
*                 Index of MB buffer being canceled,  Controller Options.
*
*
*/
static Can_43_LLCE_ControllerStatusType Can_43_LLCE_ControllerStatuses[LLCE_CAN_CONFIG_MAXCTRL_COUNT];

static uint8 au8VersionStringBuf[LLCE_VERSION_MAX_LENGTH];
static uint8 u8VersionLength = 0;

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
  /* Counters used for HRH-filter mapping */
  #if defined(S32G2XX)
    static uint16 Can_Llce_u16RxLutExactMatchCounter = 0U, Can_Llce_u16RxLutConfigurableCounter = 512U;
  #elif defined(S32G3XX)
    static uint16 Can_Llce_au16RxLutCounter[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
  #endif

    static boolean Can_Llce_bHeadlessInitDone_InitPlatform = FALSE;
    static boolean Can_Llce_bHeadlessInitDone_InitController = FALSE;
    static boolean Can_Llce_bHeadlessInitDone_SetConfiguredReceiveFilters = FALSE;
    static boolean Can_Llce_bHeadlessInitDone_AfInit = FALSE;
    static boolean Can_Llce_bHeadlessInitDone_SetControllerToStartMode[LLCE_CAN_CONFIG_MAXCTRL_COUNT] =
        { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE  };


#endif /* CAN_LLCE_USE_HEADLESSMODE == STD_ON */

#define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_SHAREDMEMORY
#include "Can_43_LLCE_MemMap.h"

static volatile Llce_Can_SharedMemoryType Can_SharedMemory;
    
#define CAN_43_LLCE_STOP_SEC_SHAREDMEMORY
#include "Can_43_LLCE_MemMap.h"

/** @brief   STM timer used for performance measurements. */
#ifdef CAN_43_LLCE_STM_MEASUREMENT_ENABLE
/* Status variable used to get feedback from Llce when the boot has ended */
extern volatile uint32 Stm_Measurement;
#endif

#define CAN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

static uint16 Can_u16NotifIntrEnable[LLCE_CAN_CONFIG_HIF_COUNT];

#if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U) || (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0)
static uint16 Can_Llce_au16RxHrh2FilterAddr[CAN_43_LLCE_MAXHRH_CONFIGURED];
#endif

#if (CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED == STD_ON)
  static Llce_Can_AdvancedFilterType* Can_Llce_apRxHrh2AfFilterCfg[CAN_43_LLCE_MAXHRH_CONFIGURED];
#endif


#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
/* Buffer table for notification errors reported in polling mode */
static Llce_Can_NotificationType Can_Llce_aNotif1_Table[LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE];
/* Sw fifo for errors buffering */
static Llce_SwFifo_Type Can_Llce_xNotifSwFifo;
#endif

/* Number of interrupt enable requests per interface. Helps to disable the interface interrupt
   only when all the controllers assigned to that interface are being requested to interrupt disable.  */
static uint8 Can_Llce_au8FifoSetIntEnCnt[LLCE_CAN_CONFIG_MAXCTRL_COUNT];

#define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"


#define CAN_43_LLCE_START_SEC_VAR_INIT_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

static const Can_43_LLCE_ConfigType * Can_Llce_pxGlobalConfigs[CAN_43_LLCE_MAX_PARTITIONS];

#define CAN_43_LLCE_STOP_SEC_VAR_INIT_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"


#define CAN_43_LLCE_START_SEC_CODE
#include "Can_43_LLCE_MemMap.h"


/*=================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
=================================================================================================*/
static const Can_43_LLCE_ConfigType* Can_Llce_GetCurrentConfig(void);

#if (CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED == STD_OFF)
static void Can_Llce_ControllerBusOff(uint8 u8HwCtrl);
#endif

static inline void Can_Llce_DisableInterrupts (uint8 u8HwCtrl);
static inline void Can_Llce_EnableInterrupts (uint8 u8HwCtrl);
static inline void Can_Llce_ResetIntFlags (uint8 u8HwCtrl);

static Std_ReturnType Can_Llce_SetControllerToStopMode(uint8 u8HwCtrl);
static Std_ReturnType Can_Llce_SetControllerToStartMode(uint8 u8HwCtrl, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr);
static Std_ReturnType Can_Llce_SetControllerToSleepMode(uint8 u8HwCtrl);
static Std_ReturnType Can_Llce_GetLlceControllerMode(uint8 u8HwCtrl, Llce_Can_CtrlStateType *eLlceControllerMode);
static Llce_Fw_ReturnType Can_Llce_ExecuteIfCommand(uint8 u8HwCtrl);
static void Can_Llce_UpdateMB(const Can_43_LLCE_TxFrameInfoType* TxFrameInfo);
static void Can_Llce_ProcessFilterIdMaskType(Llce_Can_IdLengthType eIdType, volatile Llce_Can_ReceiveFilterType * pxFilter);
static Llce_Fw_ReturnType Can_Llce_InitPlatform(const Can_43_LLCE_ConfigType * pxCurrentConfig, uint8 u8ControllersCount);
static Llce_Fw_ReturnType Can_Llce_InitController(void);
static void Can_Llce_SetConfiguredReceiveFilters(void);
#if (RXLUT2_ENABLE == STD_ON)
static void Can_Llce_SetConfiguredAuxReceiveFilters(void);
#endif
static Std_ReturnType Can_Llce_SendSetFilterCommand(const volatile Llce_Can_ReceiveFilterType *pRxFilters, uint8 filterLoadedCount, uint8 u8HwCtrl);
static Llce_Fw_ReturnType Can_Llce_SendStopCmd(uint8 u8HwCtrl);
static void Can_Llce_ComputeMbConfig(uint32 SduLength, uint32 u32MessageId, uint8 u8EnabledFD, uint32* pu32MbConfig, uint8* pu8RealDataLength);
static void Can_Llce_ResetFifoContent(uint8 u8Interface);
static inline Std_ReturnType Can_Llce_CheckCommandAvailable(void);
static Std_ReturnType Can_Llce_UpdateToStartMode(uint8 u8HwCtrl, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr);

#if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0) && ((LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0))
static Llce_Fw_ReturnType Can_Llce_CreateConfiguredAfDestinations(void);
#endif

#if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0)
static void Can_Llce_AfInit( void );
static void Can_Llce_SetConfiguredAfFilters(void);
#endif

static Std_ReturnType Can_Llce_SendSetAfFilterCommand(const volatile Llce_Can_AdvancedFilterType *pAfFilters, uint8 filterLoadedCount, uint8 u8HwCtrl);

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
static void Can_Llce_EmulateSetConfiguredReceiveFilters(void);
  #if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0)
  static void Can_Llce_EmulateSetConfiguredAfFilters(void);
  #endif
#endif

#if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)
static void Can_Llce_ProcessTxPollingClass( uint8 u8PollClassIdx );
#endif

#if (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON)
static void Can_Llce_ProcessRxPollingClass( uint8 u8PollClassIdx );
#endif

#if (CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED == STD_ON)
static boolean Can_Llce_CheckCustomCallback(uint16 u16HrhId, uint32 u32MbMessageId, uint8 u8MbDataLength, uint8* u8FramePayload, uint16 u16RxMbDescIdx);
#endif

/*================================================================================================
*                                       LOCAL FUNCTIONS
=================================================================================================*/
static const Can_43_LLCE_ConfigType* Can_Llce_GetCurrentConfig(void)
{
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
    return Can_Llce_pxGlobalConfigs[Can_43_LLCE_GetCoreID()];
#else
    return Can_Llce_pxGlobalConfigs[0];
#endif
}

static inline Std_ReturnType Can_Llce_CheckCommandAvailable(void)
{
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Check if the command buffer is not already used by other command request. */
    if (LLCE_FIFO_FNEMTY_U32 != (Reg_Read32(LLCE_FIFO_STATUS0(LLCE_FIFO_CMD_BASE_ADDRESS(pxConfig->u8ActiveHif))) & (uint32)(LLCE_FIFO_FNEMTY_U32)))    
    {
        eReturnValue = (Std_ReturnType)E_OK;
    }

    return eReturnValue;
}

static Std_ReturnType Can_Llce_UpdateToStartMode(uint8 u8HwCtrl, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Make sure no pending message was left in the FIFOs after the interrupts were disabled. */
    Can_Llce_ResetFifoContent(u8HwCtrl);

    /* (CAN384) Each time the CAN controller state machine is triggered with the state transition value CAN_CS_STARTED, the function
    Can_43_LLCE_SetControllerMode shall re-initialize the CAN controller with the same controller configuration set previously used by functions
    Can_43_LLCE_Init.*/
    if ((Std_ReturnType)E_OK == Can_Llce_ChangeBaudrate( u8HwCtrl, pxBaudrateConfigPtr))
    {
        /*
        (CAN261) The function Can_43_LLCE_SetControllerMode(CAN_CS_STARTED) shall set the hardware registers in a way that makes the CAN controller participating on the network.
        */
        /* Check if the command buffer is not already used by other command request */
        SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
        if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
        {
            /* Configure the command id. */
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETCONTROLLERMODE;

            /* Add command parameter. */
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetControllerMode.eTransition = LLCE_CAN_T_START;
            /* Send the command prepared above to the LLCE in order to be executed. */
            if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( u8HwCtrl ))
            {
                eReturnValue = (Std_ReturnType)E_OK;
            }
        }
        SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief  Disable LLCE_FIFO_FNEMTY_U32 interrupt for the FIFO interface assigned to a given controller.
*/
static inline void Can_Llce_DisableInterrupts (uint8 u8HwCtrl)
{

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    uint32 u32DrvControllerOptions = pxConfig->aHwControllerDescriptors[u8HwCtrl].u32DrvControllerOptions;
    /* Determine physical FIFO Interface assigned to HwCtrl. */
    uint8 u8FifoInterface = pxConfig->aHwControllerDescriptors[u8HwCtrl].u8FifoInterface;

    if (CAN_INTERRUPT_ENABLED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eSetIntEnRequest)
    {
        Can_43_LLCE_ControllerStatuses[u8HwCtrl].eSetIntEnRequest = CAN_INTERRUPT_DISABLED;
        /*Decrement only once per controller interrupt disable request*/
        if (Can_Llce_au8FifoSetIntEnCnt[u8FifoInterface] > 0U)
        {
            Can_Llce_au8FifoSetIntEnCnt[u8FifoInterface]--;
        }
    }

    /* Clear IER only when all controllers assigned to this interface are being requested to disable interrupts. */
    if (0U == Can_Llce_au8FifoSetIntEnCnt[u8FifoInterface])
    {
        if(LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32))
        {
            #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
            OsIf_Trusted_Call2params(Llce_Sema42_Lock, Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
            #else
            Llce_Sema42_Lock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
            #endif
            
            /* Disable needed interrupt. */
            Reg_Bit_Clear32( LLCE_FIFO_IER(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);

            #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
            OsIf_Trusted_Call1param(Llce_Sema42_Unlock, Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif));
            #else
            Llce_Sema42_Unlock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif));
            #endif
        }

        if(LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32))
        {
            #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
            OsIf_Trusted_Call2params(Llce_Sema42_Lock, Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
            #else
            Llce_Sema42_Lock(Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
            #endif

            /* Disable needed interrupt. */
            Reg_Bit_Clear32( LLCE_FIFO_IER(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);

            #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
            OsIf_Trusted_Call1param(Llce_Sema42_Unlock, Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif));
            #else
            Llce_Sema42_Unlock(Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif));
            #endif
        }
    }

    if(LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32))
    {
        /* Clear every bit before disabling the interrupt */
        Can_u16NotifIntrEnable[pxConfig->u8ActiveHif] &= ~(((uint16)1U) << u8HwCtrl);

        Can_Llce_DisableNotifInterrupt(pxConfig->u8ActiveHif);
    }
}

static inline void Can_Llce_ResetIntFlags (uint8 u8HwCtrl)
{
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    uint32 u32DrvControllerOptions = pxConfig->aHwControllerDescriptors[u8HwCtrl].u32DrvControllerOptions;
   /* Determine physical FIFO Interface assigned to HwCtrl. */
    uint8 u8FifoInterface = pxConfig->aHwControllerDescriptors[u8HwCtrl].u8FifoInterface;

    if(LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32))
    {   
        /* Clear all interrupt status flags. */
        Reg_Write32(LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface)),Reg_Read32(LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface))));
    }

     if(LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32))
    {
        /* Clear all interrupt status flags. */
        Reg_Write32(LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface)),Reg_Read32(LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface))));
    }

}
/*================================================================================================*/
/**
* @brief  Enable LLCE_FIFO_FNEMTY_U32 interrupt for the FIFO interface assigned to a given controller.
*/
static inline void Can_Llce_EnableInterrupts (uint8 u8HwCtrl)
{
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    uint32 u32DrvControllerOptions = pxConfig->aHwControllerDescriptors[u8HwCtrl].u32DrvControllerOptions;
   /* Determine physical FIFO Interface assigned to HwCtrl. */
    uint8 u8FifoInterface = pxConfig->aHwControllerDescriptors[u8HwCtrl].u8FifoInterface;

    if (CAN_INTERRUPT_DISABLED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eSetIntEnRequest)
    {
        Can_43_LLCE_ControllerStatuses[u8HwCtrl].eSetIntEnRequest = CAN_INTERRUPT_ENABLED;
        /*Increment only once per controller interrupt enable request*/
        Can_Llce_au8FifoSetIntEnCnt[u8FifoInterface]++;
    }
    
    if(LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32))
    {   
        #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
        OsIf_Trusted_Call2params(Llce_Sema42_Lock, Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
        #else
        Llce_Sema42_Lock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
        #endif
        
        /* Enable needed interrupt. */
        Reg_Bit_Set32( LLCE_FIFO_IER(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);

        #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
        OsIf_Trusted_Call1param(Llce_Sema42_Unlock, Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif));
        #else
        Llce_Sema42_Unlock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif));
        #endif
    }
    
    if(LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32))
    {
        #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
        OsIf_Trusted_Call2params(Llce_Sema42_Lock, Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
        #else
        Llce_Sema42_Lock(Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
        #endif

        /* Enable needed interrupt. */
        Reg_Bit_Set32( LLCE_FIFO_IER(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);

        #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
        OsIf_Trusted_Call1param(Llce_Sema42_Unlock, Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif));
        #else
        Llce_Sema42_Unlock(Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif));
        #endif
    }
      
    if(LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32))
    {
        Can_Llce_EnableNotifInterrupt(pxConfig->u8ActiveHif);

        Can_u16NotifIntrEnable[pxConfig->u8ActiveHif] |= (((uint16)1U) << u8HwCtrl);
    }

}

/*================================================================================================*/
/**
* @brief  Enable LLCE_FIFO_FNEMTY_U32 interrupt for the FIFO NOTIF of the given Hif.
*/
void Can_Llce_EnableNotifInterrupt(uint8 u8ActiveHif)
{
    if (0U == Can_u16NotifIntrEnable[u8ActiveHif])
    {
        /* Enable NOTIF interrupt. */
        Reg_Bit_Set32( LLCE_FIFO_IER(LLCE_NOTIF_FIFO0_BASE_ADDRESS(u8ActiveHif)), LLCE_FIFO_FNEMTY_U32);
    }
}

/*================================================================================================*/
/**
* @brief  Disable LLCE_FIFO_FNEMTY_U32 interrupt for the FIFO NOTIF of the given Hif.
*/
void Can_Llce_DisableNotifInterrupt(uint8 u8ActiveHif)
{
    if (0U == Can_u16NotifIntrEnable[u8ActiveHif])
    {
        /* Disable NOTIF interrupt. */
        Reg_Bit_Clear32( LLCE_FIFO_IER(LLCE_NOTIF_FIFO0_BASE_ADDRESS(u8ActiveHif)), LLCE_FIFO_FNEMTY_U32);
    }
}

/*================================================================================================*/
/**
* @brief          Service to Perform software triggered state transitions of the CAN controller State machine.
* @details        Transition controller to Stop state/mode.
*
*                 This routine is called by:
*                  - Can_Llce_SetControllerMode()
*
* @param[in]      u8HwCtrl CAN controller for which the init shall be done.
*
* @return         Std_ReturnType
* @retval         E_OK transition initiated
* @retval         E_NOT_OK development or production error
*
*/
static Std_ReturnType Can_Llce_SetControllerToStopMode(uint8 u8HwCtrl)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue;
    
    Can_ControllerStateType eCtrlState = CAN_CS_UNINIT;

    if((Std_ReturnType)E_OK == Can_Llce_GetControllerMode(u8HwCtrl, &eCtrlState))
    {
        /*
           (PR-MCAL-3057) The Can driver shall not create a development error if the CanIf requests a transition to a state that was already reached.
        */
        if ( CAN_CS_STOPPED == eCtrlState)
        {
            /* Notify the CanIf about a successfully transition. */
            Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_STOPPED);
            /* If the controller is already in STOP state, return E_OK. */
            eReturnValue = E_OK;
        }
        else
        {
            /* Evaluate transition */
            if ( CAN_CS_STARTED == eCtrlState)
            {
                /*
                  (CAN263) The function Can_43_LLCE_SetControllerMode(CAN_CS_STOPPED) shall set the bits inside the CAN hardware such that the CAN controller
                           stops participating on the network.
                */
                eCommandReturnValue = Can_Llce_SendStopCmd( u8HwCtrl );
                if(LLCE_FW_SUCCESS == eCommandReturnValue)
                {
                    eReturnValue = E_OK;
                }
            }
            else if (CAN_CS_SLEEP == eCtrlState)
            {
                /*
                   (CAN267) If the CAN HW does not support a sleep mode, the transition from SLEEP to STOPPED shall return from the logical sleep mode
                */
                SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState= CAN_CS_STOPPED;
                SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
                /* Notify the CanIf about a successfully transition. */
                Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_STOPPED);

                /* Set API return code.*/
                eReturnValue = E_OK;
            }
            /* Report invalid transition */
            else
            {
                (void)Can_43_LLCE_ReportError((uint8)CAN_43_LLCE_SID_SET_CONTROLLER_MODE, (uint8)CAN_43_LLCE_E_TRANSITION);
            }
        }
    }

    return eReturnValue;
}


static Llce_Fw_ReturnType Can_Llce_SendStopCmd(uint8 u8HwCtrl)
{

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Variable for return status. */
    Llce_Fw_ReturnType eCommandReturnValue = LLCE_FW_NOTRUN;
    
    /* Timeout counter. */
    uint32          u32timeStart = 0U;
    uint32          u32timeElapsed = 0U;
    uint32          u32TicksDelayDuration = 0U;

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    /* Check if the command buffer is not already used by other command request */
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETCONTROLLERMODE;  

        /* Add command parameter. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetControllerMode.eTransition = LLCE_CAN_T_STOP;

        /* Send the command prepared above to the LLCE in order to be executed */
        eCommandReturnValue = Can_Llce_ExecuteIfCommand( u8HwCtrl );
    }
 
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    if (LLCE_FW_SUCCESS == eCommandReturnValue)
    {
        u32TicksDelayDuration = OsIf_MicrosToTicks(CAN_43_LLCE_TIMEOUT_DURATION, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
        
        u32timeStart = OsIf_GetCounter(CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);

        /* 
        [SWS_Can_00372] 
        In case the flag signals that the change takes no effect and the maximum time CanTimeoutDuration is elapsed,
        the function Can_SetControllerMode shall be left and the function Can_Mainfunction_Mode shall continue to poll the flag. 
        */
        do
        {
            u32timeElapsed += OsIf_GetElapsed(&u32timeStart, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            Can_Llce_MainFunctionMode(u8HwCtrl);
        } while ( (u32timeElapsed < u32TicksDelayDuration) && (CAN_CS_STOPPED != Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState) );
        
        #ifdef MCAL_ENABLE_FAULT_INJECTION
        MCAL_FAULT_INJECTION_POINT(CAN_43_LLCE_FIP_1_STOP_MODE_WHILE_LOOP);
        #endif
    }

    return eCommandReturnValue;
}

/*================================================================================================*/
/**
* @brief          Service to Perform software triggered state transitions of the CAN controller State machine.
* @details        Transition controller to Start state/mode.
*
*                 This routine is called by:
*                  - Can_Llce_SetControllerMode()
*
* @param[in]      u8HwCtrl CAN controller for which the init shall be done.
* @param[in]      pxBaudrateConfigPtr Configuration parameters for the controller baud rate settings
*
* @return         Std_ReturnType
* @retval         E_OK transition initiated
* @retval         E_NOT_OK development or production error
*
*/
static Std_ReturnType Can_Llce_SetControllerToStartMode(uint8 u8HwCtrl, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue;
    /* Timeout counter. */
    uint32          u32timeStart = 0U;
    uint32          u32timeElapsed = 0U;
    uint32          u32TicksDelayDuration = 0U;
    Llce_Can_CtrlStateType eLlceControllerMode = LLCE_CAN_UNINIT_CTRL;
    Can_ControllerStateType eCachedStateCopy;
    
#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();
#endif

    eReturnValue = Can_Llce_GetLlceControllerMode(u8HwCtrl, &eLlceControllerMode);

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
  if((FALSE == pxConfig->bHeadlessModeEnabled) || (TRUE == Can_Llce_bHeadlessInitDone_SetControllerToStartMode[u8HwCtrl]) )
  {
#endif

    if((Std_ReturnType)E_OK == eReturnValue)
    {
        eCachedStateCopy = Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState;
        if ((LLCE_CAN_START_PENDING == eLlceControllerMode) || 
            ((LLCE_CAN_STARTED == eLlceControllerMode) && (CAN_CS_STOPPED == eCachedStateCopy)))
        {
            /* FW is still performing START transition or has switched to START meanwhile  */
            eReturnValue = E_OK;
        }
        else
        {
            /* Valid transitions to Start mode are allowed only from Stop state. */
            if (( LLCE_CAN_STOPPED != eLlceControllerMode) || (CAN_CS_SLEEP == eCachedStateCopy))
            {
                (void)Can_43_LLCE_ReportError((uint8)CAN_43_LLCE_SID_SET_CONTROLLER_MODE, (uint8)CAN_43_LLCE_E_TRANSITION);
                eReturnValue = E_NOT_OK;
            }
            else
            {
               eReturnValue = Can_Llce_UpdateToStartMode(u8HwCtrl, pxBaudrateConfigPtr);
            }
        }
    }

    if ((Std_ReturnType)E_OK == eReturnValue)
    {
        u32TicksDelayDuration = OsIf_MicrosToTicks(CAN_43_LLCE_TIMEOUT_DURATION, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
        u32timeStart = OsIf_GetCounter(CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);

        /*
        [SWS_Can_00372]
        In case the flag signals that the change takes no effect and the maximum time CanTimeoutDuration is elapsed,
        the function Can_SetControllerMode shall be left and the function Can_Mainfunction_Mode shall continue to poll the flag. 
        */
        do
        {
            u32timeElapsed += OsIf_GetElapsed(&u32timeStart, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            Can_Llce_MainFunctionMode(u8HwCtrl);
        } while ( (u32timeElapsed < u32TicksDelayDuration) && (CAN_CS_STARTED != Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState) );
        
        #ifdef MCAL_ENABLE_FAULT_INJECTION
        MCAL_FAULT_INJECTION_POINT(CAN_43_LLCE_FIP_2_START_MODE_WHILE_LOOP);
        #endif
    }

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
  }
  else
  {
    Can_Llce_bHeadlessInitDone_SetControllerToStartMode[u8HwCtrl] = TRUE;

    Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState= CAN_CS_STARTED;
    
    /* Notify the CanIf about a successfully transition. */
    Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_STARTED);

    /* (CAN196) The function Can_43_LLCE_SetControllerMode shall enable interrupts that are needed in the new state.
    (CAN425)   Enabling of CAN interrupts shall not be executed, when CAN interrupts have been disabled by function CAN_DisableControllerInterrupts.
    */
    if ( CAN_INTERRUPT_ENABLED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eInterruptMode )
    {
        Can_Llce_EnableInterrupts(u8HwCtrl);
    }

    eReturnValue = E_OK;
  }
#endif

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief          Service to Perform software triggered state transitions of the CAN controller State machine.
* @details        Transition controller to Sleep state/mode.
*
*                 This routine is called by:
*                  - Can_Llce_SetControllerMode()
*
* @param[in]      u8HwCtrl CAN controller for which the init shall be done.
*
* @return         Std_ReturnType
* @retval         E_OK transition initiated
* @retval         E_NOT_OK development or production error
*
*/
static Std_ReturnType Can_Llce_SetControllerToSleepMode(uint8 u8HwCtrl)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue;
    Can_ControllerStateType eCtrlState = CAN_CS_UNINIT;

    if((Std_ReturnType)E_OK == Can_Llce_GetControllerMode(u8HwCtrl, &eCtrlState))
    {
        /*
           (PR-MCAL-3057) The Can driver shall not create a development error if the CanIf requests a transition to a state that was already reached.
        */
        if ( CAN_CS_SLEEP == eCtrlState )
        {
            /* If the controller is already in SLEEP state, return E_OK. */
            eReturnValue = E_OK;
        }
        else
        {
            /* Valid transitions to Sleep state are only from Stop state. */
            if ( CAN_CS_STOPPED != eCtrlState)
            {
               (void)Can_43_LLCE_ReportError((uint8)CAN_43_LLCE_SID_SET_CONTROLLER_MODE, (uint8)CAN_43_LLCE_E_TRANSITION);
            }
            else
            {
                /* Send stop command to cover intermediate states (e.g. START_PENDING) */
                eCommandReturnValue = Can_Llce_SendStopCmd(u8HwCtrl);

                /* Stop command may return success for START_PENDING or fail if already stopped */
                if( (LLCE_FW_SUCCESS == eCommandReturnValue) ||  (LLCE_ERROR_COMMAND_NOTACCEPTED == eCommandReturnValue) )
                {
                    eReturnValue = E_OK;

                    /*[CAN290]If the CAN HW does not support a sleep mode, the function Can_43_LLCE_SetControllerMode(CAN_CS_SLEEP) shall set the CAN controller to the logical sleep mode*/
                    /*[CAN405] This logical sleep mode shall left only, if function Can_43_LLCE_SetControllerMode(CAN_CS_STOPPED) is called.*/
                    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
                    Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_SLEEP;
                    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
                }
            }
        }
    }

    if((Std_ReturnType)E_OK == eReturnValue)
    {
        Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_SLEEP);
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief          Service to write data into the Message buffer for transition
* @details        This routine is used in case enabled FD feature.
*
*                 This routine is called by:
*                  - Can_Llce_Write()
*
* @param[in]     TxMbDesc - Tx message buffer descriptor
*                u32MessageId - message id
*                SduDataPtr - Pointer to Sdu data
*                SduLength  - Sdu length
*                u16HohIndex - The index of HOH in the structure array which stores the information of configured HOHs
*                u8EnabledFD - Be TRUE if CAN FD is enabled, otherwise it is FALSE
*                u8FdPaddingValue - FD padding value
*
* @return        void
*/
static void Can_Llce_UpdateMB(const Can_43_LLCE_TxFrameInfoType* TxFrameInfo)
{
    /* Variable for byte index of the MB data. */
    uint32 u32MbDataIdx = 0U;
    /* The length of data which will be filled in MB */
    uint8  u8RealDataLength = (uint8)8U;
    /* Index of MB to be filled */
    uint16 u16MbFrameIdx = 0U;
    /* Variable for storing the ConfigReg of the MB. */
    uint32 u32MbConfig = 0U;

    uint32 u32Word0 = 0U;

    uint16 u16TxMbDescIdx = 0U;

    /* Pointer to the frame payload to be sent. */
    volatile uint8 * u8FramePayload = NULL_PTR;

    /* Retrieve Tx Mb Descriptor. TX Mb descriptor index delivered by LLCE in the caller is stored in u16MbFrameIdx inside TxMbDesc.*/
    u16TxMbDescIdx = TxFrameInfo->u16MbFrameIdx;
    
    /* Set-up the MB content for Tx. */
    /* Remember the PduId for reporting back to host core when the frame is really transmitted. */
    Can_SharedMemory.Can_Tx_aMbDesc[u16TxMbDescIdx].u16FrameTag2 = TxFrameInfo->u16FrameTag2;

    /* Remember the index into the configured hardware object configuration array in order to be used later for HTH management. */
    Can_SharedMemory.Can_Tx_aMbDesc[u16TxMbDescIdx].u16FrameTag1 = TxFrameInfo->u16FrameTag1;

    /* The options for ack interface are: 0-15 for interrupt processing, 16-21 for polling classes. */
    Can_SharedMemory.Can_Tx_aMbDesc[u16TxMbDescIdx].u8AckInterface = TxFrameInfo->u8AckInterface;

    Can_SharedMemory.Can_Tx_aMbDesc[u16TxMbDescIdx].u8EnableTxFrameMac = TxFrameInfo->u8EnableTxFrameMac;
    
    u32Word0 = ((uint32)TxFrameInfo->u32MessageId & CAN_LPDU_ID_MASK_U32);

    if ( CAN_LPDU_IDE_U32 == ((uint32)TxFrameInfo->u32MessageId & CAN_LPDU_IDE_U32))
    {
        /* Set the IDE field in the tx message buffer. */
        u32Word0 |= (LLCE_CAN_MB_IDE_U32);
    }
    else
    {
       /* Standard ID - need to shift left 18 bits. */
       u32Word0 <<= LLCE_CAN_MB_IDSTD_SHIFT_U32;
    }
    
    u16MbFrameIdx = Can_SharedMemory.Can_Tx_aMbDesc[u16TxMbDescIdx].u16MbFrameIdx;
    Can_SharedMemory.Can_aMb[u16MbFrameIdx].u32Word0 = u32Word0;

    u8FramePayload = Can_SharedMemory.Can_aMb[u16MbFrameIdx].u8Payload;
    /* Copy the data into the MB memory. The driver will not read from a null pointer SDU. */
    for ( u32MbDataIdx = 0U; u32MbDataIdx < TxFrameInfo->u32SduLength; u32MbDataIdx++)
    {
       ((volatile uint8*)u8FramePayload)[u32MbDataIdx] = ((const uint8*)TxFrameInfo->u8SduDataPtr)[u32MbDataIdx];
    }

    Can_Llce_ComputeMbConfig(TxFrameInfo->u32SduLength, TxFrameInfo->u32MessageId, TxFrameInfo->u8FdEnabled, &u32MbConfig, &u8RealDataLength);

    /* Pad with configured value if applicable */
    if ((uint8)TRUE == TxFrameInfo->u8FdEnabled)
    {
        for ( u32MbDataIdx = (uint8)TxFrameInfo->u32SduLength; u32MbDataIdx < u8RealDataLength ; u32MbDataIdx++)
        {
            u8FramePayload[u32MbDataIdx] = TxFrameInfo->u8FdPaddingValue;
        }
    }
    /* Add BRS feature to the message buffer. */
    Can_SharedMemory.Can_aMb[u16MbFrameIdx].u32Word1 = u32MbConfig;

    /* Timestamp buffer is not used for Tx frames. Storing HSE KeyHandle here. */
    /* KeyHandle shall be stored only if TxFrameMac is active */
    if((uint8)TRUE == TxFrameInfo->u8EnableTxFrameMac)
    {
        Can_SharedMemory.Can_aMb[u16MbFrameIdx].u32Timestamp = TxFrameInfo->u32TxHseKeyHandle;
    }
}


static void Can_Llce_ComputeMbConfig(uint32 SduLength, uint32 u32MessageId, uint8 u8EnabledFD, uint32* pu32MbConfig, uint8* pu8RealDataLength)
{
    /*u8DataLengthMax, u8DataLengthMin, u8LengthIndex index counter*/
    uint8  u8DataLengthCount = 0U;
    /*maximum threshold values for DLC*/
    const uint8 u8DataLengthMax[8] = {8U, 12U, 16U, 20U, 24U, 32U, 48U, 64U};
    /*minimum threshold values for DLC*/
    const uint8 u8DataLengthMin[8] = {0U, 9U, 13U, 17U, 21U, 25U, 33U, 49U};

    if (((uint8)SduLength) <= (uint8)u8DataLengthMax[0])
    {
        *pu32MbConfig |= (uint32)SduLength ;
        *pu8RealDataLength = (uint8)SduLength;
    }
    else
    {
        if ((((uint32)u32MessageId) & (uint32)CAN_LPDU_FD_U32) == CAN_LPDU_FD_U32 )
        {
            for (u8DataLengthCount=1U; u8DataLengthCount<8U; u8DataLengthCount++)
            {
                if ((((uint8)SduLength)<=(uint8)u8DataLengthMax[u8DataLengthCount])&&(((uint8)SduLength)>=(uint8)u8DataLengthMin[u8DataLengthCount]))
                {
                    *pu32MbConfig |= ((uint32)((uint32)8U+(uint32)u8DataLengthCount));
                    *pu8RealDataLength = (uint8)u8DataLengthMax[u8DataLengthCount];
                    break;
                }
            }
        }
    }

    /*check to see if CanIf bit send from the user enables FD*/
    if (((uint8)TRUE == u8EnabledFD) && ((((uint32)u32MessageId) & (uint32)CAN_LPDU_FD_U32) == CAN_LPDU_FD_U32 ))
    {
        /* Configure the tx mb as a CAN FD frame. */
        *pu32MbConfig |= LLCE_CAN_MB_FDF_U32;

        /* Enable BRS feature in order to allow receiving of all CAN Fd frames.*/
        *pu32MbConfig |= LLCE_CAN_MB_BRS_U32;
    }

}

/**
* @brief          Initialization of indicator, statuses, etc.
* @details        Initialization of indicator, statuses, etc.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
* @implements     Can_Llce_ExecuteIfCommand_Activity
*
*/
static Llce_Fw_ReturnType Can_Llce_ExecuteIfCommand(uint8 u8HwCtrl)
{
    uint32 u32timeStart = 0U;
    /* Timeout counter. */
    uint32          u32timeElapsed = 0U;
    uint32          u32TicksDelayDuration = 0U;
    Std_ReturnType  temp;
    Llce_Fw_ReturnType eReturnValue;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eReturnValue = LLCE_FW_NOTRUN;
    /* Trigger an interrupt to LLCE and wait until LLCE finishes ISR processing by checking non-dynamic flags. */
    Reg_Write32( LLCE_FIFO_PUSH0(LLCE_FIFO_CMD_BASE_ADDRESS(pxConfig->u8ActiveHif)), (uint32)u8HwCtrl);
    
    u32timeStart = OsIf_GetCounter(CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
    u32TicksDelayDuration = OsIf_MicrosToTicks(CAN_43_LLCE_TIMEOUT_DURATION, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);

    do
    {
        u32timeElapsed += OsIf_GetElapsed(&u32timeStart, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
        temp = Can_Llce_CheckCommandAvailable();
    }
    while ((u32timeElapsed < u32TicksDelayDuration) && ( (Std_ReturnType)E_NOT_OK == temp));

    #ifdef MCAL_ENABLE_FAULT_INJECTION
    MCAL_FAULT_INJECTION_POINT(CAN_43_LLCE_FIP_3_EXECUTE_CMD_WHILE_LOOP);
    #endif

    if (u32timeElapsed < u32TicksDelayDuration)
    {
        eReturnValue = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eReturnValue;
    }
    else
    {
        eReturnValue = LLCE_FW_NOTRUN;
    }

    return eReturnValue;
}

/**
* @brief          Send CREATE_AF_DESTINATION command.
* @details        Create a new destination rule for LLCE Advanced Feature.
*
* @param[in]      destRule - The destination to add to the LLCE destination list
* @param[out]     pu8RuleIdx - The index of the new destination in the LLCE list. Needed for SetAdvancedFilter.
*
* @return        Std_ReturnType. Result of the request.
* @retval        E_OK  Destination created
* @retval        E_NOT_OK  Error
*/
Std_ReturnType Can_Llce_CreateAfDestination(Can_Af_DestRulesType destRule, uint8* pu8RuleIdx)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_OK;
    
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {      
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_CREATE_AF_DESTINATION;
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.CreateAfDest.rule = destRule;       
        /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( pxConfig->u8DefaultController ))
        {
            *(pu8RuleIdx) = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.CreateAfDest.u8Idx;
        }
        else
        {
            eReturnValue = E_NOT_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

/**
* @brief          Send REMOVE_AF_DESTINATION command.
* @details        This service removes an existing destination for advanced features
*
* @param[in]     u8RuleIdx - The index of the destination to be removed from the LLCE list.
*
* @return        Std_ReturnType. Result of the request.
* @retval        E_OK  Destination removed
* @retval        E_NOT_OK  Error
*/

Std_ReturnType Can_Llce_RemoveAfDestination(uint8 u8RuleIdx)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_OK;
    
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {      
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_REMOVE_AF_DESTINATION;
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.RemoveAfDest = u8RuleIdx;
        /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( pxConfig->u8DefaultController ))
        {
            /* Set the return value. */
            eReturnValue = E_OK;
        }
        else
        {
            eReturnValue = E_NOT_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}


#if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0U) && ((LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT > 0U) || (LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0U) || (LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0U))
/**
* @brief          Create AF Destinations from driver configuration
* @details        Initialization of indicator, statuses, etc.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
static Llce_Fw_ReturnType Can_Llce_CreateConfiguredAfDestinations(void)
{
    /* Variable for indexing all the MBs from hardware unit chain (all controllers). */
    uint16 i = 0U;
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_SUCCESS;
    volatile Can_Af_DestRulesType* pAfRule;

#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
    const uint32 u32CoreId = Can_43_LLCE_GetCoreID();
#endif

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();
    pAfRule = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.CreateAfDest.rule);

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Load the destination rule lists. Use any controller. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_CREATE_AF_DESTINATION;

        for(i=0; i < (LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT); i++)
        {
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            /* Multicore: create only destinations mapped to this core */
            if(u32CoreId == Llce_Can_AfDestOwnerCoreId[i])
            {
#endif
                *pAfRule = Llce_Can_AfRoutingTable[i];
                #if ((LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0U) || (LLCE_CAN_ADVANCED_FEATURE_CAN2PCIE_CNT > 0U))
                    switch (pAfRule->eAfDestId)
                    {
                    case CAN_AF_CAN2ETH:
                        pAfRule->AfDest.Can2Eth.pu8Can2EthBuffAddr = (uint32)pLlce_Can_AfBuffer[i];
                        break;
                    case CAN_AF_CAN2PCIE:
                        pAfRule->AfDest.Can2Pcie.pu8Can2PcieBuffAddr = (uint32)pLlce_Can_AfBuffer[i];
                        break;
                    default:
                        /* Copying the buffer is only required for CAN2ETH and CAN2OTHER */
                        break;
                    }
                #endif
                /* Send the command prepared above to the LLCE in order to be executed */
                eReturnValue = Can_Llce_ExecuteIfCommand( pxConfig->u8DefaultController );
                if(LLCE_FW_SUCCESS == eReturnValue)
                {
                    Can_au8DestinationIdxMap[i] = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.CreateAfDest.u8Idx;
                }
                else
                {
                    break;
                }
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            }
#endif
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;

}
#endif

/**
* @brief          Send SETADVANCEDFILTER command.
* @details        Initialization of filters which include AF rules.
*                 This routine is called by:
*                 - Can_Llce_AfInit from Can_Llce.c file.
*
* @pre            The AF rules must be set in advance.
* @post           Set the filters and AF rules as generated in configuration.
*
*/
#if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0)
static void Can_Llce_SetConfiguredAfFilters(void)
{
    uint8 u8HwCtrl = 0U;
    uint8 u8CtrlIndex;
    uint16 crtFilter = 0U;
    uint8 filterLoadedCount = 0U;
    Llce_Can_AdvancedFilterType * filterList;
    volatile Llce_Can_SetAdvancedFilterCmdType * pSAFCmd;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    for ( u8CtrlIndex = 0U; u8CtrlIndex < CAN_43_LLCE_MAXCTRL_CONFIGURED; u8CtrlIndex++)
    {
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
        if(Can_43_LLCE_GetCoreID() == pxConfig->aControllerDescriptors[u8CtrlIndex].u32CoreId)
        {
#endif
            u8HwCtrl = pxConfig->aControllerDescriptors[u8CtrlIndex].u8HwCtrl;

            /* Skip disabled controllers */
            if(LLCE_NULL_OFFSET_U8 != u8HwCtrl)
            {
                /*Configure the command id for all controllers which are used. */
                Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETADVANCEDFILTER;
                
                pSAFCmd = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter);

                filterList = pxConfig->paAdvancedFilters[u8HwCtrl];
                filterLoadedCount = 0U;

                for(crtFilter = 0U; crtFilter < pxConfig->pPlatfInitConfig->au16MaxAdvancedFilterCount[u8HwCtrl]; crtFilter++)
                {
                    /* Copy the AF filter to the shared memory */
                    pSAFCmd->aAdvancedFilters[filterLoadedCount] = filterList[crtFilter];

                  #if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0) && ((LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0))
                    /* Update the destination index to the actual value in FW */
                    if(LLCE_CAN_ADVANCED_FILTER_NOT_USED != filterList[crtFilter].Llce_Can_AdvancedFeature.u8Can2CanRoutingTableIdx)
                    {
                        pSAFCmd->aAdvancedFilters[filterLoadedCount].Llce_Can_AdvancedFeature.u8Can2CanRoutingTableIdx = Can_au8DestinationIdxMap[filterList[crtFilter].Llce_Can_AdvancedFeature.u8Can2CanRoutingTableIdx];
                    }
                    if(LLCE_CAN_ADVANCED_FILTER_NOT_USED != filterList[crtFilter].Llce_Can_AdvancedFeature.u8Can2EthRoutingTableIdx)
                    {
                        pSAFCmd->aAdvancedFilters[filterLoadedCount].Llce_Can_AdvancedFeature.u8Can2EthRoutingTableIdx = Can_au8DestinationIdxMap[filterList[crtFilter].Llce_Can_AdvancedFeature.u8Can2EthRoutingTableIdx];
                    }
                  #endif

                    /* Increase the count of the filters.*/
                    filterLoadedCount++;

                    /* Check if the command buffer for filters is full. */
                    if (LLCE_CAN_CONFIG_ADVANCED_FILTERS_COUNT == filterLoadedCount)
                    {
                        pSAFCmd->u16RxFiltersCount = filterLoadedCount;

                        (void)Can_Llce_SendSetAfFilterCommand(pSAFCmd->aAdvancedFilters, filterLoadedCount, u8HwCtrl);

                        /* Reset the number of filters. */
                        filterLoadedCount = 0;
                    }

                    #if (CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED == STD_ON)
                      /* Save reference to filter config for later usage. */
                      Can_Llce_apRxHrh2AfFilterCfg[filterList[crtFilter].Llce_Can_RxFilter.u16FilterId] = &(filterList[crtFilter]);
                    #endif
                }

                /* Load remaining filters if any*/
                if (filterLoadedCount > 0U)
                {
                    pSAFCmd->u16RxFiltersCount = filterLoadedCount;

                    (void)Can_Llce_SendSetAfFilterCommand(pSAFCmd->aAdvancedFilters, filterLoadedCount, u8HwCtrl);

                    /* Reset the number of filters. */
                    filterLoadedCount = 0;
                }
            }
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
        }
#endif
    }
}
#endif /* LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0 */

static Std_ReturnType Can_Llce_SendSetAfFilterCommand(const volatile Llce_Can_AdvancedFilterType *pAfFilters, uint8 filterLoadedCount, uint8 u8HwCtrl)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue = LLCE_FW_NOTRUN;

    #if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U)
    uint8 i = 0U;
    #endif

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {             
        /* Send the command prepared above to the LLCE in order to be executed */
        eCommandReturnValue =  Can_Llce_ExecuteIfCommand(u8HwCtrl);
    }

    if (LLCE_FW_SUCCESS == eCommandReturnValue)
    {
        #if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U)
        /* Copy the hw filter addr for later usage. */
        for(i = 0; i < filterLoadedCount; i++)
        {  
            Can_Llce_au16RxHrh2FilterAddr[pAfFilters[i].Llce_Can_RxFilter.u16FilterId] = pAfFilters[i].Llce_Can_RxFilter.u16FilterAddr;                                
        }
        #else
        (void)pAfFilters;
        (void)filterLoadedCount;
        #endif
        eReturnValue = E_OK;
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}





/**
* @brief          Check user callback
* @details        Check if the RX filter is configured with custom user callback, and execute it if so
*
* @return         TRUE if frame should be delivered (no custom processing or custom callback returned TRUE), FALSE otherwise
*/
#if (CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED == STD_ON)
static boolean Can_Llce_CheckCustomCallback(uint16 u16HrhId, uint32 u32MbMessageId, uint8 u8MbDataLength, uint8* u8FramePayload, uint16 u16RxMbDescIdx)
{
    boolean returnValue = TRUE;
    const Llce_Can_AdvancedFilterType * pAfFilter;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Custom processing can only apply to Advanced Filters */
    if(CAN_43_LLCE_RECEIVE_AF == pxConfig->aHohList[u16HrhId].eMBType)
    {
        pAfFilter = Can_Llce_apRxHrh2AfFilterCfg[u16HrhId];

        /* Check if custom processing is enabled */
        if(LLCE_AF_CUSTOMPROCESSING_ENABLED == pAfFilter->Llce_Can_AdvancedFeature.eCanCustomProcessing)
        {
            returnValue = Can_43_LLCE_CustomRxCallback((uint8)u16HrhId, u32MbMessageId, u8MbDataLength, u8FramePayload, u16RxMbDescIdx);
        }
    }

    return returnValue;
}
#endif
/*=================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
/**
* @brief          Removes receive filter.
* @details        Removes a single filter and make it unavailable for filtering..
*                 This routine is called by:
*
* @param[in]     Hrh - Hardware receive handler configured by user.
* @param[in]     u16FilterAddr - address of the removed filter, to be later used by Can_Llce_SetFilterAtAddress.
*
* @pre            Platform shall be insialized and the related controller initialized.
* @post           The related controller acept frames received by the filter if is started.
*
*/
Std_ReturnType Can_Llce_RemoveFilter(Can_HwHandleType Hrh, uint16* u16FilterAddr)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;

#if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U)
    uint8 u8HwCtrl;
    uint8 u8LogicCtrl;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

  if((CAN_43_LLCE_FIRST_HTH_CONFIGURED > Hrh) && (NULL_PTR != u16FilterAddr))
  {
      /* Get the logical controller id corresponding to the above hrh */
      u8LogicCtrl = pxConfig->aHohList[Hrh].u8ControllerId;

      /* Get the hardware controller corresponding to above logical controller */
      u8HwCtrl = pxConfig->aControllerDescriptors[u8LogicCtrl].u8HwCtrl;

      if(Can_Llce_au16RxHrh2FilterAddr[Hrh] != CAN_LLCE_FILTER_DEFAULT_EMPTY_ADDRESS_U16)
      {
          SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
          if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
          {                
              /*Configure the command id for all controllers which are used. */
              Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_REMOVE_FILTER;

              /*Initialize the number of filters for all controllers which are used. */
               Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.ChangeFilter.u16FilterAddr = Can_Llce_au16RxHrh2FilterAddr[Hrh]; 
               /* Return the filter address from LLCE RxLut so that the SetFilterAtAddress function can use it */
               *u16FilterAddr = Can_Llce_au16RxHrh2FilterAddr[Hrh]; 
       
              /* Send the command prepared above to the LLCE in order to be executed */
              if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( u8HwCtrl ))
              {                      
                  Can_Llce_au16RxHrh2FilterAddr[Hrh] = CAN_LLCE_FILTER_DEFAULT_EMPTY_ADDRESS_U16;
                  /* Set the return value. */
                  eReturnValue = E_OK;
              }
          }
          
          SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
      }
  }

#else /* (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U) */
        (void)Hrh;
        (void)eReturnValue;
        (void)u16FilterAddr;
#endif /* (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U) */

    return eReturnValue;
}

/**
* @brief          Set receive filter.
* @details        Set a single filter inside hw module.
*                 This routine is called by:
*                 - Can_43_LLCE_SetFilter() from Can_43_LLCE.c file.
*
* @pre            Platform shall be initialized and the related controller initialized.
* @post           The related controller accepts frames received by the filter if is started.
*
*
*/
Std_ReturnType Can_Llce_SetFilter(const Can_SetFilterType * pCanFilter)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    uint8 u8HwCtrl;
    uint8 u8LogicCtrl;
    volatile Llce_Can_ReceiveFilterType * pRxFilter = NULL_PTR;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Get the logical controller id corresponding to the current HRH */
    u8LogicCtrl = pxConfig->aHohList[pCanFilter->Hrh].u8ControllerId;

    /* Get the hardware controller corresponding to above logical controller */
    u8HwCtrl = pxConfig->aControllerDescriptors[u8LogicCtrl].u8HwCtrl;
   
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    /* Check if the command buffer is not already used by other command request. */
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /*Configure the command id for all controllers which are used. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETFILTER;

        pRxFilter = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetFilter.aRxFilters[0U]);
        /*Set a single receive filter inside LLCE for timing reasons. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetFilter.u16RxFiltersCount = 1U; 

        pRxFilter->eEntryType = pCanFilter->eFilterType;

        pRxFilter->u16FilterId = pCanFilter->Hrh;

        pRxFilter->uIdMask = pCanFilter->uIdMask;

        /* Set Rx interface for current filter. First 16 interfaces (0-15) are reserved for interrupt processing, next 6 interfaces (16-21) are for polling classes. */
        pRxFilter->u8RxDestInterface = pCanFilter->u8RWInterface;

        pRxFilter->uMessageId = pCanFilter->uMessageId;
        
        pRxFilter->u16MbCount = pCanFilter->u16MbCount;

        pRxFilter->eFilterMbLength = pCanFilter->eFilterMbLength;

        Can_Llce_ProcessFilterIdMaskType(pCanFilter->eIdType, pRxFilter);

        eReturnValue = Can_Llce_SendSetFilterCommand(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetFilter.aRxFilters, 1U /* filterLoadedCount */, u8HwCtrl);
    }
   
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

/**
* @brief          Set receive filter.
* @details        Set a single filter inside hw module.
*                 This routine is called by:
*                 - Can_43_LLCE_SetFilter() from Can_43_LLCE.c file.
*
* @pre            Platform shall be initialized and the related controller initialized.
* @post           The related controller accepts frames received by the filter if is started.
*
*
*/
Std_ReturnType Can_Llce_SetFilterAtAddress(const Can_SetFilterType * pCanFilter, const uint16 u16FilterAddr)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    uint8 u8HwCtrl;
    uint8 u8LogicCtrl;
    volatile Llce_Can_ReceiveFilterType * pRxFilter = NULL_PTR;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Get the logical controller id corresponding to the current HRH */
    u8LogicCtrl = pxConfig->aHohList[pCanFilter->Hrh].u8ControllerId;

    /* Get the hardware controller corresponding to above logical controller */
    u8HwCtrl = pxConfig->aControllerDescriptors[u8LogicCtrl].u8HwCtrl;
   
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    /* Check if the command buffer is not already used by other command request. */
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /*Configure the command id for all controllers which are used. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETFILTER_AT_ADDRESS;
        /*TDO : memorise the filter id*/

        pRxFilter = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetFilter.aRxFilters[0U]);
        /*Set a single receive filter inside LLCE for timing reasons. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetFilter.u16RxFiltersCount = 1U; 

        pRxFilter->u16FilterAddr = u16FilterAddr;

        pRxFilter->eEntryType = pCanFilter->eFilterType;

        pRxFilter->u16FilterId = pCanFilter->Hrh;

        pRxFilter->uIdMask = pCanFilter->uIdMask;

        /* Set Rx interface for current filter. First 16 interfaces (0-15) are reserved for interrupt processing, next 6 interfaces (16-21) are for polling classes. */
        pRxFilter->u8RxDestInterface = pCanFilter->u8RWInterface;

        pRxFilter->uMessageId = pCanFilter->uMessageId;
        
        pRxFilter->u16MbCount = pCanFilter->u16MbCount;

        pRxFilter->eFilterMbLength = pCanFilter->eFilterMbLength;

        Can_Llce_ProcessFilterIdMaskType(pCanFilter->eIdType, pRxFilter);

        eReturnValue = Can_Llce_SendSetFilterCommand(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetFilter.aRxFilters, 1U /* filterLoadedCount */, u8HwCtrl);
    }
   
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

/**
* @brief          Set advanced receive filter.
* @details        Set a single advanced filter inside hw module.
*                 This routine is called by:
*                 - Can_43_LLCE_SetAfFilter() from Can_43_LLCE.c file.
*
* @pre            Platform shall be initialized and the related controller initialized.
* @post           The related controller accepts frames received by the filter if is started.
*
*
*/
Std_ReturnType Can_Llce_SetAfFilter(const Can_SetAfFilterType * pAfFilter)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue;
    uint8 u8HwCtrl;
    uint8 u8LogicCtrl;
    volatile Llce_Can_ReceiveFilterType * pRxFilter = NULL_PTR;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Get the logical controller id corresponding to the current HRH */
    u8LogicCtrl = pxConfig->aHohList[pAfFilter->Filter.Hrh].u8ControllerId;

    /* Get the hardware controller corresponding to above logical controller */
    u8HwCtrl = pxConfig->aControllerDescriptors[u8LogicCtrl].u8HwCtrl;
   
    /*Configure the command id for all controllers which are used. */
    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETADVANCEDFILTER;

    /*Set a single receive filter inside LLCE for timing reasons. */
    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.u16RxFiltersCount = 1U; 

    pRxFilter = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.aAdvancedFilters[0U].Llce_Can_RxFilter);

    pRxFilter->eEntryType = pAfFilter->Filter.eFilterType;

    pRxFilter->u16FilterId = pAfFilter->Filter.Hrh;        

    pRxFilter->uIdMask = pAfFilter->Filter.uIdMask;

    /* Set Rx interface for current filter. First 16 interfaces (0-15) are reserved for interrupt processing, next 6 interfaces (16-21) are for polling classes. */
    pRxFilter->u8RxDestInterface = pAfFilter->Filter.u8RWInterface;

    pRxFilter->uMessageId = pAfFilter->Filter.uMessageId;
    
    pRxFilter->u16MbCount = pAfFilter->Filter.u16MbCount;

    Can_Llce_ProcessFilterIdMaskType(pAfFilter->Filter.eIdType, pRxFilter);
    
    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.aAdvancedFilters[0U].Llce_Can_AdvancedFeature = pAfFilter->AdvancedFeature;

    eReturnValue = Can_Llce_SendSetAfFilterCommand(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.aAdvancedFilters, 1U /* filterLoadedCount */, u8HwCtrl);

    return eReturnValue;
}

/**
* @brief          Set advanced receive filter at given address.
* @details        Set a single advanced filter inside hw module.
*                 This routine is called by:
*                 - Can_43_LLCE_SetAfFilterAtAddress from Can_43_LLCE.c file.
*
* @pre            Platform shall be initialized and the related controller initialized.
* @post           The related controller accepts frames received by the filter if it is started.
*
*
*/
Std_ReturnType Can_Llce_SetAfFilterAtAddress(const Can_SetAfFilterType * pAfFilter, const uint16 u16FilterAddr)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue;
    uint8 u8HwCtrl;
    uint8 u8LogicCtrl;
    volatile Llce_Can_ReceiveFilterType * pRxFilter = NULL_PTR;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Get the logical controller id corresponding to the current HRH */
    u8LogicCtrl = pxConfig->aHohList[pAfFilter->Filter.Hrh].u8ControllerId;

    /* Get the hardware controller corresponding to above logical controller */
    u8HwCtrl = pxConfig->aControllerDescriptors[u8LogicCtrl].u8HwCtrl;
   
    /*Configure the command id for all controllers which are used. */
    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETADVANCEDFILTER_AT_ADDRESS;
    
    /*Set a single receive filter inside LLCE for timing reasons. */
    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.u16RxFiltersCount = 1U; 

    pRxFilter = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.aAdvancedFilters[0U].Llce_Can_RxFilter);

    pRxFilter->u16FilterAddr = u16FilterAddr;

    pRxFilter->eEntryType = pAfFilter->Filter.eFilterType;

    pRxFilter->u16FilterId = pAfFilter->Filter.Hrh;        

    pRxFilter->uIdMask = pAfFilter->Filter.uIdMask;

    /* Set Rx interface for current filter. First 16 interfaces (0-15) are reserved for interrupt processing, next 6 interfaces (16-21) are for polling classes. */
    pRxFilter->u8RxDestInterface = pAfFilter->Filter.u8RWInterface;

    pRxFilter->uMessageId = pAfFilter->Filter.uMessageId;
    
    pRxFilter->u16MbCount = pAfFilter->Filter.u16MbCount;

    Can_Llce_ProcessFilterIdMaskType(pAfFilter->Filter.eIdType, pRxFilter);
    
    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.aAdvancedFilters[0U].Llce_Can_AdvancedFeature = pAfFilter->AdvancedFeature;

    eReturnValue = Can_Llce_SendSetAfFilterCommand(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.aAdvancedFilters, 1U /* filterLoadedCount */, u8HwCtrl);

    return eReturnValue;
}

/**
* @brief          Enable/disable receive filter.
* @details        Set enabled state for a single filter. Its configuration is still in LLCE and my be 
*                 reactivated later.
*/
Std_ReturnType Can_Llce_SetFilterState(Can_HwHandleType Hrh, Can_43_LLCE_FilterStateType eState)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
#if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U)
    uint8 u8HwCtrl;
    uint8 u8LogicCtrl;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

  if(CAN_43_LLCE_FIRST_HTH_CONFIGURED > Hrh )
  {
      /* Get the logical controller id corresponding to the above hrh */
      u8LogicCtrl = pxConfig->aHohList[Hrh].u8ControllerId;

      /* Get the hardware controller corresponding to above logical controller */
      u8HwCtrl = pxConfig->aControllerDescriptors[u8LogicCtrl].u8HwCtrl;

      if(Can_Llce_au16RxHrh2FilterAddr[Hrh] != CAN_LLCE_FILTER_DEFAULT_EMPTY_ADDRESS_U16)
      {
          SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
          if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
          { 
              /*Configure the command id for all controllers which are used. */
              Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETFILTERENABLESTATUS;

              /*Initialize the number of filters for all controllers which are used. */
              Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.ChangeFilter.u16FilterAddr = Can_Llce_au16RxHrh2FilterAddr[Hrh]; 
              Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.ChangeFilter.u8FilterEnabled = (uint8)eState;
          
              /* Send the command prepared above to the LLCE in order to be executed */
              if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( u8HwCtrl ))
              {                      
                  /* Set the return value. */
                  eReturnValue = E_OK;
              }
          }
          SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
      }
  }

#else /* (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U) */
        (void)Hrh;
        (void)eReturnValue;
        (void)eState;
#endif /* (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U) */

    return eReturnValue;
}

/**
* @brief          Enable/disable channel.
* @details        Set state of controller in a multicast routing configuration. 
* 
*/
Std_ReturnType Can_Llce_SetChannelRoutingOutputState(uint8 u8HwCtrl, Can_43_LLCE_ChannelStateType eChannelStatus)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /*Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETCHANNELROUTINGOUTPUTSTATE;

        if(CAN_43_LLCE_CHANNELSTATE_ENABLED == eChannelStatus)
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.eBinaryValue = LLCE_TRUE;
        }
        else
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.eBinaryValue = LLCE_FALSE;
        }

        /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( u8HwCtrl ))
        {                      
            /* Set the return value. */
            eReturnValue = E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}
/**
* @brief          Initialization of indicator, statuses, etc.
* @details        Initialization of indicator, statuses, etc.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
static void Can_Llce_InitVariables(const Can_43_LLCE_ConfigType * pxCurrentConfig, uint8 u8ControllersCount)
{
    /* Index CAN controllers from configuration. */
    uint8 u8CtrlIndex = 0U;
    /* Set local pointer to configuration structure */
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();
    Can_Llce_pxGlobalConfigs[u32CoreId] = pxCurrentConfig;
#else
    Can_Llce_pxGlobalConfigs[0] = pxCurrentConfig;
#endif

    uint8 u8HwCtrl = 0U;

    /* Init all global varibales/statuses for all controllers. */
    for ( u8CtrlIndex = 0U; u8CtrlIndex < u8ControllersCount; u8CtrlIndex++)
    {
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
        if(pxCurrentConfig->aControllerDescriptors[u8CtrlIndex].u32CoreId == u32CoreId )
        {    
#endif
            u8HwCtrl = pxCurrentConfig->aControllerDescriptors[u8CtrlIndex].u8HwCtrl;
            /* check for enabled controller */
            if(CAN_43_LLCE_NULL_OFFSET != u8HwCtrl)
            {
                /* Init INT Disable nesting indicator. It is incremented after every call of Can_43_LLCE_DisableControllerInterrupts().
                The function Can_43_LLCE_EnableControllerInterrupts() shall perform no action when Can_43_LLCE_DisableControllerInterrupts() has not been called before. */
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].u8IntDisableLevel = (uint8)0;

                /* Set  interrupt mode status to interrupt enabled mode.
                This is needed in order to support the implementation of requirements CAN425 and CAN426 into Can_43_LLCE_SetControllerMode API. */
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eInterruptMode= CAN_INTERRUPT_ENABLED;

                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eSetIntEnRequest= CAN_INTERRUPT_DISABLED;

                Can_Llce_au8FifoSetIntEnCnt[u8HwCtrl] = 0U;
            }
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
        }
#endif
    }

#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
    /* Init sw fifo used for errors buffering */
    (void)Llce_SwFifo_Init(Can_Llce_aNotif1_Table, (uint8)(sizeof(Llce_Can_NotificationType)), (uint16)(LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE), &Can_Llce_xNotifSwFifo);
#endif

}


static void Can_Llce_ProcessFilterIdMaskType(Llce_Can_IdLengthType eIdType, volatile Llce_Can_ReceiveFilterType * pxFilter)
{
    /* Range filters must not have values changed */
    if(pxFilter->eEntryType != LLCE_CAN_ENTRY_CFG_RANGED)
    {
        /* Mask the ID and Mask in order to not allow the user to configure more than 29 bits. */
        pxFilter->uIdMask &= LLCE_CAN_MB_29BIT_MASK_U32;
        pxFilter->uMessageId &= LLCE_CAN_MB_29BIT_MASK_U32;

        switch(eIdType)
        {
        case LLCE_CAN_STANDARD:
            /* Add IDE to Mask.*/
            pxFilter->uIdMask |= LLCE_CAN_MB_IDE_U32;
            break;

        case LLCE_CAN_EXTENDED:
            /* Add IDE to Mask.*/
            pxFilter->uIdMask |= LLCE_CAN_MB_IDE_U32;
            /* Add IDE bit to ID. Only Extended ID. */
            pxFilter->uMessageId |= LLCE_CAN_MB_IDE_U32;
            break;

        case LLCE_CAN_MIXED:
            /* Remove IDE from Mask.*/
            pxFilter->uIdMask &= ~(LLCE_CAN_MB_IDE_U32);
            break;

        default:
            /* Bad identifier type  */
            break; 
        }
    }
}
/**
* @brief          Perform INIT_HSE command.
* @details        Enable HSE support in the firmware if hardware support it for MAC generation and verification.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
* @pre            
* @post           
*/
#if (CAN_43_LLCE_HSE_SUPPORT_ENABLE == STD_ON)
static Llce_Fw_ReturnType Can_Llce_InitHse( void )
{
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_ERROR;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Prepare command.*/
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId  = LLCE_CAN_CMD_INIT_HSE;

        /* Execute command.*/
        eReturnValue = Can_Llce_ExecuteIfCommand( pxConfig->u8DefaultController );
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}
#endif

/**
* @brief          Perform standard Autosar initialization flow.
* @details        Service which initializes LLCE using multiple commands, as expected by LLCE firmware:
*                 LLCE_CAN_CMD_INIT_PLATFORM - initialization of common LLCE services and buffer reservation 
*                 LLCE_CAN_CMD_INIT_HSE - initialization of HSE advanced service. Enabled only with FDK LLCE sw package.
*                 LLCE_CAN_CMD_INIT - initialization of each controller in configuration with default baudrate as per configuration
*                 LLCE_CAN_CMD_SETFILTER - configuration of filters for each channel, as per configuration
*                 LLCE_CAN_CMD_CREATE_AF_DESTINATION - creation of destinations for the messages to be forwarded to
*                 LLCE_CAN_CMD_SETADVANCEDFILTER - configuration of advanced filters, mapped to the AF destinations created previously
*                 This routine is called by:
*                 - Can_43_LLCE_IPW_Init from Can_43_LLCE_IPW.c file.
*
* @pre            LLCE is not initialized
* @post           LLCE is initialized using the Autosar configuration. The controllers are in STOP state
*/
Llce_Fw_ReturnType Can_Llce_Init(const Can_43_LLCE_ConfigType * pxCurrentConfig)
{
    Llce_Fw_ReturnType eReturnValue;
#if (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON)
    uint8 i;
#endif

    eReturnValue = Can_Llce_InitPlatform(pxCurrentConfig, CAN_43_LLCE_MAXCTRL_CONFIGURED);

    if(LLCE_FW_SUCCESS == eReturnValue)
    {

        #if (CAN_43_LLCE_HSE_SUPPORT_ENABLE == STD_ON)
        eReturnValue = Can_Llce_InitHse();

        if(LLCE_FW_SUCCESS == eReturnValue)
        {
        #endif
            eReturnValue = Can_Llce_InitController();
            if(LLCE_FW_SUCCESS == eReturnValue)
            {
                Can_Llce_SetConfiguredReceiveFilters();
                #if (RXLUT2_ENABLE == STD_ON)
                Can_Llce_SetConfiguredAuxReceiveFilters();
                #endif
                #if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0)
                Can_Llce_AfInit();
                #endif
                #if (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON)
                for(i = 0U; i < LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_FORMAT_CNT; i++)
                {
                    eReturnValue = Can_Llce_SetEth2CanFormatState(Llce_Eth2Can_EnabledFormats[i], CAN_LLCE_ETH2CAN_ENABLED);
                }
                #endif
            }
        #if (CAN_43_LLCE_HSE_SUPPORT_ENABLE == STD_ON)
        }
        #endif
    }

    return eReturnValue;
}
/**
* @brief          Perform INIT_PLATFORM command.
* @details        Write variables from interface into shared memory.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
static Llce_Fw_ReturnType Can_Llce_InitPlatform(const Can_43_LLCE_ConfigType * pxCurrentConfig, uint8 u8ControllersCount)
{
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_ERROR;
#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
  #if defined(S32G3XX)
    uint8 u8HwCtrl;
  #endif
#endif

    /* Initialize local variable used by the driver. */
    Can_Llce_InitVariables(pxCurrentConfig, u8ControllersCount);

    /* Reset the notification interrupt enable. */
    Can_u16NotifIntrEnable[pxCurrentConfig->u8ActiveHif] = 0;

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
    if((FALSE == pxCurrentConfig->bHeadlessModeEnabled) || (TRUE == Can_Llce_bHeadlessInitDone_InitPlatform) )
    {
#endif
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Prepare command for initialization of common elements of the platform.*/
        Can_SharedMemory.aCanCmd[pxCurrentConfig->u8ActiveHif].eCmdId  = LLCE_CAN_CMD_INIT_PLATFORM;

        Can_SharedMemory.aCanCmd[pxCurrentConfig->u8ActiveHif].CmdList.InitPlatform =  *(pxCurrentConfig->pPlatfInitConfig);

        eReturnValue = Can_Llce_ExecuteIfCommand( pxCurrentConfig->u8DefaultController );
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
    } else {
    #if defined(S32G3XX)
        /* Calculate filter intervals in RXLUT */
        Can_Llce_au16RxLutCounter[0] = 0U;
        for(u8HwCtrl = 0U; u8HwCtrl < LLCE_CAN_CONFIG_MAXCTRL_COUNT - 1U; u8HwCtrl++)
        {
            Can_Llce_au16RxLutCounter[u8HwCtrl + 1U] = Can_Llce_au16RxLutCounter[u8HwCtrl] + 
                                                      pxCurrentConfig->pPlatfInitConfig->au16MaxRegularFilterCount[u8HwCtrl] +
                                                      pxCurrentConfig->pPlatfInitConfig->au16MaxAdvancedFilterCount[u8HwCtrl]; 
        }
    #endif /* defined(S32G3XX) */
    eReturnValue = LLCE_FW_SUCCESS;    
    Can_Llce_bHeadlessInitDone_InitPlatform = TRUE;
    }
#endif

    return eReturnValue;
}

/**
* @brief          Perform INIT command.
* @details        Initialization of indicator, statuses, etc.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
static Llce_Fw_ReturnType Can_Llce_InitController(void)
{
    uint8 u8HwCtrl = 0U;
    uint8 u8CtrlIndex = 0u;
    /* Variable for return status. */
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_SUCCESS;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    while((u8CtrlIndex < (uint8)CAN_43_LLCE_MAXCTRL_CONFIGURED) && (LLCE_FW_SUCCESS == eReturnValue))
    {
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
        if(Can_43_LLCE_GetCoreID() == pxConfig->aControllerDescriptors[u8CtrlIndex].u32CoreId)
        {
#endif
            /* Skip the initialization for the controllers that are not enabled. */
            if ( pxConfig->aControllerDescriptors[u8CtrlIndex].u8HwCtrl != (uint8)LLCE_NULL_OFFSET_U8 )
            {
                u8HwCtrl = pxConfig->aControllerDescriptors[u8CtrlIndex].u8HwCtrl;
                /* Init INT Disable nesting indicator. It is incremented after every call of Can_43_LLCE_DisableControllerInterrupts().
                The function Can_43_LLCE_EnableControllerInterrupts() shall perform no action when Can_43_LLCE_DisableControllerInterrupts() has not been called before. */
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].u8IntDisableLevel = (uint8)0U;

                /* Set  interrupt mode status to interrupt enabled mode.
                This is needed in order to support the implementation of requirements CAN425 and CAN426 into Can_43_LLCE_SetControllerMode API. */
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eInterruptMode= CAN_INTERRUPT_ENABLED;

              #if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
              if((FALSE == pxConfig->bHeadlessModeEnabled) || (TRUE == Can_Llce_bHeadlessInitDone_InitController) )
              {
              #endif
                /*Reset Interrupt Status Flags*/
                Can_Llce_ResetIntFlags(u8HwCtrl);

                SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
                /* Check if a previous command is ongoing. */
                if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
                {                     
                    /* Configure the command id */
                    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId  = LLCE_CAN_CMD_INIT;
                    
                    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.Init = pxConfig->pChannelInitConfig[u8HwCtrl];

                    eReturnValue = Can_Llce_ExecuteIfCommand(u8HwCtrl);

                    if (LLCE_FW_SUCCESS == eReturnValue)
                    {
                        Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_STOPPED;
                    }
                }

                SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

              #if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
              }
              #endif
            }
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
        }
#endif
        u8CtrlIndex++;
    }

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
    Can_Llce_bHeadlessInitDone_InitController = TRUE;
#endif

    return eReturnValue;
}

/**
* @brief          Writes configuration to memory and sends SETFILTER for all enabled controllers.
* @details        Initialization of indicator, statuses, etc.
*                 This function is non-reentrant and does not provide thread safety
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
static void Can_Llce_SetConfiguredReceiveFilters(void)
{
    uint8 u8HwCtrl = 0U;
    uint8 u8CtrlIndex;
    uint16 crtFilter;
    uint8 filterLoadedCount = 0U;
    const Llce_Can_ReceiveFilterType * filterList;
    volatile Llce_Can_SetFilterCmdType * pSFCmd;
    Std_ReturnType eReturnValue = (Std_ReturnType)E_OK;
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
    uint32 u32CoreId;
#endif

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
  /* Skip first entry for headless mode */
  if((FALSE == pxConfig->bHeadlessModeEnabled) || (TRUE == Can_Llce_bHeadlessInitDone_SetConfiguredReceiveFilters) )
  {
#endif
    /* Check if the command buffer is not already used by other command request. */
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        for (u8CtrlIndex = 0U; (u8CtrlIndex < CAN_43_LLCE_MAXCTRL_CONFIGURED); u8CtrlIndex++)
        {
            u8HwCtrl = pxConfig->aControllerDescriptors[u8CtrlIndex].u8HwCtrl;

            /* Skip disabled controllers */
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            u32CoreId = Can_43_LLCE_GetCoreID();
            if((u32CoreId == pxConfig->aControllerDescriptors[u8CtrlIndex].u32CoreId) && (LLCE_NULL_OFFSET_U8 != u8HwCtrl))
#else
            if(LLCE_NULL_OFFSET_U8 != u8HwCtrl)
#endif
            {
                /*Configure the command id for all controllers which are used. */
                Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETFILTER;
                pSFCmd = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetFilter);
                
                filterList = pxConfig->paReceiveFilters[u8HwCtrl];
                filterLoadedCount = 0U;
                crtFilter = 0u;
                while((crtFilter < pxConfig->pPlatfInitConfig->au16MaxRegularFilterCount[u8HwCtrl]) && ((Std_ReturnType)E_OK == eReturnValue))
                {
                    pSFCmd->aRxFilters[filterLoadedCount] = filterList[crtFilter];
                    #if (CAN_43_LLCE_DUMMY_HRH_EN == STD_ON)
                        if(FALSE == pxConfig->aHohList[filterList[crtFilter].u16FilterId].bDummyHRH)
                        {
                    #endif
                            filterLoadedCount++;
                            /* Check if the command buffer for filters is full. */
                            if (LLCE_CAN_CONFIG_MAX_FILTERS_COUNT == filterLoadedCount)
                            {
                                pSFCmd->u16RxFiltersCount = filterLoadedCount;
                                eReturnValue = Can_Llce_SendSetFilterCommand(pSFCmd->aRxFilters, filterLoadedCount, u8HwCtrl);
                                /* Reset the number of filters. */
                                filterLoadedCount = 0;
                            }
                    #if (CAN_43_LLCE_DUMMY_HRH_EN == STD_ON)
                        }
                    #endif
                    crtFilter++;
                }

                /* Load remaining filters if any*/            
                if (filterLoadedCount > 0U)
                {
                    pSFCmd->u16RxFiltersCount = filterLoadedCount;
                    eReturnValue = Can_Llce_SendSetFilterCommand(pSFCmd->aRxFilters, filterLoadedCount, u8HwCtrl);
                    /* Reset the number of filters. */
                    filterLoadedCount = 0;
                }
            }
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
  }
  else 
  {
    Can_Llce_EmulateSetConfiguredReceiveFilters();
    Can_Llce_bHeadlessInitDone_SetConfiguredReceiveFilters = TRUE;
  }
#endif
}

static Std_ReturnType Can_Llce_SendSetFilterCommand(const volatile Llce_Can_ReceiveFilterType *pRxFilters, uint8 filterLoadedCount, uint8 u8HwCtrl)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    uint8 i = 0U;
             
    /* Send the command prepared above to the LLCE in order to be executed */
    if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( u8HwCtrl ))
    {
        /* Copy the hw filter addr for later usage. */
        for(i = 0; i < filterLoadedCount; i++)
        {  
            #if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U) || (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0)
                Can_Llce_au16RxHrh2FilterAddr[pRxFilters[i].u16FilterId] = pRxFilters[i].u16FilterAddr;
            #else
            (void)pRxFilters;
            #endif
        }

        eReturnValue = E_OK;
    }

    return eReturnValue;

}

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
/**
* @brief          Calculates where filters would be loaded inside LLCE
* @details        When LLCE is started in headless mode, calculate HRH-filter mapping, to allow
*                 removal or disabling.
*/
static void Can_Llce_EmulateSetConfiguredReceiveFilters(void)
{
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();
    const Llce_Can_ReceiveFilterType * filterList;
    uint8 u8HwCtrl;
    uint16 u16CrtFilter, u16HrhId;

    /* FW loads filters based on physical controller */
    for(u8HwCtrl = 0U; u8HwCtrl < LLCE_CAN_CONFIG_MAXCTRL_COUNT; u8HwCtrl++)
    {
        filterList = pxConfig->paReceiveFilters[u8HwCtrl];

        for(u16CrtFilter = 0U; u16CrtFilter < pxConfig->pPlatfInitConfig->au16MaxRegularFilterCount[u8HwCtrl]; u16CrtFilter++)
        {
            u16HrhId = filterList[u16CrtFilter].u16FilterId;

           #if defined(S32G2XX)
            /* On G2 filters are assigned based on type */
            if(LLCE_CAN_ENTRY_EXACT_MATCH == filterList[u16CrtFilter].eEntryType)
            {
                Can_Llce_au16RxHrh2FilterAddr[u16HrhId] = Can_Llce_u16RxLutExactMatchCounter;
                Can_Llce_u16RxLutExactMatchCounter++;
            }
            else
            {
                Can_Llce_au16RxHrh2FilterAddr[u16HrhId] = Can_Llce_u16RxLutConfigurableCounter;
                Can_Llce_u16RxLutConfigurableCounter++;
            }
           #elif defined(S32G3XX)
            /* On G3 filters are simply loaded sequentially */
            Can_Llce_au16RxHrh2FilterAddr[u16HrhId] = Can_Llce_au16RxLutCounter[u8HwCtrl];
            Can_Llce_au16RxLutCounter[u8HwCtrl]++;
           #endif
        }
    }
}
#endif /* CAN_LLCE_USE_HEADLESSMODE == STD_ON */

/**
* @brief          Writes configuration to memory and sends SETAUXFILTER for all enabled controllers.
* @details        Initialization of indicator, statuses, etc.
*                 This function is non-reentrant and does not provide thread safety
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
#if (RXLUT2_ENABLE == STD_ON)
static void Can_Llce_SetConfiguredAuxReceiveFilters(void)
{
    uint8 u8HwCtrl = 0U;
    uint8 u8CtrlIndex= 0U;
    uint16 crtFilter = 0U;
    uint8 filterLoadedCount = 0U;
    const Llce_Can_AuxFilterType * filterList;
    volatile Llce_Can_SetAuxFilterCmdType * pSFCmd;
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_SUCCESS;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        while((u8CtrlIndex < CAN_43_LLCE_MAXCTRL_CONFIGURED) && (LLCE_FW_SUCCESS == eReturnValue))
        {
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            if(Can_43_LLCE_GetCoreID() == pxConfig->aControllerDescriptors[u8CtrlIndex].u32CoreId)
            {
#endif

                /* Skip disabled controllers */
                if(LLCE_NULL_OFFSET_U8 != u8HwCtrl)
                {
                    u8HwCtrl = pxConfig->aControllerDescriptors[u8CtrlIndex].u8HwCtrl;
                    /*Configure the command id for all controllers which are used. */
                    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETAUXFILTER;
                    pSFCmd = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAuxFilter);
                    
                    filterList = pxConfig->paAuxFilters[u8HwCtrl];
                    filterLoadedCount = 0U;

                    crtFilter = 0U;
                    while((crtFilter < pxConfig->paLlce_MaxAuxilliaryFilterCount[u8HwCtrl]) && (LLCE_FW_SUCCESS == eReturnValue))
                    {
                        pSFCmd->aRxAuxFilters[filterLoadedCount] = filterList[crtFilter];
                        filterLoadedCount++;

                        /* Check if the command buffer for filters is full. */
                        if (LLCE_CAN_CONFIG_MAX_FILTERS_COUNT == filterLoadedCount)
                        {
                            pSFCmd->u16RxAuxFiltersCount = filterLoadedCount;
                
                            /* Send the command prepared above to the LLCE in order to be executed */
                            eReturnValue = Can_Llce_ExecuteIfCommand( u8HwCtrl );

                            /* Reset the number of filters. */
                            filterLoadedCount = 0;
                        }
                        crtFilter++;
                    }

                    /* Load remaining filters if any*/            
                    if (filterLoadedCount > 0U)
                    {
                        pSFCmd->u16RxAuxFiltersCount = filterLoadedCount;
                    
                        /* Send the command prepared above to the LLCE in order to be executed */
                        eReturnValue = Can_Llce_ExecuteIfCommand( u8HwCtrl );
                        /* Reset the number of filters. */
                        filterLoadedCount = 0;
                    }
                }
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            }
#endif
            u8CtrlIndex++;
        }
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
}
#endif



/**
* @brief          Initialize advanced feature.
* @details        Initialization of indicator, statuses, etc.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
#if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0)
static void Can_Llce_AfInit(void)
{
#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
    uint16 u16Idx;
    
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    if((FALSE == pxConfig->bHeadlessModeEnabled) || (TRUE == Can_Llce_bHeadlessInitDone_AfInit) )
    {
#endif
        /* Send CREATE_AF_DESTINATION command*/
        #if (LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0)
            if(LLCE_FW_SUCCESS == Can_Llce_CreateConfiguredAfDestinations())
            {
        #endif
                /* Send SETADVANCEDFILTER command. */
                Can_Llce_SetConfiguredAfFilters();
        #if (LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0)
            }
        #endif
#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
    }
    else
    {
        for (u16Idx = 0U; u16Idx < (LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT); u16Idx++)
        {           
            /* Assume destinations are created in order */
            Can_au8DestinationIdxMap[u16Idx] = (uint8)u16Idx;
        }

        Can_Llce_EmulateSetConfiguredAfFilters();
        
        Can_Llce_bHeadlessInitDone_AfInit = TRUE;
    }
#endif
}

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
/**
* @brief          Calculates where filters would be loaded inside LLCE
* @details        When LLCE is started in headless mode, calculate HRH-filter mapping, to allow
*                 removal or disabling.
*/
static void Can_Llce_EmulateSetConfiguredAfFilters(void)
{
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();
    const Llce_Can_AdvancedFilterType * filterList;
    uint8 u8HwCtrl;
    uint16 u16CrtFilter, u16HrhId;

    /* FW loads filters based on physical controller */
    for(u8HwCtrl = 0U; u8HwCtrl < LLCE_CAN_CONFIG_MAXCTRL_COUNT; u8HwCtrl++)
    {
        filterList = pxConfig->paAdvancedFilters[u8HwCtrl];

        for(u16CrtFilter = 0U; u16CrtFilter < pxConfig->pPlatfInitConfig->au16MaxAdvancedFilterCount[u8HwCtrl]; u16CrtFilter++)
        {
            u16HrhId = filterList[u16CrtFilter].Llce_Can_RxFilter.u16FilterId;

          #if defined(S32G2XX)
            /* On G2 filters are assigned based on type */
            if(LLCE_CAN_ENTRY_EXACT_MATCH == filterList[u16CrtFilter].Llce_Can_RxFilter.eEntryType)
            {
                Can_Llce_au16RxHrh2FilterAddr[u16HrhId] = Can_Llce_u16RxLutExactMatchCounter;
                Can_Llce_u16RxLutExactMatchCounter++;
            }
            else
            {
                Can_Llce_au16RxHrh2FilterAddr[u16HrhId] = Can_Llce_u16RxLutConfigurableCounter;
                Can_Llce_u16RxLutConfigurableCounter++;
            }
          #elif defined(S32G3XX)
            /* On G3 filters are simply loaded sequentially */
            Can_Llce_au16RxHrh2FilterAddr[u16HrhId] = Can_Llce_au16RxLutCounter[u8HwCtrl];
            Can_Llce_au16RxLutCounter[u8HwCtrl]++;
          #endif

          #if (CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED == STD_ON)
            /* Save reference to filter config for later usage. */
            Can_Llce_apRxHrh2AfFilterCfg[u16HrhId] = &(pxConfig->paAdvancedFilters[u8HwCtrl][u16CrtFilter]);
          #endif
        }
    }
}
#endif /* CAN_LLCE_USE_HEADLESSMODE == STD_ON */

#endif /* LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0 */

#if((LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON))

/** @implements    Can_Llce_Init_PfeIf_Activity */
Std_ReturnType Can_Llce_Init_PfeIf(uint8 Hif)
{
    uint32 u32ringSize;
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue = LLCE_FW_NOTRUN;
    #if (LLCE_USE_EXTERNAL_RING_BUF == STD_ON)
        volatile Llce_Can_InitPfeWithExternRingCmdType* pfeInitCmd = NULL_PTR;
    #else
        volatile Llce_Can_InitPfeCmdType* pfeInitCmd = NULL_PTR;
    #endif
    pfe_ct_phy_if_id_t pfe_hif_id;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Init LLCE-PFE interface */
        #if (LLCE_USE_EXTERNAL_RING_BUF == STD_ON)
            pfeInitCmd = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.InitPfeWithExternRing);

            pfeInitCmd->pRxRing = (uint32)&Llce_PfeIf_RxRing;
            pfeInitCmd->pRxWbRing = (uint32)&Llce_PfeIf_RxWbRing;
            pfeInitCmd->pTxRing = (uint32)&Llce_PfeIf_TxRing;
            pfeInitCmd->pTxWbRing = (uint32)&Llce_PfeIf_TxWbRing;
            pfeInitCmd->pHeader = (uint32)&Llce_PfeIf_Hdr;
            pfeInitCmd->u8HeaderSize = LLCE_PFE_TX_HDR_COUNT;
            pfeInitCmd->u32RingSize = LLCE_PFE_HIF_RING_CFG_LENGTH;

            u32ringSize = pfeInitCmd->u32RingSize;
            
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_INIT_PFE_EXT_RING_BUF;
        #else
            pfeInitCmd = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.InitPfe);
            u32ringSize = PFE_HIF_RING_CFG_LENGTH;
            
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_INIT_PFE;
        #endif

        pfeInitCmd->u8Hif = Hif;
#if LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON
        pfeInitCmd->pRxBuffers = (uint32)&Llce_Eth2Can_Buffer;
        pfeInitCmd->u16RxBufSize = LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_SIZE;
        pfeInitCmd->u8RxBufCount = LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_CNT;        
#else
        pfeInitCmd->pRxBuffers = 0U;
        pfeInitCmd->u16RxBufSize = 0U;
        pfeInitCmd->u8RxBufCount = 0U;        
#endif

        eCommandReturnValue = Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController);
    }

    if (LLCE_FW_SUCCESS == eCommandReturnValue )
    {
        switch(Hif)
        {
            case 0:
                pfe_hif_id = PFE_PHY_IF_ID_EMAC0;
                break;
            case 1:
                pfe_hif_id = PFE_PHY_IF_ID_EMAC1;
                break;
            case 2:
                pfe_hif_id = PFE_PHY_IF_ID_EMAC2;
                break;
            case 3:
                pfe_hif_id = PFE_PHY_IF_ID_HIF;
                break;
            case 4:
                pfe_hif_id = PFE_PHY_IF_ID_HIF_NOCPY;
                break;
            case 5:
                pfe_hif_id = PFE_PHY_IF_ID_UTIL;
                break;
            case 6:
                pfe_hif_id = PFE_PHY_IF_ID_HIF0;
                break;
            case 7:
                pfe_hif_id = PFE_PHY_IF_ID_HIF1;
                break;
            case 8:
                pfe_hif_id = PFE_PHY_IF_ID_HIF2;
                break;            
            case 9:
                pfe_hif_id = PFE_PHY_IF_ID_HIF3;
                break;
            default:
                pfe_hif_id = PFE_PHY_IF_ID_INVALID;
                break;
        }

        /* Set the contents of llce_minihif to known values */
        (void)memset(&llce_minihif, 0, sizeof(llce_minihif));

        if((Std_ReturnType)E_OK == (Std_ReturnType)pfe_minihif_drv_create(&llce_minihif, pfe_hif_id, FALSE))
        {
            if((Std_ReturnType)E_OK == (Std_ReturnType)pfe_minihif_drv_attach_ring(&llce_minihif, TRUE,  (void*)(pfeInitCmd->pRxRing), (void*)(pfeInitCmd->pRxWbRing), u32ringSize))
            {
                if((Std_ReturnType)E_OK == (Std_ReturnType)pfe_minihif_drv_attach_ring(&llce_minihif, FALSE, (void*)(pfeInitCmd->pTxRing), (void*)(pfeInitCmd->pTxWbRing), u32ringSize))
                {
                    if((Std_ReturnType)E_OK == (Std_ReturnType)pfe_minihif_drv_init(&llce_minihif))
                    {
                        eReturnValue = E_OK;
                    }
                }
            }
        }
    }

    if((Std_ReturnType)E_OK == eReturnValue)
    {
        /* If this application was reloaded with PFE still running, the pfe_minihif calls above 
         * could have altered the state of the rings. Call the INIT_PFE command again to trigger
         * a reinit of the minihif in LLCE */
        eCommandReturnValue = Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController);

        if (LLCE_FW_SUCCESS != eCommandReturnValue )
        {
            eReturnValue = (Std_ReturnType)E_NOT_OK;
        }
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    return eReturnValue;
}

/**
* @brief          Start of PFE.
* @details        Initialization of indicator, statuses, etc.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
Std_ReturnType Can_Llce_Start_PfeIf(void)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;

    if((Std_ReturnType)E_OK == (Std_ReturnType)pfe_minihif_drv_start_rx(&llce_minihif))
    {
        if((Std_ReturnType)E_OK == (Std_ReturnType)pfe_minihif_drv_start_tx(&llce_minihif))
        {
            eReturnValue = E_OK;
        }
    }

    return eReturnValue;
}
#endif /* ((LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON)) */

#if(LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0)
/**
* @brief          Set current Can2Eth state
* @details        Initialization of indicator, statuses, etc.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
* @implements     Can_Llce_SetCan2EthState_Activity
*
*/
Std_ReturnType Can_Llce_SetCan2EthState(Can_Llce_Can2EthStateType eState)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue = LLCE_FW_NOTRUN;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    /* Check if command is available */
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETCAN2ETHSTATE;

        if(CAN_LLCE_CAN2ETH_ENABLED == eState)
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.eBinaryValue = LLCE_TRUE;
        }
        else
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.eBinaryValue = LLCE_FALSE;
        }

        eCommandReturnValue = Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController);
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    if (LLCE_FW_SUCCESS == eCommandReturnValue)
    {
        eReturnValue = (Std_ReturnType)E_OK;
    }

    return eReturnValue;
}
#endif /* LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0 */

#if (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON)
/**
* @brief          Enable/disable Eth2Can decapsulation for a particular format.
* @details        Sends command to FW to start/stop decapsulation Eth2Can frames of a particular type
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
*/
Llce_Fw_ReturnType Can_Llce_SetEth2CanFormatState(Llce_Can_EthEncapsulationFormat eFormat, Can_Llce_Eth2CanStateType eState)
{
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_NOTRUN;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    /* Check if command is available */
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETETH2CANFORMATSTATE;
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetEth2CanFormatState.eFormat = eFormat;
        if(CAN_LLCE_ETH2CAN_ENABLED == eState)
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetEth2CanFormatState.eState = LLCE_TRUE;
        }
        else
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetEth2CanFormatState.eState = LLCE_FALSE;
        }

        eReturnValue = Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController);
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}
#endif /* (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON) */

#if LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0
/**
* @brief          Set current Can2Pcie state
* @details        Enable/disable Can2Pcie in LLCE FW
*
* @pre            At least one controller must be configured in the Driver structure.
* @implements     Can_Llce_SetCan2PcieState_Activity
*
*/
Std_ReturnType Can_Llce_SetCan2PcieState(Can_Llce_Can2PcieStateType eState)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue = LLCE_FW_NOTRUN;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    /* Check if command is available */
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETCAN2PCIESTATE;

        if(CAN_LLCE_CAN2PCIE_ENABLED == eState)
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.eBinaryValue = LLCE_TRUE;
        }
        else
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.eBinaryValue = LLCE_FALSE;
        }

        eCommandReturnValue = Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController);
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    if (LLCE_FW_SUCCESS == eCommandReturnValue)
    {
        eReturnValue = (Std_ReturnType)E_OK;
    }

    return eReturnValue;
}
#endif /* LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0 */


/*================================================================================================*/
/**
* @brief          Service for de-initializing only CAN controller specific settings.
* @details        CAN controller de-initialization.
*                 This routine is called by:
*                  - Can_43_LLCE_DeInit() from Can.c file.
*
* @param[in]      u8HwCtrl: CAN controller for which the initialization shall be done.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           De-initialization controller's configuration.
*
*/
Std_ReturnType Can_Llce_DeInitController(uint8 u8HwCtrl)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_DEINIT;
        
        /* Send the command prepared above to the LLCE in order to be executed */
        eCommandReturnValue = Can_Llce_ExecuteIfCommand( u8HwCtrl );

        if(LLCE_FW_SUCCESS == eCommandReturnValue)
        {
            /* Update status in order to discard tx/rx processing */
            SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
            Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_UNINIT;
            SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
            eReturnValue = (Std_ReturnType)E_OK;
        }
    }
    
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

Std_ReturnType Can_Llce_DeInitPlatform(void)
{   
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;
    uint8 u8Interface;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /*All the FIFOs corresponding to a given HIF are reset at once due to the flexible FIFO allocation feature*/
    for (u8Interface = 0U; u8Interface < LLCE_CAN_CONFIG_MAXCTRL_COUNT; u8Interface++)
    {   
        /*check alive RX int interfaces that shall be cleaned in case the data was not consumed*/
        if (0U != pxConfig->pPlatfInitConfig->au16MaxIntMbCount[u8Interface])
        {
            Can_Llce_ResetFifoContent(u8Interface);
        }
    }

    for (u8Interface = 0U; u8Interface < LLCE_CAN_MAX_POLLING_CLASSES; u8Interface++)
    {   
        /*check alive RX poll interfaces that shall be cleaned in case the data was not consumed*/
        if (0U != pxConfig->pPlatfInitConfig->au16MaxPollMbCount[u8Interface])
        {
            Can_Llce_ResetFifoContent(u8Interface + LLCE_CAN_CONFIG_MAXCTRL_COUNT);
        }
    }

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_DEINIT_PLATFORM;
        
        /* Send the command prepared above to the LLCE in order to be executed */
        if(LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( pxConfig->u8DefaultController ))
        {
            eReturnValue = (Std_ReturnType)E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    /*Disable the Notif FIFO interrupt*/
    Can_Llce_DisableNotifInterrupt(pxConfig->u8ActiveHif);

    return eReturnValue;
}

/**
* @brief          Send LLCE shutdown command 
* @details        Shut down LLCE before doing a partition reset
*
* @pre            Both HIFs are uninitialized/deinitialized.
* @post           LLCE is shut down and must be reset.
*
* @implements     Can_Llce_Shutdown_Activity
*/
Std_ReturnType Can_Llce_Shutdown(void)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue = LLCE_FW_NOTRUN;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    /* Check if command is available */
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SHUTDOWN;

        eCommandReturnValue = Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController);
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    if (LLCE_FW_SUCCESS == eCommandReturnValue)
    {
        eReturnValue = (Std_ReturnType)E_OK;
    }

    return eReturnValue;
}

/**
* @brief          Routine for resetting FIFO content
* @details        In case of a message sent by LLCE firmware just after the SetControllerMode(STOP) command,
*                 the driver shall cancel the pending message.                  
*                 This routine is called by Can_Llce_SetControllerToStartMode and it makes sure about a
*                 clean FIFO content before the controller is requested to start.
*
* @param[in]      u8Interface FIFO interface to be reset
*
*/
static void Can_Llce_ResetFifoContent(uint8 u8Interface)
{
    uint16 u16Token;
    uint16 u16SafetyLoopEscapeCnt = 0U;
    /* Timeout counter. */
    uint32 u32timeStart = 0U;
    uint32 u32timeElapsed = 0U;
    uint32 u32TicksDelayDuration = 0U;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    if (u8Interface < (LLCE_CAN_CONFIG_MAXCTRL_COUNT + LLCE_CAN_MAX_POLLING_CLASSES))
    {
        if (u8Interface < LLCE_CAN_CONFIG_MAXCTRL_COUNT)
        {
            u16SafetyLoopEscapeCnt = pxConfig->pPlatfInitConfig->au16MaxIntMbCount[u8Interface];
        }
        else
        {
            u16SafetyLoopEscapeCnt = pxConfig->pPlatfInitConfig->au16MaxPollMbCount[u8Interface - LLCE_CAN_CONFIG_MAXCTRL_COUNT];
        }

        /* Abort RX messages and return the token to LLCE */
        while (( LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8Interface))) & (uint32)(LLCE_FIFO_FEMTYD_U32)) ) && \
               (u16SafetyLoopEscapeCnt > 0U))
        {
            u16SafetyLoopEscapeCnt--;

            /* Read data from the fifo. */
            u16Token = (uint16)Reg_Read32( LLCE_FIFO_POP0(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8Interface)));

            u32timeStart = OsIf_GetCounter(CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            u32TicksDelayDuration = OsIf_MicrosToTicks(CAN_43_LLCE_TIMEOUT_DURATION, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            u32timeElapsed = 0U;

            /* Wait for LLCE to consume the tokens before DEINIT_PLATFORM cmd is issued */
            while ( (0U == (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif))) & (uint32)(LLCE_FIFO_FEMTYD_U32)) ) && (u32timeElapsed < u32TicksDelayDuration))
            {
                u32timeElapsed += OsIf_GetElapsed(&u32timeStart, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            }
            
            Reg_Write32( LLCE_FIFO_PUSH0(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif)), (uint32)u16Token);
        }
        
        /* Abort TX confirmations. */
        Reg_Bit_Set32(LLCE_FIFO_CONFIG(LLCE_FIFO_TXACK_BASE_ADDRESS(u8Interface)), LLCE_FIFO_FCR_FLUSH_U32);
    }

}

#if (CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED == STD_OFF)
/*================================================================================================*/
/**
* @brief          API for servicing the bus-off event.
* @details        CAN controller bus-off reaction.
*                 This routine is called by:
*                  
*
* @param[in]      Controller CAN controller for which the bus-off was generated.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           
*
*
*/
static void Can_Llce_ControllerBusOff(uint8 u8HwCtrl)
{
    uint16 u16RxMbDescIdx;
    uint16 u16SafetyLoopEscapeCnt;
    uint32 u32DrvControllerOptions;
    /* Timeout counter. */
    uint32 u32timeStart = 0U;
    uint32 u32timeElapsed = 0U;
    uint32 u32TicksDelayDuration = 0U;
    
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Update status */
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
    Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_STOPPED;
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();

    u16SafetyLoopEscapeCnt = pxConfig->pPlatfInitConfig->au16MaxIntMbCount[u8HwCtrl];
    u32DrvControllerOptions = pxConfig->aHwControllerDescriptors[u8HwCtrl].u32DrvControllerOptions;

    /* In case of polling classes, the outdated messages are detected at MainFunction_Read/Write by checking the controller state. */
    if(LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32))
    {
        while ( (LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8HwCtrl))) & (uint32)(LLCE_FIFO_FEMTYD_U32)) ) && \
                (u16SafetyLoopEscapeCnt > 0U))
        {
            u16SafetyLoopEscapeCnt --;
            /* Read data from the fifo. */
            u16RxMbDescIdx = (uint16)Reg_Read32( LLCE_FIFO_POP0(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8HwCtrl)));

            u32timeStart = OsIf_GetCounter(CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            u32TicksDelayDuration = OsIf_MicrosToTicks(CAN_43_LLCE_TIMEOUT_DURATION, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            u32timeElapsed = 0U;

            /* Wait for LLCE to consume the tokens before next token is pushed */
            while ( (0U == (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif))) & (uint32)(LLCE_FIFO_FEMTYD_U32)) ) && (u32timeElapsed < u32TicksDelayDuration))
            {
                u32timeElapsed += OsIf_GetElapsed(&u32timeStart, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            }

            Reg_Write32( LLCE_FIFO_PUSH0(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif)), (uint32)u16RxMbDescIdx);
        }
    }

    if(LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32))
    {
        /* Process all the ACK before notify BusOff event. */
        Can_Llce_ProcessTx(u8HwCtrl);
    }
    
    Can_43_LLCE_ControllerBusOff(u8HwCtrl);

}
#endif /* #if (CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED == STD_OFF) */

/*================================================================================================*/
/**
* @brief          Service for (re)initializing only CAN controller specific settings.
* @details        CAN controller (re-)initialization.
*                 This routine is called by:
*                  - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @param[in]      Controller CAN controller (HW) for which the init shall be done.
* @param[in]      pxBaudrateConfigPtr The baud rate configuration (contains baud rate parameters for arbitration phase).
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set the MBs and interrupts into predefinite state for Can bus communication.
*
*
*/

Std_ReturnType Can_Llce_ChangeBaudrate(uint8 u8HwCtrl, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if(NULL_PTR != pxBaudrateConfigPtr) 
    {
        eReturnValue = Can_Llce_CheckCommandAvailable();
        if((Std_ReturnType)E_OK == eReturnValue)
        {
            /* Configure the command id */
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETBAUDRATE;

            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetBaudrate = *pxBaudrateConfigPtr;

            /* Send the command prepared above to the LLCE in order to be executed */
            if(LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( u8HwCtrl ))
            {
                eReturnValue = E_OK;
            }
            else
            {
                eReturnValue = E_NOT_OK;
            }
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief          Return the mode of the CAN controller
* @details        Retrieve the mode of the specified controller from firmware and update the local state.
*                 Exception: (logical) sleep mode is stored in the driver. In Sleep state, no request is made to FW.
*                 This routine is called by:
*                  - Can_43_LLCE_GetControllerMode() from Can_43_LLCE.c file.
*
* @param[in]      u8HwCtrl CAN controller for which the status shall be requested.
* @param[out]     ControllerModePtr Current AUTOSAR state of the CAN controller will be stored.
*
* @return         Std_ReturnType
* @retval         E_OK Controller mode request has been accepted.
* @retval         E_NOT_OK Controller mode request has not been accepted.
*
* @pre            
* @post           
*
* @requirements   
* @implements     Can_Llce_GetControllerMode_Activity
*/
Std_ReturnType Can_Llce_GetControllerMode(uint8 u8HwCtrl, Can_ControllerStateType * ControllerModePtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    Llce_Can_CtrlStateType eLlceControllerMode;

    /* Sleep state is "logical" and stored internally */
    if(CAN_CS_SLEEP == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState )
    {
        *ControllerModePtr = CAN_CS_SLEEP;
        eReturnValue = E_OK;
    }
    else
    {
        /* Send the command prepared above to the LLCE in order to be executed */
        if((Std_ReturnType)E_OK == Can_Llce_GetLlceControllerMode(u8HwCtrl, &eLlceControllerMode))
        {
            /* Update local status as well */
            switch(eLlceControllerMode)
            {
                case LLCE_CAN_UNINIT_CTRL:
                    *ControllerModePtr = CAN_CS_UNINIT;
                    break;
#if (CAN_43_LLCE_CONTROLLER_START_NOSYNC == STD_ON)
                case LLCE_CAN_START_PENDING:
                    *ControllerModePtr = CAN_CS_STARTED;
                    break;
#endif
                case LLCE_CAN_STARTED:
                    *ControllerModePtr = CAN_CS_STARTED;
                    break;
                case LLCE_CAN_STOPPED:
                    *ControllerModePtr = CAN_CS_STOPPED;
                    break;
                default:
                    /* If the state is pending or there are no changes to current status, retrieve the last state. */
                    *ControllerModePtr = Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState;
                    break;
            }

            eReturnValue = E_OK;
        }
    }

    return (eReturnValue);
}

/*================================================================================================*/
/**
* @brief          Return the internal state of LLCE controller
* @details        Retrieve the mode of the specified controller from firmware.
*                 According to the LLCE interface, multiple states are possible for a given controller which may be
*                 needed for the CAN driver to comply with the internal LLCE state machine.
*
* @param[in]      Controller CAN controller for which the status shall be requested. Based on configuration order list (CanControllerId).
* @param[out]     eLlceControllerMode Pointer to a memory location, where the current internal mode of the CAN controller will be stored.
*
* @return         Std_ReturnType
* @retval         E_OK Controller mode request has been accepted.
* @retval         E_NOT_OK Controller mode request has not been accepted.
*
*/
static Std_ReturnType Can_Llce_GetLlceControllerMode(uint8 u8HwCtrl,  Llce_Can_CtrlStateType *eLlceControllerMode)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_GETCONTROLLERMODE;  

        /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( u8HwCtrl ))
        {
            *eLlceControllerMode = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.GetControllerMode.eControllerState;

            eReturnValue = E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief          Service to Perform software triggered state transitions of the CAN controller State machine.
* @details        Transition controller to another state/mode.
*                 This routine is called by:
*                  - Can_43_LLCE_SetControllerMode() from Can_43_LLCE.c file.
*                  - Can_43_LLCE_IPW_ProcessBusOff() from Can_IPW.c file.
*
* @param[in]      Controller CAN controller for which the init shall be done.
* @param[in]      Transition Possible transitions
* @param[in]      pxBaudrateConfigPtr Configuration parameters for the controller baud rate settings
*
* @return         Std_ReturnType
* @retval         E_OK transition initiated
* @retval         E_NOT_OK development or production error
*
* @pre            Controller is configured and must be into a state that permit the valid transition to another different state.
* @post           Shall enable interrupts that are needed in the new state. Shall disable interrupts that are not allowed in the new state.
*
* @requirements   CAN283
*
* @implements     Can_Llce_SetControllerMode_Activity
*/
Std_ReturnType Can_Llce_SetControllerMode(uint8 u8HwCtrl, Can_ControllerStateType Transition, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    /*
      (CAN017) The function Can_43_LLCE_SetControllerMode shall perform software triggered state transitions of the CAN controller State machine.
    */
    switch (Transition)
    {
        /* CAN_CS_STARTED -> CAN_CS_STOPPED. */
        case (CAN_CS_STOPPED):
            eReturnValue = Can_Llce_SetControllerToStopMode(u8HwCtrl);
            break;

        /* CAN_CS_STOPPED -> CAN_CS_STARTED. */
        case (CAN_CS_STARTED):
            eReturnValue = Can_Llce_SetControllerToStartMode(u8HwCtrl, pxBaudrateConfigPtr);
            break;

        /* CAN_CS_STOPPED -> CAN_CS_SLEEP. */
        case (CAN_CS_SLEEP):
            eReturnValue = Can_Llce_SetControllerToSleepMode(u8HwCtrl);
            break;

        /* Unknown transition requested. */
        default:
        /*
           (CAN200) If development error detection for the Can module is enabled: if an invalid transition has been requested, the function Can_43_LLCE_SetControllerMode shall raise the error CAN_43_LLCE_E_TRANSITION and return E_NOT_OK.
        */
            (void)Can_43_LLCE_ReportError((uint8)CAN_43_LLCE_SID_SET_CONTROLLER_MODE, (uint8)CAN_43_LLCE_E_TRANSITION);

            break;

        } /* end switch */

    return (eReturnValue);
}

/*================================================================================================*/
/**
* @brief          Send a frame to the hardware.
* @details        Checks if hardware transmit object that is identified by the HTH is free.
*                     Can_43_LLCE_Write checks if another Can_43_LLCE_Write is ongoing for the same HTH.
*                     a) hardware transmit object is free:
*                         The mutex for that HTH is set to 'signaled' the ID, DLC and SDU are put in a format appropriate for
*                           the hardware (if necessary) and copied in the appropriate hardware registers/buffers.
*                         All necessary control operations to initiate the transmit are done.
*                         The mutex for that HTH is released. The function returns with E_OK.
*                     b) hardware transmit object is busy with another transmit request.
*                         The function returns with CAN_BUSY.
*                     c) A preemptive call of Can_43_LLCE_Write has been issued, that could not be handled reentrant (i.e. a call with the same HTH).
*                         The function returns with CAN_BUSY the function is non blocking
*                     d) The hardware transmit object is busy with another transmit request for an L-PDU that has lower priority than that for the current request
*                         The transmission of the previous L-PDU is cancelled (asynchronously).
*                         The function returns with CAN_BUSY.
*                         This routine is called by:
*                         - Can_43_LLCE_Write() from Can_43_LLCE.c file.
*                     Algorithm Description:
*                     Case1: TxMUX supported = ON
*                           Can_43_LLCE_Write receive the Hth handle and the PduInfo for transmission. It starts to check from the first MBs of the
*                           current controller to search for a free MB. On the first free MB it stops and place the PduInfo and activate the transmission.
*                           In this case function set E_OK for return value and all other functionality is skipped.
*                           If no MB is finded as free then the lowest priority MB is selected for comparing with the priority of the current PduInfo.
*                           If the current PduInfo has a higher priority than the current lower priority (from all MBs) then this lower priority MB is canceled.
*                    Case2: TxMUX supported = OFF
*                          CanWrite() receive the Hth handle and the PduInfo for transmission. It checks if MB with the same index as Hth is free and if yes prepare
*                          and sends the current PduInfo data. If that MB is busy with another data then it checks the priority between these 2 structures.
*                          Depending by the last evaluation it decides what MB data to cancel.
*
* @param[in]      Hth information which HW-transmit handle shall be used for transmit.
*                 Implicitly this is also the information about the controller to use
*                 because the Hth numbers are unique inside one hardware unit.
* @param[in]      PduInfo Pointer to SDU user memory, DLC and Identifier
*
* @return          Std_ReturnType
* @retval          E_OK write command has been accepted
* @retval          E_NOT_OK development error occurred
* @retval          CAN_BUSY no TX hardware buffer available or preemtive call of Can_43_LLCE_Write() that can't be implemented reentrant
*
* @pre            The MB must be configured for Tx.
* @post           Transmit the data or ignore it in case of MB is full with another task.
*
*/
    Std_ReturnType Can_Llce_Write(uint8 u8HwCtrl, Can_43_LLCE_TxFrameInfoType* TxFrameInfo)
    {
        /* Variable for the TX MB descriptor */
        uint32 u32TxMbDescIdx = 0U;
        /* Variable for return status. */
        Std_ReturnType eReturnValue = (Std_ReturnType)CAN_BUSY;

    #ifdef CAN_43_LLCE_MEASURE_WRITE_LATENCY       
        Reg_Write32(LLCE_STM_CR,0x00);/* Disable STM counter. */ 
        Reg_Write32(LLCE_STM_CNT,0);/* Clear STM counter. */   
        Reg_Write32(LLCE_STM_CR,0x01);/* Enable STM counter. */ 
    #endif

        /* Attempt to get address of a free message buffer*/
        /* Read data from the fifo. */
        u32TxMbDescIdx = Reg_Read32( LLCE_FIFO_POP0(LLCE_FIFO_BLROUT_BASE_ADDRESS(u8HwCtrl)));

        /* Check if buffer ID is valid */
        if (LLCE_FIFO_NULL_VALUE != u32TxMbDescIdx)
        {  
            /* Apply mask to get the correct fifo entry value */
            u32TxMbDescIdx = u32TxMbDescIdx & LLCE_CAN_CONFIG_FIFO_FIXED_MASK_U32;

            /* Share TX MB descriptor to Can_Llce_UpdateMB using u16MbFrameIdx field*/
            TxFrameInfo->u16MbFrameIdx = (uint16)u32TxMbDescIdx;

            /* Write data into the Message buffer for transition. */
            Can_Llce_UpdateMB(TxFrameInfo);

            /*Check if the pointer to the full tx message buffer can be sent to the LLCE*/
            if ( LLCE_FIFO_FFULLD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_BLRIN_BASE_ADDRESS(u8HwCtrl))) & (uint32)(LLCE_FIFO_FFULLD_U32)) )
            {
                #if (CAN_43_LLCE_CUSTOM_WRITE_CALLBACK_USED == STD_ON)
                
                Can_43_LLCE_CustomWriteCallback(TxFrameInfo->u16FrameTag1 /*HoH*/, TxFrameInfo->u16FrameTag2 /*swPduHandle*/, (uint16)u32TxMbDescIdx /*TxMbDescIdx*/);

                #endif

                /* Write data to the fifo. */
                Reg_Write32( LLCE_FIFO_PUSH0(LLCE_FIFO_BLRIN_BASE_ADDRESS(u8HwCtrl)),u32TxMbDescIdx);

        #ifdef CAN_43_LLCE_MEASURE_WRITE_LATENCY  
    #ifndef CAN_43_LLCE_MEASURE_WRITE_BUS_LATENCY         
        Stm_Measurement = Reg_Read32(LLCE_STM_CNT) - Stm_Measurement;
    #endif
        host_write_label:
    #endif
                /* The request was successfully sent to the LLCE. */
                eReturnValue = E_OK;
            }
            else /* Defensive action against hardware FIFO communication fail. */
            {
                /* The pointer to the full tx mb can not be sent to the LLCE. Token lost. Requires controller restart. */
                eReturnValue = E_NOT_OK;

                #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                (void)Can_43_LLCE_ReportError((uint8)CAN_43_LLCE_SID_WRITE, (uint8)CAN_43_LLCE_E_LLCE_FAILED);
                #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
            }

        }
        else
        {
            /* No pointer available to a free message buffer */
            eReturnValue = CAN_BUSY;
        }

        return (eReturnValue);
    }

/*================================================================================================*/
/**
* @brief          Local function for calling notification function to notify upper layer from ISR when Interrupt mode selected.
* @details        Processes Tx interrupt flags.
*               This routine is called by:
*                - Can_43_LLCE_IPW_ProcessTx() from Can_43_LLCE.c file.
*                - Can_IsrFC##FC##_UNI() / Can_IsrFC##FC##_##Name() from Can_Irq.c file.
*
* @param[in]      u8AckInterface Fifo Interface [0-15] which generated interrupt for ACK event.
*
* @pre            MB is configured for Tx.
* @post           CanIf is informed with cancellation or transmit success.
*
*/
void Can_Llce_ProcessTx(const uint8 u8AckInterface)
{
    #ifdef MCAL_ENABLE_FAULT_INJECTION
    MCAL_FAULT_INJECTION_POINT(CAN_43_LLCE_FIP_4_MODIFY_IER_WHILE_PROCESSTX);
    #endif

    uint16 u16HohIndex;
    uint16 u16SafetyLoopEscapeCnt;
    uint16 u16AckEntry = 0U;
    uint8 u8HwCtrl;
    uint8 u8ControllerId;
    uint32 u32IER = Reg_Read32(LLCE_FIFO_IER(LLCE_FIFO_TXACK_BASE_ADDRESS(u8AckInterface)));
    uint32 u32Status = Reg_Read32(LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS(u8AckInterface)));
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

#if (CAN_43_LLCE_ACK_TIMESTAMP == STD_ON)
    uint16 u16FrameTag2 = 0u;
#endif

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Check for spurious interrupt and for initialized driver. */
    if ( (CAN_43_LLCE_READY == Can_43_LLCE_eDriverStatus[u32CoreId]) &&
        (LLCE_FIFO_FNEMTY_U32 == (u32IER & LLCE_FIFO_FNEMTY_U32)) && \
        (LLCE_FIFO_FNEMTY_U32 == (u32Status & LLCE_FIFO_FNEMTY_U32)) )
    {
        u16SafetyLoopEscapeCnt = pxConfig->pPlatfInitConfig->au16MaxIntTxAckCount[u8AckInterface];

        /* Process all entries from the TXACK FIFO. They can be originated by multiple hardware controllers. */
        while ((LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS(u8AckInterface))) & (uint32)(LLCE_FIFO_FEMTYD_U32))) && \
               (u16SafetyLoopEscapeCnt > 0U))
        {
            u16SafetyLoopEscapeCnt--;
            /* Read the index into the circular buffer containing the ack info.*/
            u16AckEntry = (uint16)(Reg_Read32( LLCE_FIFO_POP0(LLCE_FIFO_TXACK_BASE_ADDRESS(u8AckInterface))) & LLCE_CAN_CONFIG_FIFO_FIXED_MASK_U32);
            
            u16HohIndex = Can_SharedMemory.Can_Tx_aAckInfo[u16AckEntry].u16FrameTag1;

            Can_Hth_FreeTxObject(u16HohIndex, 1U);

            u8ControllerId = pxConfig->aHohList[u16HohIndex].u8ControllerId;
  
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            if(Can_43_LLCE_GetCoreID() == pxConfig->aControllerDescriptors[u8ControllerId].u32CoreId)
            {
#endif
                /* Get the hardware offset for this controller. */
                u8HwCtrl = pxConfig->aControllerDescriptors[u8ControllerId].u8HwCtrl;
           
                if ( CAN_CS_STARTED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState )
                {
                    /* Check if corresponding controller is started and the hoh is configured for reporting through interrupt mode */
                    if (LLCE_CAN_REFERENCE_NOT_USED == pxConfig->aHohList[u16HohIndex].u8CanMainFuncRWPeriodRef)
                    {
                        #if (CAN_43_LLCE_CUSTOM_CONFIRMATION_CALLBACK == STD_ON)
                    
                        Can_43_LLCE_CustomTxConfirmationCallback(u16HohIndex /*HoH*/, Can_SharedMemory.Can_Tx_aAckInfo[u16AckEntry].u16FrameTag2 /*swPduHandle*/);

                        #endif
                        /*
                        (CAN058) The Can module interacts among other modules (eg. Diagnostic Event Manager (DEM), Development Error Tracer (DET)) with the CanIf module in a direct way.
                                The driver only sees the CanIf module as origin and destination.
                        */
                        Can_43_LLCE_TxConfirmation( Can_SharedMemory.Can_Tx_aAckInfo[u16AckEntry].u16FrameTag2 );

                        /* Get Frame Tag */
                        #if (CAN_43_LLCE_ACK_TIMESTAMP == STD_ON)
                            u16FrameTag2 = Can_SharedMemory.Can_Tx_aAckInfo[u16AckEntry].u16FrameTag2;
                            Can_43_LLCE_TxTimestampNotification(u16HohIndex, u16FrameTag2, Can_SharedMemory.Can_Tx_aAckInfo[u16AckEntry].u32TxTimestamp);
                        #endif
                    }
                }
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            }
#endif
        }
    }

    /* Clear the interrupt status flag. */
    Reg_Write32( LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS(u8AckInterface)), LLCE_FIFO_FNEMTY_U32); 
    
}

/*================================================================================================*/
/**
* @brief          This routine accesses the notification interface configured in interrupt mode.
* @details        This routine accesses the notification interface configured in interrupt mode using indexes popped from NOTIF FIFO
*                 to retrieve the event information from notification table filled up by Llce firmware.
* @pre            
* @post           CanIf is notified about the bus-off events reported by the Llce firmware.
* @implements     Can_Isr_X_Activity
*/
void Can_Llce_ProcessNotificationISR(void)
{   
    uint8 u8NotifIdx = 0U;
    uint8 u8HwCtrl = 0U;
    uint16 u16SafetyLoopEscapeCnt = 0U;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    #if (CAN_43_LLCE_ERROR_NOTIF_ENABLE == STD_ON)
    CanErrorNotificationType CanError;
    #endif

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    uint32 u32IER = Reg_Read32( LLCE_FIFO_IER(LLCE_NOTIF_FIFO0_BASE_ADDRESS(pxConfig->u8ActiveHif)));
    uint32 u32Status = Reg_Read32( LLCE_FIFO_STATUS1(LLCE_NOTIF_FIFO0_BASE_ADDRESS(pxConfig->u8ActiveHif)));

    /* Check for spurious interrupt and for initialized driver. */
    if ( (CAN_43_LLCE_READY == Can_43_LLCE_eDriverStatus[u32CoreId]) &&
            (LLCE_FIFO_FNEMTY_U32 == (u32IER & LLCE_FIFO_FNEMTY_U32)) && \
            (LLCE_FIFO_FNEMTY_U32 == (u32Status & LLCE_FIFO_FNEMTY_U32)) )
    {
        u16SafetyLoopEscapeCnt = LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE;
        while ( (LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_NOTIF_FIFO0_BASE_ADDRESS(pxConfig->u8ActiveHif))) & (uint32)(LLCE_FIFO_FEMTYD_U32))) &&
                (u16SafetyLoopEscapeCnt > 0U))
        {
            u16SafetyLoopEscapeCnt--;
            u8NotifIdx = (uint8)Reg_Read32( LLCE_FIFO_POP0(LLCE_NOTIF_FIFO0_BASE_ADDRESS(pxConfig->u8ActiveHif)));

            if (LLCE_CAN_NOTIF_CHANNELERROR == Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId)
            {
                u8HwCtrl = Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.u8HwCtrl;
                /* Treat cases defined by Autosar spec. Rest of them are only sent through the user-defined callback */
                switch (Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.ErrorInfo.eErrorCode)
                {
                    case (LLCE_ERROR_BUSOFF):
                    #if (CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED == STD_ON)
                        /* LLCE issues bus-off notification, but does not freeze the controller. */
                        Can_43_LLCE_ControllerBusOffCallback(pxConfig->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId);
                    #else
                        /* LLCE issues bus-off notification after controller freezes. AUTOSAR required behavior */
                        Can_Llce_ControllerBusOff(u8HwCtrl);
                    #endif
                    break;

                    /* DATALOST root causes */
                    case (LLCE_ERROR_RXOUT_FIFO_FULL):
                    case (LLCE_ERROR_MB_NOTAVAILABLE):
                    case (LLCE_ERROR_FRAME_NOT_DELIVERED_TO_HOST):
                    case (LLCE_ERROR_BCAN_RXFIFO_OVERRUN):
                        (void)Can_43_LLCE_ReportRuntimeError((uint8)CAN_43_LLCE_SID_PROCESS_NOTIFICATION_ISR, (uint8)CAN_43_LLCE_E_DATALOST);
                        break;

                    default:
                        /* Switch must handle all states. No action, just appease MISRA */
                        break;
                }

                #if (CAN_43_LLCE_ERROR_NOTIF_ENABLE == STD_ON)
                /* Report a channel error */
                CanError.u8CanIfCtrlId = pxConfig->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId;
                CanError.eNotifId = Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId;
                CanError.ErrorInfo = &(Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.ErrorInfo);
                Can_43_LLCE_ErrorNotificationCallback(&CanError);
                #endif
            }
            else if (LLCE_CAN_NOTIF_PLATFORMERROR == Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId)
            {
                #if (CAN_43_LLCE_ERROR_NOTIF_ENABLE == STD_ON)
                /* Report a platform error */
                CanError.u8CanIfCtrlId = CAN_43_LLCE_NULL_OFFSET;
                CanError.eNotifId = Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId;
                CanError.ErrorInfo = &(Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.PlatformError);
                Can_43_LLCE_ErrorNotificationCallback(&CanError);
                #endif
            }
            else
            {
                /* Unknown error. */
            }
            
        }
        
    }

    /* Clear the interrupt status flag. */
    Reg_Write32( LLCE_FIFO_STATUS1(LLCE_NOTIF_FIFO0_BASE_ADDRESS(pxConfig->u8ActiveHif)), LLCE_FIFO_FNEMTY_U32); 
}

#if (CAN_43_LLCE_BUSOFFPOLL_SUPPORTED == STD_ON)
/*================================================================================================*/
/**
* @brief          This routine accesses the notification interface configured in polling mode.
* @details        This routine accesses the notification interface configured in polling mode using indexes popped from NOTIF FIFO
*                 to retrieve the bus-off events from notification table filled up by Llce firmware.
* @pre            
* @post           CanIf is notified about the bus-off events reported by the Llce firmware.
* @implements     Can_Isr_X_Activity
*/
void Can_Llce_ProcessBusOffNotification(void)
{   
    uint8 u8NotifIdx = 0U;
    uint8 u8HwCtrl = 0U;
    uint16 u16SafetyLoopEscapeCnt = LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE;
    Llce_Fw_ReturnType eErrorCode;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    while ( (LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_NOTIF_FIFO1_BASE_ADDRESS(pxConfig->u8ActiveHif))) & (uint32)(LLCE_FIFO_FEMTYD_U32))) && \
           (u16SafetyLoopEscapeCnt > 0U))
    {
        u16SafetyLoopEscapeCnt--;
        u8NotifIdx = (uint8)Reg_Read32( LLCE_FIFO_POP0(LLCE_NOTIF_FIFO1_BASE_ADDRESS(pxConfig->u8ActiveHif)));

        /* Get error code */
        eErrorCode = Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.ErrorInfo.eErrorCode;

        if ((LLCE_CAN_NOTIF_CHANNELERROR == Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId) && \
                (LLCE_ERROR_BUSOFF == eErrorCode))
        {
            /* Get hw controller (BCAN instance) which raised the bus-off notification. */
            u8HwCtrl = Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.u8HwCtrl;

            /* Make sure the controller is configured to get bus-off events in polling mode. */
            if (LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32 != (LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32 & (uint32)(pxConfig->aHwControllerDescriptors[u8HwCtrl].u32DrvControllerOptions)))
            {
                #if (CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED == STD_ON)
                    /* LLCE issues bus-off notification, but does not freeze the controller. */
                    Can_43_LLCE_ControllerBusOffCallback(pxConfig->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId);
                #else
                    /* LLCE issues bus-off notification after controller freezes. AUTOSAR required behavior */
                    Can_Llce_ControllerBusOff(u8HwCtrl);
                #endif
            }
        }
        #if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
        else
        {
            if ( LLCE_SWFIFO_FULL != Can_Llce_xNotifSwFifo.eFifoStatus )
            {
                (void)Llce_SwFifo_Push((const void*)&(Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx]) , &Can_Llce_xNotifSwFifo);
            }
        }
        #endif

    }
}
#endif /* (CAN_43_LLCE_BUSOFFPOLL_SUPPORTED == STD_ON) */

#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
/**
* @brief          This routine accesses the notification interface configured in polling mode.
* @details        This routine accesses the notification interface configured in polling mode using indexes popped from NOTIF FIFO
*                 to retrieve the event information from notification table filled up by Llce firmware.
* @pre            
* @post           CanIf is notified about the bus-off events reported by the Llce firmware. User-defined callback for errors is called if defined.
* @implements     Can_Isr_X_Activity
*/
void Can_Llce_ProcessErrorNotification(void)
{   
    uint8 u8NotifIdx = 0U;
    uint8 u8HwCtrl = 0U;

    uint16 u16SafetyLoopEscapeCnt;

    Llce_Can_NotificationType genericError;
    CanErrorNotificationType CanError;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Report the possible buffered errors */
    while (LLCE_SWFIFO_EMPTY != Can_Llce_xNotifSwFifo.eFifoStatus)
    {
        (void)Llce_SwFifo_Pop(&genericError , &Can_Llce_xNotifSwFifo);

        if (LLCE_CAN_NOTIF_CHANNELERROR == genericError.eNotifId)
        {
            #if (CAN_43_LLCE_ERROR_NOTIF_ENABLE == STD_ON)
            /* Get hw controller id */
            u8HwCtrl = genericError.NotifList.ChannelError.u8HwCtrl;
            /* Report a channel error */
            CanError.u8CanIfCtrlId = pxConfig->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId;
            CanError.eNotifId = genericError.eNotifId;
            CanError.ErrorInfo = &(genericError.NotifList.ChannelError.ErrorInfo);
            Can_43_LLCE_ErrorNotificationCallback(&CanError);
            #endif
        }
        else
        {
            #if (CAN_43_LLCE_ERROR_NOTIF_ENABLE == STD_ON)
            /* Report a platform error */
            CanError.u8CanIfCtrlId = CAN_43_LLCE_NULL_OFFSET;
            CanError.eNotifId = genericError.eNotifId;
            CanError.ErrorInfo = &(genericError.NotifList.PlatformError);
            Can_43_LLCE_ErrorNotificationCallback(&CanError);
            #endif
        }
            
    }

    u16SafetyLoopEscapeCnt = LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE;

    while ( (LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_NOTIF_FIFO1_BASE_ADDRESS(pxConfig->u8ActiveHif))) & (uint32)(LLCE_FIFO_FEMTYD_U32))) && \
            (u16SafetyLoopEscapeCnt > 0U) )
    {
        u16SafetyLoopEscapeCnt--;
        u8NotifIdx = (uint8)Reg_Read32( LLCE_FIFO_POP0(LLCE_NOTIF_FIFO1_BASE_ADDRESS(pxConfig->u8ActiveHif)));

        /* Report busoff through the standard CanIf callback.  */
        if (LLCE_CAN_NOTIF_CHANNELERROR == Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId)
        {   
            /* Get hw controller (BCAN instance) which raised the bus-off notification. */
            u8HwCtrl = Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.u8HwCtrl;
            if (LLCE_ERROR_BUSOFF == Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.ErrorInfo.eErrorCode)
            {
                /* Make sure the controller is configured to get bus-off events in polling mode. */
                if (LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32 != (LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32 & (uint32)(pxConfig->aHwControllerDescriptors[u8HwCtrl].u32DrvControllerOptions)))
                {
                    #if (CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED == STD_ON)
                        /* LLCE issues bus-off notification, but does not freeze the controller. */
                        Can_43_LLCE_ControllerBusOffCallback(pxConfig->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId);
                    #else
                        /* LLCE issues bus-off notification after controller freezes. AUTOSAR required behavior */
                        Can_Llce_ControllerBusOff(u8HwCtrl);
                    #endif
                }
            }
            else /* Report the rest of possible errors through the user-defined callback */
            {
                #if (CAN_43_LLCE_ERROR_NOTIF_ENABLE == STD_ON)
                /* Report a channel error */
                CanError.u8CanIfCtrlId = pxConfig->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId;
                CanError.eNotifId = Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId;
                CanError.ErrorInfo = &(Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.ErrorInfo);
                Can_43_LLCE_ErrorNotificationCallback(&CanError);
                #endif
            }
        }
        else
        {
            #if (CAN_43_LLCE_ERROR_NOTIF_ENABLE == STD_ON)
            /* Report a platform error */
            CanError.u8CanIfCtrlId = CAN_43_LLCE_NULL_OFFSET;
            CanError.eNotifId = Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId;
            CanError.ErrorInfo = &(Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.PlatformError);
            Can_43_LLCE_ErrorNotificationCallback(&CanError);
            #endif
        }
    }
}
#endif /* (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON) */

#if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)
static void Can_Llce_ProcessTxPollingClass(uint8 u8PollClassIdx)
{
    uint8 u8ControllerId = 0U;
    uint8 u8HwCtrl = 0U;

    uint16 u16HohIndex = 0U;

    uint16 u16AckEntry = 0U;
    uint16 u16SafetyLoopEscapeCnt;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    u16SafetyLoopEscapeCnt = pxConfig->pPlatfInitConfig->au16MaxPollTxAckCount[u8PollClassIdx];
    /* Process all entries from the TXACK FIFO corresponding to a polling class. Their order number starts with 16 (LLCE_CAN_CONFIG_MAXCTRL_COUNT) */
    while ((LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS((LLCE_CAN_CONFIG_MAXCTRL_COUNT + u8PollClassIdx)))) & (uint32)(LLCE_FIFO_FEMTYD_U32))) && \
           (u16SafetyLoopEscapeCnt > 0U) )
    {
        u16SafetyLoopEscapeCnt--;
        /* Read the index into the circular buffer containing the ack info.*/
        u16AckEntry = (uint16)(Reg_Read32( LLCE_FIFO_POP0(LLCE_FIFO_TXACK_BASE_ADDRESS((LLCE_CAN_CONFIG_MAXCTRL_COUNT + u8PollClassIdx)))) & LLCE_CAN_CONFIG_FIFO_FIXED_MASK_U32);
        
        u16HohIndex = Can_SharedMemory.Can_Tx_aAckInfo[u16AckEntry].u16FrameTag1;
        
        Can_Hth_FreeTxObject(u16HohIndex, 1U);

        u8ControllerId = pxConfig->aHohList[u16HohIndex].u8ControllerId;
        
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
        if(Can_43_LLCE_GetCoreID() == pxConfig->aControllerDescriptors[u8ControllerId].u32CoreId)
        {
#endif
            /* Get the hardware offset for this controller. */
            u8HwCtrl = pxConfig->aControllerDescriptors[u8ControllerId].u8HwCtrl;

            /* Filter outdated Acks gathered as a consequence of bus-off event or STOP command. */
            if (CAN_CS_STARTED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState)
            {
                /*
                (CAN108) The function Can_43_LLCE_MainFunction_Write shall perform the polling of TX indications when CanTxProcessing is set to POLLING or Mixed.
                In case of MIXED processing only the hardware objects for which CanHardwareObjectUsesPolling is set to TRUE shall be polled
                */
                if (LLCE_CAN_REFERENCE_NOT_USED != pxConfig->aHohList[u16HohIndex].u8CanMainFuncRWPeriodRef)
                {
                    /*
                    (CAN058) The Can module interacts among other modules (eg. Diagnostic Event Manager (DEM), Development Error Tracer (DET)) with the CanIf module in a direct way.
                            The driver only sees the CanIf module as origin and destination.
                    */
                    Can_43_LLCE_TxConfirmation( Can_SharedMemory.Can_Tx_aAckInfo[u16AckEntry].u16FrameTag2 );
                }
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            }
#endif
        }
    }
}
#endif /* (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON) */



static void Can_Llce_ProcessRxMb(const uint16 u16RxMbDescIdx)
{
    /* Number of data bytes. */
    uint8      u8MbDataLength = 0U;
    /* Variables for storing the CanID. */
    Can_IdType u32MbMessageId = 0U;
    /* Variable for storing the ConfigReg of the MB. */
    uint32     u32MbConfig = 0U;

    uint16  u16FilterId = 0U;

    #if (RXLUT2_ENABLE == STD_ON)
        uint16 u16AuxSearchResult = 0U;
    #endif

    uint32 u32Timestamp = 0U;

    uint32 u32Word1 = 0U;

    /* Pointer to the received frame payload. */
    uint8 * u8FramePayload = NULL_PTR;

    Llce_Can_GetMbData(&Can_SharedMemory, u16RxMbDescIdx, &u32MbConfig /*u32Word0*/, &u32Word1, &u8FramePayload, &u32Timestamp);

    /* Read the precalculated payload length; this is encoded in word1 of the MB */
    u8MbDataLength = (uint8)(u32Word1 >> LLCE_CAN_MB_PRECALC_LEN_SHIFT_U32);

    /* Get the ID of the message. */
    if(LLCE_CAN_MB_IDE_U32 == (u32MbConfig & LLCE_CAN_MB_IDE_U32))
    {
        /* For extended IDs the most significant bit must be set - according to Can_IdType requirement - chapter 8.2.3 of SWS CAN.*/
        u32MbMessageId = (Can_IdType)((u32MbConfig & LLCE_CAN_MB_ID_MASK_U32) | CAN_LPDU_IDE_U32 );
    }
    else
    {
        u32MbMessageId = (Can_IdType)((u32MbConfig & LLCE_CAN_MB_ID_MASK_U32) >> LLCE_CAN_MB_IDSTD_SHIFT_U32);
    }

    /* For FD the second most significant bit must be set - according to Can_IdType requirement - chapter 8.2.3 of SWS CAN.*/

   if(LLCE_CAN_MB_FDF_U32 == (u32Word1 & LLCE_CAN_MB_FDF_U32))
   {
        u32MbMessageId |= CAN_LPDU_FD_U32;
   }

    u16FilterId = Can_SharedMemory.Can_Rx_aMbDesc[u16RxMbDescIdx].u16FilterId;
    #if (RXLUT2_ENABLE == STD_ON)
        u16AuxSearchResult = Can_SharedMemory.Can_Rx_aMbDesc[u16RxMbDescIdx].u16AuxSearchResult;
    #endif

#if (CAN_43_LLCE_LPDU_NOTIFICATION_ENABLE == STD_ON)
     /*[CAN444] If the L-PDU call out returns false, the L-PDU shall not be processed any further. */
#if (CAN_43_LLCE_LPDU_CALLOUT_EXTENSION == STD_ON)
    if (TRUE == Can_43_LLCE_LPduReceiveCalloutFunction(u16FilterId, u32MbMessageId, u8MbDataLength, u8FramePayload))
#else
    if (TRUE == Can_43_LLCE_LPduReceiveCalloutFunction((uint8)u16FilterId, u32MbMessageId, u8MbDataLength, u8FramePayload))
#endif
    {
#endif
  #if (CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED == STD_ON)
        if (TRUE == Can_Llce_CheckCustomCallback(u16FilterId, u32MbMessageId, u8MbDataLength, u8FramePayload, u16RxMbDescIdx))
        {
  #endif
            Can_43_LLCE_RxIndication(u32MbMessageId, u16FilterId, u8FramePayload, u8MbDataLength);
            #if (RXLUT2_ENABLE == STD_ON)
                Can_43_LLCE_CanAuxFilterCallback(u16FilterId, u16AuxSearchResult);
            #endif
            #if (CAN_43_LLCE_RX_TIMESTAMP == STD_ON)
            Can_43_LLCE_RxTimestampNotification(u16FilterId, u32Timestamp);
            #else
            (void) u32Timestamp; /* Timestamp notification is disabled */
            #endif

  #if (CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED == STD_ON)
        }
  #endif
#if (CAN_43_LLCE_LPDU_NOTIFICATION_ENABLE == STD_ON)
    }
#endif

}

/*================================================================================================*/
/**
* @brief          Local function for calling notification function to notify upper layer from ISR when Interrupt mode selected.
* @details        Processes Rx interrupt flags.
                  This routine is called by:
                    - Can_43_LLCE_IPW_ProcessRx() from Can_43_LLCE.c file
                    - Can_IsrFC##FC##_UNI() / Can_IsrFC##FC##_##Name() from Can_Irq.c file
*
* @param[in]      u8RxInterface Fifo Interface [0-15] which generated interrupt for RX event.
*
* @pre            MB is configured for Rx.
* @post           Inform CanIf in case a data frame was received.
*
*
*/
void Can_Llce_ProcessRx(const uint8 u8RxInterface)
{
    uint8 u8ControllerId = 0U;
    uint8 u8HwCtrl = 0U;

    /* Index to the full receive message buffer */
    uint16 u16RxMbDescIdx = 0U;
    uint16 u16HohIndex = 0U;
    uint16 u16SafetyLoopEscapeCnt = 0U;
    uint32 u32FifoStatus = 0U;
    uint32 u32IER = Reg_Read32(LLCE_FIFO_IER(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8RxInterface)));
    uint32 u32Status = Reg_Read32(LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8RxInterface)));
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Check for spurious interrupt and for initialized driver. */
    if ( (CAN_43_LLCE_READY == Can_43_LLCE_eDriverStatus[u32CoreId]) &&
            (LLCE_FIFO_FNEMTY_U32 == (u32IER & LLCE_FIFO_FNEMTY_U32)) && \
            (LLCE_FIFO_FNEMTY_U32 == (u32Status & LLCE_FIFO_FNEMTY_U32)) )
    {      
        u32FifoStatus = (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif))));

        u16SafetyLoopEscapeCnt = pxConfig->pPlatfInitConfig->au16MaxIntMbCount[u8RxInterface];

        /* Add the behavior for the else branch when one of FIFOs are empty of full.*/
        /*Check if there is available any pointer to a full rx message buffer*/
        while (( LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8RxInterface))) & (uint32)(LLCE_FIFO_FEMTYD_U32))) && \
                ( LLCE_FIFO_FFULLD_U32 != (u32FifoStatus & (uint32)(LLCE_FIFO_FFULLD_U32)) ) && \
                (u16SafetyLoopEscapeCnt > 0U ))
        {
            u16SafetyLoopEscapeCnt--;
            /* Read data from the fifo. */
            u16RxMbDescIdx = (uint16)Reg_Read32( LLCE_FIFO_POP0(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8RxInterface)));

            u16HohIndex = Can_SharedMemory.Can_Rx_aMbDesc[u16RxMbDescIdx].u16FilterId;

            u8ControllerId = pxConfig->aHohList[u16HohIndex].u8ControllerId;

            /* Get the hardware offset for this controller. */
            u8HwCtrl = pxConfig->aControllerDescriptors[u8ControllerId].u8HwCtrl;
             
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            if(Can_43_LLCE_GetCoreID() == pxConfig->aControllerDescriptors[u8ControllerId].u32CoreId)
            {
#endif
                if ( CAN_CS_STARTED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState ) 
                {   
                    /* Check if corresponding controller is started and the hoh is configured for reporting through interrupt mode. */
                    if (LLCE_CAN_REFERENCE_NOT_USED == pxConfig->aHohList[u16HohIndex].u8CanMainFuncRWPeriodRef)
                    {
                        Can_Llce_ProcessRxMb(u16RxMbDescIdx);
                    }
                }

                /* Write address of RX message buffer back to the LLCE */
                Reg_Write32( LLCE_FIFO_PUSH0(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif)), (uint32)u16RxMbDescIdx);
                u32FifoStatus = (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif))));
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            }
#endif
        }
        
    }

    /* Clear the interrupt status flag. */
    Reg_Write32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8RxInterface)), LLCE_FIFO_FNEMTY_U32); 

}

#if (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON)
    static void Can_Llce_ProcessRxPollingClass(uint8 u8PollClassIdx)
    {
        uint8 u8ControllerId = 0U;
        uint8 u8HwCtrl = 0U;

        uint16 u16RxMbDescIdx = 0U;

        uint16 u16HohIndex = 0U;

        uint16 u16SafetyLoopEscapeCnt;
        /* Timeout counter. */
        uint32 u32timeStart = 0U;
        uint32 u32timeElapsed = 0U;
        uint32 u32TicksDelayDuration = 0U;

        const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

        u16SafetyLoopEscapeCnt = pxConfig->pPlatfInitConfig->au16MaxPollMbCount[u8PollClassIdx];

        /* Process all entries from the RxOut FIFO corresponding to a polling class. Their order number starts with 16 (LLCE_CAN_CONFIG_MAXCTRL_COUNT) */
        while ((LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS((LLCE_CAN_CONFIG_MAXCTRL_COUNT + u8PollClassIdx)))) & (uint32)(LLCE_FIFO_FEMTYD_U32))) && \
               (u16SafetyLoopEscapeCnt > 0U ) )
        {
            u16SafetyLoopEscapeCnt--;
            /* Read data from the fifo. */
            u16RxMbDescIdx = (uint16)Reg_Read32( LLCE_FIFO_POP0(LLCE_FIFO_RXOUT_BASE_ADDRESS((LLCE_CAN_CONFIG_MAXCTRL_COUNT + u8PollClassIdx))));
            u16HohIndex = Can_SharedMemory.Can_Rx_aMbDesc[u16RxMbDescIdx].u16FilterId;

            u8ControllerId = pxConfig->aHohList[u16HohIndex].u8ControllerId;
            
            /* Get the hardware offset for this controller. */
            u8HwCtrl = pxConfig->aControllerDescriptors[u8ControllerId].u8HwCtrl;

#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            if(Can_43_LLCE_GetCoreID() == pxConfig->aControllerDescriptors[u8ControllerId].u32CoreId)
            {
#endif
                /* Filter outdated frames gathered as a consequence of bus-off event or STOP command. */
                if (CAN_CS_STARTED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState)
                {
                    /*
                    (CAN108) The function Can_43_LLCE_MainFunction_Read shall perform the polling of RX indications when CanRxProcessing is set to POLLING or Mixed.
                    In case of MIXED processing only the hardware objects for which CanHardwareObjectUsesPolling is set to TRUE shall be polled
                    */
                    if (LLCE_CAN_REFERENCE_NOT_USED != pxConfig->aHohList[u16HohIndex].u8CanMainFuncRWPeriodRef)
                    {
                        Can_Llce_ProcessRxMb(u16RxMbDescIdx);
                    }
                }

                u32timeStart = OsIf_GetCounter(CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
                u32TicksDelayDuration = OsIf_MicrosToTicks(CAN_43_LLCE_TIMEOUT_DURATION, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
                u32timeElapsed = 0U;

                /* Wait for LLCE to consume the tokens before next token is pushed */
                while ( (0U == (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif))) & (uint32)(LLCE_FIFO_FEMTYD_U32)) ) && (u32timeElapsed < u32TicksDelayDuration))
                {
                    u32timeElapsed += OsIf_GetElapsed(&u32timeStart, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
                }

                /* Write address of RX message buffer back to the LLCE */
                Reg_Write32( LLCE_FIFO_PUSH0(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif)), (uint32)u16RxMbDescIdx);
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            }
#endif
        }
    }
#endif

#if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)
    #ifdef CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE
       #if (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE == STD_OFF)
            /*================================================================================================*/
            /**
            * @brief          Service to perform the polling of TX confirmation and TX cancellation confirmation
            * @details        This routine is called by:
            *               - Can_43_LLCE_MainFunction_Write() from Can_43_LLCE.c file.
            *
            * @pre            The controller must be configured for transmit in polling mode and at least one MB is configured for Tx.
            * @post           Process the transmission data in case of availability.
            *
            *
            */
            void Can_Llce_MainFunctionWrite(void)
            {   
                uint8  u8PollClassIdx;

                const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

                if ( NULL_PTR != pxConfig )
                {   
                    for ( u8PollClassIdx = 0U; u8PollClassIdx < LLCE_CAN_MAX_POLLING_CLASSES; u8PollClassIdx++)
                    {   
                        /* Check only the polling classes which have been configured */
                        if (0U != pxConfig->pPlatfInitConfig->au16MaxPollTxAckCount[u8PollClassIdx])
                        {
                            Can_Llce_ProcessTxPollingClass(u8PollClassIdx);
                        }
                    }
                }
            }
        #else
            /*================================================================================================*/
            /**
            * @brief          Function called at fixed cyclic time, with polling of all the MessageBuffer referenced to writepoll
            * @details        Service for performs the polling of TX confirmation and TX cancellation confirmation when CAN_TX_PROCESSING is set to POLLING.
            *                 This routine is called by:
            *                 - CanIf or an upper layer according to Autosar requirements.
            *
            * @api
            *
            * @pre            Driver must be initialized.
            * @post           Send the data from that MB that is configured for Tx.
            */
            void Can_Llce_MainFunctionMultipleWritePoll(uint8 writepoll)
            {

                const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

                if ( NULL_PTR != pxConfig )
                {   
                    Can_Llce_ProcessTxPollingClass(writepoll);
                }
            }
            #endif /* End CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE */
    #endif /*ifdef (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE)*/
#endif /* (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON) */



#if (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON)
    #ifdef CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ
        #if (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ == STD_OFF)
            /*================================================================================================*/
            /**
            * @brief          Service to perform the polling of RX indications.
            * @details        Processes Rx interrupt flags.
            *                 This routine is called by:
            *                    - Can_43_LLCE_MainFunction_Read() from Can_43_LLCE.c file.
            *
            * @pre            The controller must be configured for receive in polling mode and at least one MB is configured for Rx.
            * @post           Process the reception data in case of availability.
            *
            *
            */
            void Can_Llce_MainFunctionRead(void)
            {   
                uint8  u8PollClassIdx;

                const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

                if ( NULL_PTR != pxConfig )
                {   
                    for ( u8PollClassIdx = 0U; u8PollClassIdx < LLCE_CAN_MAX_POLLING_CLASSES; u8PollClassIdx++)
                    {   
                        /* Check only the polling classes which have been configured */
                        if (0U != pxConfig->pPlatfInitConfig->au16MaxPollMbCount[u8PollClassIdx])
                        {
                            Can_Llce_ProcessRxPollingClass(u8PollClassIdx);
                        }
                    }
                }
            }
        #else
            /*================================================================================================*/
            /**
            * @brief          Function called at fixed cyclic time, with polling of all the MessageBuffer referenced to .readpoll
            * @details        Service for performs the polling of RX indications when CAN_RX_PROCESSING is set to POLLING.
            *                 This routine is called by:
            *                 - CanIf or an upper layer according to Autosar requirements.
            *
            * @api
            * @pre            Driver must be initialized.
            * @post           Receive the data from that MB that is configured for Rx.
            *
            */
            void Can_Llce_MainFunctionMultipleReadPoll(uint8 readpoll)
            {
                const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();


                if ( NULL_PTR != pxConfig )
                {   
                    Can_Llce_ProcessRxPollingClass(readpoll);
                }
            }
        #endif  /* (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ == STD_OFF) */   
    #endif /* ifdef (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ)*/
#endif /* (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON) */


/*================================================================================================*/
/**
* @brief          Service to perform the polling of CAN status register flags to detect transition of CAN Controller state
* @details        The function Can_43_LLCE_MainFunction_Mode shall implement the polling of CAN status register flags to detect transition of CAN Controller state
*
* @param[in]      u8HwCtrl    CAN controller for which the polling shall be done.
*
* @pre
* @post
*
*/

void Can_Llce_MainFunctionMode(uint8 u8HwCtrl)
{
    /* Variable for updated mode */
    Can_ControllerStateType crtControllerMode = CAN_CS_UNINIT;
    
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
    /* Update mode indicator */
    (void)Can_Llce_GetControllerMode(u8HwCtrl, &crtControllerMode);

    /* Check for state changes */
    if(crtControllerMode != Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState) 
    {
        switch(crtControllerMode)
        {
            case CAN_CS_UNINIT:
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_UNINIT;
                Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_UNINIT);
                break;

            case CAN_CS_SLEEP:
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_SLEEP;
                Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_SLEEP);
                break;

            case CAN_CS_STARTED:
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_STARTED;
                Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_STARTED);
                /*
                (CAN425)   Enabling of CAN interrupts shall not be executed, when CAN interrupts have been disabled by function CAN_DisableControllerInterrupts.
                */
                if ( CAN_INTERRUPT_ENABLED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eInterruptMode )
                {
                    Can_Llce_EnableInterrupts(u8HwCtrl);
                }
                break;

            case CAN_CS_STOPPED:
                /* Check if interrupts are enabled */
                if ( CAN_INTERRUPT_ENABLED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eInterruptMode )
                {
                    Can_Llce_DisableInterrupts(u8HwCtrl);
                }
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_STOPPED;
                Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_STOPPED);
                break;

            default:
                /* Switch must handle all states. No action, just appease MISRA */
                break;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
}

/*================================================================================================*/
/**
* @brief          Service disables all interrupts for the given CAN controller.
* @details        This routine is called by:
*                 - Can_43_LLCE_DisableControllerInterrupts() from Can_43_LLCE.c file.
*
* @param[in]      Controller CAN controller for which the init shall be done.
*
* @pre            Disable interrupts must be called prior to enable interrupts.
* @post           Clear all flags/bits that are needed for disabling the interrupts.
*
*
*/
void Can_Llce_DisableControllerInterrupts(uint8 u8HwCtrl)
{
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_00();
    /*
       (CAN202) When Can_43_LLCE_DisableControllerInterrupts has been called several times, Can_43_LLCE_EnableControllerInterrupts must be called
                as many times before the interrupts are re-enabled.
    */
    Can_43_LLCE_ControllerStatuses[u8HwCtrl].u8IntDisableLevel++;

    /*
       (CAN049) The function Can_43_LLCE_DisableControllerInterrupts shall disable all interrupts for this CAN controller only at the first call of this function.
    */
    if ( (uint8)1 == Can_43_LLCE_ControllerStatuses[u8HwCtrl].u8IntDisableLevel )
    {
        /* Switch to disabled mode. */
        Can_43_LLCE_ControllerStatuses[u8HwCtrl].eInterruptMode = CAN_INTERRUPT_DISABLED;
        Can_Llce_DisableInterrupts(u8HwCtrl);
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_00();
}


/*================================================================================================*/
/**
* @brief          Service enables all interrupts that shall be enabled according the current software status.
* @details        This routine is called by:
*                  - Can_43_LLCE_EnableControllerInterrupts() from Can_43_LLCE.c file.
*
* @param[in]      Controller CAN controller for which the init shall be done.
*
* @pre            Can be executed only if disable interrupts was called before.
* @post           Enable all interrupts that must be enabled according the current sw status.
*
*
*/
void Can_Llce_EnableControllerInterrupts(uint8 u8HwCtrl )
{
    /* Variable that tells if disable ints was called at least once before. */
    uint8   u8DisCalledBefore = 0U;

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_01();
    /*
       (CAN202) When Can_43_LLCE_DisableControllerInterrupts has been called several times, Can_43_LLCE_EnableControllerInterrupts must be called as many
               times before the interrupts are re-enabled.
    */

    if ( Can_43_LLCE_ControllerStatuses[u8HwCtrl].u8IntDisableLevel > (uint8)0 )
    {
        /* When u8IntDisableLevel is greater than 0  means Can_43_LLCE_DisableControllerInterrupts was called at least once before this call of current function. */

        /* Decrement the nesting level. */
        Can_43_LLCE_ControllerStatuses[u8HwCtrl].u8IntDisableLevel--;

        u8DisCalledBefore = (uint8)0x1U;
    }

    /* Can_43_LLCE_DisableControllerInterrupts and Can_43_LLCE_EnableControllerInterrupts do not modify the software flags. */

    /*
       (CAN208) The function Can_43_LLCE_EnableControllerInterrupts shall perform no action when Can_43_LLCE_DisableControllerInterrupts has not been called before.
    */
    if ( ((uint8)0 == Can_43_LLCE_ControllerStatuses[u8HwCtrl].u8IntDisableLevel) && ((uint8)0x1U == u8DisCalledBefore) )
    {

        /* Switch to enabled mode. */
        Can_43_LLCE_ControllerStatuses[u8HwCtrl].eInterruptMode = CAN_INTERRUPT_ENABLED;
        Can_Llce_EnableInterrupts(u8HwCtrl);
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_01();
}


Std_ReturnType Can_Llce_GetControllerErrorState(uint8 u8HwCtrl, Can_ErrorStateType * ErrorStatePtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue;
    /* The value Error State of Controller */
    uint32  u32ErrorState = 0U;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_GETSTATUS;

        /* Send the command prepared above to the LLCE in order to be executed */
        eCommandReturnValue = Can_Llce_ExecuteIfCommand(u8HwCtrl);
        /* Read the BCAN error state */
        u32ErrorState =  Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.GetStatus.u32SR & LLCE_BCAN_SR_FLTCONF_MASK_U32;

        if (LLCE_FW_SUCCESS == eCommandReturnValue)
        {            
            switch(u32ErrorState)
            {
                case (LLCE_BCAN_SR_FLTCONF_ERROR_ACTIVE_U32):
                    *ErrorStatePtr = CAN_ERRORSTATE_ACTIVE;
                    eReturnValue = E_OK;
                    break;
                case (LLCE_BCAN_SR_FLTCONF_ERROR_PASSIVE_U32):
                    *ErrorStatePtr = CAN_ERRORSTATE_PASSIVE;
                    eReturnValue = E_OK;
                    break;
                case (LLCE_BCAN_SR_FLTCONF_BUSOFF10_U32):
                    *ErrorStatePtr = CAN_ERRORSTATE_BUSOFF;
                    eReturnValue = E_OK;
                    break;
                case (LLCE_BCAN_SR_FLTCONF_BUSOFF11_U32):
                    *ErrorStatePtr = CAN_ERRORSTATE_BUSOFF;
                    eReturnValue = E_OK;
                    break;
                default:
                    eReturnValue = E_NOT_OK;
                    break;
            }
        }
    }
    
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    
    return eReturnValue;
}

/**
*   @brief      Get Controller Rx Error Counter
*/
Std_ReturnType Can_Llce_GetControllerRxErrorCounter(uint8 u8HwCtrl, uint8 * RxErrorCounterPtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_GETSTATUS;

         /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand(u8HwCtrl) )
        {
            /* Read the BCAN Rx Error Counter */
            *RxErrorCounterPtr = (uint8)((Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.GetStatus.u32ECR & LLCE_BCAN_ECR_REC_MASK_U32) >> LLCE_BCAN_ECR_REC_SHIFT_U8);
            eReturnValue = E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

/**
*   @brief      Get Controller Tx Error Counter
*/
Std_ReturnType Can_Llce_GetControllerTxErrorCounter(uint8 u8HwCtrl, uint8 * TxErrorCounterPtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_GETSTATUS;

         /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand(u8HwCtrl) )
        {
            /* Read the BCAN Tx Error Counter */
            *TxErrorCounterPtr = (uint8)((Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.GetStatus.u32ECR & LLCE_BCAN_ECR_TEC_MASK_U32) >> LLCE_BCAN_ECR_TEC_SHIFT_U8);
            eReturnValue = E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

Std_ReturnType Can_Llce_GetControllerStatus(uint8 u8HwCtrl, Llce_Can_GetStatusCmdType * StatusPtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_GETSTATUS;

         /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand(u8HwCtrl) )
        {
            *StatusPtr = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.GetStatus;
            eReturnValue = E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

Std_ReturnType Can_Llce_GetFwVersion(const uint8 ** pVersionString, uint8 * pStringLength)
{
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue;

    uint8 u8Idx = 0;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    if(0U == u8VersionLength)
    {
        SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
        /* Read version from LLCE */
        if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
        {
            /* Configure the command id. */
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_GETFWVERSION;

            /* Send the command prepared above to the LLCE in order to be executed */
            eCommandReturnValue = Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController);

            u8VersionLength = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.GetFwVersion.stringLength;

            for(u8Idx = 0; u8Idx < u8VersionLength; u8Idx++)
            {
                au8VersionStringBuf[u8Idx] = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.GetFwVersion.versionString[u8Idx];
            }

            if (LLCE_FW_SUCCESS == eCommandReturnValue)
            {
                eReturnValue = E_OK;
            }
        }
       
        SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    }
    else 
    {
        eReturnValue = E_OK;
    }
        
    *pVersionString = au8VersionStringBuf;
    *pStringLength = u8VersionLength;

    return eReturnValue;
   
}

Std_ReturnType Can_Llce_ExecuteCustomCommand(const void* const argument)
{
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_CUSTOM;
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.pCustomCmdArg= (uint32)argument;

         /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController) )
        {
            eReturnValue = E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    
    return eReturnValue;
}


#if (CAN_43_LLCE_API_ENABLE_ABORT_MB == STD_ON)
/*================================================================================================*/
/**
* @brief          This service requests LLCE to abort lowest priority pending transmission
* @details        This service requests LLCE to abort lowest priority pending transmission
*                 belonging to a specific HTH. The MB will be released if the command succeeds.
*
* @param[in]      Hth - HW-transmit handler
*
* @return         Std_ReturnType
* @retval         E_OK MB has been aborted
* @retval         E_NOT_OK MB could not be aborted
*/
Std_ReturnType Can_Llce_AbortMb( Can_HwHandleType Hth)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue = LLCE_FW_NOTRUN;
    uint8 u8HwCtrl = 0U;
    uint8 u8CtrlId = 0U;
    uint8 u8AbortedFrameCnt = 0U;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    u8CtrlId = pxConfig->aHohList[Hth].u8ControllerId;

    /* Get the hardware offset for this controller. */
    u8HwCtrl = pxConfig->aControllerDescriptors[u8CtrlId].u8HwCtrl;

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_ABORT_MB;

        /* Configure the MB tag in order for the LLCE firmware to find the MB. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.AbortMb.u16FrameTag = Hth;

#if (CAN_43_LLCE_ABORT_ONLY_ONE_MB == STD_ON)
        /* Configure the MB tag in order for the LLCE firmware to find the MB. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.AbortMb.eAbortMbType = ABORT_ONLY_ONE_MB;
#else
        /* Configure the MB tag in order for the LLCE firmware to find the MB. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.AbortMb.eAbortMbType = ABORT_ALL_MB;
#endif 
         /* Send the command prepared above to LLCE in order to be executed */
        eCommandReturnValue =  Can_Llce_ExecuteIfCommand(u8HwCtrl);
        
        u8AbortedFrameCnt = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.AbortMb.u8AbortedFrameCnt;
    }
    
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    if (LLCE_FW_SUCCESS == eCommandReturnValue)
    {
        eReturnValue = E_OK;

        Can_Hth_FreeTxObject(Hth, u8AbortedFrameCnt);
    }

    return eReturnValue;
}
#endif


#if (CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY == STD_ON)
/*================================================================================================*/
/**
* @brief          This service requests LLCE to recover the given controller from bus-off state.
* @details        This synchronous service requests bus-off recovery when the controller is configured
*                 in manual bus-off recovery mode. No outstanding TX or RX frames are discarded.
*
* @param[in]      u8HwCtrl - hw controller
*
* @return         Std_ReturnType
* @retval         E_OK command acknowledged by LLCE
* @retval         E_NOT_OK command not acknowledged by LLCE
*/
Std_ReturnType Can_Llce_ManualBusOffRecovery(uint8 u8HwCtrl)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_MANUAL_BUSOFF_RECOVERY;

         /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand(u8HwCtrl) )
        {
            eReturnValue = E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}
#endif


#define CAN_43_LLCE_STOP_SEC_CODE
#include "Can_43_LLCE_MemMap.h"


#ifdef __cplusplus
}
#endif

/** @} */


===== 文件 [104/112]: source&include\src\Llce_InterfaceCanConfig.c =====
/**
*   @file    Llce_InterfaceConfig.c
*
*   @version 1.0.0
*   @brief   LLCE defines used to configure the LLCE firmware and interface regarding FIFO usage.
*   @details LLCE  defines used to configure the LLCE firmware and interface regarding FIFOs. Those configuration parameters are used both by LLCE firmware and host software.
*
*
*   @addtogroup Llce_interface_configuration Configuration of FIFOs used as host interface.
*   @{
*/
/*==================================================================================================
*
* Copyright 2018-2023 NXP 
* 
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in 
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/


#ifdef __cplusplus
extern "C"
{
#endif
#ifndef __DOXYGEN__
/**
* @page misra_violations MISRA-C:2004 violations
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.1, Identifiers (internal and external) shall not rely 
* on the significance of more than 31 characters. 
* The used compilers use more than 31 chars for identifiers.
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.4, Macro identifiers shall be distinct.
* This violation is due to the AUTOSAR requirement [SWS_BSW_00036] (perform inter module checks).
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.2, Identifiers declared in the same scope and name space shall be distinct.
* This rule does not apply if either identifier is a macro identifier, because this case is covered
* by Rule 5.4 and Rule 5.5.
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.5, Identifiers shall be distinct from macro names.
* The identifier clash is between macro identifiers. Therefore, this rule is incorrectly reported by the tool.
* 
*@section [global]
* Violates MISRA 2012 Advisory Rule 8.9, Objects shall be defined at block scope if they are only accessed from within a single function
* Some macros are used either in FW or driver, or provided as API
*
* @section [global]
* Violates MISRA 2012 Advisory Rule 8.7, Functions and objects should not be defined with external linkage if they are referenced in only one translation unit.
* Some macros are used either in FW or driver, or provided as API
*
*/
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Llce_InterfaceCanConfig.h"
#include "Llce_InterfaceFifo.h"
#include "Llce_InterfaceMemLayoutCheck.h"
#include "Llce_InterfaceCanTypes.h"
#include "Llce_InterfaceCanUtils.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/

/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/
/** @brief    Configuration of FIFOs used for BLRIN role. 
 *  @details  It is used to configure which FIFOs are used to send indexes to full tx mb descriptors from host to LLCE.
 **/ 

const uint32 Llce_Can_u32BlrinBaseAddress[LLCE_CAN_CONFIG_MAXCTRL_COUNT] = {
    LLCE_FIFO_42_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO0*/
    LLCE_FIFO_43_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO1*/
    LLCE_FIFO_44_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO2*/
    LLCE_FIFO_45_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO3*/
    LLCE_FIFO_46_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO4*/
    LLCE_FIFO_47_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO5*/
    LLCE_FIFO_48_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO6*/
    LLCE_FIFO_49_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO7*/
    LLCE_FIFO_50_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO8*/
    LLCE_FIFO_51_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO9*/
    LLCE_FIFO_52_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO10*/
    LLCE_FIFO_53_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO11*/
    LLCE_FIFO_54_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO12*/
    LLCE_FIFO_55_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO13*/
    LLCE_FIFO_56_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO14*/
    LLCE_FIFO_57_BASE_ADDRESS   /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO15*/
    };
   

 /** @brief    Configuration of FIFOs used for RXOUT role. 
 *   @details  It is used to configure which FIFOs are used to send indexes to full rx mb descriptors from LLCE to host.
 **/  
const uint32 Llce_Can_u32RxoutBaseAddress[LLCE_CAN_CONFIG_MAXCTRL_COUNT + LLCE_CAN_MAX_POLLING_CLASSES] = {
    LLCE_FIFO_21_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO0*/
    LLCE_FIFO_22_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO1*/
    LLCE_FIFO_23_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO2*/
    LLCE_FIFO_24_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO3*/
    LLCE_FIFO_25_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO4*/
    LLCE_FIFO_26_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO5*/
    LLCE_FIFO_27_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO6*/
    LLCE_FIFO_28_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO7*/
    LLCE_FIFO_29_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO8*/
    LLCE_FIFO_30_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO9*/
    LLCE_FIFO_31_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO10*/
    LLCE_FIFO_32_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO11*/
    LLCE_FIFO_33_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO12*/
    LLCE_FIFO_34_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO13*/
    LLCE_FIFO_35_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO14*/
    LLCE_FIFO_36_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO15*/
    LLCE_FIFO_2_BASE_ADDRESS,    /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO16*/
    LLCE_FIFO_3_BASE_ADDRESS,    /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO17*/
    LLCE_FIFO_4_BASE_ADDRESS,    /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO18*/
    LLCE_FIFO_5_BASE_ADDRESS,    /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO19*/
    LLCE_FIFO_6_BASE_ADDRESS,    /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO20*/
    LLCE_FIFO_7_BASE_ADDRESS     /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO21*/
    };

/** @brief    Configuration of FIFOs used for either NOTIF_INTR or NOTIF_POLL role. 
 *  @details  It is used to configure for each host which FIFOs are used to send notifications from LLCE to host in interrupt mode.
 **/ 
const uint32 Llce_Can_u32NotifFifo0BaseAddress[LLCE_CAN_CONFIG_HIF_COUNT] = {
    LLCE_FIFO_0_BASE_ADDRESS,     /**< @brief   Base address of the hardware FIFO having the role of NOTIF_INTR FIFO for HIF0 */
    LLCE_FIFO_8_BASE_ADDRESS      /**< @brief   Base address of the hardware FIFO having the role of NOTIF_INTR FIFO for HIF1 */
    };

 /** @brief    Configuration of FIFOs used for either NOTIF_INTR or NOTIF_POLL role. 
 *   @details  It is used to configure for each host which FIFOs are used to send notifications from LLCE to host in polling mode.
 **/    
const uint32 Llce_Can_u32NotifFifo1BaseAddress[LLCE_CAN_CONFIG_HIF_COUNT] = {
    LLCE_FIFO_1_BASE_ADDRESS,     /**< @brief   Base address of the hardware FIFO having the role of NOTIF_POLL FIFO for HIF0 */
    LLCE_FIFO_9_BASE_ADDRESS,     /**< @brief   Base address of the hardware FIFO having the role of NOTIF_POLL FIFO for HIF1 */
    };    

/** @brief    Configuration of FIFOs used for TXACK role. 
 *  @details  It is used to configure which FIFOs are used to send tx confirmations from LLCE to host.
 **/ 
const uint32 Llce_Can_u32TxackBaseAddress[LLCE_CAN_RX_TX_INTERFACES] = {
    LLCE_FIFO_84_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK0 FIFO*/
    LLCE_FIFO_85_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK1 FIFO*/
    LLCE_FIFO_86_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK2 FIFO*/
    LLCE_FIFO_87_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK3 FIFO*/
    LLCE_FIFO_88_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK4 FIFO*/
    LLCE_FIFO_89_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK5 FIFO*/
    LLCE_FIFO_90_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK6 FIFO*/
    LLCE_FIFO_91_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK7 FIFO*/
    LLCE_FIFO_92_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK8 FIFO*/
    LLCE_FIFO_93_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK9 FIFO*/
    LLCE_FIFO_94_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK10 FIFO*/
    LLCE_FIFO_95_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK11 FIFO*/
    LLCE_FIFO_96_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK12 FIFO*/
    LLCE_FIFO_97_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK13 FIFO*/
    LLCE_FIFO_98_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK14 FIFO*/
    LLCE_FIFO_99_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK15 FIFO*/
    LLCE_FIFO_10_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK16 FIFO*/
    LLCE_FIFO_11_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK17 FIFO*/
    LLCE_FIFO_12_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK18 FIFO*/
    LLCE_FIFO_13_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK19 FIFO*/
    LLCE_FIFO_14_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK20 FIFO*/
    LLCE_FIFO_15_BASE_ADDRESS    /**< @brief   Base address of the hardware FIFO having the role of TXACK21 FIFO*/
    };


/** @brief    Configuration of FIFOs used for BLROUT role. 
 *  @details  It is used to configure which FIFOs are used to send indexes to empty tx mb descriptors from LLCE to host.
 **/ 
const uint32 Llce_Can_u32BlroutBaseAddress[LLCE_CAN_CONFIG_MAXCTRL_COUNT] = {
    LLCE_FIFO_63_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT0 FIFO*/
    LLCE_FIFO_64_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT1 FIFO*/
    LLCE_FIFO_65_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT2 FIFO*/
    LLCE_FIFO_66_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT3 FIFO*/
    LLCE_FIFO_67_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT4 FIFO*/
    LLCE_FIFO_68_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT5 FIFO*/
    LLCE_FIFO_69_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT6 FIFO*/
    LLCE_FIFO_70_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT7 FIFO*/
    LLCE_FIFO_71_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT8 FIFO*/
    LLCE_FIFO_72_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT9 FIFO*/
    LLCE_FIFO_73_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT10 FIFO*/
    LLCE_FIFO_74_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT11 FIFO*/
    LLCE_FIFO_75_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT12 FIFO*/
    LLCE_FIFO_76_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT13 FIFO*/
    LLCE_FIFO_77_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT14 FIFO*/
    LLCE_FIFO_78_BASE_ADDRESS       /**< @brief   Base address of the hardware FIFO having the role of BLROUT15 FIFO*/
    };

/** @brief    Configuration of FIFOs used for RXIN role. 
 *  @details  It is used to configure for each host  which FIFOs are used to send indexes to empty rx mb descriptors from host to LLCE.
 **/   
const uint32 Llce_Can_u32RxinBaseAddress[LLCE_CAN_CONFIG_HIF_COUNT] = {
    LLCE_FIFO_16_BASE_ADDRESS,/**< @brief   Base address of the FIFO having the role of RXIN FIFO for HIF0*/
    LLCE_FIFO_18_BASE_ADDRESS /**< @brief   Base address of the FIFO having the role of RXIN FIFO for HIF1*/
    };

/** @brief    Configuration of FIFOs used for commands. 
 *  @details  It is used to configure which FIFOs are used to send commands from host to LLCE.
 **/ 
const uint32 Llce_Can_u32CmdBaseAddress[LLCE_CAN_CONFIG_HIF_COUNT] = {
    LLCE_FIFO_101_BASE_ADDRESS, /**< @brief   Base address of the CMD FIFO for HIF0   */
    LLCE_FIFO_102_BASE_ADDRESS  /**< @brief   Base address of the CMD FIFO for HIF1   */
    };



/** @brief    Configuration of FIFO used for logging interface. 
 *  @details  It is used to configure which FIFO is used to send indexes to full rx mb descriptors from logging host core  back to LLCE.
 **/ 
const uint32 Llce_Can_u32RxinLogBaseAddress[1] = {
    LLCE_FIFO_37_BASE_ADDRESS  /**< @brief   Base address of the RXINLOG FIFO. */
    }; 

    
/** @brief    Configuration of FIFO used for logging interface. 
 *  @details  It is used to configure which FIFO is used to send indexes to  full rx mb descriptors from LLCE to logging host core.
 **/  
const uint32 Llce_Can_u32RxoutLogBaseAddress[1] = {
    LLCE_FIFO_38_BASE_ADDRESS  /**< @brief   Base address of the RXOUTLOG FIFO. */
    };

/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

/*=================================================================================================
*                                       LOCAL FUNCTIONS PROTOTYPES
==================================================================================================*/

/*=================================================================================================
*                                            LOCAL FUNCTIONS 
==================================================================================================*/

/*=================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/

/*================================================================================================*/


/**
* @brief          Disable FNEMPTY interrupt for TXACK and RXOUT fifos, thus disabling ACK and RX frames to be processed on interrupt.
* @details        Recommended API to disable FIFO interrupt for host processing
*
* @param[in]      u8FifoInterface Fifo interface mapped to the hw controller (1 to 1 default mapping).
* @param[in]      u8Hif Host Interface
*
* @return         void
*
*/
void DisableFifoInterrupts (uint8 u8FifoInterface, uint8 u8Hif)
{
    Llce_Sema42_Lock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, u8Hif), LLCE_HOST_CORE_SEMA42_DOMAIN);
    /* Disable RXOUT interrupt. */
    Reg_Bit_Clear32( LLCE_FIFO_IER(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);
    Llce_Sema42_Unlock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, u8Hif));


    Llce_Sema42_Lock( Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, u8Hif), LLCE_HOST_CORE_SEMA42_DOMAIN);
    /* Disable TXACK interrupt. */
    Reg_Bit_Clear32( LLCE_FIFO_IER(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);
    Llce_Sema42_Unlock( Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, u8Hif));

}


/**
* @brief          Enable FNEMPTY interrupt for TXACK and RXOUT fifos, thus enabling ACK and RX frames to be processed on interrupt.
* @details        Recommended API to enable FIFO interrupt for host processing
*
* @param[in]      u8FifoInterface Fifo interface mapped to the hw controller (1 to 1 default mapping).
* @param[in]      u8Hif Host Interface
*
* @return         void
*
*/
void EnableFifoInterrupts (uint8 u8FifoInterface, uint8 u8Hif)
{
    /* Clear all interrupt status flags. */
    Reg_Write32(LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface)), Reg_Read32(LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface))));

    Llce_Sema42_Lock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, u8Hif), LLCE_HOST_CORE_SEMA42_DOMAIN);
    /* Enable needed interrupt. */
    Reg_Bit_Set32( LLCE_FIFO_IER(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);
    Llce_Sema42_Unlock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, u8Hif));

    /* Clear all interrupt status flags. */
    Reg_Write32(LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface)),Reg_Read32(LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface))));

    Llce_Sema42_Lock( Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, u8Hif), LLCE_HOST_CORE_SEMA42_DOMAIN);
    /* Enable needed interrupt. */
    Reg_Bit_Set32( LLCE_FIFO_IER(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);
    Llce_Sema42_Unlock( Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, u8Hif));

}



#ifdef __cplusplus
}
#endif

/** @} */


===== 文件 [105/112]: source&include\src\Llce_SwFifo.c =====
/**
*   
*   @brief   LLCE Generic Software Fifo functions
*   @details This file contains the LLCE Generic Software Fifo function definitions.
*
*   @addtogroup LLCE_SwFifo
*   @{
*/
/*==================================================================================================
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

#include "Llce_SwFifo.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/

/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

/*=================================================================================================
*                                       LOCAL FUNCTIONS PROTOTYPES
==================================================================================================*/

/*=================================================================================================
*                                            LOCAL FUNCTIONS 
==================================================================================================*/        

/*=================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
/**
    * @brief          Initialize the Software Fifo structure with needed fields.
    * @details        Receives the size of the elements stored in the FIFO, the number of elements
    *                 able to be stored in the FIFO, the base address and the structure itself needed
    *                 to be initialized and updates the fields: u16MaxNElements, u16WrByteIdx, u16RdByteIdx,
    *                 pu8BaseAddr, u8ElemSize, eFifoStatus
    *  
    * @param          pu8BaseAddr - pointer to the base address of the buffer used by the FIFO
    * @param          u8ElemSize - the size of the elements stored in the FIFO
    * @param          u16MaxNElements - the maximum number of elements stored in the FIFO
    * @param          pLlce_SwFifo - pointer to the Software Fifo structure used
    *
    * @retval         Llce_Fw_ReturnType
    *
    * @pre            A buffer should be declared in order to be passed to the FIFO 
    *
    */
Llce_Fw_ReturnType Llce_SwFifo_Init(void *pu8BaseAddr, uint8 u8ElemSize, uint16 u16MaxNElements, Llce_SwFifo_Type *pLlce_SwFifo)
{   
    pLlce_SwFifo->u16MaxNElements = u16MaxNElements;
    pLlce_SwFifo->u16WrByteIdx = 0;
    pLlce_SwFifo->u16RdByteIdx = 0;
    pLlce_SwFifo->pu8BaseAddr = (uint8*)pu8BaseAddr;
    pLlce_SwFifo->u8ElemSize = u8ElemSize;
    pLlce_SwFifo->eFifoStatus = LLCE_SWFIFO_EMPTY;
    return LLCE_FW_SUCCESS;
}

/**
    * @brief          Stores a new element in the FIFO
    * @details        Receives the element to be stored and the Software FIFO and writes the
    *                 information, byte by byte into the FIFO buffer
    *  
    * @param          pGenericElem - pointer to the element which needs to be pushed into FIFO
    * @param          pLlce_SwFifo - pointer the Software FIFO structure used
    *
    * @retval         Llce_Fw_ReturnType
    *
    * @pre            The FIFO should be initialized before applying any operation on it
    *
    */
Llce_Fw_ReturnType Llce_SwFifo_Push(const void *pGenericElem, Llce_SwFifo_Type *pLlce_SwFifo)
{
    /* Index used to iterate each byte into the elements of struct type */
    uint8 u8CopyIdx;
    /* Variable for return status. */
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_SUCCESS;
    /* Pointer to the element which needs to be pushed. Used for elements of struct type */
    const uint8 *pElem;

    /* Check FIFO STATUS */
    if (pLlce_SwFifo->eFifoStatus == LLCE_SWFIFO_FULL)
    {
        eReturnValue = LLCE_FW_ERROR;
    }
    else /* Fifo not full */
    {   
        switch (pLlce_SwFifo->u8ElemSize)
        {
        case ((uint8)sizeof(uint32)):
            *(uint32*)(&(pLlce_SwFifo->pu8BaseAddr[pLlce_SwFifo->u16WrByteIdx])) = *(const uint32*)pGenericElem;
            
            break;
        case ((uint8)sizeof(uint16)):
            *(uint16*)(&(pLlce_SwFifo->pu8BaseAddr[pLlce_SwFifo->u16WrByteIdx])) = *(const uint16*)pGenericElem;

            break;
        case ((uint8)sizeof(uint8)):
            *(uint8*)(&(pLlce_SwFifo->pu8BaseAddr[pLlce_SwFifo->u16WrByteIdx])) = *(const uint8*)pGenericElem;

            break;
        default: /* used for elements of struct type */
            pElem = (const uint8*)pGenericElem;
            /* Copy each byte from source to destination */
            for (u8CopyIdx = 0; u8CopyIdx < pLlce_SwFifo->u8ElemSize; u8CopyIdx++)
            {
                pLlce_SwFifo ->pu8BaseAddr[pLlce_SwFifo->u16WrByteIdx + u8CopyIdx] = pElem[u8CopyIdx];
            }

            break;
        }

        /* Update the position of the writing index */
        pLlce_SwFifo->u16WrByteIdx += pLlce_SwFifo->u8ElemSize;

        /* Check writing index position and reset if needed */
        if (pLlce_SwFifo->u16WrByteIdx >= (pLlce_SwFifo->u8ElemSize * pLlce_SwFifo->u16MaxNElements))
        {
            pLlce_SwFifo->u16WrByteIdx = 0;
        }

        /* Update FIFO status after push operation */
        if (pLlce_SwFifo->u16WrByteIdx == pLlce_SwFifo->u16RdByteIdx)
        {
            pLlce_SwFifo->eFifoStatus = LLCE_SWFIFO_FULL;
        }
        else
        {
            pLlce_SwFifo->eFifoStatus = LLCE_SWFIFO_OPERATIONAL;
        }
    }

    return eReturnValue;
}

/**
    * @brief          Removes an element in the FIFO
    * @details        Receives a pointer to the location where the element will be stored
    *                 and the Software FIFO and writes the information, byte by byte from
    *                 the FIFO buffer to the destination location
    *  
    * @param          pGenericElem - pointer location where the extracted element will be stored
    * @param          pLlce_SwFifo - pointer the Software Fifo structure used
    *
    * @retval         Llce_Fw_ReturnType
    *
    * @pre            The FIFO should be initialized before applying any operation on it
    *
    */
Llce_Fw_ReturnType Llce_SwFifo_Pop(void *pGenericElem, Llce_SwFifo_Type *pLlce_SwFifo)
{
    /* Index used to iterate each byte into the elements of struct type */
    uint8 u8CopyIdx;
    /* Variable for return status. */
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_SUCCESS;
    /* Pointer to the element which needs to be popped.Used for elements of struct type  */
    uint8 *pElem;
    
    /* Check FIFO STATUS */
    if (pLlce_SwFifo->eFifoStatus == LLCE_SWFIFO_EMPTY)
    {
        eReturnValue = LLCE_FW_ERROR;
    }
    else /* Fifo not empty */
    {   
        switch (pLlce_SwFifo->u8ElemSize)
        {
        case ((uint8)sizeof(uint32)):
            *(uint32*)pGenericElem = *(uint32*)(&(pLlce_SwFifo->pu8BaseAddr[pLlce_SwFifo->u16RdByteIdx]));

            break;
        case ((uint8)sizeof(uint16)):
            *(uint16*)pGenericElem = *(uint16*)(&(pLlce_SwFifo->pu8BaseAddr[pLlce_SwFifo->u16RdByteIdx]));

            break;
        case ((uint8)sizeof(uint8)):
            *(uint8*)pGenericElem = *(uint8*)(&(pLlce_SwFifo->pu8BaseAddr[pLlce_SwFifo->u16RdByteIdx]));

            break;
        default: /* used for elements of struct type */
            pElem = (uint8*)pGenericElem;
            /* Copy each byte from source to destination */
            for (u8CopyIdx = 0; u8CopyIdx < pLlce_SwFifo->u8ElemSize; u8CopyIdx++)
            {
                pElem[u8CopyIdx] = pLlce_SwFifo ->pu8BaseAddr[pLlce_SwFifo->u16RdByteIdx + u8CopyIdx];
            }

            break;
        }

        /* Update the position of the reading index */
        pLlce_SwFifo->u16RdByteIdx += pLlce_SwFifo->u8ElemSize;

        /* Check reading index position and reset if needed */
        if (pLlce_SwFifo->u16RdByteIdx >= (pLlce_SwFifo->u8ElemSize * pLlce_SwFifo->u16MaxNElements))
        {
            pLlce_SwFifo->u16RdByteIdx = 0;
        }
        /* Update FIFO status after pop operation */
        if (pLlce_SwFifo->u16WrByteIdx == pLlce_SwFifo->u16RdByteIdx)
        {
            pLlce_SwFifo->eFifoStatus = LLCE_SWFIFO_EMPTY;
        }
        else
        {
            pLlce_SwFifo->eFifoStatus = LLCE_SWFIFO_OPERATIONAL;
        }
    }

    return eReturnValue;
}
#endif

#ifdef __cplusplus
}
#endif

/** @} */


===== 文件 [106/112]: src\Can_43_LLCE.c =====
/**
*   @internal
*   @file    Can_43_LLCE.c
*   @implements Can.c_Artifact
*   @version 1.0.10
*   @file    Can_43_LLCE.c
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details API implementation for CAN driver.
*
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/


#ifdef __cplusplus
extern "C"{
#endif


/*
Driver Limitations:
    1. The maximum number of Can_43_LLCE_DisableControllerInterrupts levels of nesting is 255.
    2. This file contains 2 types of functions: first are the Autosar APIs and then are some user defined functions.
*/


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
/*
* @file           Can_43_LLCE.c
*/
#include "Can_43_LLCE.h"
#include "Can_43_LLCE_IPW.h"
#include "CanIf_Can.h"
#include "CanIf.h"
#include "Std_Types.h"

#include "SchM_Can_43_LLCE.h"

#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
#include "Det.h"
#endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/*  (CAN111) Can_43_LLCE.c shall check if the correct version of Can_43_LLCE.h is included.
            This shall be done by a preprocessor check of the version numbers CAN_43_LLCE_SW_MAJOR_VERSION, CAN_43_LLCE_SW_MINOR_VERSION and CAN_43_LLCE_SW_PATCH_VERSION.
*/
/**
* @file           Can_43_LLCE.c
*/
#define CAN_43_LLCE_VENDOR_ID_C                      43
#define CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C       4
#define CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_C       4
#define CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_C    0
#define CAN_SW_MAJOR_VERSION_C               1
#define CAN_SW_MINOR_VERSION_C               0
#define CAN_SW_PATCH_VERSION_C               10


/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/
/* Check if current file and CAN header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID_C != CAN_43_LLCE_VENDOR_ID)
    #error "Can_43_LLCE.c and Can_43_LLCE.h have different vendor ids"
#endif
/* Check if current file and CAN header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C    != CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_C    != CAN_43_LLCE_AR_RELEASE_MINOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_C != CAN_43_LLCE_AR_RELEASE_REVISION_VERSION))
    #error "AutoSar Version Numbers of Can_43_LLCE.c and Can_43_LLCE.h are different"
#endif
/* Check if current file and CAN header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_C != CAN_43_LLCE_SW_MAJOR_VERSION) || \
     (CAN_SW_MINOR_VERSION_C != CAN_43_LLCE_SW_MINOR_VERSION) || \
     (CAN_SW_PATCH_VERSION_C != CAN_43_LLCE_SW_PATCH_VERSION))
    #error "Software Version Numbers of Can_43_LLCE.c and Can_43_LLCE.h are different"
#endif


/* Check if current file and CAN_IPW header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID_C != CAN_IPW_VENDOR_ID_H)
    #error "Can_43_LLCE.c and Can_43_LLCE_IPW.h have different vendor ids"
#endif
/* Check if current file and CAN_IPW header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C    != CAN_IPW_AR_RELEASE_MAJOR_VERSION_H) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_C    != CAN_IPW_AR_RELEASE_MINOR_VERSION_H) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_C != CAN_IPW_AR_RELEASE_REVISION_VERSION_H))
    #error "AutoSar Version Numbers of Can_43_LLCE.c and Can_43_LLCE_IPW.h are different"
#endif
/* Check if current file and CAN_IPW header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_C != CAN_IPW_SW_MAJOR_VERSION_H) || \
     (CAN_SW_MINOR_VERSION_C != CAN_IPW_SW_MINOR_VERSION_H) || \
     (CAN_SW_PATCH_VERSION_C != CAN_IPW_SW_PATCH_VERSION_H))
    #error "Software Version Numbers of Can_43_LLCE.c and Can_43_LLCE_IPW.h are different"
#endif

/* Check if current file and DET header file are of the same version */
#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
  #ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
    #if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C != DET_AR_RELEASE_MAJOR_VERSION) || \
         (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_C != DET_AR_RELEASE_MINOR_VERSION))
        #error "AutoSar Version Numbers of Can_43_LLCE.c and Det.h are different"
    #endif
  #endif
#endif

/* Check if current file and CANIF_CBK header file are of the same version */
#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
  #ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
    #if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_C != CANIF_CAN_AR_RELEASE_MAJOR_VERSION) || \
         (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_C != CANIF_CAN_AR_RELEASE_MINOR_VERSION))
        #error "AutoSar Version Numbers of Can_43_LLCE.c and CanIf_Can.h are different"
    #endif
  #endif
#endif

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/
#if (STD_ON == CAN_43_LLCE_PRECOMPILE_SUPPORT)
#define CAN_43_LLCE_START_SEC_CONFIG_DATA_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

#define CAN_43_LLCE_STOP_SEC_CONFIG_DATA_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"
#endif /* (STD_ON == CAN_43_LLCE_PRECOMPILE_SUPPORT) */

#define CAN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

volatile uint16 Can_au16TransmitHwObjectCnt[CAN_43_LLCE_MAXHTH_CONFIGURED];

#define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

#define CAN_43_LLCE_START_SEC_VAR_INIT_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"


/**
* @brief          This variable holds the state of the driver.
* @details        This variable holds the state of the driver. After reset is UNINIT. The output of Can_43_LLCE_Init() function
*                 (only to first call) should set this variable into READY state.
*                  CAN_43_LLCE_UNINIT = The CAN controller is not initialized. All registers belonging to the CAN module are in reset state, CAN interrupts are disabled.
*                  The CAN Controller is not participating on the CAN bus.
*                  The Can module must only implement a variable for the module state, when the development error tracing is switched on.
*                  When the development error tracing is switched off, the Can module does not need to implement this 'state machine',
*                  because the state information is only needed to check if Can_43_LLCE_Init was called prior to any Can module function.
*
*/
Can_43_LLCE_StatusType Can_43_LLCE_eDriverStatus[CAN_43_LLCE_MAX_PARTITIONS];

/* Pointer to the current Driver Configuration (passed to the driver during initialization). Initialized by Can_43_LLCE_Init(). */
const Can_43_LLCE_ConfigType * Can_43_LLCE_pCurrentConfig[CAN_43_LLCE_MAX_PARTITIONS];

#define CAN_43_LLCE_STOP_SEC_VAR_INIT_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"


/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/
#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
static boolean Can_ValidateController(uint8 u8Controller, uint8 u8Sid);
#endif

static Std_ReturnType Can_43_LLCE_SendWriteCmd(Can_HwHandleType Hth, const Can_PduType * PduInfo);

#ifdef CAN_43_LLCE_SET_BAUDRATE_API
#if (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON)
static Std_ReturnType Can_43_LLCE_SendSetBaudrateCmd(uint8 Controller, const uint16 BaudRateConfigID);
#endif
#endif

static void Can_43_LLCE_InitializeControllers(const uint32* u32CoreId);

/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_CODE
#include "Can_43_LLCE_MemMap.h"

static boolean Can_ValidateController(uint8 u8Controller, uint8 u8Sid)
{
    boolean bValid = TRUE;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

#if (CAN_43_LLCE_DEV_ERROR_DETECT != STD_ON)
    /* Suppress warning */
    (void)u8Sid;
#endif

    /* Check if the driver was initialised */
    if (CAN_43_LLCE_UNINIT == Can_43_LLCE_eDriverStatus[u32CoreId] )
    {
        /*
        (CAN089) The Can module environment shall indicate development errors only in the return values of a function of the Can module when DET
                 is switched on and the function provides a return value. The returned value is E_NOT_OK.
        */
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /*
           (CAN198) If development error detection for the Can module is enabled: if the module is not yet initialized, the
                   function Can_43_LLCE_SetControllerMode shall raise development error CAN_43_LLCE_E_UNINIT and return E_NOT_OK.
        */

        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, u8Sid, (uint8)CAN_43_LLCE_E_UNINIT);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

        bValid = FALSE;
    }
    else if ( (u8Controller >= CAN_43_LLCE_MAXCTRL_CONFIGURED) ||
             (CAN_43_LLCE_NULL_OFFSET == (Can_43_LLCE_pCurrentConfig[u32CoreId]->aControllerDescriptors[u8Controller].u8HwCtrl)))
        /* Controller ID must be within range and the selected Controller must be configured for use in the config tool. */
    {
        /*
           (CAN199) If development error detection for the Can module is enabled: if the parameter Controller is out of range,
                   the function Can_43_LLCE_SetControllerMode shall raise development error CAN_43_LLCE_E_PARAM_CONTROLLER and return E_NOT_OK.
        */
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, u8Sid, (uint8)CAN_43_LLCE_E_PARAM_CONTROLLER);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

        bValid = FALSE;
    }
    #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
    else if(Can_43_LLCE_pCurrentConfig[u32CoreId]->aControllerDescriptors[u8Controller].u32CoreId != u32CoreId)
    {
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, u8Sid, (uint8)CAN_43_LLCE_E_PARAM_CONFIG);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

        bValid = FALSE;
    }
    #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
    else
    {
        ;/* Do nothing */
    }
    
    return bValid;
}

static void Can_43_LLCE_InitializeControllers(const uint32* u32CoreId)
{
    /* Variable for indexing the controllers. */
    uint8 can_controller;
    /* Status variable for platform init. */
    Llce_Fw_ReturnType eReturnValue;
                
    eReturnValue = Can_43_LLCE_IPW_Init(Can_43_LLCE_pCurrentConfig[*(u32CoreId)]);

    if(LLCE_FW_SUCCESS == eReturnValue)
    {
        /* Loop through all Can controllers configured based CanControllerId parameter. */
        for (can_controller = 0U; can_controller < CAN_43_LLCE_MAXCTRL_CONFIGURED; can_controller++)
        {
          #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
          if(Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->aControllerDescriptors[can_controller].u32CoreId == *(u32CoreId))
          {
          #endif
            /* The initialization is skipped for the controllers that are not enabled. */
            if (CAN_43_LLCE_NULL_OFFSET != (Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->aControllerDescriptors[can_controller].u8HwCtrl))
            {
                /*
                (CAN250) The function Can_43_LLCE_Init shall initialize: static variables, including flags, Common setting for the
                         complete CAN HW unit, CAN controller specific settings for each CAN controller.
                (CAN245) The function Can_43_LLCE_Init shall initialize all CAN controllers according to their configuration.
                (CAN053) Can module/controller initialization - registers of CAN controller hardware resources that are not used.
                */
                (void)Can_43_LLCE_IPW_ChangeBaudrate( can_controller, Can_43_LLCE_ControllerBaudRateIndexes[can_controller].u8CurrentBaudRateIndex);
            }
          #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
          }
          #endif
        }
        /*
        (CAN246) After initializing all controllers inside the HW Unit, the function Can_43_LLCE_Init shall change the module state to CAN_43_LLCE_READY.
        */
        Can_43_LLCE_eDriverStatus[*(u32CoreId)] = CAN_43_LLCE_READY;

        /*If any of the Error reporting category is set to interrupt, then turn on the unique Interrupt Notif Fifo*/
        if ((NOTIF_FIFO0 == Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->pPlatfInitConfig->CanErrorReporting.eCanProtocolErr) || 
            (NOTIF_FIFO0 == Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->pPlatfInitConfig->CanErrorReporting.eDataLostErr) || 
            (NOTIF_FIFO0 == Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->pPlatfInitConfig->CanErrorReporting.eInitErr) || 
            (NOTIF_FIFO0 == Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->pPlatfInitConfig->CanErrorReporting.eInternalErr) || 
            (NOTIF_FIFO0 == Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->pPlatfInitConfig->CanErrorReporting.eCanProtocolWarn))
        {
            /*Enable the Notif FIFO interrupt after fw initializes the FIFO*/
            Can_43_LLCE_IPW_EnableNotifInterrupt(Can_43_LLCE_pCurrentConfig[*(u32CoreId)]->u8ActiveHif);
        }
    }
}

/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/


/*================================================================================================*/


/*
(CAN252) The function Can_43_LLCE_GetVersionInfo shall be pre compile time configurable (ON/Off) by the configuration parameter: CanVersionInfoApi
*/

#if (CAN_43_LLCE_VERSION_INFO_API == STD_ON)
/**
* @brief          Returns the version information of this module. SID is 0x07
* @details        This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      versioninfo A pointer to location to store version info
*                             Must be omitted if the function does not have parameters.
*
* @return         void
*
*
* @pre            The CAN_43_LLCE_VERSION_INFO_API define must be configured on.
* @post           The version information is return if the parameter versionInfo is not a null pointer.
*
* @implements     Can_GetVersionInfo_Activity
*/
void Can_43_LLCE_GetVersionInfo(Std_VersionInfoType * versioninfo)
{
    if (NULL_PTR == versioninfo)
    {
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /*
        (CAN177) If development error detection for the Can module is enabled: The function Can_43_LLCE_GetVersionInfo shall
                    raise the error CAN_43_LLCE_E_PARAM_POINTER if the parameter versionInfo is a null pointer.
        */
        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_GET_VERSION_INFO, (uint8)CAN_43_LLCE_E_PARAM_POINTER);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */

    }
    else
    {
        /*
        (CAN105) The function Can_43_LLCE_GetVersionInfo shall return the version information of this module. The version information
                     includes: Module Id, Vendor Id, Vendor specific version numbers.
        */
        versioninfo->vendorID         = (uint16)CAN_43_LLCE_VENDOR_ID;
        versioninfo->moduleID         = (uint16)CAN_43_LLCE_MODULE_ID;
        versioninfo->sw_major_version = (uint8)CAN_43_LLCE_SW_MAJOR_VERSION;
        versioninfo->sw_minor_version = (uint8)CAN_43_LLCE_SW_MINOR_VERSION;
        versioninfo->sw_patch_version = (uint8)CAN_43_LLCE_SW_PATCH_VERSION;
    }
}
#endif /* (CAN_43_LLCE_VERSION_INFO_API == STD_ON) */

/*================================================================================================*/
/**
* @brief          Initialize the CAN driver. SID is 0x00.
* @details        Initialize all the controllers.
*                 The CAN module shall be initialized by Can_43_LLCE_Init(<&Can_Configuration>) service call during the start-up.
*                 This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      pxConfig Pointer to driver configuration.
*
* @return         void
*
*
* @pre            Can_43_LLCE_Init shall be called at most once during runtime.
* @post           Can_43_LLCE_Init shall initialize all the controllers and set the driver in READY state.
*
* @implements     Can_Init_Activity
*/
void Can_43_LLCE_Init(const Can_43_LLCE_ConfigType * pxConfig)
{

#if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
    boolean bCoreValid = FALSE;
#endif 

    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    if (CAN_43_LLCE_READY == Can_43_LLCE_eDriverStatus[u32CoreId])
    {    
        /*
        (CAN027) Detected development errors shall be reported to the Det_ReportError service of the Development Error Tracer (DET)
                 if the pre-processor switch CanDevErrorDetect is set.
        (CAN083) If the CanDevErrorDetect switch is enabled API parameter checking is enabled.
        (CAN028)Development Errors call the Development Error Tracer when DET is switched on and the Can module detects an error.

        */
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /*
        (CAN247) The Can module environment shall call Can_43_LLCE_Init at most once during runtime.
        (CAN091) After return of the DET the Can module function that raised the development error shall return immediately.
        (CAN174) If development error detection for the Can module is enabled: The function Can_43_LLCE_Init shall raise the
                   error CAN_43_LLCE_E_TRANSITION if the driver is not in 'uninitialized' state.
        (CAN248) The function Can_43_LLCE_Init shall report the error CAN_43_LLCE_E_UNINIT, if Can_43_LLCE_Init was called prior to any Can module function.
        */

        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_INIT, (uint8)CAN_43_LLCE_E_TRANSITION);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
    }
    else
    {
#if (CAN_43_LLCE_PRECOMPILE_SUPPORT == STD_ON)
        if (NULL_PTR != pxConfig)
#else
        if (NULL_PTR == pxConfig)
#endif /* CAN_43_LLCE_PRECOMPILE_SUPPORT */
        {
            #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_INIT, (uint8)CAN_43_LLCE_E_INIT_FAILED);
            #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        }
        else
        {

#if (CAN_43_LLCE_PRECOMPILE_SUPPORT == STD_ON)
    #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            /* Sanity check for Ecuc definitions */
            if(u32CoreId < CAN_43_LLCE_MAX_PARTITIONS)
            {
                /* Update config pointer with default configuration if precompile support on. */
                Can_43_LLCE_pCurrentConfig[u32CoreId] = Can_43_LLCE_Config[u32CoreId];
                bCoreValid = TRUE;
            }
    #else
            /* Update config pointer with default configuration if precompile support on. */
            Can_43_LLCE_pCurrentConfig[u32CoreId] = &Can_43_LLCE_Config;
    #endif /*  (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
            /* Suppress "unused argument" warning */
            (void)pxConfig;
#else
    #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            if((u32CoreId < CAN_43_LLCE_MAX_PARTITIONS) && (pxConfig->u32CoreId == u32CoreId))
            {
    #endif /*  (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
              /* Copy pointer to current Can Driver configuration. */
              Can_43_LLCE_pCurrentConfig[u32CoreId] = pxConfig;
    #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
              bCoreValid = TRUE;
            }
    #endif /*  (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */

#endif /* CAN_43_LLCE_PRECOMPILE_SUPPORT */
    #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            if(TRUE == bCoreValid)
            {
    #endif /*  (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
                /*
                   (CAN239) The function Can_43_LLCE_Init shall initialize all on-chip hardware resources that are used by the CAN controller.
                */
               Can_43_LLCE_InitializeControllers(&u32CoreId);

    #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            }
            else
            {
            #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_INIT, (uint8)CAN_43_LLCE_E_PARAM_CONFIG);
            #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
            }
    #endif /*  (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
        }
    }
}


/*================================================================================================*/
/**
* @brief          De-initialize the CAN driver. SID is 0x10.
* @details        De-initialize all the controllers.
*                 The CAN module shall be de-initialized by Can_DeInit() service call during the start-up.
*                 This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      None
*
* @return         void
*
*
* @pre            Before controller de-initialization, the driver must be initialized and the controllers must be not in Start state.
* @post           Can_DeInit shall de-initialize all the controllers and set the driver in UNINIT state.
*
* @implements     Can_DeInit_Activity
*/
void Can_43_LLCE_DeInit(void)
{
    /* Variable for indexing the controllers. */
    uint8 can_controller = 0U;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    /* Returns the result of CAN APIs */
    Std_ReturnType eReturnGetCtrlModeValue;
    Can_ControllerStateType eCtrlState = CAN_CS_UNINIT;
    
    /* The flag of checking of Can Controller status */
    boolean bIsCanCtrlBusy = FALSE;
    /* Return status */
    Std_ReturnType  eReturnValue;
       
    if (CAN_43_LLCE_READY != Can_43_LLCE_eDriverStatus[u32CoreId])
    {
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /* 
            (SWS_Can_91011) If development error detection for the Can module is enabled: The function Can_DeInit shall raise the error CAN_E_TRANSITION 
            if the driver is not in state CAN_READY.
        */
        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_DEINIT, (uint8)CAN_43_LLCE_E_TRANSITION);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */           
    }
    else
    {
        /* Loop through all Can controllers configured based CanControllerId parameter. */
        for (can_controller = 0U; can_controller < CAN_43_LLCE_MAXCTRL_CONFIGURED; can_controller++)
        {
        #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            if(Can_43_LLCE_pCurrentConfig[u32CoreId]->aControllerDescriptors[can_controller].u32CoreId == u32CoreId)
            {
        #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
                /* Skipping controllers that are not configured. */
                if (CAN_43_LLCE_NULL_OFFSET != (Can_43_LLCE_pCurrentConfig[u32CoreId]->aControllerDescriptors[can_controller].u8HwCtrl))
                {      
                    eReturnGetCtrlModeValue = Can_43_LLCE_IPW_GetControllerMode(can_controller, &eCtrlState);

                    if (((uint8)E_OK == eReturnGetCtrlModeValue) && ( CAN_CS_STARTED == eCtrlState ))
                    {
                        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                        /* 
                            (SWS_Can_91012) If development error detection for the Can module is enabled: The function Can_DeInit shall raise the error CAN_E_TRANSITION 
                            if any of the CAN controllers is in state STARTED.
                        */
                        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_DEINIT, (uint8)CAN_43_LLCE_E_TRANSITION);
                        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */           
                        
                        /* Controller is busy */
                        bIsCanCtrlBusy =  TRUE;

                        /* Skipping the loop if any of Can Controller is in state STARTED */
                        break;
                    }
                }
        #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            }
        #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
        }
        /* No controller is busy */
        if (FALSE == bIsCanCtrlBusy)
        {
            /* Update state of Can driver */
            /* [SWS_Can_ 91009] The function Can_DeInit shall change the module state to
                CAN_UNINIT before de-initializing all controllers inside the HW unit */
            Can_43_LLCE_eDriverStatus[u32CoreId] = CAN_43_LLCE_UNINIT;
            eReturnValue = (Std_ReturnType)E_OK;
            /* Loop through all Can controllers configured based CanControllerId parameter. */
            for ( can_controller = 0U; can_controller < CAN_43_LLCE_MAXCTRL_CONFIGURED; can_controller++)
            {
            #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
                if(Can_43_LLCE_pCurrentConfig[u32CoreId]->aControllerDescriptors[can_controller].u32CoreId == u32CoreId)
                {
            #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
                    /* Skipping controllers that are not configured. */
                    if (((Std_ReturnType)E_OK == eReturnValue) && ( CAN_43_LLCE_NULL_OFFSET != (Can_43_LLCE_pCurrentConfig[u32CoreId]->aControllerDescriptors[can_controller].u8HwCtrl)))
                    {
                            eReturnValue = Can_43_LLCE_IPW_DeInitController(can_controller);
                    }
            #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
                }
            #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
            }
            
            if ((Std_ReturnType)E_OK == eReturnValue)
            {   
                /*Ignore the fw status since the DeInit must be always performed*/
                (void)Can_43_LLCE_IPW_DeInitPlatform();
               
                Can_43_LLCE_pCurrentConfig[u32CoreId] = NULL_PTR;
            }
        }
    }
}

/*================================================================================================*/
/**
* @brief          Shut down LLCE
* @details        Send the shutdown command to LLCE.
*                 Can only be called if both HIFs are deinitialized. LLCE becomes unusable until reset.
*
* @param[in]      None
*
* @return         void
*
*
* @pre            Both LLCE HIFs must be uninitialized 
* @post           LLCE is disabled
*
* @implements     Can_ShutDown_Activity
*/
Std_ReturnType Can_43_LLCE_Shutdown(void)
{
    Std_ReturnType eReturnValue = E_NOT_OK;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    /* It is only possible to check state of current driver */
    /* LLCE will reject the command if the other HIF is active */
    if(CAN_43_LLCE_UNINIT == Can_43_LLCE_eDriverStatus[u32CoreId])
    {
        eReturnValue = Can_43_LLCE_IPW_Shutdown();
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief          Put the controller into a required state. SID is 0x03.
* @details        Switch the controller from one state to another.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller - Can controller for which the status shall be changed - based on configuration order list (CanControllerId).
* @param[in]      Transition - Possible transitions (CAN_CS_STOPPED , CAN_CS_STARTED , CAN_CS_SLEEP , CAN_T_WAKEUP)
* @return         Std_ReturnType  Result of the transition.
* @retval         E_OK   Transition initiated.
* @retval         E_NOT_OK  Development or production error.
*
*
* @pre            Before changing the controller state the driver must be initialized.
* @post           After the transition to the new state the interrupts required for that state must be enabled.
*
* @implements     Can_SetControllerMode_Activity
*/
Std_ReturnType Can_43_LLCE_SetControllerMode(uint8 Controller, Can_ControllerStateType Transition)
{
    /* Returns the result of transition mode. */
    Std_ReturnType  eReturnValue = E_NOT_OK;
    uint8           u8HthIndex = 0U;
    uint8           u8CtrlId = 0U;

    if(TRUE == Can_ValidateController(Controller, (uint8)CAN_43_LLCE_SID_SET_CONTROLLER_MODE))
    {
        if (CAN_CS_STARTED == Transition)
        {
            /* Reset the hw obj count for HTH of  Controller */
            for (u8HthIndex = 0U; u8HthIndex < (uint8)CAN_43_LLCE_MAXHTH_CONFIGURED; u8HthIndex++ )
            {
                u8CtrlId = Can_43_LLCE_GetCurrentConfig()->aHohList[CAN_43_LLCE_FIRST_HTH_CONFIGURED + u8HthIndex].u8ControllerId;
                
                if (Controller == u8CtrlId)
                {
                    /* Copy the number of MB of each HTH. The HTHs are always grouped after the HRHs. */
                    Can_au16TransmitHwObjectCnt[u8HthIndex] = Can_43_LLCE_GetCurrentConfig()->aHohList[CAN_43_LLCE_FIRST_HTH_CONFIGURED + u8HthIndex].u16MbCount;
                }
            }
        }

        /* Call the IPW function for transition execution. */
        eReturnValue = (Std_ReturnType)Can_43_LLCE_IPW_SetControllerMode(Controller, Transition);
    }

    return (eReturnValue);
}

/*================================================================================================*/
/**
* @brief          Reports about the current status of the requested CAN controller. SID is 0x12
* @details        This routine is called by:
*                - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller: CAN controller for which the status shall be requested.
*
* @param[out]     ControllerModePtr: Pointer to a memory location, where the current mode of the CAN controller will be stored.
*
* @retval         E_OK : Controller mode request has been accepted.
* @retval         E_NOT_OK : Controller mode request has not been accepted.
*
* @pre            Controller is initialized
* @post           The host has got the current controller state.
*
* @implements     Can_GetControllerMode_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerMode(uint8 Controller, Can_ControllerStateType * ControllerModePtr)
{
    /* Return the result of GetControllerMode */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;

    if(TRUE == Can_ValidateController(Controller, (uint8)CAN_43_LLCE_SID_GETCONTROLLERMODE))
    {
        if (NULL_PTR == ControllerModePtr)
        {
            #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /* 
            [SWS_Can_91018] If parameter ControllerModePtr of Can_GetControllerMode() has an null pointer, 
            the CanDrv shall report development error code CAN_E_PARAM_POINTER to the Det_ReportError service of the DET.
            */
            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_GETCONTROLLERMODE, (uint8)CAN_43_LLCE_E_PARAM_POINTER);
            #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        }
        else
        {
            eReturnValue = Can_43_LLCE_IPW_GetControllerMode(Controller, ControllerModePtr);
        }
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief          Disable INTs. SID is 0x04.
* @details        Switch OFF the controller's interrupts.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller Can controller for which interrupts shall be disabled - based on configuration order list (CanControllerId).
*
* @return         void
*
*
* @pre            Driver must be initalzied before changing the interrupts state (en or dis).
* @post           Controller must not respond to any interrupt assertion.
*
* @implements     Can_DisableControllerInterrupts_Activity
*/
void Can_43_LLCE_DisableControllerInterrupts(uint8 Controller)
{
    if(TRUE == Can_ValidateController(Controller, (uint8)CAN_43_LLCE_SID_DISABLE_CONTROLLER_INTERRUPTS))
    {
        /* Call the IPW function for disabling interrupts. */
        Can_43_LLCE_IPW_DisableControllerInterrupts( Controller);
    }
}


/*================================================================================================*/
/**
* @brief          Enable INTs. SID is 0x05.
* @details        Switch ON the controller's interrupts.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Controller Can controller for which interrupts shall be disabled - based on configuration order list (CanControllerId).
*
* @return         void
*
*
* @pre            Driver must be initalzied before changing the interrupts state (en or dis).
* @post           Controller must respond to interrupt assertion.
*
* @implements     Can_EnableControllerInterrupts_Activity
*/
void Can_43_LLCE_EnableControllerInterrupts( uint8 Controller)
{
    if(TRUE == Can_ValidateController(Controller, (uint8)CAN_43_LLCE_SID_ENABLE_CONTROLLER_INTERRUPTS))
    {
        /* Call the IPW function for enabling interrupts. */
        Can_43_LLCE_IPW_EnableControllerInterrupts( Controller);
    }
}


/*================================================================================================*/
/**
* @brief          Transmit information on CAN bus. SID is 0x06.
* @details        Can_43_LLCE_Write checks if hardware transmit object that is identified by the HTH is free.
*                    Can_43_LLCE_Write checks if another Can_43_LLCE_Write is ongoing for the same HTH.
*                     a) hardware transmit object is free:
*                         The mutex for that HTH is set to 'signaled' the ID, DLC and SDU are put in a format appropriate for
*                           the hardware (if necessary) and copied in the appropriate hardware registers or buffers.
*                        All necessary control operations to initiate the transmit are done.
*                         The mutex for that HTH is released. The function returns with E_OK.
*                    b) hardware transmit object is busy with another transmit request.
*                         The function returns with CAN_BUSY.
*                     c) A preemptive call of Can_43_LLCE_Write has been issued, that could not be handled reentrant (i.e. a call with the same HTH).
*                        The function returns with CAN_BUSY the function is non blocking
*                     d) The hardware transmit object is busy with another transmit request for an L-PDU that has lower priority than that for the current request
*                        The transmission of the previous L-PDU is cancelled (asynchronously).
*                        The function returns with CAN_BUSY.
*                   This routine is called by:
*                   - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      Hth Information which HW-transmit handle shall be used for transmit.
*                 Implicitly this is also the information about the controller to use because the Hth numbers are unique inside one hardware unit.
* @param[in]      PduInfo Pointer to SDU user memory, DLC and Identifier.
* @return         Std_ReturnType   Result of the write operation.
* @retval         E_OK   Write command has been accepted.
* @retval         E_NOT_OK  Development error occurred.
* @retval         CAN_BUSY   No of TX hardware buffer available or preemtive call of Can_43_LLCE_Write() that can't be implemented reentrant.
*
*
* @pre            Driver must be initialized and MB must be configured for Tx.
* @post           The data can be transmitted or rejected because of another data with a higher priority.
*
* @implements     Can_Write_Activity
*/
Std_ReturnType Can_43_LLCE_Write(Can_HwHandleType Hth, const Can_PduType * PduInfo)
{
    /* Variable for return status */
    Std_ReturnType  eReturnValue = E_NOT_OK;

    uint8 u8CtrlId = 0U;
    /* Used to store the FD feature enable or disable. */
    uint8 u8FdEnable;  
    uint8 u8BaudrateIndex = 0U;
    const Can_43_LLCE_ControllerDescriptorType * pxCanControllerDescriptor;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();
    
    /* If Can_43_LLCE_pCurrentConfig[u32CoreId] is NULL_PTR then the driver was not initialised yet. */
    if (CAN_43_LLCE_UNINIT == Can_43_LLCE_eDriverStatus[u32CoreId] )
    {
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        /*
           (CAN216) If development error detection for the Can module is enabled: The function Can_43_LLCE_Write shall raise the error CAN_43_LLCE_E_UNINIT if
                   the driver not yet initialized.
        */

        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_WRITE, (uint8)CAN_43_LLCE_E_UNINIT);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
    }
    else
    {
        /* Hth must be below CanMaxObjectId and should be a Tx MB type. */
    #if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0)
        if ( (Hth <  CAN_43_LLCE_FIRST_HTH_CONFIGURED) ||
             (Hth >= CAN_43_LLCE_MAXHOH_CONFIGURED)
           )
    #else
        if (Hth >= CAN_43_LLCE_MAXHOH_CONFIGURED)
    #endif
        {
            #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /*
               (CAN217) If development error detection for the Can module is enabled: The function Can_43_LLCE_Write shall raise the error CAN_43_LLCE_E_PARAM_HANDLE
                       if the parameter Hth is not a configured Hardware Transmit Handle.
            */

            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_WRITE, (uint8)CAN_43_LLCE_E_PARAM_HANDLE);
            #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        }
        else
        {

        #if (CAN_43_LLCE_TRIGGER_TRANSMIT_EN == STD_ON)
            /* Report Error if Protocol Data Unit information pointer is NULL. */
            if ( (NULL_PTR == PduInfo) )
        #else
            if ( (NULL_PTR == PduInfo) || (NULL_PTR == PduInfo->sdu) )
        #endif
            {
                #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                /*
                (CAN219) If development error detection for the Can module is enabled: The function Can_43_LLCE_Write shall raise the
                        error CAN_43_LLCE_E_PARAM_POINTER if the parameter PduInfo or the SDU pointer inside PduInfo is a null-pointer.
                */

                (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_WRITE, CAN_43_LLCE_E_PARAM_POINTER);
                #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
            }
            else
            {
                u8CtrlId = Can_43_LLCE_GetCurrentConfig()->aHohList[Hth].u8ControllerId;

                pxCanControllerDescriptor = &(Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[u8CtrlId]);

                #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
                if(pxCanControllerDescriptor->u32CoreId != u32CoreId)
                {
                    #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                    (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_WRITE, (uint8)CAN_43_LLCE_E_PARAM_CONFIG);
                    #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
                }
                else
                {
                #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */


                /* Get the index of the current baud rate */
                u8BaudrateIndex = Can_43_LLCE_ControllerBaudRateIndexes[u8CtrlId].u8CurrentBaudRateIndex;

                /* Get the status of the FD feature */
                u8FdEnable = pxCanControllerDescriptor->pControllerBaudrateConfigsPtr[u8BaudrateIndex].baudrateConfig.ControllerFD.u8FdEnable;

                    /* Report error if length > 8 bytes. */
                    if ( \
                            ( (u8FdEnable == (uint8)FALSE) && ((PduInfo->length) > (uint8)8U) ) || \
                            ( (u8FdEnable == (uint8)TRUE) && ((PduInfo->length) > (uint8)64U) ) || \
                            (( (((uint32)PduInfo->id) & (uint32)CAN_LPDU_FD_U32) != CAN_LPDU_FD_U32) && ( (PduInfo->length) > (uint8)8U )) \
                    )
                    {
                        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                        
                            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_WRITE, CAN_43_LLCE_E_PARAM_DATA_LENGTH);
                        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
                    }
                    else
                    {
                        eReturnValue = Can_43_LLCE_SendWriteCmd(Hth, PduInfo);
                    }
                #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
                }
                #endif
            }
        }
    }
        
    return eReturnValue;
}

static Std_ReturnType Can_43_LLCE_SendWriteCmd(Can_HwHandleType Hth, const Can_PduType * PduInfo)
{
    /* Variable for return status */
    Std_ReturnType  eReturnValue = E_NOT_OK;

    #if (CAN_43_LLCE_TRIGGER_TRANSMIT_EN == STD_ON)
    /* Temporary buffer for Trigger Transmit */
    uint8 aTempSdu[LLCE_CAN_CONFIG_PAYLOAD_MAX_SIZE];
    #endif

    PduInfoType PduInfoTriggerTransmit;

    /* Enter into EA in order to protect access to Can_au16TransmitHwObjectCnt array */
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_02();

    /* Check if the maximum Tx objects for the current HTH has been exhausted */
    if (0U == Can_au16TransmitHwObjectCnt[Hth - CAN_43_LLCE_FIRST_HTH_CONFIGURED] )
    {
        /* No Tx object available */
        eReturnValue = CAN_BUSY;
    }
    else
    {
        /* Reserve a new MB in advance, assuming that this flows is E_OK */
        Can_au16TransmitHwObjectCnt[Hth - CAN_43_LLCE_FIRST_HTH_CONFIGURED]--;

        /* Create the PduInfoTriggerTransmit information */
        PduInfoTriggerTransmit.SduLength = PduInfo->length;
        PduInfoTriggerTransmit.SduDataPtr = (uint8 *)PduInfo->sdu;
        
        #if (CAN_43_LLCE_TRIGGER_TRANSMIT_EN == STD_ON)
        /* Check if this is a trigger transmit frame */
        if (NULL_PTR == PduInfoTriggerTransmit.SduDataPtr )
        {
            if(TRUE == Can_43_LLCE_GetCurrentConfig()->aHohList[Hth].CanTriggerTransmitEnable)
            {
                /* this HTH enables the trigger transmit feature */
                /* [SWS_CAN_00503] Can_43_LLCE_Write() shall accept a null pointer as SDU
                        (Can_PduType.Can_SduPtrType = NULL_PTR) if the trigger transmit API is enabled
                        for this hardware object (CanTriggerTransmitEnable = TRUE). */
                /* [SWS_CAN_00504] If the trigger transmit API is enabled for the hardware object, Can_43_LLCE_Write() shall interpret a null pointer as SDU
                        (Can_PduType.Can_SduPtrType = NULL_PTR) as request for using the trigger transmit interface.
                        If so and the hardware object is free, Can_43_LLCE_Write() shall call CanIf_TriggerTransmit() to acquire the PDU’s data. */
                PduInfoTriggerTransmit.SduLength = LLCE_CAN_CONFIG_PAYLOAD_MAX_SIZE;
                PduInfoTriggerTransmit.SduDataPtr = aTempSdu;

                    if ((Std_ReturnType)E_OK != CanIf_TriggerTransmit(PduInfo->swPduHandle, &PduInfoTriggerTransmit))
                    {
                        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)

                        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_WRITE, CAN_43_LLCE_E_PARAM_POINTER);
                        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
                        
                        eReturnValue = E_NOT_OK;
                    }
                    else
                    {
                        if(PduInfoTriggerTransmit.SduLength > LLCE_CAN_CONFIG_PAYLOAD_MAX_SIZE) 
                        {
                            eReturnValue = E_NOT_OK;
                        }
                        else
                        {
                            eReturnValue = E_OK;
                        }
                    }
            }
            else /* this MB do not enable the trigger transmit feature */
            {
                #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)

                (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_WRITE, CAN_43_LLCE_E_PARAM_POINTER);
                #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        
                eReturnValue = E_NOT_OK;
            }
        }
        if ((Std_ReturnType)E_OK == eReturnValue)
        {
        #endif
            /* Call the IPW function for transmitting data. */
            eReturnValue = Can_43_LLCE_IPW_Write( Hth, PduInfo, PduInfoTriggerTransmit);
        #if (CAN_43_LLCE_TRIGGER_TRANSMIT_EN == STD_ON)    
        }
        #endif

        if ((Std_ReturnType)E_OK != eReturnValue)
        {
            /* On the error case, release the buffer reserved in advance. */
            Can_au16TransmitHwObjectCnt[Hth - CAN_43_LLCE_FIRST_HTH_CONFIGURED]++;
        }

    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_02();

    return eReturnValue;
}


/*================================================================================================*/
/*================================================================================================*/
#if (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE == STD_OFF)
    /**
    * @brief          Function called at fixed cyclic time. SID is 0x01.
    * @details        Service for performs the polling of TX confirmation and TX cancellation confirmation when CAN_TX_PROCESSING is set to POLLING.
    *                 This routine is called by:
    *                 - CanIf or an upper layer according to Autosar requirements.
    *
    *
    * @pre            Driver must be initialized.
    * @post           Send the data from that MB that is configured for Tx.
    *
    * @implements     Can_MainFunction_Write_Activity
    */
    void Can_43_LLCE_MainFunction_Write(void)
    {
        #if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)
        uint32 u32CoreId = Can_43_LLCE_GetCoreID();

        /* Test whether the driver is already initialised. */
        /* As per CPR_RTD_00662, no action should be taken in case of error*/
        if (CAN_43_LLCE_UNINIT != Can_43_LLCE_eDriverStatus[u32CoreId] )
        {
            /* Poll all controllers for Tx MB statuses. */
            Can_43_LLCE_IPW_MainFunctionWrite();
        }

        #endif /*(CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)   */
    }

#else

    /**
    * @brief          Function called at fixed cyclic time. SID is 0x01.
    * @details        Service for performs the polling of TX confirmation and TX cancellation confirmation when CAN_TX_PROCESSING is set to POLLING.
    *                 This routine is called by:
    *                 - CanIf or an upper layer according to Autosar requirements.
    *
    *
    * @pre            Driver must be initialized.
    * @post           Send the data from that MB that is configured for Tx.
    *
    * @implements     Can_MainFunction_Multiple_Write_Activity
    */
        #if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)
        void Can_43_LLCE_MainFunction_Multiple_Write(uint8 writepoll)
        {
            uint32 u32CoreId = Can_43_LLCE_GetCoreID();

            /* Test whether the driver is already initialised. */
            if (CAN_43_LLCE_UNINIT != Can_43_LLCE_eDriverStatus[u32CoreId] )
            {
                /* Poll all controllers for Tx MB statuses. */
                Can_43_LLCE_IPW_MainFunctionMultipleWritePoll(writepoll);
            }
        }
        #endif /*#if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)*/

#endif /*ifdef (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE == STD_OFF)*/


/*================================================================================================*/

#if (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ == STD_OFF)
    /**
    * @brief          Function called at fixed cyclic time.  SID is 0x08.
    * @details        Service for performs the polling of RX indications when CAN_RX_PROCESSING is set to POLLING.
    *                 This routine is called by:
    *                 - CanIf or an upper layer according to Autosar requirements.
    *
    *
    * @pre            Driver must be initialized.
    * @post           Receive the data from that MB that is configured for Rx.
    *
    * @implements     Can_MainFunction_Read_Activity
    */
    void Can_43_LLCE_MainFunction_Read(void)
    {
        #if (CAN_43_LLCE_RXPOLL_SUPPORTED  == STD_ON)
            uint32 u32CoreId = Can_43_LLCE_GetCoreID();
            /* Test whether the driver is already initialised. */
            if (CAN_43_LLCE_UNINIT != Can_43_LLCE_eDriverStatus[u32CoreId] )
            {
                /* Poll all controllers for Rx MB statuses. */
                Can_43_LLCE_IPW_MainFunctionRead();
            }
        #endif /* (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON) */
    }

#else

    /**
    * @brief          Function called at fixed cyclic time.  SID is 0x08.
    * @details        Service for performs the polling of RX indications when CAN_RX_PROCESSING is set to POLLING.
    *                 This routine is called by:
    *                 - CanIf or an upper layer according to Autosar requirements.
    *
    *
    * @pre            Driver must be initialized.
    * @post           Receive the data from that MB that is configured for Rx.
    *
    * @implements     Can_MainFunction_Multiple_Read_Activity
    */
        #if (CAN_43_LLCE_RXPOLL_SUPPORTED  == STD_ON)
        void Can_43_LLCE_MainFunction_Multiple_Read(uint8 readpoll)
        {
            uint32 u32CoreId = Can_43_LLCE_GetCoreID();
            /* Test whether the driver is already initialised. */
            if ( CAN_43_LLCE_UNINIT != Can_43_LLCE_eDriverStatus[u32CoreId] )
            {
                /* Poll all controllers for Rx MB statuses. */
                Can_43_LLCE_IPW_MainFunctionMultipleReadPoll(readpoll);
            }
        }
        #endif /* #if (CAN_43_LLCE_RXPOLL_SUPPORTED  == STD_ON) */
#endif /* ifdef (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ == STD_OFF)*/



/*================================================================================================*/

/**
* @brief          Function called at fixed cyclic time. SID is 0x09.
* @details        Service for performs the polling of BusOff events that are configured statically as 'to be polled'.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
*
* @pre            Driver must be initialized.
* @post           Handle the Busoff event.
*
* @implements     Can_MainFunction_BusOff_Activity
*/
void Can_43_LLCE_MainFunction_BusOff(void)
{
#if (CAN_43_LLCE_BUSOFFPOLL_SUPPORTED == STD_ON)
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    /* Test whether the driver is already initialised. */
    if ( CAN_43_LLCE_UNINIT != Can_43_LLCE_eDriverStatus[u32CoreId] )
    {
        /*
            (CAN109) The function Can_43_LLCE_MainFunction_BusOff shall perform the polling of bus-off events that are configured statically as 'to be polled'.
                     The bus-off events are triggered by LLCE firmware only to the controllers configured statically as 'to be polled', since it has this information.
        */
        Can_43_LLCE_IPW_ProcessBusOffPoll();
        
    }

#endif /* (CAN_43_LLCE_BUSOFFPOLL_SUPPORTED == STD_ON) */
}


#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
/**
* @brief          Function called at fixed cyclic time.
* @details        This Service performs the polling of Error notifications that are configured as 'to be polled'.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
*
* @pre            Driver must be initialized.
* @post           Handle the Error notifications in polling.
*
* @implements     Can_MainFunction_ErrorNotification_Activity
*/
void Can_43_LLCE_MainFunction_ErrorNotification(void)
{
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    /* Test whether the driver is already initialised. */
    if ( CAN_43_LLCE_UNINIT != Can_43_LLCE_eDriverStatus[u32CoreId] )
    {
        Can_43_LLCE_IPW_ProcessErrorNotification();
    }
}

#endif /* (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON) */

/*================================================================================================*/
/**
* @brief          Function called at fixed cyclic time. SIDis 0x0C.
* @details        Service for performs performs the polling of CAN status register flags to detect transition of CAN Controller state
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
*
* @pre            Driver must be initialized.
* @post           Handle the transition of Can Controller state.
*
* @implements     Can_MainFunction_Mode_Activity
*/
void Can_43_LLCE_MainFunction_Mode(void)
{
    /* Variable for indexing the controllers. */
    uint8  u8CtrlIndex = 0U;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    /* Test whether the driver is already initialised. */
    if (CAN_43_LLCE_UNINIT != Can_43_LLCE_eDriverStatus[u32CoreId] )
    {
        /* Loop through all configured controller descriptors. */
        for (u8CtrlIndex = (uint8)0U; u8CtrlIndex < CAN_43_LLCE_MAXCTRL_CONFIGURED; u8CtrlIndex++)
        {
            #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            if(Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[u8CtrlIndex].u32CoreId == u32CoreId)
            {
            #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */

                /* Skipping controllers that are not configured. */
                if (CAN_43_LLCE_NULL_OFFSET != (Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[u8CtrlIndex].u8HwCtrl))
                {
                    /* Check for main function mode. */
                    Can_43_LLCE_IPW_MainFunctionMode(u8CtrlIndex);
                }
            #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
            }
            #endif /* (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON) */
        }
    }
}

/*================================================================================================*/
/**
* @brief          Process check of WakeUp condition. SID is 0x0B.
* @details        This service shall evaluate the WakeupSource parameter to get the information,
*                 which dedicate wakeup source needs to be checked, either a CAN transceiver or controller device.
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      controller Can controller ID - based on configuration order list (CanControllerId).
* @return         Std_ReturnType Result of the wakeup verification.
* @retval         E_OK  Wakeup was detected for the given controller.
* @retval         E_NOT_OK  No wakeup was detected for the given controller.
*
*
* @pre            Driver must be initialized.
* @post           Return the Wakeup event occurrence.
*
* @implements     Can_CheckWakeup_Activity
*/
Std_ReturnType Can_43_LLCE_CheckWakeup(uint8 controller)
{
    /* E_NOT_OK is defined as (uint8)0x01 */
    Std_ReturnType eReturnValue = E_NOT_OK;

    if(TRUE == Can_ValidateController(controller,  (uint8)CAN_43_LLCE_SID_CBK_CHECK_WAKEUP))
    {
        eReturnValue = E_NOT_OK;
    }

    return (eReturnValue);
}


#ifdef CAN_43_LLCE_SET_BAUDRATE_API
#if (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON)
/*================================================================================================*/
/**
* @brief         This function set baudrate
* @details       This routine is called by an upper layer.
*
* @param[in]     Controller controller ID
* @param[in]     BaudRateConfigID baudrateID selection
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Switch baudrate operation was ok.
* @retval        E_NOT_OK  Switch baudrate operation was not ok.
*
* @pre           Driver must be initialized.
* @implements    Can_SetBaudrate_Activity
*/
Std_ReturnType Can_43_LLCE_SetBaudrate(uint8 Controller, const uint16 BaudRateConfigID)
{
    /* Returns the result of CAN set baudrate */
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;
    Can_ControllerStateType eCtrlState = CAN_CS_UNINIT;

    if(TRUE == Can_ValidateController(Controller, (uint8)CAN_43_LLCE_SID_SET_BAUDRATE))
    {
        eReturnValue = Can_43_LLCE_IPW_GetControllerMode(Controller, &eCtrlState);

        if ((uint8)E_OK == eReturnValue)
        {
            if (CAN_CS_STOPPED != eCtrlState)
            {
                /*
                        (SWS_Can_00256) If the call of Can_SetBaudrate() would cause a re-initialization
                                of the CAN Controller and the CAN Controller is not in state STOPPED, it shall return E_NOT_OK.
                */
                eReturnValue = (uint8)E_NOT_OK;
            }
            else
            {
                eReturnValue = Can_43_LLCE_SendSetBaudrateCmd(Controller, BaudRateConfigID);
            }
        }
    }

    return eReturnValue;
}


static Std_ReturnType Can_43_LLCE_SendSetBaudrateCmd(uint8 Controller, const uint16 BaudRateConfigID)
{
    /* Returns the result of CAN set baudrate */
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;
    uint8 u8BaudrateIndex = 0U;

    /* Check the Baudrate */
    for (u8BaudrateIndex = 0U; u8BaudrateIndex < Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8MaxBaudRateCount; u8BaudrateIndex++)
    {
        /* Check the Baudrate */
        if (BaudRateConfigID == (uint16)(Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].pControllerBaudrateConfigsPtr[u8BaudrateIndex].u16ControllerBaudRateConfigID))
        {
            /* Baudrate is Valid */
            /* SWS_Can_00062 Check if a baudrate change is required */
            if (Can_43_LLCE_ControllerBaudRateIndexes[Controller].u8CurrentBaudRateIndex != u8BaudrateIndex)
            {
                /* Copy the index of Valid Baudrate into the Can_43_LLCE_ControllerBaudRateIndexes as u8CurrentBaudRateIndex */
                Can_43_LLCE_ControllerBaudRateIndexes[Controller].u8CurrentBaudRateIndex = u8BaudrateIndex;
                
                eReturnValue = Can_43_LLCE_IPW_ChangeBaudrate(Controller, u8BaudrateIndex);
            }
            else
            {
                eReturnValue = (uint8)E_OK;
            }
            break;
        }
    }

    if ((uint8)E_OK != eReturnValue )
    {
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_SET_BAUDRATE, (uint8)CAN_43_LLCE_E_PARAM_BAUDRATE);
        #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
    }

    return eReturnValue;
}

#endif
#endif


/*================================================================================================*/
/**
* @brief         This service obtains the error state of the CAN controller.
* @details       This service shall read the error state register of Can Controller and shall return the error status to upper layer.
*
* @param[in]     Controller - Abstracted CanIf ControllerId which is assigned to a CAN controller, which is requested for ErrorState.
* @param[out]    ErrorStatePtr - Pointer to a memory location, where the error state of the CAN controller will be stored.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Driver must be initialized.
*
* @implements     Can_GetControllerErrorState_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerErrorState(uint8 Controller, Can_ErrorStateType * ErrorStatePtr)
{
    /* Returns the result of CAN GetControllerErrorState */
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Controller, (uint8)CAN_43_LLCE_SID_GETCONTROLLERERRORSTATE))
    {
        /* 
            [SWS_Can_91007] If default error detection for the Can module is enabled: if the parameter ErrorStatePtr is a null pointer, 
                    the function Can_GetControllerErrorState shall raise default error CAN_E_PARAM_POINTER and return E_NOT_OK. 
        */
        if ( NULL_PTR == ErrorStatePtr )
        {
            #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_GETCONTROLLERERRORSTATE, (uint8)CAN_43_LLCE_E_PARAM_POINTER);
            #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        }
        else
        {
            eReturnValue = Can_43_LLCE_IPW_GetControllerErrorState(Controller, ErrorStatePtr);
        }
    }

    return (eReturnValue);
}

/*================================================================================================*/
/**
* @brief         This service obtains the number of RX errors of the CAN controller.
* @details       This service shall read the error state register of Can Controller and shall return the number of rx errors to upper layer.
*
* @param[in]     ControllerId - Abstracted CanIf ControllerId which is assigned to a CAN controller, which is requested for rx error counter.
* @param[out]    RxErrorCounterPtr - Pointer to a memory location, where the rx error counter of the CAN controller will be stored.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Driver must be initialized.
* @implements    Can_GetControllerRxErrorCounter_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerRxErrorCounter (uint8 ControllerId, uint8 * RxErrorCounterPtr)
{
    /* Returns the result of CAN GetControllerRxErrorCounter */
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;
 
    if(TRUE == Can_ValidateController(ControllerId, (uint8)CAN_43_LLCE_SID_GET_CTRL_RX_ERROR_COUNTER))
    {
        if (NULL_PTR == RxErrorCounterPtr)
        {
            #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /* 
            *   [SWS_Can_00514]: If development error detection for the Can module is enabled:
            *   if the parameter RxErrorCounterPtr is a null pointer, the function Can_GetControllerRxErrorCounter shall
            *   raise development error CAN_E_PARAM_POINTER and return E_NOT_OK.
            */
            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_GET_CTRL_RX_ERROR_COUNTER, (uint8)CAN_43_LLCE_E_PARAM_POINTER);
            #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        }
        else
        {
            /* 
            *   [SWS_Can_00515]: When the API Can_GetControllerRxErrorCounter is called with
            *   Controller Id as input parameter then Can driver shall read the Rx error counter
            *   register of Can Controller and shall return the Rx error count to upper layer.
            */
            eReturnValue = Can_43_LLCE_IPW_GetControllerRxErrorCounter(ControllerId, RxErrorCounterPtr);
        }
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service obtains the number of Tx errors of the CAN controller.
* @details       This service shall read the error state register of Can Controller and shall return the number of Tx errors to upper layer.
*
* @param[in]     ControllerId - Abstracted CanIf ControllerId which is assigned to a CAN controller, which is requested for rx error counter.
* @param[out]    TxErrorCounterPtr - Pointer to a memory location, where the tx error counter of the CAN controller will be stored.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Driver must be initialized.
* @implements    Can_GetControllerTxErrorCounter_Activity
*/
Std_ReturnType Can_43_LLCE_GetControllerTxErrorCounter (uint8 ControllerId, uint8 * TxErrorCounterPtr)
{
    /* Returns the result of CAN GetControllerRxErrorCounter */
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(ControllerId, (uint8)CAN_43_LLCE_SID_GET_CTRL_TX_ERROR_COUNTER))
    {
        if (NULL_PTR == TxErrorCounterPtr)
        {
            #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
            /* 
            *   [SWS_Can_00519]: If development error detection for the Can module is enabled:
            *   if the parameter TxErrorCounterPtr is a null pointer, the function Can_GetControllerTxErrorCounter shall
            *   raise development error CAN_E_PARAM_POINTER and return E_NOT_OK.
            */
            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_GET_CTRL_TX_ERROR_COUNTER , (uint8)CAN_43_LLCE_E_PARAM_POINTER);
            #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
        }
        else
        {
            /* 
            *   [SWS_Can_00520]: When the API Can_GetControllerTxErrorCounter is called with
            *   Controller Id as input parameter then Can driver shall read the Tx error counter
            *   register of Can Controller and shall return the Tx error count to upper layer.
            */
            eReturnValue = Can_43_LLCE_IPW_GetControllerTxErrorCounter(ControllerId, TxErrorCounterPtr);
        }
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service obtains the Llce Can controller status.
* @details       This service obtains a structure containing values from HW registers of the specified channel.
*
* @param[in]     ControllerId - Abstracted CanIf ControllerId which is assigned to a CAN controller, which is requested for status
* @param[out]    TxErrorCounterPtr - Pointer to a memory location, where the status of the CAN controller will be stored.
*
* @return        Std_ReturnType.  Result of the check.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Llce firmware must be loaded.
*   
*/
Std_ReturnType Can_43_LLCE_GetControllerStatus(uint8 ControllerId, Llce_Can_GetStatusCmdType * StatusPtr)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(ControllerId, CAN_43_LLCE_SID_GETCONTROLLERERRORSTATE))
    {
        eReturnValue = Can_43_LLCE_IPW_GetControllerStatus(ControllerId, StatusPtr);
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service obtains the Llce firmware version.
* @details       This service obtains a string which encapsulates all of the components versions for the Llce firmware.
*
* @param[out]    pVersionString - The string with all the components versions for the Llce firmware. 
* @param[out]    pStringLength - Length of the string.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  Error state request has been accepted.
* @retval        E_NOT_OK  Error state request has not been accepted.
*
* @pre           Llce firmware must be loaded.
* @implements    Can_GetFwVersion_Activity
*/
Std_ReturnType Can_43_LLCE_GetFwVersion(const uint8 ** pVersionString, uint8 * pStringLength)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    eReturnValue = Can_43_LLCE_IPW_GetFwVersion(pVersionString, pStringLength);

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service set a single standard filter.
* @details       This service set a single standard filter.
*
* @param[in]     pCanFilter - parameter of Can_SetFilterType, containing filter type and message buffer related configuration data
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetFilter_Activity
*/
Std_ReturnType Can_43_LLCE_SetFilter(const Can_SetFilterType * pCanFilter)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Can_43_LLCE_GetCurrentConfig()->aHohList[pCanFilter->Hrh].u8ControllerId, (uint8)CAN_43_LLCE_SID_SET_FILTER))
    {
        /* Pass only one filter at a time, for timing concerns, hence only the first value in the filter array is used, the one with index "0U". */
        eReturnValue = Can_43_LLCE_IPW_SetFilter(pCanFilter);
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service set a single standard filter at a given address.
* @details       This service set a single standard filter at a given address.
*
* @param[in]     pCanFilter - parameter of Can_SetFilterType, containing filter type and message buffer related configuration data
* @param[in]     u16FilterAddr - Address in RxLut for filter. Must be free. 
*                An address can be freed either by calling the RemoveFilter function or leaving extra free filters via host configuration.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetFilter_Activity
*/
Std_ReturnType Can_43_LLCE_SetFilterAtAddress(const Can_SetFilterType * pCanFilter, const uint16 u16FilterAddr)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Can_43_LLCE_GetCurrentConfig()->aHohList[pCanFilter->Hrh].u8ControllerId, (uint8)CAN_43_LLCE_SID_SET_FILTER))
    {
        /* Pass only one filter at a time, for timing concerns, hence only the first value in the filter array is used, the one with index "0U". */
        eReturnValue = Can_43_LLCE_IPW_SetFilterAtAddress(pCanFilter, u16FilterAddr);
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service set a single advanced filter at a given address.
* @details       This service set a single advanced filter at a given address.
*
* @param[in]     pAfFilter - parameter of Can_SetAfFilterType, containing filter type and message buffer related configuration data along with routing rules and other advanced features
* @param[in]     u16FilterAddr - address returned by the RemoveFilter function
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetAfFilterAtAddress_Activity
*/
Std_ReturnType Can_43_LLCE_SetAfFilterAtAddress(const Can_SetAfFilterType * pAfFilter, const uint16 u16FilterAddr)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Can_43_LLCE_GetCurrentConfig()->aHohList[pAfFilter->Filter.Hrh].u8ControllerId, (uint8)CAN_43_LLCE_SID_SET_FILTER))
    {
        /* Pass only one filter at a time, for timing concerns, hence only the first value in the filter array is used, the one with index "0U". */
        eReturnValue = Can_43_LLCE_IPW_SetAfFilterAtAddress(pAfFilter, u16FilterAddr);
    }

    return eReturnValue;
}
/*================================================================================================*/
/**
* @brief         This service set a single advanced filter.
* @details       This service set a single advanced filter.
*
* @param[in]     pAfFilter - parameter of Can_SetAfFilterType, containing advanced filter type and message buffer related configuration data
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetAfFilter_Activity
*/
Std_ReturnType Can_43_LLCE_SetAfFilter(const Can_SetAfFilterType * pAfFilter)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Can_43_LLCE_GetCurrentConfig()->aHohList[pAfFilter->Filter.Hrh].u8ControllerId, (uint8)CAN_43_LLCE_SID_SET_FILTER))
    {
        /* Pass only one filter at a time, for timing concerns, hence only the first value in the filter array is used, the one with index "0U". */
        eReturnValue = Can_43_LLCE_IPW_SetAfFilter(pAfFilter);
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service a new destination for advanced features
* @details       This service a new destination for advanced features
**
* @param[in]      destRule - The destination to add to the LLCE destination list
* @param[out]     pu8RuleIdx - The index of the new destination in the LLCE list. Needed for SetAdvancedFilter.
*
* @return        Std_ReturnType. Result of the request.
* @retval        E_OK  Destination created
* @retval        E_NOT_OK  Error
*
* @pre           Llce firmware must be loaded and the controller initialized
*/
Std_ReturnType Can_43_LLCE_CreateAfDestination(const Can_Af_DestRulesType destRule, uint8* pu8RuleIdx)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    if (CAN_43_LLCE_READY != Can_43_LLCE_eDriverStatus[u32CoreId] )
    {
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_CREATE_DESTINATION, (uint8)CAN_43_LLCE_E_UNINIT);
        #endif
    }
    else
    {
        /* Pass the destination rule to be added and the pointer for the index to be returned. */
        eReturnValue = Can_43_LLCE_IPW_CreateAfDestination(destRule, pu8RuleIdx);
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service removes an existing destination for advanced features
* @details       This service removes an existing destination for advanced features
**
* @param[in]     u8RuleIdx - The index of the destination to be removed from the LLCE list.
*
* @return        Std_ReturnType. Result of the request.
* @retval        E_OK  Destination removed
* @retval        E_NOT_OK  Error
*
* @pre           Llce firmware must be loaded and the controller initialized
*/
Std_ReturnType Can_43_LLCE_RemoveAfDestination(uint8 u8RuleIdx)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    if (CAN_43_LLCE_READY != Can_43_LLCE_eDriverStatus[u32CoreId] )
    {
        #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, (uint8)CAN_43_LLCE_SID_REMOVE_DESTINATION, (uint8)CAN_43_LLCE_E_UNINIT);
        #endif
    }
    else
    {
        /* Pass the index of the destination to be removed */
        eReturnValue = Can_43_LLCE_IPW_RemoveAfDestination(u8RuleIdx);
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service removes a single standard filter.
* @details       This service removes a single standard filter.
*
* @param[in]     Hrh - HRH to which the filter is attached.
* @param[in]     u16FilterAddr - address of the removed filter, to be later used by Can_43_LLCE_SetFilterAtAddress.
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully set.
* @retval        E_NOT_OK  filter was not successfully set.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_RemoveFilter_Activity
*/
Std_ReturnType Can_43_LLCE_RemoveFilter(Can_HwHandleType Hrh, uint16 *u16FilterAddr)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Can_43_LLCE_GetCurrentConfig()->aHohList[Hrh].u8ControllerId, (uint8)CAN_43_LLCE_SID_REMOVE_FILTER))
    {
        eReturnValue = Can_43_LLCE_IPW_RemoveFilter(Hrh, u16FilterAddr);    
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service enables or disables a single standard filter.
* @details       This service enables or disables a single standard filter.
*
* @param[in]     Hrh - HRH to which the filter is attached.
* @param[in]     State - Logical value to select if filter is enabled or disabled
*
* @return        Std_ReturnType.  Result of the transition.
* @retval        E_OK  filter was successfully enabled/disabled.
* @retval        E_NOT_OK  filter was not successfully enabled/disabled.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetFilterState_Activity 
*/
Std_ReturnType Can_43_LLCE_SetFilterState(Can_HwHandleType Hrh, Can_43_LLCE_FilterStateType eState)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Can_43_LLCE_GetCurrentConfig()->aHohList[Hrh].u8ControllerId, (uint8)CAN_43_LLCE_SID_SET_FILTER_ENABLE_STATE))
    {
        eReturnValue = Can_43_LLCE_IPW_SetFilterState(Hrh, eState);    
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service sets the state of controller in a multicast routing configuration.
* @details       
*
* @param[in]     ControllerId - controller to be enabled or disabled.
* @param[in]     eChannelStatus - enable or disable channel
*
* @return        Std_ReturnType.  Result of the command.
* @retval        E_OK  channel was successfully enabled/disabled.
* @retval        E_NOT_OK  channel was not successfully enabled/disabled.
*
* @pre           Llce firmware must be loaded and the controller initialized
* @implements    Can_SetChannelRoutingOutputState_Activity
*/
Std_ReturnType Can_43_LLCE_SetChannelRoutingOutputState(uint8 ControllerId, Can_43_LLCE_ChannelStateType eChannelStatus)
{
    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(ControllerId, (uint8)CAN_43_LLCE_SID_SETCHANNEL_ROUTING_OUTPUTSTATE))
    {
        eReturnValue = Can_43_LLCE_IPW_SetChannelRoutingOutputState(ControllerId, eChannelStatus);    
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief         This service forces a deinit of the driver
* @details       When LLCE is not responding and must be reset, this service may be used to allow another init call. 
*
* @implements    Can_ForceDeInit_Activity
*/
void Can_43_LLCE_ForceDeInit(void)
{
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    Can_43_LLCE_eDriverStatus[u32CoreId] = CAN_43_LLCE_UNINIT;
    Can_43_LLCE_pCurrentConfig[u32CoreId] = NULL_PTR;
}


#if (CAN_43_LLCE_API_ENABLE_ABORT_MB == STD_ON)
/**
* @brief          Process a pending transmission abort
* @details        This function requests aborting of the lowest priority pending transmission
*                 of controller ControllerId and returns the hardware transmis handler Hth which
*                 has been freed along with the message tracking information swPduHandle
*                 This routine is called by:
*                 - CanIf or an upper layer according to Autosar requirements.
*
* @param[in]      ControllerId - Logical Id of the hardware controller 
* @param[out]     Hth - HW-transmit handler
* @param[out]     swPduHandle - tracking information of the aborted MB
*
* @return         Std_ReturnType.  Result of the abort lowest priority MB service.
* @retval         E_OK  Lowest Priority Message Buffer has been discarded
* @retval         E_NOT_OK  Lowest Priority Message Buffer has not been discarded
*
* @pre            Driver must be initialized; Hardware channel of ControllerId must be started
*
* @note           Not AUTOSAR required. This is user implementation.
* @implements     Can_AbortMb_Activity
*/
Std_ReturnType Can_43_LLCE_AbortMb(Can_HwHandleType Hth)
{

    Std_ReturnType eReturnValue = (uint8)E_NOT_OK;

    if(TRUE == Can_ValidateController(Can_43_LLCE_GetCurrentConfig()->aHohList[Hth].u8ControllerId, (uint8)CAN_43_LLCE_SID_ABORT_LOWEST_PRIO_MB))
    {
        eReturnValue = Can_43_LLCE_Ipw_AborMb(Hth);
    }

    return eReturnValue;
}

#endif


#if (CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY == STD_ON)
/**
* @brief          Service for requesting recovery from bus-off event
* @details        This service requires preconfiguration of LLCE in bus-off recovery mode
*                 for the given ControllerId. In this mode, the bus-off event (LLCE_ERROR_BUSOFF)
*                 is not escalated to CanIf bus-off callout.
*                 The user may request the synchronization of controller on the bus after it 
*                 switched to bus-off state using this API.
*
* @param[in]      ControllerId - Logical Id of the hardware controller 
*
* @return         Std_ReturnType.
* @retval         E_OK  Command accepted by LLCE and recovery requested for the given ctrl.
* @retval         E_NOT_OK  Command not accepted due to misconfiguration.
*
* @pre            Driver must be initialized; ControllerId must be started
*                 ControllerId must be set in manual bus-off request mode.
*
* @note           Not AUTOSAR required.
*/
Std_ReturnType Can_43_LLCE_ManualBusOffRecovery(uint8 ControllerId )
{
    Std_ReturnType eReturnValue = E_NOT_OK;
    
    if(TRUE == Can_ValidateController(ControllerId, (uint8)CAN_43_LLCE_SID_MANUAL_BUSOFF_RECOVERY))
    {
        eReturnValue = Can_43_LLCE_Ipw_ManualBusOffRecovery(ControllerId);
    }

    return eReturnValue;
}

#endif

#define CAN_43_LLCE_STOP_SEC_CODE

#include "Can_43_LLCE_MemMap.h"


#ifdef __cplusplus
}
#endif


/** @} */


===== 文件 [107/112]: src\Can_43_LLCE_IPW.c =====
/**
*   @file    Can_Irq.c
*   @implements Can_Irq.c_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Interrupt routines for Can driver.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/


#ifdef __cplusplus
extern "C"{
#endif

/*
(CAN035) The module Can_Irq.c contains the implementation of interrupt frames.The implementation of the interrupt service routine shall be in Can_43_LLCE.c
*/

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
/**
* @file           Can_Irq.c
*/
#include "Can_43_LLCE.h"
#include "Can_43_LLCE_IPW.h"
#include "CanIf_Can.h"
#include "Mcal.h"


/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/* The integration of incompatible files shall be avoided. */
#define CAN_IPW_VENDOR_ID_C                    43
#define CAN_IPW_AR_RELEASE_MAJOR_VERSION_C     4
#define CAN_IPW_AR_RELEASE_MINOR_VERSION_C     4
#define CAN_IPW_AR_RELEASE_REVISION_VERSION_C  0
#define CAN_SW_MAJOR_VERSION_IPW_C             1
#define CAN_SW_MINOR_VERSION_IPW_C             0
#define CAN_SW_PATCH_VERSION_IPW_C             10



/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/* Check if current file and CAN header file are of the same vendor */
#if (CAN_IPW_VENDOR_ID_C != CAN_IPW_VENDOR_ID_H)
    #error "Can_IPW.c and Can_IPW.h have different vendor ids"
#endif
/* Check if current file and CAN header file are of the same Autosar version */
#if ((CAN_IPW_AR_RELEASE_MAJOR_VERSION_C    != CAN_IPW_AR_RELEASE_MAJOR_VERSION_H) || \
     (CAN_IPW_AR_RELEASE_MINOR_VERSION_C    != CAN_IPW_AR_RELEASE_MINOR_VERSION_H) || \
     (CAN_IPW_AR_RELEASE_REVISION_VERSION_C != CAN_IPW_AR_RELEASE_REVISION_VERSION_H))
    #error "AutoSar Version Numbers of Can_IPW.c and Can_IPW.h are different"
#endif
/* Check if current file and CAN header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_IPW_C != CAN_IPW_SW_MAJOR_VERSION_H) || \
     (CAN_SW_MINOR_VERSION_IPW_C != CAN_IPW_SW_MINOR_VERSION_H) || \
     (CAN_SW_PATCH_VERSION_IPW_C != CAN_IPW_SW_PATCH_VERSION_H))
    #error "Software Version Numbers of Can_IPW.c and Can_IPW.h are different"
#endif


/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

#define CAN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

Can_43_LLCE_ControllerBaudRate   Can_43_LLCE_ControllerBaudRateIndexes[CAN_43_LLCE_MAXCTRL_CONFIGURED];

#define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
Llce_Fw_ReturnType Can_43_LLCE_IPW_Init(const Can_43_LLCE_ConfigType * pxCurrentConfig)
{
    for (uint8 u8CtrlIndex = 0U; u8CtrlIndex < CAN_43_LLCE_MAXCTRL_CONFIGURED; u8CtrlIndex++)
    {
      #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
      if(Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[u8CtrlIndex].u32CoreId == Can_43_LLCE_GetCoreID())
      {
      #endif
        /* Set the controller current baudrate index as default */
        Can_43_LLCE_ControllerBaudRateIndexes[u8CtrlIndex].u8CurrentBaudRateIndex = (uint8)(pxCurrentConfig->aControllerDescriptors[u8CtrlIndex].u8DefaultBaudRateIndex);
      #if (CAN_43_LLCE_MULTICORE_ENABLED == STD_ON)
      }
      #endif
    }

    return Can_Llce_Init(pxCurrentConfig);
}

Std_ReturnType Can_43_LLCE_IPW_Write (Can_HwHandleType Hth, const Can_PduType * PduInfo, PduInfoType PduInfoTriggerTransmit)
{
    uint8 u8HwCtrl = 0U;
    uint8 u8CtrlId = 0U;
    uint8 u8BaudrateIndex = 0U;
    const Can_43_LLCE_ControllerDescriptorType * pxCanControllerDescriptor;
    Can_43_LLCE_TxFrameInfoType TxFrameInfo;
    const Can_43_LLCE_HOHType * pxHth;
    const Can_43_LLCE_ConfigType* pxCurrentConfig = Can_43_LLCE_GetCurrentConfig();

    pxHth = &(pxCurrentConfig->aHohList[Hth]);
    u8CtrlId = pxHth->u8ControllerId;

    pxCanControllerDescriptor = &(pxCurrentConfig->aControllerDescriptors[u8CtrlId]);

    u8HwCtrl = pxCanControllerDescriptor->u8HwCtrl;

    /* Get the index of the current baud rate */
    u8BaudrateIndex = Can_43_LLCE_ControllerBaudRateIndexes[u8CtrlId].u8CurrentBaudRateIndex;

    /* Get the status of the FD feature */
    TxFrameInfo.u8FdEnabled = pxCanControllerDescriptor->pControllerBaudrateConfigsPtr[u8BaudrateIndex].baudrateConfig.ControllerFD.u8FdEnable;

    TxFrameInfo.u8FdPaddingValue = pxHth->u8FdPaddingValue;

    TxFrameInfo.u16FrameTag2 = PduInfo->swPduHandle;
    TxFrameInfo.u16FrameTag1 = Hth;
    TxFrameInfo.u8AckInterface = pxHth->u8RWInterface;
    TxFrameInfo.u8EnableTxFrameMac = pxHth->u8EnableTxFrameMac;
    TxFrameInfo.u32TxHseKeyHandle = pxHth->u32TxHseKeyHandle;
    TxFrameInfo.u32MessageId = (uint32)PduInfo->id;
    TxFrameInfo.u32SduLength = PduInfoTriggerTransmit.SduLength;
    TxFrameInfo.u8SduDataPtr = (uint8*)PduInfoTriggerTransmit.SduDataPtr;

    return Can_Llce_Write(u8HwCtrl, &TxFrameInfo);
}

Std_ReturnType Can_43_LLCE_IPW_GetControllerMode(uint8 Controller, Can_ControllerStateType* ControllerModePtr)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    return Can_Llce_GetControllerMode(u8HwCtrl, ControllerModePtr);
}

Std_ReturnType Can_43_LLCE_IPW_SetControllerMode( uint8 Controller, Can_ControllerStateType Transition)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;
    uint8 u8BaudrateIndex = Can_43_LLCE_ControllerBaudRateIndexes[Controller].u8CurrentBaudRateIndex;
    const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr = &(Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].pControllerBaudrateConfigsPtr[u8BaudrateIndex].baudrateConfig);

    return Can_Llce_SetControllerMode(u8HwCtrl, Transition, pxBaudrateConfigPtr);
}

void Can_43_LLCE_IPW_DisableControllerInterrupts(uint8 Controller)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    Can_Llce_DisableControllerInterrupts(u8HwCtrl);
}

void Can_43_LLCE_IPW_EnableControllerInterrupts(uint8 Controller)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    Can_Llce_EnableControllerInterrupts(u8HwCtrl);
}

Std_ReturnType Can_43_LLCE_IPW_GetControllerStatus(uint8 Controller, Llce_Can_GetStatusCmdType* StatusPtr)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    return Can_Llce_GetControllerStatus(u8HwCtrl, StatusPtr);
}

Std_ReturnType Can_43_LLCE_IPW_ChangeBaudrate(uint8 Controller, uint8 u8BaudrateIndex)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;
    const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr = &(Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].pControllerBaudrateConfigsPtr[u8BaudrateIndex].baudrateConfig);

    return Can_Llce_ChangeBaudrate(u8HwCtrl, pxBaudrateConfigPtr);
}

void Can_43_LLCE_IPW_MainFunctionMode(uint8 Controller)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    Can_Llce_MainFunctionMode(u8HwCtrl);
}

Std_ReturnType Can_43_LLCE_IPW_GetControllerErrorState(uint8 Controller,Can_ErrorStateType* ErrorStatePtr)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    return Can_Llce_GetControllerErrorState(u8HwCtrl, ErrorStatePtr);
}

Std_ReturnType Can_43_LLCE_IPW_GetControllerRxErrorCounter(uint8 Controller, uint8* RxErrorCounterPtr)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    return Can_Llce_GetControllerRxErrorCounter(u8HwCtrl, RxErrorCounterPtr);
}

Std_ReturnType Can_43_LLCE_IPW_GetControllerTxErrorCounter(uint8 Controller, uint8* TxErrorCounterPtr)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    return Can_Llce_GetControllerTxErrorCounter(u8HwCtrl, TxErrorCounterPtr);
}

Std_ReturnType Can_43_LLCE_IPW_DeInitController(uint8 Controller)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    return Can_Llce_DeInitController(u8HwCtrl);
}

Std_ReturnType Can_43_LLCE_IPW_SetChannelRoutingOutputState(uint8 ControllerId, Can_43_LLCE_ChannelStateType eChannelStatus)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[ControllerId].u8HwCtrl;

    return Can_Llce_SetChannelRoutingOutputState(u8HwCtrl, eChannelStatus);
}
#if (CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY == STD_ON)

Std_ReturnType Can_43_LLCE_Ipw_ManualBusOffRecovery(uint8 ControllerId)
{
    /* Get hardware controller based on logical controller index */
    uint8 u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[ControllerId].u8HwCtrl;
    
    return Can_Llce_ManualBusOffRecovery(u8HwCtrl);
}

#endif

/*================================================================================================*/


#define CAN_43_LLCE_START_SEC_CODE
#include "Can_43_LLCE_MemMap.h"




#define CAN_43_LLCE_STOP_SEC_CODE
#include "Can_43_LLCE_MemMap.h"
#ifdef __cplusplus
}
#endif
/** @} */


===== 文件 [108/112]: src\Can_43_LLCE_Irq.c =====
/**
*   @file    Can_Irq.c
*   @implements Can_Irq.c_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Interrupt routines for Can driver.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/


#ifdef __cplusplus
extern "C"{
#endif


/*
(CAN035) The module Can_Irq.c contains the implementation of interrupt frames.The implementation of the interrupt service routine shall be in Can_43_LLCE.c
*/

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
/**
* @file           Can_Irq.c
*/
#include "Can_43_LLCE.h"
#include "Can_43_LLCE_IPW.h"
#include "Can_43_LLCE_IrqConfig.h"
#include "CanIf_Can.h"
#include "Mcal.h"
#include "Llce_InterfaceFifo.h"
#include "Llce_InterfaceIcsr.h"





/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/* The integration of incompatible files shall be avoided. */
#define CAN_43_LLCE_VENDOR_ID_IRQ_C                      43
#define CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_IRQ_C       4
#define CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_IRQ_C       4
#define CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_IRQ_C    0
#define CAN_SW_MAJOR_VERSION_IRQ_C               1
#define CAN_SW_MINOR_VERSION_IRQ_C               0
#define CAN_SW_PATCH_VERSION_IRQ_C               10



/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/
/* Check if current file and CAN header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID_IRQ_C != CAN_43_LLCE_VENDOR_ID)
    #error "Can_Irq.c and Can_43_LLCE.h have different vendor ids"
#endif
/* Check if current file and CAN header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_IRQ_C    != CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_IRQ_C    != CAN_43_LLCE_AR_RELEASE_MINOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_IRQ_C != CAN_43_LLCE_AR_RELEASE_REVISION_VERSION))
    #error "AutoSar Version Numbers of Can_Irq.c and Can_43_LLCE.h are different"
#endif
/* Check if current file and CAN header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_IRQ_C != CAN_43_LLCE_SW_MAJOR_VERSION) || \
     (CAN_SW_MINOR_VERSION_IRQ_C != CAN_43_LLCE_SW_MINOR_VERSION) || \
     (CAN_SW_PATCH_VERSION_IRQ_C != CAN_43_LLCE_SW_PATCH_VERSION))
    #error "Software Version Numbers of Can_Irq.c and Can_43_LLCE.h are different"
#endif

/* Check if current file and DET header file are of the same version */
#ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
#include "Det.h"
    #if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_IRQ_C != DET_AR_RELEASE_MAJOR_VERSION) || \
         (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_IRQ_C != DET_AR_RELEASE_MINOR_VERSION))
        #error "AutoSar Version Numbers of Can_Irq.c and Det.h are different"
    #endif
#endif
#endif

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/
#if defined CAN_43_LLCE_MEASURE_IRQ_ACK_LATENCY || defined CAN_43_LLCE_MEASURE_IRQ_RECV_LATENCY
extern volatile uint32 Stm_Measurement;
#endif

/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/

/*================================================================================================*/
ISR(Can_FifoTxAckNotEmptyIsr_0_7);
ISR(Can_FifoTxAckNotEmptyIsr_8_15);
ISR(Can_FifoRxOutNotEmptyIsr_0_7);
ISR(Can_FifoRxOutNotEmptyIsr_8_15);
ISR(Can_FifoRxInNotEmptyIsr_0_7);
ISR(Can_FifoRxInNotEmptyIsr_8_15);

#define CAN_43_LLCE_START_SEC_CODE
#include "Can_43_LLCE_MemMap.h"
/**
* @implements     Can_Isr_X_Activity
*/
ISR(Can_FifoTxAckNotEmptyIsr_0_7)
{ 
    uint32 u32IntrStatusFlags;

    /*Read contents of interrupt concentrator register.*/
    u32IntrStatusFlags = Reg_Read32(LLCE_ICSR_ADDR(22));

    /*Check all bit fields from interrupt concentrator register. */
#ifdef CAN_43_LLCE_MEASURE_IRQ_ACK_LATENCY
        Stm_Measurement = Reg_Read32(LLCE_STM_CNT);
host_irq_ack_label:
#endif

#if (LLCE_FIFO_TXACK_00_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_00 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_00))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_00_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_01_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_01 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_01))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_01_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_02_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_02 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_02))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_02_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_03_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_03 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_03))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_03_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_04_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_04 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_04))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_04_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_05_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_05 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_05))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_05_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_06_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_06 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_06))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_06_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_07_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_07 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_07))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_07_ISR();
    }
#endif      
}

/**
* @implements     Can_Isr_X_Activity
*/
ISR(Can_FifoTxAckNotEmptyIsr_8_15)
{ 
    uint32 u32IntrStatusFlags;

    /*Read contents of interrupt concentrator register.*/
    u32IntrStatusFlags = Reg_Read32(LLCE_ICSR_ADDR(23));

    /*Check all bit fields from interrupt concentrator register. */
#if (LLCE_FIFO_TXACK_08_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_00 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_00))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_08_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_09_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_01 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_01))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_09_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_10_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_02 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_02))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_10_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_11_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_03 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_03))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_11_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_12_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_04 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_04))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_12_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_13_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_05 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_05))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_13_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_14_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_06 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_06))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_14_ISR();
    }
#endif
#if (LLCE_FIFO_TXACK_15_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_07 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_07))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_TXACK_15_ISR();
    }
#endif      
}

/**
* @implements     Can_Isr_X_Activity
*/
ISR(Can_FifoRxOutNotEmptyIsr_0_7)
{ 
    uint32 u32IntrStatusFlags;

    /*Read contents of interrupt concentrator register.*/
    u32IntrStatusFlags = Reg_Read32(LLCE_ICSR_ADDR(16));

    /*Check all bit fields from interrupt concentrator register. */

#ifdef CAN_43_LLCE_MEASURE_IRQ_RECV_LATENCY
        Stm_Measurement = Reg_Read32(LLCE_STM_CNT);
host_irq_recv_label:
#endif

#if (LLCE_FIFO_RXOUT_00_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_00 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_00))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_00_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_01_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_01 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_01))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_01_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_02_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_02 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_02))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_02_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_03_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_03 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_03))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_03_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_04_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_04 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_04))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_04_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_05_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_05 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_05))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_05_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_06_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_06 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_06))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_06_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_07_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_07 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_07))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_07_ISR();
    }
#endif 
}

/**
* @implements     Can_Isr_X_Activity
*/
ISR(Can_FifoRxOutNotEmptyIsr_8_15)
{ 
    uint32 u32IntrStatusFlags;    

    /*Read contents of interrupt concentrator register.*/
    u32IntrStatusFlags = Reg_Read32(LLCE_ICSR_ADDR(17));

    /*Check all bit fields from interrupt concentrator register. */

#if (LLCE_FIFO_RXOUT_08_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_00 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_00))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_08_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_09_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_01 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_01))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_09_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_10_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_02 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_02))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_10_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_11_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_03 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_03))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_11_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_12_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_04 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_04))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_12_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_13_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_05 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_05))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_13_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_14_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_06 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_06))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_14_ISR();
    }
#endif
#if (LLCE_FIFO_RXOUT_15_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_07 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_07))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXOUT_15_ISR();
    }
#endif 
}

/**
* @implements     Can_Isr_X_Activity
*/
ISR(Can_FifoRxInNotEmptyIsr_0_7)
{ 
    uint32 u32IntrStatusFlags;

    /*Read contents of interrupt concentrator register.*/
    u32IntrStatusFlags = Reg_Read32(LLCE_ICSR_ADDR(14));

    /*Check all bit fields from interrupt concentrator register. */

#if (LLCE_FIFO_RXIN_00_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_00 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_00))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_00_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_01_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_01 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_01))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_01_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_02_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_02 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_02))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_02_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_03_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_03 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_03))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_03_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_04_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_04 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_04))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_04_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_05_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_05 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_05))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_05_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_06_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_06 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_06))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_06_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_07_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_07 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_07))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_07_ISR();
    }
#endif 
}

/**
* @implements     Can_Isr_X_Activity
*/
ISR(Can_FifoRxInNotEmptyIsr_8_15)
{ 
    uint32 u32IntrStatusFlags;    

    /*Read contents of interrupt concentrator register.*/
    u32IntrStatusFlags = Reg_Read32(LLCE_ICSR_ADDR(15));

    /*Check all bit fields from interrupt concentrator register. */

#if (LLCE_FIFO_RXIN_08_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_00 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_00))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_08_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_09_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_01 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_01))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_09_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_10_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_02 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_02))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_10_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_11_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_03 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_03))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_11_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_12_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_04 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_04))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_12_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_13_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_05 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_05))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_13_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_14_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_06 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_06))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_14_ISR();
    }
#endif
#if (LLCE_FIFO_RXIN_15_EN == STD_ON)
    if (LLCE_ICSR_INTFLAG_07 == (u32IntrStatusFlags & LLCE_ICSR_INTFLAG_07))
    {
        /* Call the processing routine for this kind of interrupt.*/
        LLCE_FIFO_RXIN_15_ISR();
    }
#endif 
}

#define CAN_43_LLCE_STOP_SEC_CODE
#include "Can_43_LLCE_MemMap.h"
#ifdef __cplusplus
}
#endif
/** @} */


===== 文件 [109/112]: src\Can_Callback.c =====
/**
*   @file    Can_Callback.c
*   @version 1.0.10
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/
#include "Can_Callback.h"


#if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
    #include "Det.h"
    #include "Can_43_LLCE.h"
    #include "SchM_Can_43_LLCE.h"
#endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */

#if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
/**
* @brief          Implements wrapper for error report 
* @details        This routine is called by all APIs that change controller state, e.g. Can_Llce_SetControllerToStopMode:
*
* @param[in]      sid             Controller mode
*                 eTransition     Controller transition state
*
* @return         void
*
*
* @pre            The AUTOSAR_COMPATIBLE_MODE define is set to STD_ON for code generated with Tresos.
*
*/
void Can_43_LLCE_ReportError(uint8 sid , uint8 eTransition)
{
    /*In ASR context, report error through Det module - not available in non-ASR DesignStudio*/
    #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
        if(((uint8)CAN_43_LLCE_E_DATALOST) != eTransition)
        {   
            (void)Det_ReportError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, sid, eTransition);
        }
    #else
        /* To avoid MISRA and compilation warnings */
        (void)sid;
        (void)eTransition;
    #endif
}
#else /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
void Can_43_LLCE_ReportError(uint8 sid , uint8 eTransition)
{
    /* Call custom configurable callback in NON-AUTOSAR MODE*/
    Can_43_LLCE_DevErrorDetectCallback(sid, eTransition);
}
#endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */

#if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
/**
* @brief          Implements wrapper for runtime error report 
* @details        This routine is called by Can_Llce_ProcessNotificationISR in case of overwrite or overrun
*
* @param[in]      sid             Controller mode
*                 eTransition     Controller transition state
*
* @return         void
*
*
*/
void Can_43_LLCE_ReportRuntimeError(uint8 sid , uint8 eTransition)
{
    /*In ASR context, report error through Det module - not available in non-ASR DesignStudio*/
    (void)Det_ReportRuntimeError( (uint16)CAN_43_LLCE_MODULE_ID, (uint8)CAN_43_LLCE_INSTANCE, sid, eTransition);
}
#else /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
void Can_43_LLCE_ReportRuntimeError(uint8 sid , uint8 eTransition)
{
    /* Call custom configurable callback in NON-AUTOSAR MODE*/
    Can_43_LLCE_DevErrorDetectCallback(sid, eTransition);
}
#endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */


#if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
/**
* @brief          Implements wrapper for configurable callback for controller state report to CanIf module in AUTOSAR MODE
* @details        This routine is called by all APIs that change controller state, e.g. Can_Llce_SetControllerToStopMode:
*
* @param[in]      u8HwCtrl      Controller id
*                 ctrlState     Controller transition state
*
* @return         void
*
*
* @pre            The AUTOSAR_COMPATIBLE_MODE define is set to STD_ON for code generated with Tresos.
*
*/
void Can_43_LLCE_ControllerModeIndication(uint8 u8HwCtrl, Can_ControllerStateType ctrlState)
{
    /* In ASR context, make call to CanIf - not available in non-ASR DesignStudio */
    CanIf_ControllerModeIndication(Can_43_LLCE_GetCurrentConfig()->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId, ctrlState);
}
#else /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
void Can_43_LLCE_ControllerModeIndication(uint8 u8HwCtrl, Can_ControllerStateType ctrlState)
{
    /* Call custom configurable callback for controller state report in NON-AUTOSAR MODE */
    Can_43_LLCE_ControllerModeIndicationCallback(u8HwCtrl, ctrlState);
}
#endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */

#if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
/**
* @brief          Implements wrapper for confirmation callback reporting to CanIf in AUTOSAR MODE
* @details        This routine is called by:
*                - Can_Llce_ProcessTxPollingClass and Can_Llce_ProcessTx
*
* @param[in]      tag             Frame tag
*
* @return         void
*
*
* @pre            The AUTOSAR_COMPATIBLE_MODE define is set to STD_ON for code generated with Tresos.
*
*/
void Can_43_LLCE_TxConfirmation(uint16 tag)
{
    /*In ASR context, make call to CanIf - not available in non-ASR DesignStudio*/
    CanIf_TxConfirmation(tag);
}
#else /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
void Can_43_LLCE_TxConfirmation(uint16 tag)
{
    /* Call custom confirmation callback in NON-AUTOSAR MODE */
    Can_43_LLCE_TxConfirmationCallback(tag);
}
#endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */

#if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
/**
* @brief          Implements wrapper for BusOff callback report to CanIf in AUTOSAR MODE
* @details        This routine is called by:
*                - Can_Llce_ControllerBusOff
*
* @param[in]      u8HwCtrl             controller id
*
* @return         void
*
*
* @pre            The AUTOSAR_COMPATIBLE_MODE define is set to STD_ON for code generated with Tresos.
*/
void Can_43_LLCE_ControllerBusOff(uint8 u8HwCtrl)
{
    /* Inform CanIf about BusOff event */
    CanIf_ControllerBusOff(Can_43_LLCE_GetCurrentConfig()->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId);
}
#else /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
void Can_43_LLCE_ControllerBusOff(uint8 u8HwCtrl)
{
    /* Call custom BusOff callback in NON-AUTOSAR MODE */
    Can_43_LLCE_ControllerBusOffCallback(u8HwCtrl);
}
#endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */


/* Wrapper for configurable callback in non-Autosar context, and CanIf callback in Autosar context. */
void Can_43_LLCE_RxIndication(uint32 u32MbMessageId, uint16 u16FilterId, uint8* u8FramePayload, uint8 u8MbDataLength)
{
    uint8 Controller;
    /* Used to store the FD feature enable or disable. */
    uint8 u8FdEnable;  
    /* Variable to hold the index of the current baudrate */
    uint8 u8BaudrateIndex;
    uint8 u8MbDataLengthCopy;
    uint8 u8HwCtrl;

    /* comply with misra Rule 17.8 A function parameter should not be modified */
    u8MbDataLengthCopy = u8MbDataLength;
    /* Identify the corresponding controller */
    Controller = Can_43_LLCE_GetCurrentConfig()->aHohList[u16FilterId].u8ControllerId;

    /* Get the hardware offset for this controller. */
    u8HwCtrl = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].u8HwCtrl;

    u8BaudrateIndex = Can_43_LLCE_ControllerBaudRateIndexes[Controller].u8CurrentBaudRateIndex;
    u8FdEnable = Can_43_LLCE_GetCurrentConfig()->aControllerDescriptors[Controller].pControllerBaudrateConfigsPtr[u8BaudrateIndex].baudrateConfig.ControllerFD.u8FdEnable;

    /* Check if the length parameter is bigger than the maximum accepted value defined by the configuration. */
    if ( (u8FdEnable == (uint8)FALSE) && (u8MbDataLengthCopy > (uint8)8U) )
    {
        /* Shrink the length parameter according to the configuration. This prevents a buffer overflow generated by a CAN bus error affecting length field. */
        u8MbDataLengthCopy = (uint8)8U;
    }
    else if ( (u8FdEnable == (uint8)TRUE) && (u8MbDataLengthCopy > (uint8)64U) )
    {
        u8MbDataLengthCopy = (uint8)64U;
    }
    else if (( (u32MbMessageId & (uint32)CAN_LPDU_FD_U32) != CAN_LPDU_FD_U32) && ( u8MbDataLengthCopy > (uint8)8U ))
    {
        u8MbDataLengthCopy = (uint8)8U;
    }
    else
    {
        /* Length ok. */
    }

    #if (STD_ON == AUTOSAR_COMPATIBLE_MODE)
        /* Identifies the HRH and its corresponding CAN Controller. */
        Can_HwType Mailbox;
        /* Pointer to the received L-PDU. */
        PduInfoType PduInfo;

        /* Standard/Extended CAN ID of CAN L-PDU */
        Mailbox.CanId = u32MbMessageId;       
        
        /* ID of the corresponding Hardware Object Range */
        Mailbox.Hoh = u16FilterId;

        Mailbox.ControllerId = Can_43_LLCE_GetCurrentConfig()->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId;

        /* length of the SDU in bytes */
        PduInfo.SduLength = u8MbDataLengthCopy;
        
        /* pointer to the SDU (i.e. payload data) of the PDU */
        PduInfo.SduDataPtr = u8FramePayload;

        CanIf_RxIndication(&Mailbox, &PduInfo );
    #else /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
        Can_43_LLCE_RxIndicationCallback(u8HwCtrl, u16FilterId, u8FramePayload, u8MbDataLengthCopy);
    #endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
}

void Can_Hth_FreeTxObject(uint16 Hth, uint8 freeObjCount)
{
    #if (STD_ON == AUTOSAR_COMPATIBLE_MODE)

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_02();

    /* Increase the number of free Tx objects for the current HTH */
    Can_au16TransmitHwObjectCnt[Hth - CAN_43_LLCE_FIRST_HTH_CONFIGURED] += freeObjCount;
    
    if ( Can_au16TransmitHwObjectCnt[Hth - CAN_43_LLCE_FIRST_HTH_CONFIGURED] > Can_43_LLCE_GetCurrentConfig()->aHohList[Hth].u16MbCount )
    {
        Can_au16TransmitHwObjectCnt[Hth - CAN_43_LLCE_FIRST_HTH_CONFIGURED] = Can_43_LLCE_GetCurrentConfig()->aHohList[Hth].u16MbCount;
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_02();

    #endif /* (STD_ON == AUTOSAR_COMPATIBLE_MODE) */
}


===== 文件 [110/112]: src\Can_Llce.c =====
/**
*   @file    Can_Llce.c
*   @implements Can_Llce.c_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - IP module implementation.
*   @details Low Level Driver implementation.
*
*   @internal
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/


#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Can_43_LLCE.h"
#include "Can_43_LLCE_IPW.h"
#include "Can_43_LLCE_AFcfg.h"
#include "Can_43_LLCE_Externals.h"
#include "Can_Llce_Types.h"
#include "Can_Callback.h"
#include "SchM_Can_43_LLCE.h"

#include "OsIf.h"
#include "Mcal.h"
#include "Llce_InterfaceFifo.h"
#include "Llce_FwVersion.h"
#include "Llce_SwFifo.h"
#include "Llce_InterfaceCanUtils.h"

#if ((LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON))
 /* memset */
 #include <string.h>
 /* PFE interface enabled */
 #include <pfe_minihif_drv.h>
#endif

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/**
* @file           Can_Llce.c
*/
#define CAN_LLCE_VENDOR_ID_C                    43
#define CAN_LLCE_AR_RELEASE_MAJOR_VERSION_C     4
#define CAN_LLCE_AR_RELEASE_MINOR_VERSION_C     4
#define CAN_LLCE_AR_RELEASE_REVISION_VERSION_C  0
#define CAN_LLCE_SW_MAJOR_VERSION_C             1
#define CAN_LLCE_SW_MINOR_VERSION_C             0
#define CAN_LLCE_SW_PATCH_VERSION_C             10

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/* Check if current file and CAN header file are of the same vendor */
#if (CAN_LLCE_VENDOR_ID_C != CAN_LLCE_VENDOR_ID_H)
    #error "Can_Llce.c and Can_Llce.h have different vendor ids"
#endif
/* Check if current file and CAN header file are of the same Autosar version */
#if ((CAN_LLCE_AR_RELEASE_MAJOR_VERSION_C    != CAN_LLCE_AR_RELEASE_MAJOR_VERSION_H) || \
     (CAN_LLCE_AR_RELEASE_MINOR_VERSION_C    != CAN_LLCE_AR_RELEASE_MINOR_VERSION_H) || \
     (CAN_LLCE_AR_RELEASE_REVISION_VERSION_C != CAN_LLCE_AR_RELEASE_REVISION_VERSION_H))
    #error "AutoSar Version Numbers of Can_Llce.c and Can_Llce.h are different"
#endif
/* Check if current file and CAN header file are of the same Software version */
#if ((CAN_LLCE_SW_MAJOR_VERSION_C != CAN_LLCE_SW_MAJOR_VERSION_H) || \
     (CAN_LLCE_SW_MINOR_VERSION_C != CAN_LLCE_SW_MINOR_VERSION_H) || \
     (CAN_LLCE_SW_PATCH_VERSION_C != CAN_LLCE_SW_PATCH_VERSION_H))
    #error "Software Version Numbers of Can_Llce.c and Can_Llce.h are different"
#endif


/* Check if current file and CAN_IPW header file are of the same vendor */
#if (CAN_LLCE_VENDOR_ID_C != CAN_IPW_VENDOR_ID_H)
    #error "Can_43_LLCE.c and Can_43_LLCE_IPW.h have different vendor ids"
#endif
/* Check if current file and CAN_IPW header file are of the same Autosar version */
#if ((CAN_LLCE_AR_RELEASE_MAJOR_VERSION_C    != CAN_IPW_AR_RELEASE_MAJOR_VERSION_H) || \
     (CAN_LLCE_AR_RELEASE_MINOR_VERSION_C    != CAN_IPW_AR_RELEASE_MINOR_VERSION_H) || \
     (CAN_LLCE_AR_RELEASE_REVISION_VERSION_C != CAN_IPW_AR_RELEASE_REVISION_VERSION_H))
    #error "AutoSar Version Numbers of Can_43_LLCE.c and Can_43_LLCE_IPW.h are different"
#endif
/* Check if current file and CAN_IPW header file are of the same Software version */
#if ((CAN_LLCE_SW_MAJOR_VERSION_C != CAN_IPW_SW_MAJOR_VERSION_H) || \
     (CAN_LLCE_SW_MINOR_VERSION_C != CAN_IPW_SW_MINOR_VERSION_H) || \
     (CAN_LLCE_SW_PATCH_VERSION_C != CAN_IPW_SW_PATCH_VERSION_H))
    #error "Software Version Numbers of Can_43_LLCE.c and Can_43_LLCE_IPW.h are different"
#endif

/* Check if current file and CANIF_CBK header file are of the same version */
#if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
  #ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
    #if ((CAN_LLCE_AR_RELEASE_MAJOR_VERSION_C != CANIF_CAN_AR_RELEASE_MAJOR_VERSION) || \
         (CAN_LLCE_AR_RELEASE_MINOR_VERSION_C != CANIF_CAN_AR_RELEASE_MINOR_VERSION))
        #error "AutoSar Version Numbers of Can_43_LLCE.c and CanIf_Can.h are different"
    #endif
  #endif
#endif

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/
#define LLCE_BCAN_SR_FLTCONF_MASK_U32             ((uint32)0x0000000CU)
#define LLCE_BCAN_SR_FLTCONF_ERROR_ACTIVE_U32     ((uint32)0x00000000U)
#define LLCE_BCAN_SR_FLTCONF_ERROR_PASSIVE_U32    ((uint32)0x00000004U)
#define LLCE_BCAN_SR_FLTCONF_BUSOFF10_U32         ((uint32)0x00000008U)
#define LLCE_BCAN_SR_FLTCONF_BUSOFF11_U32         ((uint32)0x0000000CU)
#define LLCE_BCAN_ECR_REC_MASK_U32                ((uint32)0x000000FFU)
#define LLCE_BCAN_ECR_TEC_MASK_U32                ((uint32)0x0000FF00U)
#define LLCE_BCAN_ECR_REC_SHIFT_U8                ((uint8)0U)
#define LLCE_BCAN_ECR_TEC_SHIFT_U8                ((uint8)8U)

#define LLCE_CAN_MB_29BIT_MASK_U32                ((uint32)0x1FFFFFFFU)

#define PFE_HIF_RING_CFG_LENGTH         128U /*number of BD*/
/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/
#if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0) && ((LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0))
 #define CAN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED_NO_CACHEABLE
 #include "Can_43_LLCE_MemMap.h"

 /* Array to store mapping between destination indexes at configuration and runtime */
 static uint8 Can_au8DestinationIdxMap[LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT];
 
 
 #define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED_NO_CACHEABLE
 #include "Can_43_LLCE_MemMap.h"
#endif /*  (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0) && ((LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0)) */

#if ((LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON))
 #define CAN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED_NO_CACHEABLE
 #include "Can_43_LLCE_MemMap.h"

 /* PFE interface enabled */
 static pfe_minihif_drv_t llce_minihif;
 
 #define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED_NO_CACHEABLE
 #include "Can_43_LLCE_MemMap.h"
#endif /* ((LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON)) */

#define CAN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"
/**
* @brief          Array holding current status/run-time configuration of individual hardware controllers
* @details        Array holding current status/run-time configuration of individual hardware controllers
*                 - information like Guard bits, Pre-calculated MB INT masks, Storage space for id, INT nesting level,
*                 Index of MB buffer being canceled,  Controller Options.
*
*
*/
static Can_43_LLCE_ControllerStatusType Can_43_LLCE_ControllerStatuses[LLCE_CAN_CONFIG_MAXCTRL_COUNT];

static uint8 au8VersionStringBuf[LLCE_VERSION_MAX_LENGTH];
static uint8 u8VersionLength = 0;

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
  /* Counters used for HRH-filter mapping */
  #if defined(S32G2XX)
    static uint16 Can_Llce_u16RxLutExactMatchCounter = 0U, Can_Llce_u16RxLutConfigurableCounter = 512U;
  #elif defined(S32G3XX)
    static uint16 Can_Llce_au16RxLutCounter[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
  #endif

    static boolean Can_Llce_bHeadlessInitDone_InitPlatform = FALSE;
    static boolean Can_Llce_bHeadlessInitDone_InitController = FALSE;
    static boolean Can_Llce_bHeadlessInitDone_SetConfiguredReceiveFilters = FALSE;
    static boolean Can_Llce_bHeadlessInitDone_AfInit = FALSE;
    static boolean Can_Llce_bHeadlessInitDone_SetControllerToStartMode[LLCE_CAN_CONFIG_MAXCTRL_COUNT] =
        { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE  };


#endif /* CAN_LLCE_USE_HEADLESSMODE == STD_ON */

#define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/


/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_SHAREDMEMORY
#include "Can_43_LLCE_MemMap.h"

static volatile Llce_Can_SharedMemoryType Can_SharedMemory;
    
#define CAN_43_LLCE_STOP_SEC_SHAREDMEMORY
#include "Can_43_LLCE_MemMap.h"

/** @brief   STM timer used for performance measurements. */
#ifdef CAN_43_LLCE_STM_MEASUREMENT_ENABLE
/* Status variable used to get feedback from Llce when the boot has ended */
extern volatile uint32 Stm_Measurement;
#endif

#define CAN_43_LLCE_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

static uint16 Can_u16NotifIntrEnable[LLCE_CAN_CONFIG_HIF_COUNT];

#if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U) || (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0)
static uint16 Can_Llce_au16RxHrh2FilterAddr[CAN_43_LLCE_MAXHRH_CONFIGURED];
#endif

#if (CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED == STD_ON)
  static Llce_Can_AdvancedFilterType* Can_Llce_apRxHrh2AfFilterCfg[CAN_43_LLCE_MAXHRH_CONFIGURED];
#endif


#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
/* Buffer table for notification errors reported in polling mode */
static Llce_Can_NotificationType Can_Llce_aNotif1_Table[LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE];
/* Sw fifo for errors buffering */
static Llce_SwFifo_Type Can_Llce_xNotifSwFifo;
#endif

/* Number of interrupt enable requests per interface. Helps to disable the interface interrupt
   only when all the controllers assigned to that interface are being requested to interrupt disable.  */
static uint8 Can_Llce_au8FifoSetIntEnCnt[LLCE_CAN_CONFIG_MAXCTRL_COUNT];

#define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"


#define CAN_43_LLCE_START_SEC_VAR_INIT_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

static const Can_43_LLCE_ConfigType * Can_Llce_pxGlobalConfigs[CAN_43_LLCE_MAX_PARTITIONS];

#define CAN_43_LLCE_STOP_SEC_VAR_INIT_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"


#define CAN_43_LLCE_START_SEC_CODE
#include "Can_43_LLCE_MemMap.h"


/*=================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
=================================================================================================*/
static const Can_43_LLCE_ConfigType* Can_Llce_GetCurrentConfig(void);

#if (CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED == STD_OFF)
static void Can_Llce_ControllerBusOff(uint8 u8HwCtrl);
#endif

static inline void Can_Llce_DisableInterrupts (uint8 u8HwCtrl);
static inline void Can_Llce_EnableInterrupts (uint8 u8HwCtrl);
static inline void Can_Llce_ResetIntFlags (uint8 u8HwCtrl);

static Std_ReturnType Can_Llce_SetControllerToStopMode(uint8 u8HwCtrl);
static Std_ReturnType Can_Llce_SetControllerToStartMode(uint8 u8HwCtrl, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr);
static Std_ReturnType Can_Llce_SetControllerToSleepMode(uint8 u8HwCtrl);
static Std_ReturnType Can_Llce_GetLlceControllerMode(uint8 u8HwCtrl, Llce_Can_CtrlStateType *eLlceControllerMode);
static Llce_Fw_ReturnType Can_Llce_ExecuteIfCommand(uint8 u8HwCtrl);
static void Can_Llce_UpdateMB(const Can_43_LLCE_TxFrameInfoType* TxFrameInfo);
static void Can_Llce_ProcessFilterIdMaskType(Llce_Can_IdLengthType eIdType, volatile Llce_Can_ReceiveFilterType * pxFilter);
static Llce_Fw_ReturnType Can_Llce_InitPlatform(const Can_43_LLCE_ConfigType * pxCurrentConfig, uint8 u8ControllersCount);
static Llce_Fw_ReturnType Can_Llce_InitController(void);
static void Can_Llce_SetConfiguredReceiveFilters(void);
#if (RXLUT2_ENABLE == STD_ON)
static void Can_Llce_SetConfiguredAuxReceiveFilters(void);
#endif
static Std_ReturnType Can_Llce_SendSetFilterCommand(const volatile Llce_Can_ReceiveFilterType *pRxFilters, uint8 filterLoadedCount, uint8 u8HwCtrl);
static Llce_Fw_ReturnType Can_Llce_SendStopCmd(uint8 u8HwCtrl);
static void Can_Llce_ComputeMbConfig(uint32 SduLength, uint32 u32MessageId, uint8 u8EnabledFD, uint32* pu32MbConfig, uint8* pu8RealDataLength);
static void Can_Llce_ResetFifoContent(uint8 u8Interface);
static inline Std_ReturnType Can_Llce_CheckCommandAvailable(void);
static Std_ReturnType Can_Llce_UpdateToStartMode(uint8 u8HwCtrl, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr);

#if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0) && ((LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0))
static Llce_Fw_ReturnType Can_Llce_CreateConfiguredAfDestinations(void);
#endif

#if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0)
static void Can_Llce_AfInit( void );
static void Can_Llce_SetConfiguredAfFilters(void);
#endif

static Std_ReturnType Can_Llce_SendSetAfFilterCommand(const volatile Llce_Can_AdvancedFilterType *pAfFilters, uint8 filterLoadedCount, uint8 u8HwCtrl);

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
static void Can_Llce_EmulateSetConfiguredReceiveFilters(void);
  #if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0)
  static void Can_Llce_EmulateSetConfiguredAfFilters(void);
  #endif
#endif

#if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)
static void Can_Llce_ProcessTxPollingClass( uint8 u8PollClassIdx );
#endif

#if (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON)
static void Can_Llce_ProcessRxPollingClass( uint8 u8PollClassIdx );
#endif

#if (CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED == STD_ON)
static boolean Can_Llce_CheckCustomCallback(uint16 u16HrhId, uint32 u32MbMessageId, uint8 u8MbDataLength, uint8* u8FramePayload, uint16 u16RxMbDescIdx);
#endif

/*================================================================================================
*                                       LOCAL FUNCTIONS
=================================================================================================*/
static const Can_43_LLCE_ConfigType* Can_Llce_GetCurrentConfig(void)
{
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
    return Can_Llce_pxGlobalConfigs[Can_43_LLCE_GetCoreID()];
#else
    return Can_Llce_pxGlobalConfigs[0];
#endif
}

static inline Std_ReturnType Can_Llce_CheckCommandAvailable(void)
{
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Check if the command buffer is not already used by other command request. */
    if (LLCE_FIFO_FNEMTY_U32 != (Reg_Read32(LLCE_FIFO_STATUS0(LLCE_FIFO_CMD_BASE_ADDRESS(pxConfig->u8ActiveHif))) & (uint32)(LLCE_FIFO_FNEMTY_U32)))    
    {
        eReturnValue = (Std_ReturnType)E_OK;
    }

    return eReturnValue;
}

static Std_ReturnType Can_Llce_UpdateToStartMode(uint8 u8HwCtrl, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Make sure no pending message was left in the FIFOs after the interrupts were disabled. */
    Can_Llce_ResetFifoContent(u8HwCtrl);

    /* (CAN384) Each time the CAN controller state machine is triggered with the state transition value CAN_CS_STARTED, the function
    Can_43_LLCE_SetControllerMode shall re-initialize the CAN controller with the same controller configuration set previously used by functions
    Can_43_LLCE_Init.*/
    if ((Std_ReturnType)E_OK == Can_Llce_ChangeBaudrate( u8HwCtrl, pxBaudrateConfigPtr))
    {
        /*
        (CAN261) The function Can_43_LLCE_SetControllerMode(CAN_CS_STARTED) shall set the hardware registers in a way that makes the CAN controller participating on the network.
        */
        /* Check if the command buffer is not already used by other command request */
        SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
        if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
        {
            /* Configure the command id. */
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETCONTROLLERMODE;

            /* Add command parameter. */
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetControllerMode.eTransition = LLCE_CAN_T_START;
            /* Send the command prepared above to the LLCE in order to be executed. */
            if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( u8HwCtrl ))
            {
                eReturnValue = (Std_ReturnType)E_OK;
            }
        }
        SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief  Disable LLCE_FIFO_FNEMTY_U32 interrupt for the FIFO interface assigned to a given controller.
*/
static inline void Can_Llce_DisableInterrupts (uint8 u8HwCtrl)
{

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    uint32 u32DrvControllerOptions = pxConfig->aHwControllerDescriptors[u8HwCtrl].u32DrvControllerOptions;
    /* Determine physical FIFO Interface assigned to HwCtrl. */
    uint8 u8FifoInterface = pxConfig->aHwControllerDescriptors[u8HwCtrl].u8FifoInterface;

    if (CAN_INTERRUPT_ENABLED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eSetIntEnRequest)
    {
        Can_43_LLCE_ControllerStatuses[u8HwCtrl].eSetIntEnRequest = CAN_INTERRUPT_DISABLED;
        /*Decrement only once per controller interrupt disable request*/
        if (Can_Llce_au8FifoSetIntEnCnt[u8FifoInterface] > 0U)
        {
            Can_Llce_au8FifoSetIntEnCnt[u8FifoInterface]--;
        }
    }

    /* Clear IER only when all controllers assigned to this interface are being requested to disable interrupts. */
    if (0U == Can_Llce_au8FifoSetIntEnCnt[u8FifoInterface])
    {
        if(LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32))
        {
            #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
            OsIf_Trusted_Call2params(Llce_Sema42_Lock, Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
            #else
            Llce_Sema42_Lock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
            #endif
            
            /* Disable needed interrupt. */
            Reg_Bit_Clear32( LLCE_FIFO_IER(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);

            #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
            OsIf_Trusted_Call1param(Llce_Sema42_Unlock, Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif));
            #else
            Llce_Sema42_Unlock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif));
            #endif
        }

        if(LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32))
        {
            #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
            OsIf_Trusted_Call2params(Llce_Sema42_Lock, Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
            #else
            Llce_Sema42_Lock(Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
            #endif

            /* Disable needed interrupt. */
            Reg_Bit_Clear32( LLCE_FIFO_IER(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);

            #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
            OsIf_Trusted_Call1param(Llce_Sema42_Unlock, Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif));
            #else
            Llce_Sema42_Unlock(Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif));
            #endif
        }
    }

    if(LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32))
    {
        /* Clear every bit before disabling the interrupt */
        Can_u16NotifIntrEnable[pxConfig->u8ActiveHif] &= ~(((uint16)1U) << u8HwCtrl);

        Can_Llce_DisableNotifInterrupt(pxConfig->u8ActiveHif);
    }
}

static inline void Can_Llce_ResetIntFlags (uint8 u8HwCtrl)
{
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    uint32 u32DrvControllerOptions = pxConfig->aHwControllerDescriptors[u8HwCtrl].u32DrvControllerOptions;
   /* Determine physical FIFO Interface assigned to HwCtrl. */
    uint8 u8FifoInterface = pxConfig->aHwControllerDescriptors[u8HwCtrl].u8FifoInterface;

    if(LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32))
    {   
        /* Clear all interrupt status flags. */
        Reg_Write32(LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface)),Reg_Read32(LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface))));
    }

     if(LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32))
    {
        /* Clear all interrupt status flags. */
        Reg_Write32(LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface)),Reg_Read32(LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface))));
    }

}
/*================================================================================================*/
/**
* @brief  Enable LLCE_FIFO_FNEMTY_U32 interrupt for the FIFO interface assigned to a given controller.
*/
static inline void Can_Llce_EnableInterrupts (uint8 u8HwCtrl)
{
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    uint32 u32DrvControllerOptions = pxConfig->aHwControllerDescriptors[u8HwCtrl].u32DrvControllerOptions;
   /* Determine physical FIFO Interface assigned to HwCtrl. */
    uint8 u8FifoInterface = pxConfig->aHwControllerDescriptors[u8HwCtrl].u8FifoInterface;

    if (CAN_INTERRUPT_DISABLED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eSetIntEnRequest)
    {
        Can_43_LLCE_ControllerStatuses[u8HwCtrl].eSetIntEnRequest = CAN_INTERRUPT_ENABLED;
        /*Increment only once per controller interrupt enable request*/
        Can_Llce_au8FifoSetIntEnCnt[u8FifoInterface]++;
    }
    
    if(LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32))
    {   
        #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
        OsIf_Trusted_Call2params(Llce_Sema42_Lock, Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
        #else
        Llce_Sema42_Lock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
        #endif
        
        /* Enable needed interrupt. */
        Reg_Bit_Set32( LLCE_FIFO_IER(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);

        #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
        OsIf_Trusted_Call1param(Llce_Sema42_Unlock, Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif));
        #else
        Llce_Sema42_Unlock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, pxConfig->u8ActiveHif));
        #endif
    }
    
    if(LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32))
    {
        #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
        OsIf_Trusted_Call2params(Llce_Sema42_Lock, Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
        #else
        Llce_Sema42_Lock(Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif), LLCE_HOST_CORE_SEMA42_DOMAIN);
        #endif

        /* Enable needed interrupt. */
        Reg_Bit_Set32( LLCE_FIFO_IER(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);

        #ifdef CAN_LLCE_ENABLE_USER_MODE_SUPPORT
        OsIf_Trusted_Call1param(Llce_Sema42_Unlock, Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif));
        #else
        Llce_Sema42_Unlock(Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, pxConfig->u8ActiveHif));
        #endif
    }
      
    if(LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32))
    {
        Can_Llce_EnableNotifInterrupt(pxConfig->u8ActiveHif);

        Can_u16NotifIntrEnable[pxConfig->u8ActiveHif] |= (((uint16)1U) << u8HwCtrl);
    }

}

/*================================================================================================*/
/**
* @brief  Enable LLCE_FIFO_FNEMTY_U32 interrupt for the FIFO NOTIF of the given Hif.
*/
void Can_Llce_EnableNotifInterrupt(uint8 u8ActiveHif)
{
    if (0U == Can_u16NotifIntrEnable[u8ActiveHif])
    {
        /* Enable NOTIF interrupt. */
        Reg_Bit_Set32( LLCE_FIFO_IER(LLCE_NOTIF_FIFO0_BASE_ADDRESS(u8ActiveHif)), LLCE_FIFO_FNEMTY_U32);
    }
}

/*================================================================================================*/
/**
* @brief  Disable LLCE_FIFO_FNEMTY_U32 interrupt for the FIFO NOTIF of the given Hif.
*/
void Can_Llce_DisableNotifInterrupt(uint8 u8ActiveHif)
{
    if (0U == Can_u16NotifIntrEnable[u8ActiveHif])
    {
        /* Disable NOTIF interrupt. */
        Reg_Bit_Clear32( LLCE_FIFO_IER(LLCE_NOTIF_FIFO0_BASE_ADDRESS(u8ActiveHif)), LLCE_FIFO_FNEMTY_U32);
    }
}

/*================================================================================================*/
/**
* @brief          Service to Perform software triggered state transitions of the CAN controller State machine.
* @details        Transition controller to Stop state/mode.
*
*                 This routine is called by:
*                  - Can_Llce_SetControllerMode()
*
* @param[in]      u8HwCtrl CAN controller for which the init shall be done.
*
* @return         Std_ReturnType
* @retval         E_OK transition initiated
* @retval         E_NOT_OK development or production error
*
*/
static Std_ReturnType Can_Llce_SetControllerToStopMode(uint8 u8HwCtrl)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue;
    
    Can_ControllerStateType eCtrlState = CAN_CS_UNINIT;

    if((Std_ReturnType)E_OK == Can_Llce_GetControllerMode(u8HwCtrl, &eCtrlState))
    {
        /*
           (PR-MCAL-3057) The Can driver shall not create a development error if the CanIf requests a transition to a state that was already reached.
        */
        if ( CAN_CS_STOPPED == eCtrlState)
        {
            /* Notify the CanIf about a successfully transition. */
            Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_STOPPED);
            /* If the controller is already in STOP state, return E_OK. */
            eReturnValue = E_OK;
        }
        else
        {
            /* Evaluate transition */
            if ( CAN_CS_STARTED == eCtrlState)
            {
                /*
                  (CAN263) The function Can_43_LLCE_SetControllerMode(CAN_CS_STOPPED) shall set the bits inside the CAN hardware such that the CAN controller
                           stops participating on the network.
                */
                eCommandReturnValue = Can_Llce_SendStopCmd( u8HwCtrl );
                if(LLCE_FW_SUCCESS == eCommandReturnValue)
                {
                    eReturnValue = E_OK;
                }
            }
            else if (CAN_CS_SLEEP == eCtrlState)
            {
                /*
                   (CAN267) If the CAN HW does not support a sleep mode, the transition from SLEEP to STOPPED shall return from the logical sleep mode
                */
                SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState= CAN_CS_STOPPED;
                SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
                /* Notify the CanIf about a successfully transition. */
                Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_STOPPED);

                /* Set API return code.*/
                eReturnValue = E_OK;
            }
            /* Report invalid transition */
            else
            {
                (void)Can_43_LLCE_ReportError((uint8)CAN_43_LLCE_SID_SET_CONTROLLER_MODE, (uint8)CAN_43_LLCE_E_TRANSITION);
            }
        }
    }

    return eReturnValue;
}


static Llce_Fw_ReturnType Can_Llce_SendStopCmd(uint8 u8HwCtrl)
{

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Variable for return status. */
    Llce_Fw_ReturnType eCommandReturnValue = LLCE_FW_NOTRUN;
    
    /* Timeout counter. */
    uint32          u32timeStart = 0U;
    uint32          u32timeElapsed = 0U;
    uint32          u32TicksDelayDuration = 0U;

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    /* Check if the command buffer is not already used by other command request */
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETCONTROLLERMODE;  

        /* Add command parameter. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetControllerMode.eTransition = LLCE_CAN_T_STOP;

        /* Send the command prepared above to the LLCE in order to be executed */
        eCommandReturnValue = Can_Llce_ExecuteIfCommand( u8HwCtrl );
    }
 
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    if (LLCE_FW_SUCCESS == eCommandReturnValue)
    {
        u32TicksDelayDuration = OsIf_MicrosToTicks(CAN_43_LLCE_TIMEOUT_DURATION, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
        
        u32timeStart = OsIf_GetCounter(CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);

        /* 
        [SWS_Can_00372] 
        In case the flag signals that the change takes no effect and the maximum time CanTimeoutDuration is elapsed,
        the function Can_SetControllerMode shall be left and the function Can_Mainfunction_Mode shall continue to poll the flag. 
        */
        do
        {
            u32timeElapsed += OsIf_GetElapsed(&u32timeStart, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            Can_Llce_MainFunctionMode(u8HwCtrl);
        } while ( (u32timeElapsed < u32TicksDelayDuration) && (CAN_CS_STOPPED != Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState) );
        
        #ifdef MCAL_ENABLE_FAULT_INJECTION
        MCAL_FAULT_INJECTION_POINT(CAN_43_LLCE_FIP_1_STOP_MODE_WHILE_LOOP);
        #endif
    }

    return eCommandReturnValue;
}

/*================================================================================================*/
/**
* @brief          Service to Perform software triggered state transitions of the CAN controller State machine.
* @details        Transition controller to Start state/mode.
*
*                 This routine is called by:
*                  - Can_Llce_SetControllerMode()
*
* @param[in]      u8HwCtrl CAN controller for which the init shall be done.
* @param[in]      pxBaudrateConfigPtr Configuration parameters for the controller baud rate settings
*
* @return         Std_ReturnType
* @retval         E_OK transition initiated
* @retval         E_NOT_OK development or production error
*
*/
static Std_ReturnType Can_Llce_SetControllerToStartMode(uint8 u8HwCtrl, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue;
    /* Timeout counter. */
    uint32          u32timeStart = 0U;
    uint32          u32timeElapsed = 0U;
    uint32          u32TicksDelayDuration = 0U;
    Llce_Can_CtrlStateType eLlceControllerMode = LLCE_CAN_UNINIT_CTRL;
    Can_ControllerStateType eCachedStateCopy;
    
#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();
#endif

    eReturnValue = Can_Llce_GetLlceControllerMode(u8HwCtrl, &eLlceControllerMode);

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
  if((FALSE == pxConfig->bHeadlessModeEnabled) || (TRUE == Can_Llce_bHeadlessInitDone_SetControllerToStartMode[u8HwCtrl]) )
  {
#endif

    if((Std_ReturnType)E_OK == eReturnValue)
    {
        eCachedStateCopy = Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState;
        if ((LLCE_CAN_START_PENDING == eLlceControllerMode) || 
            ((LLCE_CAN_STARTED == eLlceControllerMode) && (CAN_CS_STOPPED == eCachedStateCopy)))
        {
            /* FW is still performing START transition or has switched to START meanwhile  */
            eReturnValue = E_OK;
        }
        else
        {
            /* Valid transitions to Start mode are allowed only from Stop state. */
            if (( LLCE_CAN_STOPPED != eLlceControllerMode) || (CAN_CS_SLEEP == eCachedStateCopy))
            {
                (void)Can_43_LLCE_ReportError((uint8)CAN_43_LLCE_SID_SET_CONTROLLER_MODE, (uint8)CAN_43_LLCE_E_TRANSITION);
                eReturnValue = E_NOT_OK;
            }
            else
            {
               eReturnValue = Can_Llce_UpdateToStartMode(u8HwCtrl, pxBaudrateConfigPtr);
            }
        }
    }

    if ((Std_ReturnType)E_OK == eReturnValue)
    {
        u32TicksDelayDuration = OsIf_MicrosToTicks(CAN_43_LLCE_TIMEOUT_DURATION, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
        u32timeStart = OsIf_GetCounter(CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);

        /*
        [SWS_Can_00372]
        In case the flag signals that the change takes no effect and the maximum time CanTimeoutDuration is elapsed,
        the function Can_SetControllerMode shall be left and the function Can_Mainfunction_Mode shall continue to poll the flag. 
        */
        do
        {
            u32timeElapsed += OsIf_GetElapsed(&u32timeStart, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            Can_Llce_MainFunctionMode(u8HwCtrl);
        } while ( (u32timeElapsed < u32TicksDelayDuration) && (CAN_CS_STARTED != Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState) );
        
        #ifdef MCAL_ENABLE_FAULT_INJECTION
        MCAL_FAULT_INJECTION_POINT(CAN_43_LLCE_FIP_2_START_MODE_WHILE_LOOP);
        #endif
    }

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
  }
  else
  {
    Can_Llce_bHeadlessInitDone_SetControllerToStartMode[u8HwCtrl] = TRUE;

    Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState= CAN_CS_STARTED;
    
    /* Notify the CanIf about a successfully transition. */
    Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_STARTED);

    /* (CAN196) The function Can_43_LLCE_SetControllerMode shall enable interrupts that are needed in the new state.
    (CAN425)   Enabling of CAN interrupts shall not be executed, when CAN interrupts have been disabled by function CAN_DisableControllerInterrupts.
    */
    if ( CAN_INTERRUPT_ENABLED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eInterruptMode )
    {
        Can_Llce_EnableInterrupts(u8HwCtrl);
    }

    eReturnValue = E_OK;
  }
#endif

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief          Service to Perform software triggered state transitions of the CAN controller State machine.
* @details        Transition controller to Sleep state/mode.
*
*                 This routine is called by:
*                  - Can_Llce_SetControllerMode()
*
* @param[in]      u8HwCtrl CAN controller for which the init shall be done.
*
* @return         Std_ReturnType
* @retval         E_OK transition initiated
* @retval         E_NOT_OK development or production error
*
*/
static Std_ReturnType Can_Llce_SetControllerToSleepMode(uint8 u8HwCtrl)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue;
    Can_ControllerStateType eCtrlState = CAN_CS_UNINIT;

    if((Std_ReturnType)E_OK == Can_Llce_GetControllerMode(u8HwCtrl, &eCtrlState))
    {
        /*
           (PR-MCAL-3057) The Can driver shall not create a development error if the CanIf requests a transition to a state that was already reached.
        */
        if ( CAN_CS_SLEEP == eCtrlState )
        {
            /* If the controller is already in SLEEP state, return E_OK. */
            eReturnValue = E_OK;
        }
        else
        {
            /* Valid transitions to Sleep state are only from Stop state. */
            if ( CAN_CS_STOPPED != eCtrlState)
            {
               (void)Can_43_LLCE_ReportError((uint8)CAN_43_LLCE_SID_SET_CONTROLLER_MODE, (uint8)CAN_43_LLCE_E_TRANSITION);
            }
            else
            {
                /* Send stop command to cover intermediate states (e.g. START_PENDING) */
                eCommandReturnValue = Can_Llce_SendStopCmd(u8HwCtrl);

                /* Stop command may return success for START_PENDING or fail if already stopped */
                if( (LLCE_FW_SUCCESS == eCommandReturnValue) ||  (LLCE_ERROR_COMMAND_NOTACCEPTED == eCommandReturnValue) )
                {
                    eReturnValue = E_OK;

                    /*[CAN290]If the CAN HW does not support a sleep mode, the function Can_43_LLCE_SetControllerMode(CAN_CS_SLEEP) shall set the CAN controller to the logical sleep mode*/
                    /*[CAN405] This logical sleep mode shall left only, if function Can_43_LLCE_SetControllerMode(CAN_CS_STOPPED) is called.*/
                    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
                    Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_SLEEP;
                    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
                }
            }
        }
    }

    if((Std_ReturnType)E_OK == eReturnValue)
    {
        Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_SLEEP);
    }

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief          Service to write data into the Message buffer for transition
* @details        This routine is used in case enabled FD feature.
*
*                 This routine is called by:
*                  - Can_Llce_Write()
*
* @param[in]     TxMbDesc - Tx message buffer descriptor
*                u32MessageId - message id
*                SduDataPtr - Pointer to Sdu data
*                SduLength  - Sdu length
*                u16HohIndex - The index of HOH in the structure array which stores the information of configured HOHs
*                u8EnabledFD - Be TRUE if CAN FD is enabled, otherwise it is FALSE
*                u8FdPaddingValue - FD padding value
*
* @return        void
*/
static void Can_Llce_UpdateMB(const Can_43_LLCE_TxFrameInfoType* TxFrameInfo)
{
    /* Variable for byte index of the MB data. */
    uint32 u32MbDataIdx = 0U;
    /* The length of data which will be filled in MB */
    uint8  u8RealDataLength = (uint8)8U;
    /* Index of MB to be filled */
    uint16 u16MbFrameIdx = 0U;
    /* Variable for storing the ConfigReg of the MB. */
    uint32 u32MbConfig = 0U;

    uint32 u32Word0 = 0U;

    uint16 u16TxMbDescIdx = 0U;

    /* Pointer to the frame payload to be sent. */
    volatile uint8 * u8FramePayload = NULL_PTR;

    /* Retrieve Tx Mb Descriptor. TX Mb descriptor index delivered by LLCE in the caller is stored in u16MbFrameIdx inside TxMbDesc.*/
    u16TxMbDescIdx = TxFrameInfo->u16MbFrameIdx;
    
    /* Set-up the MB content for Tx. */
    /* Remember the PduId for reporting back to host core when the frame is really transmitted. */
    Can_SharedMemory.Can_Tx_aMbDesc[u16TxMbDescIdx].u16FrameTag2 = TxFrameInfo->u16FrameTag2;

    /* Remember the index into the configured hardware object configuration array in order to be used later for HTH management. */
    Can_SharedMemory.Can_Tx_aMbDesc[u16TxMbDescIdx].u16FrameTag1 = TxFrameInfo->u16FrameTag1;

    /* The options for ack interface are: 0-15 for interrupt processing, 16-21 for polling classes. */
    Can_SharedMemory.Can_Tx_aMbDesc[u16TxMbDescIdx].u8AckInterface = TxFrameInfo->u8AckInterface;

    Can_SharedMemory.Can_Tx_aMbDesc[u16TxMbDescIdx].u8EnableTxFrameMac = TxFrameInfo->u8EnableTxFrameMac;
    
    u32Word0 = ((uint32)TxFrameInfo->u32MessageId & CAN_LPDU_ID_MASK_U32);

    if ( CAN_LPDU_IDE_U32 == ((uint32)TxFrameInfo->u32MessageId & CAN_LPDU_IDE_U32))
    {
        /* Set the IDE field in the tx message buffer. */
        u32Word0 |= (LLCE_CAN_MB_IDE_U32);
    }
    else
    {
       /* Standard ID - need to shift left 18 bits. */
       u32Word0 <<= LLCE_CAN_MB_IDSTD_SHIFT_U32;
    }
    
    u16MbFrameIdx = Can_SharedMemory.Can_Tx_aMbDesc[u16TxMbDescIdx].u16MbFrameIdx;
    Can_SharedMemory.Can_aMb[u16MbFrameIdx].u32Word0 = u32Word0;

    u8FramePayload = Can_SharedMemory.Can_aMb[u16MbFrameIdx].u8Payload;
    /* Copy the data into the MB memory. The driver will not read from a null pointer SDU. */
    for ( u32MbDataIdx = 0U; u32MbDataIdx < TxFrameInfo->u32SduLength; u32MbDataIdx++)
    {
       ((volatile uint8*)u8FramePayload)[u32MbDataIdx] = ((const uint8*)TxFrameInfo->u8SduDataPtr)[u32MbDataIdx];
    }

    Can_Llce_ComputeMbConfig(TxFrameInfo->u32SduLength, TxFrameInfo->u32MessageId, TxFrameInfo->u8FdEnabled, &u32MbConfig, &u8RealDataLength);

    /* Pad with configured value if applicable */
    if ((uint8)TRUE == TxFrameInfo->u8FdEnabled)
    {
        for ( u32MbDataIdx = (uint8)TxFrameInfo->u32SduLength; u32MbDataIdx < u8RealDataLength ; u32MbDataIdx++)
        {
            u8FramePayload[u32MbDataIdx] = TxFrameInfo->u8FdPaddingValue;
        }
    }
    /* Add BRS feature to the message buffer. */
    Can_SharedMemory.Can_aMb[u16MbFrameIdx].u32Word1 = u32MbConfig;

    /* Timestamp buffer is not used for Tx frames. Storing HSE KeyHandle here. */
    /* KeyHandle shall be stored only if TxFrameMac is active */
    if((uint8)TRUE == TxFrameInfo->u8EnableTxFrameMac)
    {
        Can_SharedMemory.Can_aMb[u16MbFrameIdx].u32Timestamp = TxFrameInfo->u32TxHseKeyHandle;
    }
}


static void Can_Llce_ComputeMbConfig(uint32 SduLength, uint32 u32MessageId, uint8 u8EnabledFD, uint32* pu32MbConfig, uint8* pu8RealDataLength)
{
    /*u8DataLengthMax, u8DataLengthMin, u8LengthIndex index counter*/
    uint8  u8DataLengthCount = 0U;
    /*maximum threshold values for DLC*/
    const uint8 u8DataLengthMax[8] = {8U, 12U, 16U, 20U, 24U, 32U, 48U, 64U};
    /*minimum threshold values for DLC*/
    const uint8 u8DataLengthMin[8] = {0U, 9U, 13U, 17U, 21U, 25U, 33U, 49U};

    if (((uint8)SduLength) <= (uint8)u8DataLengthMax[0])
    {
        *pu32MbConfig |= (uint32)SduLength ;
        *pu8RealDataLength = (uint8)SduLength;
    }
    else
    {
        if ((((uint32)u32MessageId) & (uint32)CAN_LPDU_FD_U32) == CAN_LPDU_FD_U32 )
        {
            for (u8DataLengthCount=1U; u8DataLengthCount<8U; u8DataLengthCount++)
            {
                if ((((uint8)SduLength)<=(uint8)u8DataLengthMax[u8DataLengthCount])&&(((uint8)SduLength)>=(uint8)u8DataLengthMin[u8DataLengthCount]))
                {
                    *pu32MbConfig |= ((uint32)((uint32)8U+(uint32)u8DataLengthCount));
                    *pu8RealDataLength = (uint8)u8DataLengthMax[u8DataLengthCount];
                    break;
                }
            }
        }
    }

    /*check to see if CanIf bit send from the user enables FD*/
    if (((uint8)TRUE == u8EnabledFD) && ((((uint32)u32MessageId) & (uint32)CAN_LPDU_FD_U32) == CAN_LPDU_FD_U32 ))
    {
        /* Configure the tx mb as a CAN FD frame. */
        *pu32MbConfig |= LLCE_CAN_MB_FDF_U32;

        /* Enable BRS feature in order to allow receiving of all CAN Fd frames.*/
        *pu32MbConfig |= LLCE_CAN_MB_BRS_U32;
    }

}

/**
* @brief          Initialization of indicator, statuses, etc.
* @details        Initialization of indicator, statuses, etc.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
* @implements     Can_Llce_ExecuteIfCommand_Activity
*
*/
static Llce_Fw_ReturnType Can_Llce_ExecuteIfCommand(uint8 u8HwCtrl)
{
    uint32 u32timeStart = 0U;
    /* Timeout counter. */
    uint32          u32timeElapsed = 0U;
    uint32          u32TicksDelayDuration = 0U;
    Std_ReturnType  temp;
    Llce_Fw_ReturnType eReturnValue;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eReturnValue = LLCE_FW_NOTRUN;
    /* Trigger an interrupt to LLCE and wait until LLCE finishes ISR processing by checking non-dynamic flags. */
    Reg_Write32( LLCE_FIFO_PUSH0(LLCE_FIFO_CMD_BASE_ADDRESS(pxConfig->u8ActiveHif)), (uint32)u8HwCtrl);
    
    u32timeStart = OsIf_GetCounter(CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
    u32TicksDelayDuration = OsIf_MicrosToTicks(CAN_43_LLCE_TIMEOUT_DURATION, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);

    do
    {
        u32timeElapsed += OsIf_GetElapsed(&u32timeStart, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
        temp = Can_Llce_CheckCommandAvailable();
    }
    while ((u32timeElapsed < u32TicksDelayDuration) && ( (Std_ReturnType)E_NOT_OK == temp));

    #ifdef MCAL_ENABLE_FAULT_INJECTION
    MCAL_FAULT_INJECTION_POINT(CAN_43_LLCE_FIP_3_EXECUTE_CMD_WHILE_LOOP);
    #endif

    if (u32timeElapsed < u32TicksDelayDuration)
    {
        eReturnValue = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eReturnValue;
    }
    else
    {
        eReturnValue = LLCE_FW_NOTRUN;
    }

    return eReturnValue;
}

/**
* @brief          Send CREATE_AF_DESTINATION command.
* @details        Create a new destination rule for LLCE Advanced Feature.
*
* @param[in]      destRule - The destination to add to the LLCE destination list
* @param[out]     pu8RuleIdx - The index of the new destination in the LLCE list. Needed for SetAdvancedFilter.
*
* @return        Std_ReturnType. Result of the request.
* @retval        E_OK  Destination created
* @retval        E_NOT_OK  Error
*/
Std_ReturnType Can_Llce_CreateAfDestination(Can_Af_DestRulesType destRule, uint8* pu8RuleIdx)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_OK;
    
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {      
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_CREATE_AF_DESTINATION;
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.CreateAfDest.rule = destRule;       
        /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( pxConfig->u8DefaultController ))
        {
            *(pu8RuleIdx) = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.CreateAfDest.u8Idx;
        }
        else
        {
            eReturnValue = E_NOT_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

/**
* @brief          Send REMOVE_AF_DESTINATION command.
* @details        This service removes an existing destination for advanced features
*
* @param[in]     u8RuleIdx - The index of the destination to be removed from the LLCE list.
*
* @return        Std_ReturnType. Result of the request.
* @retval        E_OK  Destination removed
* @retval        E_NOT_OK  Error
*/

Std_ReturnType Can_Llce_RemoveAfDestination(uint8 u8RuleIdx)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_OK;
    
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {      
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_REMOVE_AF_DESTINATION;
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.RemoveAfDest = u8RuleIdx;
        /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( pxConfig->u8DefaultController ))
        {
            /* Set the return value. */
            eReturnValue = E_OK;
        }
        else
        {
            eReturnValue = E_NOT_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}


#if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0U) && ((LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT > 0U) || (LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0U) || (LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0U))
/**
* @brief          Create AF Destinations from driver configuration
* @details        Initialization of indicator, statuses, etc.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
static Llce_Fw_ReturnType Can_Llce_CreateConfiguredAfDestinations(void)
{
    /* Variable for indexing all the MBs from hardware unit chain (all controllers). */
    uint16 i = 0U;
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_SUCCESS;
    volatile Can_Af_DestRulesType* pAfRule;

#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
    const uint32 u32CoreId = Can_43_LLCE_GetCoreID();
#endif

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();
    pAfRule = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.CreateAfDest.rule);

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Load the destination rule lists. Use any controller. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_CREATE_AF_DESTINATION;

        for(i=0; i < (LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT); i++)
        {
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            /* Multicore: create only destinations mapped to this core */
            if(u32CoreId == Llce_Can_AfDestOwnerCoreId[i])
            {
#endif
                *pAfRule = Llce_Can_AfRoutingTable[i];
                #if ((LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0U) || (LLCE_CAN_ADVANCED_FEATURE_CAN2PCIE_CNT > 0U))
                    switch (pAfRule->eAfDestId)
                    {
                    case CAN_AF_CAN2ETH:
                        pAfRule->AfDest.Can2Eth.pu8Can2EthBuffAddr = (uint32)pLlce_Can_AfBuffer[i];
                        break;
                    case CAN_AF_CAN2PCIE:
                        pAfRule->AfDest.Can2Pcie.pu8Can2PcieBuffAddr = (uint32)pLlce_Can_AfBuffer[i];
                        break;
                    default:
                        /* Copying the buffer is only required for CAN2ETH and CAN2OTHER */
                        break;
                    }
                #endif
                /* Send the command prepared above to the LLCE in order to be executed */
                eReturnValue = Can_Llce_ExecuteIfCommand( pxConfig->u8DefaultController );
                if(LLCE_FW_SUCCESS == eReturnValue)
                {
                    Can_au8DestinationIdxMap[i] = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.CreateAfDest.u8Idx;
                }
                else
                {
                    break;
                }
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            }
#endif
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;

}
#endif

/**
* @brief          Send SETADVANCEDFILTER command.
* @details        Initialization of filters which include AF rules.
*                 This routine is called by:
*                 - Can_Llce_AfInit from Can_Llce.c file.
*
* @pre            The AF rules must be set in advance.
* @post           Set the filters and AF rules as generated in configuration.
*
*/
#if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0)
static void Can_Llce_SetConfiguredAfFilters(void)
{
    uint8 u8HwCtrl = 0U;
    uint8 u8CtrlIndex;
    uint16 crtFilter = 0U;
    uint8 filterLoadedCount = 0U;
    Llce_Can_AdvancedFilterType * filterList;
    volatile Llce_Can_SetAdvancedFilterCmdType * pSAFCmd;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    for ( u8CtrlIndex = 0U; u8CtrlIndex < CAN_43_LLCE_MAXCTRL_CONFIGURED; u8CtrlIndex++)
    {
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
        if(Can_43_LLCE_GetCoreID() == pxConfig->aControllerDescriptors[u8CtrlIndex].u32CoreId)
        {
#endif
            u8HwCtrl = pxConfig->aControllerDescriptors[u8CtrlIndex].u8HwCtrl;

            /* Skip disabled controllers */
            if(LLCE_NULL_OFFSET_U8 != u8HwCtrl)
            {
                /*Configure the command id for all controllers which are used. */
                Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETADVANCEDFILTER;
                
                pSAFCmd = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter);

                filterList = pxConfig->paAdvancedFilters[u8HwCtrl];
                filterLoadedCount = 0U;

                for(crtFilter = 0U; crtFilter < pxConfig->pPlatfInitConfig->au16MaxAdvancedFilterCount[u8HwCtrl]; crtFilter++)
                {
                    /* Copy the AF filter to the shared memory */
                    pSAFCmd->aAdvancedFilters[filterLoadedCount] = filterList[crtFilter];

                  #if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0) && ((LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0))
                    /* Update the destination index to the actual value in FW */
                    if(LLCE_CAN_ADVANCED_FILTER_NOT_USED != filterList[crtFilter].Llce_Can_AdvancedFeature.u8Can2CanRoutingTableIdx)
                    {
                        pSAFCmd->aAdvancedFilters[filterLoadedCount].Llce_Can_AdvancedFeature.u8Can2CanRoutingTableIdx = Can_au8DestinationIdxMap[filterList[crtFilter].Llce_Can_AdvancedFeature.u8Can2CanRoutingTableIdx];
                    }
                    if(LLCE_CAN_ADVANCED_FILTER_NOT_USED != filterList[crtFilter].Llce_Can_AdvancedFeature.u8Can2EthRoutingTableIdx)
                    {
                        pSAFCmd->aAdvancedFilters[filterLoadedCount].Llce_Can_AdvancedFeature.u8Can2EthRoutingTableIdx = Can_au8DestinationIdxMap[filterList[crtFilter].Llce_Can_AdvancedFeature.u8Can2EthRoutingTableIdx];
                    }
                  #endif

                    /* Increase the count of the filters.*/
                    filterLoadedCount++;

                    /* Check if the command buffer for filters is full. */
                    if (LLCE_CAN_CONFIG_ADVANCED_FILTERS_COUNT == filterLoadedCount)
                    {
                        pSAFCmd->u16RxFiltersCount = filterLoadedCount;

                        (void)Can_Llce_SendSetAfFilterCommand(pSAFCmd->aAdvancedFilters, filterLoadedCount, u8HwCtrl);

                        /* Reset the number of filters. */
                        filterLoadedCount = 0;
                    }

                    #if (CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED == STD_ON)
                      /* Save reference to filter config for later usage. */
                      Can_Llce_apRxHrh2AfFilterCfg[filterList[crtFilter].Llce_Can_RxFilter.u16FilterId] = &(filterList[crtFilter]);
                    #endif
                }

                /* Load remaining filters if any*/
                if (filterLoadedCount > 0U)
                {
                    pSAFCmd->u16RxFiltersCount = filterLoadedCount;

                    (void)Can_Llce_SendSetAfFilterCommand(pSAFCmd->aAdvancedFilters, filterLoadedCount, u8HwCtrl);

                    /* Reset the number of filters. */
                    filterLoadedCount = 0;
                }
            }
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
        }
#endif
    }
}
#endif /* LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0 */

static Std_ReturnType Can_Llce_SendSetAfFilterCommand(const volatile Llce_Can_AdvancedFilterType *pAfFilters, uint8 filterLoadedCount, uint8 u8HwCtrl)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue = LLCE_FW_NOTRUN;

    #if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U)
    uint8 i = 0U;
    #endif

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {             
        /* Send the command prepared above to the LLCE in order to be executed */
        eCommandReturnValue =  Can_Llce_ExecuteIfCommand(u8HwCtrl);
    }

    if (LLCE_FW_SUCCESS == eCommandReturnValue)
    {
        #if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U)
        /* Copy the hw filter addr for later usage. */
        for(i = 0; i < filterLoadedCount; i++)
        {  
            Can_Llce_au16RxHrh2FilterAddr[pAfFilters[i].Llce_Can_RxFilter.u16FilterId] = pAfFilters[i].Llce_Can_RxFilter.u16FilterAddr;                                
        }
        #else
        (void)pAfFilters;
        (void)filterLoadedCount;
        #endif
        eReturnValue = E_OK;
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}





/**
* @brief          Check user callback
* @details        Check if the RX filter is configured with custom user callback, and execute it if so
*
* @return         TRUE if frame should be delivered (no custom processing or custom callback returned TRUE), FALSE otherwise
*/
#if (CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED == STD_ON)
static boolean Can_Llce_CheckCustomCallback(uint16 u16HrhId, uint32 u32MbMessageId, uint8 u8MbDataLength, uint8* u8FramePayload, uint16 u16RxMbDescIdx)
{
    boolean returnValue = TRUE;
    const Llce_Can_AdvancedFilterType * pAfFilter;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Custom processing can only apply to Advanced Filters */
    if(CAN_43_LLCE_RECEIVE_AF == pxConfig->aHohList[u16HrhId].eMBType)
    {
        pAfFilter = Can_Llce_apRxHrh2AfFilterCfg[u16HrhId];

        /* Check if custom processing is enabled */
        if(LLCE_AF_CUSTOMPROCESSING_ENABLED == pAfFilter->Llce_Can_AdvancedFeature.eCanCustomProcessing)
        {
            returnValue = Can_43_LLCE_CustomRxCallback((uint8)u16HrhId, u32MbMessageId, u8MbDataLength, u8FramePayload, u16RxMbDescIdx);
        }
    }

    return returnValue;
}
#endif
/*=================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
/**
* @brief          Removes receive filter.
* @details        Removes a single filter and make it unavailable for filtering..
*                 This routine is called by:
*
* @param[in]     Hrh - Hardware receive handler configured by user.
* @param[in]     u16FilterAddr - address of the removed filter, to be later used by Can_Llce_SetFilterAtAddress.
*
* @pre            Platform shall be insialized and the related controller initialized.
* @post           The related controller acept frames received by the filter if is started.
*
*/
Std_ReturnType Can_Llce_RemoveFilter(Can_HwHandleType Hrh, uint16* u16FilterAddr)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;

#if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U)
    uint8 u8HwCtrl;
    uint8 u8LogicCtrl;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

  if((CAN_43_LLCE_FIRST_HTH_CONFIGURED > Hrh) && (NULL_PTR != u16FilterAddr))
  {
      /* Get the logical controller id corresponding to the above hrh */
      u8LogicCtrl = pxConfig->aHohList[Hrh].u8ControllerId;

      /* Get the hardware controller corresponding to above logical controller */
      u8HwCtrl = pxConfig->aControllerDescriptors[u8LogicCtrl].u8HwCtrl;

      if(Can_Llce_au16RxHrh2FilterAddr[Hrh] != CAN_LLCE_FILTER_DEFAULT_EMPTY_ADDRESS_U16)
      {
          SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
          if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
          {                
              /*Configure the command id for all controllers which are used. */
              Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_REMOVE_FILTER;

              /*Initialize the number of filters for all controllers which are used. */
               Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.ChangeFilter.u16FilterAddr = Can_Llce_au16RxHrh2FilterAddr[Hrh]; 
               /* Return the filter address from LLCE RxLut so that the SetFilterAtAddress function can use it */
               *u16FilterAddr = Can_Llce_au16RxHrh2FilterAddr[Hrh]; 
       
              /* Send the command prepared above to the LLCE in order to be executed */
              if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( u8HwCtrl ))
              {                      
                  Can_Llce_au16RxHrh2FilterAddr[Hrh] = CAN_LLCE_FILTER_DEFAULT_EMPTY_ADDRESS_U16;
                  /* Set the return value. */
                  eReturnValue = E_OK;
              }
          }
          
          SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
      }
  }

#else /* (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U) */
        (void)Hrh;
        (void)eReturnValue;
        (void)u16FilterAddr;
#endif /* (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U) */

    return eReturnValue;
}

/**
* @brief          Set receive filter.
* @details        Set a single filter inside hw module.
*                 This routine is called by:
*                 - Can_43_LLCE_SetFilter() from Can_43_LLCE.c file.
*
* @pre            Platform shall be initialized and the related controller initialized.
* @post           The related controller accepts frames received by the filter if is started.
*
*
*/
Std_ReturnType Can_Llce_SetFilter(const Can_SetFilterType * pCanFilter)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    uint8 u8HwCtrl;
    uint8 u8LogicCtrl;
    volatile Llce_Can_ReceiveFilterType * pRxFilter = NULL_PTR;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Get the logical controller id corresponding to the current HRH */
    u8LogicCtrl = pxConfig->aHohList[pCanFilter->Hrh].u8ControllerId;

    /* Get the hardware controller corresponding to above logical controller */
    u8HwCtrl = pxConfig->aControllerDescriptors[u8LogicCtrl].u8HwCtrl;
   
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    /* Check if the command buffer is not already used by other command request. */
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /*Configure the command id for all controllers which are used. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETFILTER;

        pRxFilter = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetFilter.aRxFilters[0U]);
        /*Set a single receive filter inside LLCE for timing reasons. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetFilter.u16RxFiltersCount = 1U; 

        pRxFilter->eEntryType = pCanFilter->eFilterType;

        pRxFilter->u16FilterId = pCanFilter->Hrh;

        pRxFilter->uIdMask = pCanFilter->uIdMask;

        /* Set Rx interface for current filter. First 16 interfaces (0-15) are reserved for interrupt processing, next 6 interfaces (16-21) are for polling classes. */
        pRxFilter->u8RxDestInterface = pCanFilter->u8RWInterface;

        pRxFilter->uMessageId = pCanFilter->uMessageId;
        
        pRxFilter->u16MbCount = pCanFilter->u16MbCount;

        pRxFilter->eFilterMbLength = pCanFilter->eFilterMbLength;

        Can_Llce_ProcessFilterIdMaskType(pCanFilter->eIdType, pRxFilter);

        eReturnValue = Can_Llce_SendSetFilterCommand(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetFilter.aRxFilters, 1U /* filterLoadedCount */, u8HwCtrl);
    }
   
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

/**
* @brief          Set receive filter.
* @details        Set a single filter inside hw module.
*                 This routine is called by:
*                 - Can_43_LLCE_SetFilter() from Can_43_LLCE.c file.
*
* @pre            Platform shall be initialized and the related controller initialized.
* @post           The related controller accepts frames received by the filter if is started.
*
*
*/
Std_ReturnType Can_Llce_SetFilterAtAddress(const Can_SetFilterType * pCanFilter, const uint16 u16FilterAddr)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    uint8 u8HwCtrl;
    uint8 u8LogicCtrl;
    volatile Llce_Can_ReceiveFilterType * pRxFilter = NULL_PTR;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Get the logical controller id corresponding to the current HRH */
    u8LogicCtrl = pxConfig->aHohList[pCanFilter->Hrh].u8ControllerId;

    /* Get the hardware controller corresponding to above logical controller */
    u8HwCtrl = pxConfig->aControllerDescriptors[u8LogicCtrl].u8HwCtrl;
   
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    /* Check if the command buffer is not already used by other command request. */
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /*Configure the command id for all controllers which are used. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETFILTER_AT_ADDRESS;
        /*TDO : memorise the filter id*/

        pRxFilter = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetFilter.aRxFilters[0U]);
        /*Set a single receive filter inside LLCE for timing reasons. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetFilter.u16RxFiltersCount = 1U; 

        pRxFilter->u16FilterAddr = u16FilterAddr;

        pRxFilter->eEntryType = pCanFilter->eFilterType;

        pRxFilter->u16FilterId = pCanFilter->Hrh;

        pRxFilter->uIdMask = pCanFilter->uIdMask;

        /* Set Rx interface for current filter. First 16 interfaces (0-15) are reserved for interrupt processing, next 6 interfaces (16-21) are for polling classes. */
        pRxFilter->u8RxDestInterface = pCanFilter->u8RWInterface;

        pRxFilter->uMessageId = pCanFilter->uMessageId;
        
        pRxFilter->u16MbCount = pCanFilter->u16MbCount;

        pRxFilter->eFilterMbLength = pCanFilter->eFilterMbLength;

        Can_Llce_ProcessFilterIdMaskType(pCanFilter->eIdType, pRxFilter);

        eReturnValue = Can_Llce_SendSetFilterCommand(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetFilter.aRxFilters, 1U /* filterLoadedCount */, u8HwCtrl);
    }
   
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

/**
* @brief          Set advanced receive filter.
* @details        Set a single advanced filter inside hw module.
*                 This routine is called by:
*                 - Can_43_LLCE_SetAfFilter() from Can_43_LLCE.c file.
*
* @pre            Platform shall be initialized and the related controller initialized.
* @post           The related controller accepts frames received by the filter if is started.
*
*
*/
Std_ReturnType Can_Llce_SetAfFilter(const Can_SetAfFilterType * pAfFilter)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue;
    uint8 u8HwCtrl;
    uint8 u8LogicCtrl;
    volatile Llce_Can_ReceiveFilterType * pRxFilter = NULL_PTR;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Get the logical controller id corresponding to the current HRH */
    u8LogicCtrl = pxConfig->aHohList[pAfFilter->Filter.Hrh].u8ControllerId;

    /* Get the hardware controller corresponding to above logical controller */
    u8HwCtrl = pxConfig->aControllerDescriptors[u8LogicCtrl].u8HwCtrl;
   
    /*Configure the command id for all controllers which are used. */
    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETADVANCEDFILTER;

    /*Set a single receive filter inside LLCE for timing reasons. */
    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.u16RxFiltersCount = 1U; 

    pRxFilter = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.aAdvancedFilters[0U].Llce_Can_RxFilter);

    pRxFilter->eEntryType = pAfFilter->Filter.eFilterType;

    pRxFilter->u16FilterId = pAfFilter->Filter.Hrh;        

    pRxFilter->uIdMask = pAfFilter->Filter.uIdMask;

    /* Set Rx interface for current filter. First 16 interfaces (0-15) are reserved for interrupt processing, next 6 interfaces (16-21) are for polling classes. */
    pRxFilter->u8RxDestInterface = pAfFilter->Filter.u8RWInterface;

    pRxFilter->uMessageId = pAfFilter->Filter.uMessageId;
    
    pRxFilter->u16MbCount = pAfFilter->Filter.u16MbCount;

    Can_Llce_ProcessFilterIdMaskType(pAfFilter->Filter.eIdType, pRxFilter);
    
    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.aAdvancedFilters[0U].Llce_Can_AdvancedFeature = pAfFilter->AdvancedFeature;

    eReturnValue = Can_Llce_SendSetAfFilterCommand(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.aAdvancedFilters, 1U /* filterLoadedCount */, u8HwCtrl);

    return eReturnValue;
}

/**
* @brief          Set advanced receive filter at given address.
* @details        Set a single advanced filter inside hw module.
*                 This routine is called by:
*                 - Can_43_LLCE_SetAfFilterAtAddress from Can_43_LLCE.c file.
*
* @pre            Platform shall be initialized and the related controller initialized.
* @post           The related controller accepts frames received by the filter if it is started.
*
*
*/
Std_ReturnType Can_Llce_SetAfFilterAtAddress(const Can_SetAfFilterType * pAfFilter, const uint16 u16FilterAddr)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue;
    uint8 u8HwCtrl;
    uint8 u8LogicCtrl;
    volatile Llce_Can_ReceiveFilterType * pRxFilter = NULL_PTR;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Get the logical controller id corresponding to the current HRH */
    u8LogicCtrl = pxConfig->aHohList[pAfFilter->Filter.Hrh].u8ControllerId;

    /* Get the hardware controller corresponding to above logical controller */
    u8HwCtrl = pxConfig->aControllerDescriptors[u8LogicCtrl].u8HwCtrl;
   
    /*Configure the command id for all controllers which are used. */
    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETADVANCEDFILTER_AT_ADDRESS;
    
    /*Set a single receive filter inside LLCE for timing reasons. */
    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.u16RxFiltersCount = 1U; 

    pRxFilter = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.aAdvancedFilters[0U].Llce_Can_RxFilter);

    pRxFilter->u16FilterAddr = u16FilterAddr;

    pRxFilter->eEntryType = pAfFilter->Filter.eFilterType;

    pRxFilter->u16FilterId = pAfFilter->Filter.Hrh;        

    pRxFilter->uIdMask = pAfFilter->Filter.uIdMask;

    /* Set Rx interface for current filter. First 16 interfaces (0-15) are reserved for interrupt processing, next 6 interfaces (16-21) are for polling classes. */
    pRxFilter->u8RxDestInterface = pAfFilter->Filter.u8RWInterface;

    pRxFilter->uMessageId = pAfFilter->Filter.uMessageId;
    
    pRxFilter->u16MbCount = pAfFilter->Filter.u16MbCount;

    Can_Llce_ProcessFilterIdMaskType(pAfFilter->Filter.eIdType, pRxFilter);
    
    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.aAdvancedFilters[0U].Llce_Can_AdvancedFeature = pAfFilter->AdvancedFeature;

    eReturnValue = Can_Llce_SendSetAfFilterCommand(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAdvancedFilter.aAdvancedFilters, 1U /* filterLoadedCount */, u8HwCtrl);

    return eReturnValue;
}

/**
* @brief          Enable/disable receive filter.
* @details        Set enabled state for a single filter. Its configuration is still in LLCE and my be 
*                 reactivated later.
*/
Std_ReturnType Can_Llce_SetFilterState(Can_HwHandleType Hrh, Can_43_LLCE_FilterStateType eState)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
#if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U)
    uint8 u8HwCtrl;
    uint8 u8LogicCtrl;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

  if(CAN_43_LLCE_FIRST_HTH_CONFIGURED > Hrh )
  {
      /* Get the logical controller id corresponding to the above hrh */
      u8LogicCtrl = pxConfig->aHohList[Hrh].u8ControllerId;

      /* Get the hardware controller corresponding to above logical controller */
      u8HwCtrl = pxConfig->aControllerDescriptors[u8LogicCtrl].u8HwCtrl;

      if(Can_Llce_au16RxHrh2FilterAddr[Hrh] != CAN_LLCE_FILTER_DEFAULT_EMPTY_ADDRESS_U16)
      {
          SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
          if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
          { 
              /*Configure the command id for all controllers which are used. */
              Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETFILTERENABLESTATUS;

              /*Initialize the number of filters for all controllers which are used. */
              Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.ChangeFilter.u16FilterAddr = Can_Llce_au16RxHrh2FilterAddr[Hrh]; 
              Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.ChangeFilter.u8FilterEnabled = (uint8)eState;
          
              /* Send the command prepared above to the LLCE in order to be executed */
              if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( u8HwCtrl ))
              {                      
                  /* Set the return value. */
                  eReturnValue = E_OK;
              }
          }
          SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
      }
  }

#else /* (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U) */
        (void)Hrh;
        (void)eReturnValue;
        (void)eState;
#endif /* (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U) */

    return eReturnValue;
}

/**
* @brief          Enable/disable channel.
* @details        Set state of controller in a multicast routing configuration. 
* 
*/
Std_ReturnType Can_Llce_SetChannelRoutingOutputState(uint8 u8HwCtrl, Can_43_LLCE_ChannelStateType eChannelStatus)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /*Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETCHANNELROUTINGOUTPUTSTATE;

        if(CAN_43_LLCE_CHANNELSTATE_ENABLED == eChannelStatus)
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.eBinaryValue = LLCE_TRUE;
        }
        else
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.eBinaryValue = LLCE_FALSE;
        }

        /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( u8HwCtrl ))
        {                      
            /* Set the return value. */
            eReturnValue = E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}
/**
* @brief          Initialization of indicator, statuses, etc.
* @details        Initialization of indicator, statuses, etc.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
static void Can_Llce_InitVariables(const Can_43_LLCE_ConfigType * pxCurrentConfig, uint8 u8ControllersCount)
{
    /* Index CAN controllers from configuration. */
    uint8 u8CtrlIndex = 0U;
    /* Set local pointer to configuration structure */
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();
    Can_Llce_pxGlobalConfigs[u32CoreId] = pxCurrentConfig;
#else
    Can_Llce_pxGlobalConfigs[0] = pxCurrentConfig;
#endif

    uint8 u8HwCtrl = 0U;

    /* Init all global varibales/statuses for all controllers. */
    for ( u8CtrlIndex = 0U; u8CtrlIndex < u8ControllersCount; u8CtrlIndex++)
    {
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
        if(pxCurrentConfig->aControllerDescriptors[u8CtrlIndex].u32CoreId == u32CoreId )
        {    
#endif
            u8HwCtrl = pxCurrentConfig->aControllerDescriptors[u8CtrlIndex].u8HwCtrl;
            /* check for enabled controller */
            if(CAN_43_LLCE_NULL_OFFSET != u8HwCtrl)
            {
                /* Init INT Disable nesting indicator. It is incremented after every call of Can_43_LLCE_DisableControllerInterrupts().
                The function Can_43_LLCE_EnableControllerInterrupts() shall perform no action when Can_43_LLCE_DisableControllerInterrupts() has not been called before. */
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].u8IntDisableLevel = (uint8)0;

                /* Set  interrupt mode status to interrupt enabled mode.
                This is needed in order to support the implementation of requirements CAN425 and CAN426 into Can_43_LLCE_SetControllerMode API. */
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eInterruptMode= CAN_INTERRUPT_ENABLED;

                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eSetIntEnRequest= CAN_INTERRUPT_DISABLED;

                Can_Llce_au8FifoSetIntEnCnt[u8HwCtrl] = 0U;
            }
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
        }
#endif
    }

#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
    /* Init sw fifo used for errors buffering */
    (void)Llce_SwFifo_Init(Can_Llce_aNotif1_Table, (uint8)(sizeof(Llce_Can_NotificationType)), (uint16)(LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE), &Can_Llce_xNotifSwFifo);
#endif

}


static void Can_Llce_ProcessFilterIdMaskType(Llce_Can_IdLengthType eIdType, volatile Llce_Can_ReceiveFilterType * pxFilter)
{
    /* Range filters must not have values changed */
    if(pxFilter->eEntryType != LLCE_CAN_ENTRY_CFG_RANGED)
    {
        /* Mask the ID and Mask in order to not allow the user to configure more than 29 bits. */
        pxFilter->uIdMask &= LLCE_CAN_MB_29BIT_MASK_U32;
        pxFilter->uMessageId &= LLCE_CAN_MB_29BIT_MASK_U32;

        switch(eIdType)
        {
        case LLCE_CAN_STANDARD:
            /* Add IDE to Mask.*/
            pxFilter->uIdMask |= LLCE_CAN_MB_IDE_U32;
            break;

        case LLCE_CAN_EXTENDED:
            /* Add IDE to Mask.*/
            pxFilter->uIdMask |= LLCE_CAN_MB_IDE_U32;
            /* Add IDE bit to ID. Only Extended ID. */
            pxFilter->uMessageId |= LLCE_CAN_MB_IDE_U32;
            break;

        case LLCE_CAN_MIXED:
            /* Remove IDE from Mask.*/
            pxFilter->uIdMask &= ~(LLCE_CAN_MB_IDE_U32);
            break;

        default:
            /* Bad identifier type  */
            break; 
        }
    }
}
/**
* @brief          Perform INIT_HSE command.
* @details        Enable HSE support in the firmware if hardware support it for MAC generation and verification.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
* @pre            
* @post           
*/
#if (CAN_43_LLCE_HSE_SUPPORT_ENABLE == STD_ON)
static Llce_Fw_ReturnType Can_Llce_InitHse( void )
{
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_ERROR;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Prepare command.*/
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId  = LLCE_CAN_CMD_INIT_HSE;

        /* Execute command.*/
        eReturnValue = Can_Llce_ExecuteIfCommand( pxConfig->u8DefaultController );
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}
#endif

/**
* @brief          Perform standard Autosar initialization flow.
* @details        Service which initializes LLCE using multiple commands, as expected by LLCE firmware:
*                 LLCE_CAN_CMD_INIT_PLATFORM - initialization of common LLCE services and buffer reservation 
*                 LLCE_CAN_CMD_INIT_HSE - initialization of HSE advanced service. Enabled only with FDK LLCE sw package.
*                 LLCE_CAN_CMD_INIT - initialization of each controller in configuration with default baudrate as per configuration
*                 LLCE_CAN_CMD_SETFILTER - configuration of filters for each channel, as per configuration
*                 LLCE_CAN_CMD_CREATE_AF_DESTINATION - creation of destinations for the messages to be forwarded to
*                 LLCE_CAN_CMD_SETADVANCEDFILTER - configuration of advanced filters, mapped to the AF destinations created previously
*                 This routine is called by:
*                 - Can_43_LLCE_IPW_Init from Can_43_LLCE_IPW.c file.
*
* @pre            LLCE is not initialized
* @post           LLCE is initialized using the Autosar configuration. The controllers are in STOP state
*/
Llce_Fw_ReturnType Can_Llce_Init(const Can_43_LLCE_ConfigType * pxCurrentConfig)
{
    Llce_Fw_ReturnType eReturnValue;
#if (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON)
    uint8 i;
#endif

    eReturnValue = Can_Llce_InitPlatform(pxCurrentConfig, CAN_43_LLCE_MAXCTRL_CONFIGURED);

    if(LLCE_FW_SUCCESS == eReturnValue)
    {

        #if (CAN_43_LLCE_HSE_SUPPORT_ENABLE == STD_ON)
        eReturnValue = Can_Llce_InitHse();

        if(LLCE_FW_SUCCESS == eReturnValue)
        {
        #endif
            eReturnValue = Can_Llce_InitController();
            if(LLCE_FW_SUCCESS == eReturnValue)
            {
                Can_Llce_SetConfiguredReceiveFilters();
                #if (RXLUT2_ENABLE == STD_ON)
                Can_Llce_SetConfiguredAuxReceiveFilters();
                #endif
                #if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0)
                Can_Llce_AfInit();
                #endif
                #if (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON)
                for(i = 0U; i < LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_FORMAT_CNT; i++)
                {
                    eReturnValue = Can_Llce_SetEth2CanFormatState(Llce_Eth2Can_EnabledFormats[i], CAN_LLCE_ETH2CAN_ENABLED);
                }
                #endif
            }
        #if (CAN_43_LLCE_HSE_SUPPORT_ENABLE == STD_ON)
        }
        #endif
    }

    return eReturnValue;
}
/**
* @brief          Perform INIT_PLATFORM command.
* @details        Write variables from interface into shared memory.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
static Llce_Fw_ReturnType Can_Llce_InitPlatform(const Can_43_LLCE_ConfigType * pxCurrentConfig, uint8 u8ControllersCount)
{
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_ERROR;
#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
  #if defined(S32G3XX)
    uint8 u8HwCtrl;
  #endif
#endif

    /* Initialize local variable used by the driver. */
    Can_Llce_InitVariables(pxCurrentConfig, u8ControllersCount);

    /* Reset the notification interrupt enable. */
    Can_u16NotifIntrEnable[pxCurrentConfig->u8ActiveHif] = 0;

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
    if((FALSE == pxCurrentConfig->bHeadlessModeEnabled) || (TRUE == Can_Llce_bHeadlessInitDone_InitPlatform) )
    {
#endif
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Prepare command for initialization of common elements of the platform.*/
        Can_SharedMemory.aCanCmd[pxCurrentConfig->u8ActiveHif].eCmdId  = LLCE_CAN_CMD_INIT_PLATFORM;

        Can_SharedMemory.aCanCmd[pxCurrentConfig->u8ActiveHif].CmdList.InitPlatform =  *(pxCurrentConfig->pPlatfInitConfig);

        eReturnValue = Can_Llce_ExecuteIfCommand( pxCurrentConfig->u8DefaultController );
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
    } else {
    #if defined(S32G3XX)
        /* Calculate filter intervals in RXLUT */
        Can_Llce_au16RxLutCounter[0] = 0U;
        for(u8HwCtrl = 0U; u8HwCtrl < LLCE_CAN_CONFIG_MAXCTRL_COUNT - 1U; u8HwCtrl++)
        {
            Can_Llce_au16RxLutCounter[u8HwCtrl + 1U] = Can_Llce_au16RxLutCounter[u8HwCtrl] + 
                                                      pxCurrentConfig->pPlatfInitConfig->au16MaxRegularFilterCount[u8HwCtrl] +
                                                      pxCurrentConfig->pPlatfInitConfig->au16MaxAdvancedFilterCount[u8HwCtrl]; 
        }
    #endif /* defined(S32G3XX) */
    eReturnValue = LLCE_FW_SUCCESS;    
    Can_Llce_bHeadlessInitDone_InitPlatform = TRUE;
    }
#endif

    return eReturnValue;
}

/**
* @brief          Perform INIT command.
* @details        Initialization of indicator, statuses, etc.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
static Llce_Fw_ReturnType Can_Llce_InitController(void)
{
    uint8 u8HwCtrl = 0U;
    uint8 u8CtrlIndex = 0u;
    /* Variable for return status. */
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_SUCCESS;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    while((u8CtrlIndex < (uint8)CAN_43_LLCE_MAXCTRL_CONFIGURED) && (LLCE_FW_SUCCESS == eReturnValue))
    {
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
        if(Can_43_LLCE_GetCoreID() == pxConfig->aControllerDescriptors[u8CtrlIndex].u32CoreId)
        {
#endif
            /* Skip the initialization for the controllers that are not enabled. */
            if ( pxConfig->aControllerDescriptors[u8CtrlIndex].u8HwCtrl != (uint8)LLCE_NULL_OFFSET_U8 )
            {
                u8HwCtrl = pxConfig->aControllerDescriptors[u8CtrlIndex].u8HwCtrl;
                /* Init INT Disable nesting indicator. It is incremented after every call of Can_43_LLCE_DisableControllerInterrupts().
                The function Can_43_LLCE_EnableControllerInterrupts() shall perform no action when Can_43_LLCE_DisableControllerInterrupts() has not been called before. */
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].u8IntDisableLevel = (uint8)0U;

                /* Set  interrupt mode status to interrupt enabled mode.
                This is needed in order to support the implementation of requirements CAN425 and CAN426 into Can_43_LLCE_SetControllerMode API. */
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eInterruptMode= CAN_INTERRUPT_ENABLED;

              #if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
              if((FALSE == pxConfig->bHeadlessModeEnabled) || (TRUE == Can_Llce_bHeadlessInitDone_InitController) )
              {
              #endif
                /*Reset Interrupt Status Flags*/
                Can_Llce_ResetIntFlags(u8HwCtrl);

                SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
                /* Check if a previous command is ongoing. */
                if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
                {                     
                    /* Configure the command id */
                    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId  = LLCE_CAN_CMD_INIT;
                    
                    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.Init = pxConfig->pChannelInitConfig[u8HwCtrl];

                    eReturnValue = Can_Llce_ExecuteIfCommand(u8HwCtrl);

                    if (LLCE_FW_SUCCESS == eReturnValue)
                    {
                        Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_STOPPED;
                    }
                }

                SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

              #if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
              }
              #endif
            }
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
        }
#endif
        u8CtrlIndex++;
    }

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
    Can_Llce_bHeadlessInitDone_InitController = TRUE;
#endif

    return eReturnValue;
}

/**
* @brief          Writes configuration to memory and sends SETFILTER for all enabled controllers.
* @details        Initialization of indicator, statuses, etc.
*                 This function is non-reentrant and does not provide thread safety
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
static void Can_Llce_SetConfiguredReceiveFilters(void)
{
    uint8 u8HwCtrl = 0U;
    uint8 u8CtrlIndex;
    uint16 crtFilter;
    uint8 filterLoadedCount = 0U;
    const Llce_Can_ReceiveFilterType * filterList;
    volatile Llce_Can_SetFilterCmdType * pSFCmd;
    Std_ReturnType eReturnValue = (Std_ReturnType)E_OK;
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
    uint32 u32CoreId;
#endif

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
  /* Skip first entry for headless mode */
  if((FALSE == pxConfig->bHeadlessModeEnabled) || (TRUE == Can_Llce_bHeadlessInitDone_SetConfiguredReceiveFilters) )
  {
#endif
    /* Check if the command buffer is not already used by other command request. */
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        for (u8CtrlIndex = 0U; (u8CtrlIndex < CAN_43_LLCE_MAXCTRL_CONFIGURED); u8CtrlIndex++)
        {
            u8HwCtrl = pxConfig->aControllerDescriptors[u8CtrlIndex].u8HwCtrl;

            /* Skip disabled controllers */
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            u32CoreId = Can_43_LLCE_GetCoreID();
            if((u32CoreId == pxConfig->aControllerDescriptors[u8CtrlIndex].u32CoreId) && (LLCE_NULL_OFFSET_U8 != u8HwCtrl))
#else
            if(LLCE_NULL_OFFSET_U8 != u8HwCtrl)
#endif
            {
                /*Configure the command id for all controllers which are used. */
                Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETFILTER;
                pSFCmd = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetFilter);
                
                filterList = pxConfig->paReceiveFilters[u8HwCtrl];
                filterLoadedCount = 0U;
                crtFilter = 0u;
                while((crtFilter < pxConfig->pPlatfInitConfig->au16MaxRegularFilterCount[u8HwCtrl]) && ((Std_ReturnType)E_OK == eReturnValue))
                {
                    pSFCmd->aRxFilters[filterLoadedCount] = filterList[crtFilter];
                    #if (CAN_43_LLCE_DUMMY_HRH_EN == STD_ON)
                        if(FALSE == pxConfig->aHohList[filterList[crtFilter].u16FilterId].bDummyHRH)
                        {
                    #endif
                            filterLoadedCount++;
                            /* Check if the command buffer for filters is full. */
                            if (LLCE_CAN_CONFIG_MAX_FILTERS_COUNT == filterLoadedCount)
                            {
                                pSFCmd->u16RxFiltersCount = filterLoadedCount;
                                eReturnValue = Can_Llce_SendSetFilterCommand(pSFCmd->aRxFilters, filterLoadedCount, u8HwCtrl);
                                /* Reset the number of filters. */
                                filterLoadedCount = 0;
                            }
                    #if (CAN_43_LLCE_DUMMY_HRH_EN == STD_ON)
                        }
                    #endif
                    crtFilter++;
                }

                /* Load remaining filters if any*/            
                if (filterLoadedCount > 0U)
                {
                    pSFCmd->u16RxFiltersCount = filterLoadedCount;
                    eReturnValue = Can_Llce_SendSetFilterCommand(pSFCmd->aRxFilters, filterLoadedCount, u8HwCtrl);
                    /* Reset the number of filters. */
                    filterLoadedCount = 0;
                }
            }
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
  }
  else 
  {
    Can_Llce_EmulateSetConfiguredReceiveFilters();
    Can_Llce_bHeadlessInitDone_SetConfiguredReceiveFilters = TRUE;
  }
#endif
}

static Std_ReturnType Can_Llce_SendSetFilterCommand(const volatile Llce_Can_ReceiveFilterType *pRxFilters, uint8 filterLoadedCount, uint8 u8HwCtrl)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    uint8 i = 0U;
             
    /* Send the command prepared above to the LLCE in order to be executed */
    if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( u8HwCtrl ))
    {
        /* Copy the hw filter addr for later usage. */
        for(i = 0; i < filterLoadedCount; i++)
        {  
            #if (CAN_43_LLCE_FIRST_HTH_CONFIGURED != 0U) || (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0)
                Can_Llce_au16RxHrh2FilterAddr[pRxFilters[i].u16FilterId] = pRxFilters[i].u16FilterAddr;
            #else
            (void)pRxFilters;
            #endif
        }

        eReturnValue = E_OK;
    }

    return eReturnValue;

}

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
/**
* @brief          Calculates where filters would be loaded inside LLCE
* @details        When LLCE is started in headless mode, calculate HRH-filter mapping, to allow
*                 removal or disabling.
*/
static void Can_Llce_EmulateSetConfiguredReceiveFilters(void)
{
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();
    const Llce_Can_ReceiveFilterType * filterList;
    uint8 u8HwCtrl;
    uint16 u16CrtFilter, u16HrhId;

    /* FW loads filters based on physical controller */
    for(u8HwCtrl = 0U; u8HwCtrl < LLCE_CAN_CONFIG_MAXCTRL_COUNT; u8HwCtrl++)
    {
        filterList = pxConfig->paReceiveFilters[u8HwCtrl];

        for(u16CrtFilter = 0U; u16CrtFilter < pxConfig->pPlatfInitConfig->au16MaxRegularFilterCount[u8HwCtrl]; u16CrtFilter++)
        {
            u16HrhId = filterList[u16CrtFilter].u16FilterId;

           #if defined(S32G2XX)
            /* On G2 filters are assigned based on type */
            if(LLCE_CAN_ENTRY_EXACT_MATCH == filterList[u16CrtFilter].eEntryType)
            {
                Can_Llce_au16RxHrh2FilterAddr[u16HrhId] = Can_Llce_u16RxLutExactMatchCounter;
                Can_Llce_u16RxLutExactMatchCounter++;
            }
            else
            {
                Can_Llce_au16RxHrh2FilterAddr[u16HrhId] = Can_Llce_u16RxLutConfigurableCounter;
                Can_Llce_u16RxLutConfigurableCounter++;
            }
           #elif defined(S32G3XX)
            /* On G3 filters are simply loaded sequentially */
            Can_Llce_au16RxHrh2FilterAddr[u16HrhId] = Can_Llce_au16RxLutCounter[u8HwCtrl];
            Can_Llce_au16RxLutCounter[u8HwCtrl]++;
           #endif
        }
    }
}
#endif /* CAN_LLCE_USE_HEADLESSMODE == STD_ON */

/**
* @brief          Writes configuration to memory and sends SETAUXFILTER for all enabled controllers.
* @details        Initialization of indicator, statuses, etc.
*                 This function is non-reentrant and does not provide thread safety
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
#if (RXLUT2_ENABLE == STD_ON)
static void Can_Llce_SetConfiguredAuxReceiveFilters(void)
{
    uint8 u8HwCtrl = 0U;
    uint8 u8CtrlIndex= 0U;
    uint16 crtFilter = 0U;
    uint8 filterLoadedCount = 0U;
    const Llce_Can_AuxFilterType * filterList;
    volatile Llce_Can_SetAuxFilterCmdType * pSFCmd;
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_SUCCESS;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        while((u8CtrlIndex < CAN_43_LLCE_MAXCTRL_CONFIGURED) && (LLCE_FW_SUCCESS == eReturnValue))
        {
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            if(Can_43_LLCE_GetCoreID() == pxConfig->aControllerDescriptors[u8CtrlIndex].u32CoreId)
            {
#endif

                /* Skip disabled controllers */
                if(LLCE_NULL_OFFSET_U8 != u8HwCtrl)
                {
                    u8HwCtrl = pxConfig->aControllerDescriptors[u8CtrlIndex].u8HwCtrl;
                    /*Configure the command id for all controllers which are used. */
                    Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETAUXFILTER;
                    pSFCmd = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetAuxFilter);
                    
                    filterList = pxConfig->paAuxFilters[u8HwCtrl];
                    filterLoadedCount = 0U;

                    crtFilter = 0U;
                    while((crtFilter < pxConfig->paLlce_MaxAuxilliaryFilterCount[u8HwCtrl]) && (LLCE_FW_SUCCESS == eReturnValue))
                    {
                        pSFCmd->aRxAuxFilters[filterLoadedCount] = filterList[crtFilter];
                        filterLoadedCount++;

                        /* Check if the command buffer for filters is full. */
                        if (LLCE_CAN_CONFIG_MAX_FILTERS_COUNT == filterLoadedCount)
                        {
                            pSFCmd->u16RxAuxFiltersCount = filterLoadedCount;
                
                            /* Send the command prepared above to the LLCE in order to be executed */
                            eReturnValue = Can_Llce_ExecuteIfCommand( u8HwCtrl );

                            /* Reset the number of filters. */
                            filterLoadedCount = 0;
                        }
                        crtFilter++;
                    }

                    /* Load remaining filters if any*/            
                    if (filterLoadedCount > 0U)
                    {
                        pSFCmd->u16RxAuxFiltersCount = filterLoadedCount;
                    
                        /* Send the command prepared above to the LLCE in order to be executed */
                        eReturnValue = Can_Llce_ExecuteIfCommand( u8HwCtrl );
                        /* Reset the number of filters. */
                        filterLoadedCount = 0;
                    }
                }
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            }
#endif
            u8CtrlIndex++;
        }
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
}
#endif



/**
* @brief          Initialize advanced feature.
* @details        Initialization of indicator, statuses, etc.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
#if (LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0)
static void Can_Llce_AfInit(void)
{
#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
    uint16 u16Idx;
    
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    if((FALSE == pxConfig->bHeadlessModeEnabled) || (TRUE == Can_Llce_bHeadlessInitDone_AfInit) )
    {
#endif
        /* Send CREATE_AF_DESTINATION command*/
        #if (LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0)
            if(LLCE_FW_SUCCESS == Can_Llce_CreateConfiguredAfDestinations())
            {
        #endif
                /* Send SETADVANCEDFILTER command. */
                Can_Llce_SetConfiguredAfFilters();
        #if (LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0)
            }
        #endif
#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
    }
    else
    {
        for (u16Idx = 0U; u16Idx < (LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT); u16Idx++)
        {           
            /* Assume destinations are created in order */
            Can_au8DestinationIdxMap[u16Idx] = (uint8)u16Idx;
        }

        Can_Llce_EmulateSetConfiguredAfFilters();
        
        Can_Llce_bHeadlessInitDone_AfInit = TRUE;
    }
#endif
}

#if (CAN_LLCE_USE_HEADLESSMODE == STD_ON)
/**
* @brief          Calculates where filters would be loaded inside LLCE
* @details        When LLCE is started in headless mode, calculate HRH-filter mapping, to allow
*                 removal or disabling.
*/
static void Can_Llce_EmulateSetConfiguredAfFilters(void)
{
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();
    const Llce_Can_AdvancedFilterType * filterList;
    uint8 u8HwCtrl;
    uint16 u16CrtFilter, u16HrhId;

    /* FW loads filters based on physical controller */
    for(u8HwCtrl = 0U; u8HwCtrl < LLCE_CAN_CONFIG_MAXCTRL_COUNT; u8HwCtrl++)
    {
        filterList = pxConfig->paAdvancedFilters[u8HwCtrl];

        for(u16CrtFilter = 0U; u16CrtFilter < pxConfig->pPlatfInitConfig->au16MaxAdvancedFilterCount[u8HwCtrl]; u16CrtFilter++)
        {
            u16HrhId = filterList[u16CrtFilter].Llce_Can_RxFilter.u16FilterId;

          #if defined(S32G2XX)
            /* On G2 filters are assigned based on type */
            if(LLCE_CAN_ENTRY_EXACT_MATCH == filterList[u16CrtFilter].Llce_Can_RxFilter.eEntryType)
            {
                Can_Llce_au16RxHrh2FilterAddr[u16HrhId] = Can_Llce_u16RxLutExactMatchCounter;
                Can_Llce_u16RxLutExactMatchCounter++;
            }
            else
            {
                Can_Llce_au16RxHrh2FilterAddr[u16HrhId] = Can_Llce_u16RxLutConfigurableCounter;
                Can_Llce_u16RxLutConfigurableCounter++;
            }
          #elif defined(S32G3XX)
            /* On G3 filters are simply loaded sequentially */
            Can_Llce_au16RxHrh2FilterAddr[u16HrhId] = Can_Llce_au16RxLutCounter[u8HwCtrl];
            Can_Llce_au16RxLutCounter[u8HwCtrl]++;
          #endif

          #if (CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED == STD_ON)
            /* Save reference to filter config for later usage. */
            Can_Llce_apRxHrh2AfFilterCfg[u16HrhId] = &(pxConfig->paAdvancedFilters[u8HwCtrl][u16CrtFilter]);
          #endif
        }
    }
}
#endif /* CAN_LLCE_USE_HEADLESSMODE == STD_ON */

#endif /* LLCE_CAN_ADVANCED_FEATURE_AF_CNT > 0 */

#if((LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON))

/** @implements    Can_Llce_Init_PfeIf_Activity */
Std_ReturnType Can_Llce_Init_PfeIf(uint8 Hif)
{
    uint32 u32ringSize;
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue = LLCE_FW_NOTRUN;
    #if (LLCE_USE_EXTERNAL_RING_BUF == STD_ON)
        volatile Llce_Can_InitPfeWithExternRingCmdType* pfeInitCmd = NULL_PTR;
    #else
        volatile Llce_Can_InitPfeCmdType* pfeInitCmd = NULL_PTR;
    #endif
    pfe_ct_phy_if_id_t pfe_hif_id;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Init LLCE-PFE interface */
        #if (LLCE_USE_EXTERNAL_RING_BUF == STD_ON)
            pfeInitCmd = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.InitPfeWithExternRing);

            pfeInitCmd->pRxRing = (uint32)&Llce_PfeIf_RxRing;
            pfeInitCmd->pRxWbRing = (uint32)&Llce_PfeIf_RxWbRing;
            pfeInitCmd->pTxRing = (uint32)&Llce_PfeIf_TxRing;
            pfeInitCmd->pTxWbRing = (uint32)&Llce_PfeIf_TxWbRing;
            pfeInitCmd->pHeader = (uint32)&Llce_PfeIf_Hdr;
            pfeInitCmd->u8HeaderSize = LLCE_PFE_TX_HDR_COUNT;
            pfeInitCmd->u32RingSize = LLCE_PFE_HIF_RING_CFG_LENGTH;

            u32ringSize = pfeInitCmd->u32RingSize;
            
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_INIT_PFE_EXT_RING_BUF;
        #else
            pfeInitCmd = &(Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.InitPfe);
            u32ringSize = PFE_HIF_RING_CFG_LENGTH;
            
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_INIT_PFE;
        #endif

        pfeInitCmd->u8Hif = Hif;
#if LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON
        pfeInitCmd->pRxBuffers = (uint32)&Llce_Eth2Can_Buffer;
        pfeInitCmd->u16RxBufSize = LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_SIZE;
        pfeInitCmd->u8RxBufCount = LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_CNT;        
#else
        pfeInitCmd->pRxBuffers = 0U;
        pfeInitCmd->u16RxBufSize = 0U;
        pfeInitCmd->u8RxBufCount = 0U;        
#endif

        eCommandReturnValue = Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController);
    }

    if (LLCE_FW_SUCCESS == eCommandReturnValue )
    {
        switch(Hif)
        {
            case 0:
                pfe_hif_id = PFE_PHY_IF_ID_EMAC0;
                break;
            case 1:
                pfe_hif_id = PFE_PHY_IF_ID_EMAC1;
                break;
            case 2:
                pfe_hif_id = PFE_PHY_IF_ID_EMAC2;
                break;
            case 3:
                pfe_hif_id = PFE_PHY_IF_ID_HIF;
                break;
            case 4:
                pfe_hif_id = PFE_PHY_IF_ID_HIF_NOCPY;
                break;
            case 5:
                pfe_hif_id = PFE_PHY_IF_ID_UTIL;
                break;
            case 6:
                pfe_hif_id = PFE_PHY_IF_ID_HIF0;
                break;
            case 7:
                pfe_hif_id = PFE_PHY_IF_ID_HIF1;
                break;
            case 8:
                pfe_hif_id = PFE_PHY_IF_ID_HIF2;
                break;            
            case 9:
                pfe_hif_id = PFE_PHY_IF_ID_HIF3;
                break;
            default:
                pfe_hif_id = PFE_PHY_IF_ID_INVALID;
                break;
        }

        /* Set the contents of llce_minihif to known values */
        (void)memset(&llce_minihif, 0, sizeof(llce_minihif));

        if((Std_ReturnType)E_OK == (Std_ReturnType)pfe_minihif_drv_create(&llce_minihif, pfe_hif_id, FALSE))
        {
            if((Std_ReturnType)E_OK == (Std_ReturnType)pfe_minihif_drv_attach_ring(&llce_minihif, TRUE,  (void*)(pfeInitCmd->pRxRing), (void*)(pfeInitCmd->pRxWbRing), u32ringSize))
            {
                if((Std_ReturnType)E_OK == (Std_ReturnType)pfe_minihif_drv_attach_ring(&llce_minihif, FALSE, (void*)(pfeInitCmd->pTxRing), (void*)(pfeInitCmd->pTxWbRing), u32ringSize))
                {
                    if((Std_ReturnType)E_OK == (Std_ReturnType)pfe_minihif_drv_init(&llce_minihif))
                    {
                        eReturnValue = E_OK;
                    }
                }
            }
        }
    }

    if((Std_ReturnType)E_OK == eReturnValue)
    {
        /* If this application was reloaded with PFE still running, the pfe_minihif calls above 
         * could have altered the state of the rings. Call the INIT_PFE command again to trigger
         * a reinit of the minihif in LLCE */
        eCommandReturnValue = Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController);

        if (LLCE_FW_SUCCESS != eCommandReturnValue )
        {
            eReturnValue = (Std_ReturnType)E_NOT_OK;
        }
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    return eReturnValue;
}

/**
* @brief          Start of PFE.
* @details        Initialization of indicator, statuses, etc.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
*
*
*/
Std_ReturnType Can_Llce_Start_PfeIf(void)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;

    if((Std_ReturnType)E_OK == (Std_ReturnType)pfe_minihif_drv_start_rx(&llce_minihif))
    {
        if((Std_ReturnType)E_OK == (Std_ReturnType)pfe_minihif_drv_start_tx(&llce_minihif))
        {
            eReturnValue = E_OK;
        }
    }

    return eReturnValue;
}
#endif /* ((LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0) || (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON)) */

#if(LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0)
/**
* @brief          Set current Can2Eth state
* @details        Initialization of indicator, statuses, etc.
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set variables into a definite state.
* @implements     Can_Llce_SetCan2EthState_Activity
*
*/
Std_ReturnType Can_Llce_SetCan2EthState(Can_Llce_Can2EthStateType eState)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue = LLCE_FW_NOTRUN;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    /* Check if command is available */
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETCAN2ETHSTATE;

        if(CAN_LLCE_CAN2ETH_ENABLED == eState)
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.eBinaryValue = LLCE_TRUE;
        }
        else
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.eBinaryValue = LLCE_FALSE;
        }

        eCommandReturnValue = Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController);
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    if (LLCE_FW_SUCCESS == eCommandReturnValue)
    {
        eReturnValue = (Std_ReturnType)E_OK;
    }

    return eReturnValue;
}
#endif /* LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0 */

#if (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON)
/**
* @brief          Enable/disable Eth2Can decapsulation for a particular format.
* @details        Sends command to FW to start/stop decapsulation Eth2Can frames of a particular type
*                 This routine is called by:
*                 - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
*/
Llce_Fw_ReturnType Can_Llce_SetEth2CanFormatState(Llce_Can_EthEncapsulationFormat eFormat, Can_Llce_Eth2CanStateType eState)
{
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_NOTRUN;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    /* Check if command is available */
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETETH2CANFORMATSTATE;
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetEth2CanFormatState.eFormat = eFormat;
        if(CAN_LLCE_ETH2CAN_ENABLED == eState)
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetEth2CanFormatState.eState = LLCE_TRUE;
        }
        else
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetEth2CanFormatState.eState = LLCE_FALSE;
        }

        eReturnValue = Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController);
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}
#endif /* (LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED == STD_ON) */

#if LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0
/**
* @brief          Set current Can2Pcie state
* @details        Enable/disable Can2Pcie in LLCE FW
*
* @pre            At least one controller must be configured in the Driver structure.
* @implements     Can_Llce_SetCan2PcieState_Activity
*
*/
Std_ReturnType Can_Llce_SetCan2PcieState(Can_Llce_Can2PcieStateType eState)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue = LLCE_FW_NOTRUN;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    /* Check if command is available */
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETCAN2PCIESTATE;

        if(CAN_LLCE_CAN2PCIE_ENABLED == eState)
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.eBinaryValue = LLCE_TRUE;
        }
        else
        {
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.eBinaryValue = LLCE_FALSE;
        }

        eCommandReturnValue = Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController);
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    if (LLCE_FW_SUCCESS == eCommandReturnValue)
    {
        eReturnValue = (Std_ReturnType)E_OK;
    }

    return eReturnValue;
}
#endif /* LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT > 0 */


/*================================================================================================*/
/**
* @brief          Service for de-initializing only CAN controller specific settings.
* @details        CAN controller de-initialization.
*                 This routine is called by:
*                  - Can_43_LLCE_DeInit() from Can.c file.
*
* @param[in]      u8HwCtrl: CAN controller for which the initialization shall be done.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           De-initialization controller's configuration.
*
*/
Std_ReturnType Can_Llce_DeInitController(uint8 u8HwCtrl)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_DEINIT;
        
        /* Send the command prepared above to the LLCE in order to be executed */
        eCommandReturnValue = Can_Llce_ExecuteIfCommand( u8HwCtrl );

        if(LLCE_FW_SUCCESS == eCommandReturnValue)
        {
            /* Update status in order to discard tx/rx processing */
            SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
            Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_UNINIT;
            SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
            eReturnValue = (Std_ReturnType)E_OK;
        }
    }
    
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

Std_ReturnType Can_Llce_DeInitPlatform(void)
{   
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;
    uint8 u8Interface;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /*All the FIFOs corresponding to a given HIF are reset at once due to the flexible FIFO allocation feature*/
    for (u8Interface = 0U; u8Interface < LLCE_CAN_CONFIG_MAXCTRL_COUNT; u8Interface++)
    {   
        /*check alive RX int interfaces that shall be cleaned in case the data was not consumed*/
        if (0U != pxConfig->pPlatfInitConfig->au16MaxIntMbCount[u8Interface])
        {
            Can_Llce_ResetFifoContent(u8Interface);
        }
    }

    for (u8Interface = 0U; u8Interface < LLCE_CAN_MAX_POLLING_CLASSES; u8Interface++)
    {   
        /*check alive RX poll interfaces that shall be cleaned in case the data was not consumed*/
        if (0U != pxConfig->pPlatfInitConfig->au16MaxPollMbCount[u8Interface])
        {
            Can_Llce_ResetFifoContent(u8Interface + LLCE_CAN_CONFIG_MAXCTRL_COUNT);
        }
    }

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_DEINIT_PLATFORM;
        
        /* Send the command prepared above to the LLCE in order to be executed */
        if(LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( pxConfig->u8DefaultController ))
        {
            eReturnValue = (Std_ReturnType)E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    /*Disable the Notif FIFO interrupt*/
    Can_Llce_DisableNotifInterrupt(pxConfig->u8ActiveHif);

    return eReturnValue;
}

/**
* @brief          Send LLCE shutdown command 
* @details        Shut down LLCE before doing a partition reset
*
* @pre            Both HIFs are uninitialized/deinitialized.
* @post           LLCE is shut down and must be reset.
*
* @implements     Can_Llce_Shutdown_Activity
*/
Std_ReturnType Can_Llce_Shutdown(void)
{
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue = LLCE_FW_NOTRUN;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    /* Check if command is available */
    if ((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SHUTDOWN;

        eCommandReturnValue = Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController);
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    if (LLCE_FW_SUCCESS == eCommandReturnValue)
    {
        eReturnValue = (Std_ReturnType)E_OK;
    }

    return eReturnValue;
}

/**
* @brief          Routine for resetting FIFO content
* @details        In case of a message sent by LLCE firmware just after the SetControllerMode(STOP) command,
*                 the driver shall cancel the pending message.                  
*                 This routine is called by Can_Llce_SetControllerToStartMode and it makes sure about a
*                 clean FIFO content before the controller is requested to start.
*
* @param[in]      u8Interface FIFO interface to be reset
*
*/
static void Can_Llce_ResetFifoContent(uint8 u8Interface)
{
    uint16 u16Token;
    uint16 u16SafetyLoopEscapeCnt = 0U;
    /* Timeout counter. */
    uint32 u32timeStart = 0U;
    uint32 u32timeElapsed = 0U;
    uint32 u32TicksDelayDuration = 0U;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    if (u8Interface < (LLCE_CAN_CONFIG_MAXCTRL_COUNT + LLCE_CAN_MAX_POLLING_CLASSES))
    {
        if (u8Interface < LLCE_CAN_CONFIG_MAXCTRL_COUNT)
        {
            u16SafetyLoopEscapeCnt = pxConfig->pPlatfInitConfig->au16MaxIntMbCount[u8Interface];
        }
        else
        {
            u16SafetyLoopEscapeCnt = pxConfig->pPlatfInitConfig->au16MaxPollMbCount[u8Interface - LLCE_CAN_CONFIG_MAXCTRL_COUNT];
        }

        /* Abort RX messages and return the token to LLCE */
        while (( LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8Interface))) & (uint32)(LLCE_FIFO_FEMTYD_U32)) ) && \
               (u16SafetyLoopEscapeCnt > 0U))
        {
            u16SafetyLoopEscapeCnt--;

            /* Read data from the fifo. */
            u16Token = (uint16)Reg_Read32( LLCE_FIFO_POP0(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8Interface)));

            u32timeStart = OsIf_GetCounter(CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            u32TicksDelayDuration = OsIf_MicrosToTicks(CAN_43_LLCE_TIMEOUT_DURATION, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            u32timeElapsed = 0U;

            /* Wait for LLCE to consume the tokens before DEINIT_PLATFORM cmd is issued */
            while ( (0U == (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif))) & (uint32)(LLCE_FIFO_FEMTYD_U32)) ) && (u32timeElapsed < u32TicksDelayDuration))
            {
                u32timeElapsed += OsIf_GetElapsed(&u32timeStart, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            }
            
            Reg_Write32( LLCE_FIFO_PUSH0(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif)), (uint32)u16Token);
        }
        
        /* Abort TX confirmations. */
        Reg_Bit_Set32(LLCE_FIFO_CONFIG(LLCE_FIFO_TXACK_BASE_ADDRESS(u8Interface)), LLCE_FIFO_FCR_FLUSH_U32);
    }

}

#if (CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED == STD_OFF)
/*================================================================================================*/
/**
* @brief          API for servicing the bus-off event.
* @details        CAN controller bus-off reaction.
*                 This routine is called by:
*                  
*
* @param[in]      Controller CAN controller for which the bus-off was generated.
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           
*
*
*/
static void Can_Llce_ControllerBusOff(uint8 u8HwCtrl)
{
    uint16 u16RxMbDescIdx;
    uint16 u16SafetyLoopEscapeCnt;
    uint32 u32DrvControllerOptions;
    /* Timeout counter. */
    uint32 u32timeStart = 0U;
    uint32 u32timeElapsed = 0U;
    uint32 u32TicksDelayDuration = 0U;
    
    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Update status */
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
    Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_STOPPED;
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();

    u16SafetyLoopEscapeCnt = pxConfig->pPlatfInitConfig->au16MaxIntMbCount[u8HwCtrl];
    u32DrvControllerOptions = pxConfig->aHwControllerDescriptors[u8HwCtrl].u32DrvControllerOptions;

    /* In case of polling classes, the outdated messages are detected at MainFunction_Read/Write by checking the controller state. */
    if(LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32))
    {
        while ( (LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8HwCtrl))) & (uint32)(LLCE_FIFO_FEMTYD_U32)) ) && \
                (u16SafetyLoopEscapeCnt > 0U))
        {
            u16SafetyLoopEscapeCnt --;
            /* Read data from the fifo. */
            u16RxMbDescIdx = (uint16)Reg_Read32( LLCE_FIFO_POP0(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8HwCtrl)));

            u32timeStart = OsIf_GetCounter(CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            u32TicksDelayDuration = OsIf_MicrosToTicks(CAN_43_LLCE_TIMEOUT_DURATION, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            u32timeElapsed = 0U;

            /* Wait for LLCE to consume the tokens before next token is pushed */
            while ( (0U == (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif))) & (uint32)(LLCE_FIFO_FEMTYD_U32)) ) && (u32timeElapsed < u32TicksDelayDuration))
            {
                u32timeElapsed += OsIf_GetElapsed(&u32timeStart, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
            }

            Reg_Write32( LLCE_FIFO_PUSH0(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif)), (uint32)u16RxMbDescIdx);
        }
    }

    if(LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32 == (u32DrvControllerOptions & LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32))
    {
        /* Process all the ACK before notify BusOff event. */
        Can_Llce_ProcessTx(u8HwCtrl);
    }
    
    Can_43_LLCE_ControllerBusOff(u8HwCtrl);

}
#endif /* #if (CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED == STD_OFF) */

/*================================================================================================*/
/**
* @brief          Service for (re)initializing only CAN controller specific settings.
* @details        CAN controller (re-)initialization.
*                 This routine is called by:
*                  - Can_43_LLCE_Init() from Can_43_LLCE.c file.
*
* @param[in]      Controller CAN controller (HW) for which the init shall be done.
* @param[in]      pxBaudrateConfigPtr The baud rate configuration (contains baud rate parameters for arbitration phase).
*
* @pre            At least one controller must be configured in the Driver structure.
* @post           Set the MBs and interrupts into predefinite state for Can bus communication.
*
*
*/

Std_ReturnType Can_Llce_ChangeBaudrate(uint8 u8HwCtrl, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if(NULL_PTR != pxBaudrateConfigPtr) 
    {
        eReturnValue = Can_Llce_CheckCommandAvailable();
        if((Std_ReturnType)E_OK == eReturnValue)
        {
            /* Configure the command id */
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_SETBAUDRATE;

            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.SetBaudrate = *pxBaudrateConfigPtr;

            /* Send the command prepared above to the LLCE in order to be executed */
            if(LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( u8HwCtrl ))
            {
                eReturnValue = E_OK;
            }
            else
            {
                eReturnValue = E_NOT_OK;
            }
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief          Return the mode of the CAN controller
* @details        Retrieve the mode of the specified controller from firmware and update the local state.
*                 Exception: (logical) sleep mode is stored in the driver. In Sleep state, no request is made to FW.
*                 This routine is called by:
*                  - Can_43_LLCE_GetControllerMode() from Can_43_LLCE.c file.
*
* @param[in]      u8HwCtrl CAN controller for which the status shall be requested.
* @param[out]     ControllerModePtr Current AUTOSAR state of the CAN controller will be stored.
*
* @return         Std_ReturnType
* @retval         E_OK Controller mode request has been accepted.
* @retval         E_NOT_OK Controller mode request has not been accepted.
*
* @pre            
* @post           
*
* @requirements   
* @implements     Can_Llce_GetControllerMode_Activity
*/
Std_ReturnType Can_Llce_GetControllerMode(uint8 u8HwCtrl, Can_ControllerStateType * ControllerModePtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    Llce_Can_CtrlStateType eLlceControllerMode;

    /* Sleep state is "logical" and stored internally */
    if(CAN_CS_SLEEP == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState )
    {
        *ControllerModePtr = CAN_CS_SLEEP;
        eReturnValue = E_OK;
    }
    else
    {
        /* Send the command prepared above to the LLCE in order to be executed */
        if((Std_ReturnType)E_OK == Can_Llce_GetLlceControllerMode(u8HwCtrl, &eLlceControllerMode))
        {
            /* Update local status as well */
            switch(eLlceControllerMode)
            {
                case LLCE_CAN_UNINIT_CTRL:
                    *ControllerModePtr = CAN_CS_UNINIT;
                    break;
#if (CAN_43_LLCE_CONTROLLER_START_NOSYNC == STD_ON)
                case LLCE_CAN_START_PENDING:
                    *ControllerModePtr = CAN_CS_STARTED;
                    break;
#endif
                case LLCE_CAN_STARTED:
                    *ControllerModePtr = CAN_CS_STARTED;
                    break;
                case LLCE_CAN_STOPPED:
                    *ControllerModePtr = CAN_CS_STOPPED;
                    break;
                default:
                    /* If the state is pending or there are no changes to current status, retrieve the last state. */
                    *ControllerModePtr = Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState;
                    break;
            }

            eReturnValue = E_OK;
        }
    }

    return (eReturnValue);
}

/*================================================================================================*/
/**
* @brief          Return the internal state of LLCE controller
* @details        Retrieve the mode of the specified controller from firmware.
*                 According to the LLCE interface, multiple states are possible for a given controller which may be
*                 needed for the CAN driver to comply with the internal LLCE state machine.
*
* @param[in]      Controller CAN controller for which the status shall be requested. Based on configuration order list (CanControllerId).
* @param[out]     eLlceControllerMode Pointer to a memory location, where the current internal mode of the CAN controller will be stored.
*
* @return         Std_ReturnType
* @retval         E_OK Controller mode request has been accepted.
* @retval         E_NOT_OK Controller mode request has not been accepted.
*
*/
static Std_ReturnType Can_Llce_GetLlceControllerMode(uint8 u8HwCtrl,  Llce_Can_CtrlStateType *eLlceControllerMode)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_GETCONTROLLERMODE;  

        /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand( u8HwCtrl ))
        {
            *eLlceControllerMode = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.GetControllerMode.eControllerState;

            eReturnValue = E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

/*================================================================================================*/
/**
* @brief          Service to Perform software triggered state transitions of the CAN controller State machine.
* @details        Transition controller to another state/mode.
*                 This routine is called by:
*                  - Can_43_LLCE_SetControllerMode() from Can_43_LLCE.c file.
*                  - Can_43_LLCE_IPW_ProcessBusOff() from Can_IPW.c file.
*
* @param[in]      Controller CAN controller for which the init shall be done.
* @param[in]      Transition Possible transitions
* @param[in]      pxBaudrateConfigPtr Configuration parameters for the controller baud rate settings
*
* @return         Std_ReturnType
* @retval         E_OK transition initiated
* @retval         E_NOT_OK development or production error
*
* @pre            Controller is configured and must be into a state that permit the valid transition to another different state.
* @post           Shall enable interrupts that are needed in the new state. Shall disable interrupts that are not allowed in the new state.
*
* @requirements   CAN283
*
* @implements     Can_Llce_SetControllerMode_Activity
*/
Std_ReturnType Can_Llce_SetControllerMode(uint8 u8HwCtrl, Can_ControllerStateType Transition, const Llce_Can_SetBaudrateCmdType* pxBaudrateConfigPtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    /*
      (CAN017) The function Can_43_LLCE_SetControllerMode shall perform software triggered state transitions of the CAN controller State machine.
    */
    switch (Transition)
    {
        /* CAN_CS_STARTED -> CAN_CS_STOPPED. */
        case (CAN_CS_STOPPED):
            eReturnValue = Can_Llce_SetControllerToStopMode(u8HwCtrl);
            break;

        /* CAN_CS_STOPPED -> CAN_CS_STARTED. */
        case (CAN_CS_STARTED):
            eReturnValue = Can_Llce_SetControllerToStartMode(u8HwCtrl, pxBaudrateConfigPtr);
            break;

        /* CAN_CS_STOPPED -> CAN_CS_SLEEP. */
        case (CAN_CS_SLEEP):
            eReturnValue = Can_Llce_SetControllerToSleepMode(u8HwCtrl);
            break;

        /* Unknown transition requested. */
        default:
        /*
           (CAN200) If development error detection for the Can module is enabled: if an invalid transition has been requested, the function Can_43_LLCE_SetControllerMode shall raise the error CAN_43_LLCE_E_TRANSITION and return E_NOT_OK.
        */
            (void)Can_43_LLCE_ReportError((uint8)CAN_43_LLCE_SID_SET_CONTROLLER_MODE, (uint8)CAN_43_LLCE_E_TRANSITION);

            break;

        } /* end switch */

    return (eReturnValue);
}

/*================================================================================================*/
/**
* @brief          Send a frame to the hardware.
* @details        Checks if hardware transmit object that is identified by the HTH is free.
*                     Can_43_LLCE_Write checks if another Can_43_LLCE_Write is ongoing for the same HTH.
*                     a) hardware transmit object is free:
*                         The mutex for that HTH is set to 'signaled' the ID, DLC and SDU are put in a format appropriate for
*                           the hardware (if necessary) and copied in the appropriate hardware registers/buffers.
*                         All necessary control operations to initiate the transmit are done.
*                         The mutex for that HTH is released. The function returns with E_OK.
*                     b) hardware transmit object is busy with another transmit request.
*                         The function returns with CAN_BUSY.
*                     c) A preemptive call of Can_43_LLCE_Write has been issued, that could not be handled reentrant (i.e. a call with the same HTH).
*                         The function returns with CAN_BUSY the function is non blocking
*                     d) The hardware transmit object is busy with another transmit request for an L-PDU that has lower priority than that for the current request
*                         The transmission of the previous L-PDU is cancelled (asynchronously).
*                         The function returns with CAN_BUSY.
*                         This routine is called by:
*                         - Can_43_LLCE_Write() from Can_43_LLCE.c file.
*                     Algorithm Description:
*                     Case1: TxMUX supported = ON
*                           Can_43_LLCE_Write receive the Hth handle and the PduInfo for transmission. It starts to check from the first MBs of the
*                           current controller to search for a free MB. On the first free MB it stops and place the PduInfo and activate the transmission.
*                           In this case function set E_OK for return value and all other functionality is skipped.
*                           If no MB is finded as free then the lowest priority MB is selected for comparing with the priority of the current PduInfo.
*                           If the current PduInfo has a higher priority than the current lower priority (from all MBs) then this lower priority MB is canceled.
*                    Case2: TxMUX supported = OFF
*                          CanWrite() receive the Hth handle and the PduInfo for transmission. It checks if MB with the same index as Hth is free and if yes prepare
*                          and sends the current PduInfo data. If that MB is busy with another data then it checks the priority between these 2 structures.
*                          Depending by the last evaluation it decides what MB data to cancel.
*
* @param[in]      Hth information which HW-transmit handle shall be used for transmit.
*                 Implicitly this is also the information about the controller to use
*                 because the Hth numbers are unique inside one hardware unit.
* @param[in]      PduInfo Pointer to SDU user memory, DLC and Identifier
*
* @return          Std_ReturnType
* @retval          E_OK write command has been accepted
* @retval          E_NOT_OK development error occurred
* @retval          CAN_BUSY no TX hardware buffer available or preemtive call of Can_43_LLCE_Write() that can't be implemented reentrant
*
* @pre            The MB must be configured for Tx.
* @post           Transmit the data or ignore it in case of MB is full with another task.
*
*/
    Std_ReturnType Can_Llce_Write(uint8 u8HwCtrl, Can_43_LLCE_TxFrameInfoType* TxFrameInfo)
    {
        /* Variable for the TX MB descriptor */
        uint32 u32TxMbDescIdx = 0U;
        /* Variable for return status. */
        Std_ReturnType eReturnValue = (Std_ReturnType)CAN_BUSY;

    #ifdef CAN_43_LLCE_MEASURE_WRITE_LATENCY       
        Reg_Write32(LLCE_STM_CR,0x00);/* Disable STM counter. */ 
        Reg_Write32(LLCE_STM_CNT,0);/* Clear STM counter. */   
        Reg_Write32(LLCE_STM_CR,0x01);/* Enable STM counter. */ 
    #endif

        /* Attempt to get address of a free message buffer*/
        /* Read data from the fifo. */
        u32TxMbDescIdx = Reg_Read32( LLCE_FIFO_POP0(LLCE_FIFO_BLROUT_BASE_ADDRESS(u8HwCtrl)));

        /* Check if buffer ID is valid */
        if (LLCE_FIFO_NULL_VALUE != u32TxMbDescIdx)
        {  
            /* Apply mask to get the correct fifo entry value */
            u32TxMbDescIdx = u32TxMbDescIdx & LLCE_CAN_CONFIG_FIFO_FIXED_MASK_U32;

            /* Share TX MB descriptor to Can_Llce_UpdateMB using u16MbFrameIdx field*/
            TxFrameInfo->u16MbFrameIdx = (uint16)u32TxMbDescIdx;

            /* Write data into the Message buffer for transition. */
            Can_Llce_UpdateMB(TxFrameInfo);

            /*Check if the pointer to the full tx message buffer can be sent to the LLCE*/
            if ( LLCE_FIFO_FFULLD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_BLRIN_BASE_ADDRESS(u8HwCtrl))) & (uint32)(LLCE_FIFO_FFULLD_U32)) )
            {
                #if (CAN_43_LLCE_CUSTOM_WRITE_CALLBACK_USED == STD_ON)
                
                Can_43_LLCE_CustomWriteCallback(TxFrameInfo->u16FrameTag1 /*HoH*/, TxFrameInfo->u16FrameTag2 /*swPduHandle*/, (uint16)u32TxMbDescIdx /*TxMbDescIdx*/);

                #endif

                /* Write data to the fifo. */
                Reg_Write32( LLCE_FIFO_PUSH0(LLCE_FIFO_BLRIN_BASE_ADDRESS(u8HwCtrl)),u32TxMbDescIdx);

        #ifdef CAN_43_LLCE_MEASURE_WRITE_LATENCY  
    #ifndef CAN_43_LLCE_MEASURE_WRITE_BUS_LATENCY         
        Stm_Measurement = Reg_Read32(LLCE_STM_CNT) - Stm_Measurement;
    #endif
        host_write_label:
    #endif
                /* The request was successfully sent to the LLCE. */
                eReturnValue = E_OK;
            }
            else /* Defensive action against hardware FIFO communication fail. */
            {
                /* The pointer to the full tx mb can not be sent to the LLCE. Token lost. Requires controller restart. */
                eReturnValue = E_NOT_OK;

                #if (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON)
                (void)Can_43_LLCE_ReportError((uint8)CAN_43_LLCE_SID_WRITE, (uint8)CAN_43_LLCE_E_LLCE_FAILED);
                #endif /* (CAN_43_LLCE_DEV_ERROR_DETECT == STD_ON) */
            }

        }
        else
        {
            /* No pointer available to a free message buffer */
            eReturnValue = CAN_BUSY;
        }

        return (eReturnValue);
    }

/*================================================================================================*/
/**
* @brief          Local function for calling notification function to notify upper layer from ISR when Interrupt mode selected.
* @details        Processes Tx interrupt flags.
*               This routine is called by:
*                - Can_43_LLCE_IPW_ProcessTx() from Can_43_LLCE.c file.
*                - Can_IsrFC##FC##_UNI() / Can_IsrFC##FC##_##Name() from Can_Irq.c file.
*
* @param[in]      u8AckInterface Fifo Interface [0-15] which generated interrupt for ACK event.
*
* @pre            MB is configured for Tx.
* @post           CanIf is informed with cancellation or transmit success.
*
*/
void Can_Llce_ProcessTx(const uint8 u8AckInterface)
{
    #ifdef MCAL_ENABLE_FAULT_INJECTION
    MCAL_FAULT_INJECTION_POINT(CAN_43_LLCE_FIP_4_MODIFY_IER_WHILE_PROCESSTX);
    #endif

    uint16 u16HohIndex;
    uint16 u16SafetyLoopEscapeCnt;
    uint16 u16AckEntry = 0U;
    uint8 u8HwCtrl;
    uint8 u8ControllerId;
    uint32 u32IER = Reg_Read32(LLCE_FIFO_IER(LLCE_FIFO_TXACK_BASE_ADDRESS(u8AckInterface)));
    uint32 u32Status = Reg_Read32(LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS(u8AckInterface)));
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

#if (CAN_43_LLCE_ACK_TIMESTAMP == STD_ON)
    uint16 u16FrameTag2 = 0u;
#endif

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Check for spurious interrupt and for initialized driver. */
    if ( (CAN_43_LLCE_READY == Can_43_LLCE_eDriverStatus[u32CoreId]) &&
        (LLCE_FIFO_FNEMTY_U32 == (u32IER & LLCE_FIFO_FNEMTY_U32)) && \
        (LLCE_FIFO_FNEMTY_U32 == (u32Status & LLCE_FIFO_FNEMTY_U32)) )
    {
        u16SafetyLoopEscapeCnt = pxConfig->pPlatfInitConfig->au16MaxIntTxAckCount[u8AckInterface];

        /* Process all entries from the TXACK FIFO. They can be originated by multiple hardware controllers. */
        while ((LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS(u8AckInterface))) & (uint32)(LLCE_FIFO_FEMTYD_U32))) && \
               (u16SafetyLoopEscapeCnt > 0U))
        {
            u16SafetyLoopEscapeCnt--;
            /* Read the index into the circular buffer containing the ack info.*/
            u16AckEntry = (uint16)(Reg_Read32( LLCE_FIFO_POP0(LLCE_FIFO_TXACK_BASE_ADDRESS(u8AckInterface))) & LLCE_CAN_CONFIG_FIFO_FIXED_MASK_U32);
            
            u16HohIndex = Can_SharedMemory.Can_Tx_aAckInfo[u16AckEntry].u16FrameTag1;

            Can_Hth_FreeTxObject(u16HohIndex, 1U);

            u8ControllerId = pxConfig->aHohList[u16HohIndex].u8ControllerId;
  
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            if(Can_43_LLCE_GetCoreID() == pxConfig->aControllerDescriptors[u8ControllerId].u32CoreId)
            {
#endif
                /* Get the hardware offset for this controller. */
                u8HwCtrl = pxConfig->aControllerDescriptors[u8ControllerId].u8HwCtrl;
           
                if ( CAN_CS_STARTED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState )
                {
                    /* Check if corresponding controller is started and the hoh is configured for reporting through interrupt mode */
                    if (LLCE_CAN_REFERENCE_NOT_USED == pxConfig->aHohList[u16HohIndex].u8CanMainFuncRWPeriodRef)
                    {
                        #if (CAN_43_LLCE_CUSTOM_CONFIRMATION_CALLBACK == STD_ON)
                    
                        Can_43_LLCE_CustomTxConfirmationCallback(u16HohIndex /*HoH*/, Can_SharedMemory.Can_Tx_aAckInfo[u16AckEntry].u16FrameTag2 /*swPduHandle*/);

                        #endif
                        /*
                        (CAN058) The Can module interacts among other modules (eg. Diagnostic Event Manager (DEM), Development Error Tracer (DET)) with the CanIf module in a direct way.
                                The driver only sees the CanIf module as origin and destination.
                        */
                        Can_43_LLCE_TxConfirmation( Can_SharedMemory.Can_Tx_aAckInfo[u16AckEntry].u16FrameTag2 );

                        /* Get Frame Tag */
                        #if (CAN_43_LLCE_ACK_TIMESTAMP == STD_ON)
                            u16FrameTag2 = Can_SharedMemory.Can_Tx_aAckInfo[u16AckEntry].u16FrameTag2;
                            Can_43_LLCE_TxTimestampNotification(u16HohIndex, u16FrameTag2, Can_SharedMemory.Can_Tx_aAckInfo[u16AckEntry].u32TxTimestamp);
                        #endif
                    }
                }
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            }
#endif
        }
    }

    /* Clear the interrupt status flag. */
    Reg_Write32( LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS(u8AckInterface)), LLCE_FIFO_FNEMTY_U32); 
    
}

/*================================================================================================*/
/**
* @brief          This routine accesses the notification interface configured in interrupt mode.
* @details        This routine accesses the notification interface configured in interrupt mode using indexes popped from NOTIF FIFO
*                 to retrieve the event information from notification table filled up by Llce firmware.
* @pre            
* @post           CanIf is notified about the bus-off events reported by the Llce firmware.
* @implements     Can_Isr_X_Activity
*/
void Can_Llce_ProcessNotificationISR(void)
{   
    uint8 u8NotifIdx = 0U;
    uint8 u8HwCtrl = 0U;
    uint16 u16SafetyLoopEscapeCnt = 0U;
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    #if (CAN_43_LLCE_ERROR_NOTIF_ENABLE == STD_ON)
    CanErrorNotificationType CanError;
    #endif

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    uint32 u32IER = Reg_Read32( LLCE_FIFO_IER(LLCE_NOTIF_FIFO0_BASE_ADDRESS(pxConfig->u8ActiveHif)));
    uint32 u32Status = Reg_Read32( LLCE_FIFO_STATUS1(LLCE_NOTIF_FIFO0_BASE_ADDRESS(pxConfig->u8ActiveHif)));

    /* Check for spurious interrupt and for initialized driver. */
    if ( (CAN_43_LLCE_READY == Can_43_LLCE_eDriverStatus[u32CoreId]) &&
            (LLCE_FIFO_FNEMTY_U32 == (u32IER & LLCE_FIFO_FNEMTY_U32)) && \
            (LLCE_FIFO_FNEMTY_U32 == (u32Status & LLCE_FIFO_FNEMTY_U32)) )
    {
        u16SafetyLoopEscapeCnt = LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE;
        while ( (LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_NOTIF_FIFO0_BASE_ADDRESS(pxConfig->u8ActiveHif))) & (uint32)(LLCE_FIFO_FEMTYD_U32))) &&
                (u16SafetyLoopEscapeCnt > 0U))
        {
            u16SafetyLoopEscapeCnt--;
            u8NotifIdx = (uint8)Reg_Read32( LLCE_FIFO_POP0(LLCE_NOTIF_FIFO0_BASE_ADDRESS(pxConfig->u8ActiveHif)));

            if (LLCE_CAN_NOTIF_CHANNELERROR == Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId)
            {
                u8HwCtrl = Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.u8HwCtrl;
                /* Treat cases defined by Autosar spec. Rest of them are only sent through the user-defined callback */
                switch (Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.ErrorInfo.eErrorCode)
                {
                    case (LLCE_ERROR_BUSOFF):
                    #if (CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED == STD_ON)
                        /* LLCE issues bus-off notification, but does not freeze the controller. */
                        Can_43_LLCE_ControllerBusOffCallback(pxConfig->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId);
                    #else
                        /* LLCE issues bus-off notification after controller freezes. AUTOSAR required behavior */
                        Can_Llce_ControllerBusOff(u8HwCtrl);
                    #endif
                    break;

                    /* DATALOST root causes */
                    case (LLCE_ERROR_RXOUT_FIFO_FULL):
                    case (LLCE_ERROR_MB_NOTAVAILABLE):
                    case (LLCE_ERROR_FRAME_NOT_DELIVERED_TO_HOST):
                    case (LLCE_ERROR_BCAN_RXFIFO_OVERRUN):
                        (void)Can_43_LLCE_ReportRuntimeError((uint8)CAN_43_LLCE_SID_PROCESS_NOTIFICATION_ISR, (uint8)CAN_43_LLCE_E_DATALOST);
                        break;

                    default:
                        /* Switch must handle all states. No action, just appease MISRA */
                        break;
                }

                #if (CAN_43_LLCE_ERROR_NOTIF_ENABLE == STD_ON)
                /* Report a channel error */
                CanError.u8CanIfCtrlId = pxConfig->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId;
                CanError.eNotifId = Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId;
                CanError.ErrorInfo = &(Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.ErrorInfo);
                Can_43_LLCE_ErrorNotificationCallback(&CanError);
                #endif
            }
            else if (LLCE_CAN_NOTIF_PLATFORMERROR == Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId)
            {
                #if (CAN_43_LLCE_ERROR_NOTIF_ENABLE == STD_ON)
                /* Report a platform error */
                CanError.u8CanIfCtrlId = CAN_43_LLCE_NULL_OFFSET;
                CanError.eNotifId = Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId;
                CanError.ErrorInfo = &(Can_SharedMemory.Can_NotificationTable.Can_aNotif0_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.PlatformError);
                Can_43_LLCE_ErrorNotificationCallback(&CanError);
                #endif
            }
            else
            {
                /* Unknown error. */
            }
            
        }
        
    }

    /* Clear the interrupt status flag. */
    Reg_Write32( LLCE_FIFO_STATUS1(LLCE_NOTIF_FIFO0_BASE_ADDRESS(pxConfig->u8ActiveHif)), LLCE_FIFO_FNEMTY_U32); 
}

#if (CAN_43_LLCE_BUSOFFPOLL_SUPPORTED == STD_ON)
/*================================================================================================*/
/**
* @brief          This routine accesses the notification interface configured in polling mode.
* @details        This routine accesses the notification interface configured in polling mode using indexes popped from NOTIF FIFO
*                 to retrieve the bus-off events from notification table filled up by Llce firmware.
* @pre            
* @post           CanIf is notified about the bus-off events reported by the Llce firmware.
* @implements     Can_Isr_X_Activity
*/
void Can_Llce_ProcessBusOffNotification(void)
{   
    uint8 u8NotifIdx = 0U;
    uint8 u8HwCtrl = 0U;
    uint16 u16SafetyLoopEscapeCnt = LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE;
    Llce_Fw_ReturnType eErrorCode;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    while ( (LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_NOTIF_FIFO1_BASE_ADDRESS(pxConfig->u8ActiveHif))) & (uint32)(LLCE_FIFO_FEMTYD_U32))) && \
           (u16SafetyLoopEscapeCnt > 0U))
    {
        u16SafetyLoopEscapeCnt--;
        u8NotifIdx = (uint8)Reg_Read32( LLCE_FIFO_POP0(LLCE_NOTIF_FIFO1_BASE_ADDRESS(pxConfig->u8ActiveHif)));

        /* Get error code */
        eErrorCode = Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.ErrorInfo.eErrorCode;

        if ((LLCE_CAN_NOTIF_CHANNELERROR == Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId) && \
                (LLCE_ERROR_BUSOFF == eErrorCode))
        {
            /* Get hw controller (BCAN instance) which raised the bus-off notification. */
            u8HwCtrl = Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.u8HwCtrl;

            /* Make sure the controller is configured to get bus-off events in polling mode. */
            if (LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32 != (LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32 & (uint32)(pxConfig->aHwControllerDescriptors[u8HwCtrl].u32DrvControllerOptions)))
            {
                #if (CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED == STD_ON)
                    /* LLCE issues bus-off notification, but does not freeze the controller. */
                    Can_43_LLCE_ControllerBusOffCallback(pxConfig->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId);
                #else
                    /* LLCE issues bus-off notification after controller freezes. AUTOSAR required behavior */
                    Can_Llce_ControllerBusOff(u8HwCtrl);
                #endif
            }
        }
        #if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
        else
        {
            if ( LLCE_SWFIFO_FULL != Can_Llce_xNotifSwFifo.eFifoStatus )
            {
                (void)Llce_SwFifo_Push((const void*)&(Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx]) , &Can_Llce_xNotifSwFifo);
            }
        }
        #endif

    }
}
#endif /* (CAN_43_LLCE_BUSOFFPOLL_SUPPORTED == STD_ON) */

#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
/**
* @brief          This routine accesses the notification interface configured in polling mode.
* @details        This routine accesses the notification interface configured in polling mode using indexes popped from NOTIF FIFO
*                 to retrieve the event information from notification table filled up by Llce firmware.
* @pre            
* @post           CanIf is notified about the bus-off events reported by the Llce firmware. User-defined callback for errors is called if defined.
* @implements     Can_Isr_X_Activity
*/
void Can_Llce_ProcessErrorNotification(void)
{   
    uint8 u8NotifIdx = 0U;
    uint8 u8HwCtrl = 0U;

    uint16 u16SafetyLoopEscapeCnt;

    Llce_Can_NotificationType genericError;
    CanErrorNotificationType CanError;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Report the possible buffered errors */
    while (LLCE_SWFIFO_EMPTY != Can_Llce_xNotifSwFifo.eFifoStatus)
    {
        (void)Llce_SwFifo_Pop(&genericError , &Can_Llce_xNotifSwFifo);

        if (LLCE_CAN_NOTIF_CHANNELERROR == genericError.eNotifId)
        {
            #if (CAN_43_LLCE_ERROR_NOTIF_ENABLE == STD_ON)
            /* Get hw controller id */
            u8HwCtrl = genericError.NotifList.ChannelError.u8HwCtrl;
            /* Report a channel error */
            CanError.u8CanIfCtrlId = pxConfig->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId;
            CanError.eNotifId = genericError.eNotifId;
            CanError.ErrorInfo = &(genericError.NotifList.ChannelError.ErrorInfo);
            Can_43_LLCE_ErrorNotificationCallback(&CanError);
            #endif
        }
        else
        {
            #if (CAN_43_LLCE_ERROR_NOTIF_ENABLE == STD_ON)
            /* Report a platform error */
            CanError.u8CanIfCtrlId = CAN_43_LLCE_NULL_OFFSET;
            CanError.eNotifId = genericError.eNotifId;
            CanError.ErrorInfo = &(genericError.NotifList.PlatformError);
            Can_43_LLCE_ErrorNotificationCallback(&CanError);
            #endif
        }
            
    }

    u16SafetyLoopEscapeCnt = LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE;

    while ( (LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_NOTIF_FIFO1_BASE_ADDRESS(pxConfig->u8ActiveHif))) & (uint32)(LLCE_FIFO_FEMTYD_U32))) && \
            (u16SafetyLoopEscapeCnt > 0U) )
    {
        u16SafetyLoopEscapeCnt--;
        u8NotifIdx = (uint8)Reg_Read32( LLCE_FIFO_POP0(LLCE_NOTIF_FIFO1_BASE_ADDRESS(pxConfig->u8ActiveHif)));

        /* Report busoff through the standard CanIf callback.  */
        if (LLCE_CAN_NOTIF_CHANNELERROR == Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId)
        {   
            /* Get hw controller (BCAN instance) which raised the bus-off notification. */
            u8HwCtrl = Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.u8HwCtrl;
            if (LLCE_ERROR_BUSOFF == Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.ErrorInfo.eErrorCode)
            {
                /* Make sure the controller is configured to get bus-off events in polling mode. */
                if (LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32 != (LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32 & (uint32)(pxConfig->aHwControllerDescriptors[u8HwCtrl].u32DrvControllerOptions)))
                {
                    #if (CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED == STD_ON)
                        /* LLCE issues bus-off notification, but does not freeze the controller. */
                        Can_43_LLCE_ControllerBusOffCallback(pxConfig->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId);
                    #else
                        /* LLCE issues bus-off notification after controller freezes. AUTOSAR required behavior */
                        Can_Llce_ControllerBusOff(u8HwCtrl);
                    #endif
                }
            }
            else /* Report the rest of possible errors through the user-defined callback */
            {
                #if (CAN_43_LLCE_ERROR_NOTIF_ENABLE == STD_ON)
                /* Report a channel error */
                CanError.u8CanIfCtrlId = pxConfig->aHwControllerDescriptors[u8HwCtrl].u8CanIfCtrlId;
                CanError.eNotifId = Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId;
                CanError.ErrorInfo = &(Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.ChannelError.ErrorInfo);
                Can_43_LLCE_ErrorNotificationCallback(&CanError);
                #endif
            }
        }
        else
        {
            #if (CAN_43_LLCE_ERROR_NOTIF_ENABLE == STD_ON)
            /* Report a platform error */
            CanError.u8CanIfCtrlId = CAN_43_LLCE_NULL_OFFSET;
            CanError.eNotifId = Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].eNotifId;
            CanError.ErrorInfo = &(Can_SharedMemory.Can_NotificationTable.Can_aNotif1_Table[pxConfig->u8ActiveHif][u8NotifIdx].NotifList.PlatformError);
            Can_43_LLCE_ErrorNotificationCallback(&CanError);
            #endif
        }
    }
}
#endif /* (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON) */

#if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)
static void Can_Llce_ProcessTxPollingClass(uint8 u8PollClassIdx)
{
    uint8 u8ControllerId = 0U;
    uint8 u8HwCtrl = 0U;

    uint16 u16HohIndex = 0U;

    uint16 u16AckEntry = 0U;
    uint16 u16SafetyLoopEscapeCnt;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    u16SafetyLoopEscapeCnt = pxConfig->pPlatfInitConfig->au16MaxPollTxAckCount[u8PollClassIdx];
    /* Process all entries from the TXACK FIFO corresponding to a polling class. Their order number starts with 16 (LLCE_CAN_CONFIG_MAXCTRL_COUNT) */
    while ((LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS((LLCE_CAN_CONFIG_MAXCTRL_COUNT + u8PollClassIdx)))) & (uint32)(LLCE_FIFO_FEMTYD_U32))) && \
           (u16SafetyLoopEscapeCnt > 0U) )
    {
        u16SafetyLoopEscapeCnt--;
        /* Read the index into the circular buffer containing the ack info.*/
        u16AckEntry = (uint16)(Reg_Read32( LLCE_FIFO_POP0(LLCE_FIFO_TXACK_BASE_ADDRESS((LLCE_CAN_CONFIG_MAXCTRL_COUNT + u8PollClassIdx)))) & LLCE_CAN_CONFIG_FIFO_FIXED_MASK_U32);
        
        u16HohIndex = Can_SharedMemory.Can_Tx_aAckInfo[u16AckEntry].u16FrameTag1;
        
        Can_Hth_FreeTxObject(u16HohIndex, 1U);

        u8ControllerId = pxConfig->aHohList[u16HohIndex].u8ControllerId;
        
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
        if(Can_43_LLCE_GetCoreID() == pxConfig->aControllerDescriptors[u8ControllerId].u32CoreId)
        {
#endif
            /* Get the hardware offset for this controller. */
            u8HwCtrl = pxConfig->aControllerDescriptors[u8ControllerId].u8HwCtrl;

            /* Filter outdated Acks gathered as a consequence of bus-off event or STOP command. */
            if (CAN_CS_STARTED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState)
            {
                /*
                (CAN108) The function Can_43_LLCE_MainFunction_Write shall perform the polling of TX indications when CanTxProcessing is set to POLLING or Mixed.
                In case of MIXED processing only the hardware objects for which CanHardwareObjectUsesPolling is set to TRUE shall be polled
                */
                if (LLCE_CAN_REFERENCE_NOT_USED != pxConfig->aHohList[u16HohIndex].u8CanMainFuncRWPeriodRef)
                {
                    /*
                    (CAN058) The Can module interacts among other modules (eg. Diagnostic Event Manager (DEM), Development Error Tracer (DET)) with the CanIf module in a direct way.
                            The driver only sees the CanIf module as origin and destination.
                    */
                    Can_43_LLCE_TxConfirmation( Can_SharedMemory.Can_Tx_aAckInfo[u16AckEntry].u16FrameTag2 );
                }
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            }
#endif
        }
    }
}
#endif /* (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON) */



static void Can_Llce_ProcessRxMb(const uint16 u16RxMbDescIdx)
{
    /* Number of data bytes. */
    uint8      u8MbDataLength = 0U;
    /* Variables for storing the CanID. */
    Can_IdType u32MbMessageId = 0U;
    /* Variable for storing the ConfigReg of the MB. */
    uint32     u32MbConfig = 0U;

    uint16  u16FilterId = 0U;

    #if (RXLUT2_ENABLE == STD_ON)
        uint16 u16AuxSearchResult = 0U;
    #endif

    uint32 u32Timestamp = 0U;

    uint32 u32Word1 = 0U;

    /* Pointer to the received frame payload. */
    uint8 * u8FramePayload = NULL_PTR;

    Llce_Can_GetMbData(&Can_SharedMemory, u16RxMbDescIdx, &u32MbConfig /*u32Word0*/, &u32Word1, &u8FramePayload, &u32Timestamp);

    /* Read the precalculated payload length; this is encoded in word1 of the MB */
    u8MbDataLength = (uint8)(u32Word1 >> LLCE_CAN_MB_PRECALC_LEN_SHIFT_U32);

    /* Get the ID of the message. */
    if(LLCE_CAN_MB_IDE_U32 == (u32MbConfig & LLCE_CAN_MB_IDE_U32))
    {
        /* For extended IDs the most significant bit must be set - according to Can_IdType requirement - chapter 8.2.3 of SWS CAN.*/
        u32MbMessageId = (Can_IdType)((u32MbConfig & LLCE_CAN_MB_ID_MASK_U32) | CAN_LPDU_IDE_U32 );
    }
    else
    {
        u32MbMessageId = (Can_IdType)((u32MbConfig & LLCE_CAN_MB_ID_MASK_U32) >> LLCE_CAN_MB_IDSTD_SHIFT_U32);
    }

    /* For FD the second most significant bit must be set - according to Can_IdType requirement - chapter 8.2.3 of SWS CAN.*/

   if(LLCE_CAN_MB_FDF_U32 == (u32Word1 & LLCE_CAN_MB_FDF_U32))
   {
        u32MbMessageId |= CAN_LPDU_FD_U32;
   }

    u16FilterId = Can_SharedMemory.Can_Rx_aMbDesc[u16RxMbDescIdx].u16FilterId;
    #if (RXLUT2_ENABLE == STD_ON)
        u16AuxSearchResult = Can_SharedMemory.Can_Rx_aMbDesc[u16RxMbDescIdx].u16AuxSearchResult;
    #endif

#if (CAN_43_LLCE_LPDU_NOTIFICATION_ENABLE == STD_ON)
     /*[CAN444] If the L-PDU call out returns false, the L-PDU shall not be processed any further. */
#if (CAN_43_LLCE_LPDU_CALLOUT_EXTENSION == STD_ON)
    if (TRUE == Can_43_LLCE_LPduReceiveCalloutFunction(u16FilterId, u32MbMessageId, u8MbDataLength, u8FramePayload))
#else
    if (TRUE == Can_43_LLCE_LPduReceiveCalloutFunction((uint8)u16FilterId, u32MbMessageId, u8MbDataLength, u8FramePayload))
#endif
    {
#endif
  #if (CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED == STD_ON)
        if (TRUE == Can_Llce_CheckCustomCallback(u16FilterId, u32MbMessageId, u8MbDataLength, u8FramePayload, u16RxMbDescIdx))
        {
  #endif
            Can_43_LLCE_RxIndication(u32MbMessageId, u16FilterId, u8FramePayload, u8MbDataLength);
            #if (RXLUT2_ENABLE == STD_ON)
                Can_43_LLCE_CanAuxFilterCallback(u16FilterId, u16AuxSearchResult);
            #endif
            #if (CAN_43_LLCE_RX_TIMESTAMP == STD_ON)
            Can_43_LLCE_RxTimestampNotification(u16FilterId, u32Timestamp);
            #else
            (void) u32Timestamp; /* Timestamp notification is disabled */
            #endif

  #if (CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED == STD_ON)
        }
  #endif
#if (CAN_43_LLCE_LPDU_NOTIFICATION_ENABLE == STD_ON)
    }
#endif

}

/*================================================================================================*/
/**
* @brief          Local function for calling notification function to notify upper layer from ISR when Interrupt mode selected.
* @details        Processes Rx interrupt flags.
                  This routine is called by:
                    - Can_43_LLCE_IPW_ProcessRx() from Can_43_LLCE.c file
                    - Can_IsrFC##FC##_UNI() / Can_IsrFC##FC##_##Name() from Can_Irq.c file
*
* @param[in]      u8RxInterface Fifo Interface [0-15] which generated interrupt for RX event.
*
* @pre            MB is configured for Rx.
* @post           Inform CanIf in case a data frame was received.
*
*
*/
void Can_Llce_ProcessRx(const uint8 u8RxInterface)
{
    uint8 u8ControllerId = 0U;
    uint8 u8HwCtrl = 0U;

    /* Index to the full receive message buffer */
    uint16 u16RxMbDescIdx = 0U;
    uint16 u16HohIndex = 0U;
    uint16 u16SafetyLoopEscapeCnt = 0U;
    uint32 u32FifoStatus = 0U;
    uint32 u32IER = Reg_Read32(LLCE_FIFO_IER(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8RxInterface)));
    uint32 u32Status = Reg_Read32(LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8RxInterface)));
    uint32 u32CoreId = Can_43_LLCE_GetCoreID();

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    /* Check for spurious interrupt and for initialized driver. */
    if ( (CAN_43_LLCE_READY == Can_43_LLCE_eDriverStatus[u32CoreId]) &&
            (LLCE_FIFO_FNEMTY_U32 == (u32IER & LLCE_FIFO_FNEMTY_U32)) && \
            (LLCE_FIFO_FNEMTY_U32 == (u32Status & LLCE_FIFO_FNEMTY_U32)) )
    {      
        u32FifoStatus = (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif))));

        u16SafetyLoopEscapeCnt = pxConfig->pPlatfInitConfig->au16MaxIntMbCount[u8RxInterface];

        /* Add the behavior for the else branch when one of FIFOs are empty of full.*/
        /*Check if there is available any pointer to a full rx message buffer*/
        while (( LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8RxInterface))) & (uint32)(LLCE_FIFO_FEMTYD_U32))) && \
                ( LLCE_FIFO_FFULLD_U32 != (u32FifoStatus & (uint32)(LLCE_FIFO_FFULLD_U32)) ) && \
                (u16SafetyLoopEscapeCnt > 0U ))
        {
            u16SafetyLoopEscapeCnt--;
            /* Read data from the fifo. */
            u16RxMbDescIdx = (uint16)Reg_Read32( LLCE_FIFO_POP0(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8RxInterface)));

            u16HohIndex = Can_SharedMemory.Can_Rx_aMbDesc[u16RxMbDescIdx].u16FilterId;

            u8ControllerId = pxConfig->aHohList[u16HohIndex].u8ControllerId;

            /* Get the hardware offset for this controller. */
            u8HwCtrl = pxConfig->aControllerDescriptors[u8ControllerId].u8HwCtrl;
             
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            if(Can_43_LLCE_GetCoreID() == pxConfig->aControllerDescriptors[u8ControllerId].u32CoreId)
            {
#endif
                if ( CAN_CS_STARTED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState ) 
                {   
                    /* Check if corresponding controller is started and the hoh is configured for reporting through interrupt mode. */
                    if (LLCE_CAN_REFERENCE_NOT_USED == pxConfig->aHohList[u16HohIndex].u8CanMainFuncRWPeriodRef)
                    {
                        Can_Llce_ProcessRxMb(u16RxMbDescIdx);
                    }
                }

                /* Write address of RX message buffer back to the LLCE */
                Reg_Write32( LLCE_FIFO_PUSH0(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif)), (uint32)u16RxMbDescIdx);
                u32FifoStatus = (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif))));
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            }
#endif
        }
        
    }

    /* Clear the interrupt status flag. */
    Reg_Write32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8RxInterface)), LLCE_FIFO_FNEMTY_U32); 

}

#if (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON)
    static void Can_Llce_ProcessRxPollingClass(uint8 u8PollClassIdx)
    {
        uint8 u8ControllerId = 0U;
        uint8 u8HwCtrl = 0U;

        uint16 u16RxMbDescIdx = 0U;

        uint16 u16HohIndex = 0U;

        uint16 u16SafetyLoopEscapeCnt;
        /* Timeout counter. */
        uint32 u32timeStart = 0U;
        uint32 u32timeElapsed = 0U;
        uint32 u32TicksDelayDuration = 0U;

        const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

        u16SafetyLoopEscapeCnt = pxConfig->pPlatfInitConfig->au16MaxPollMbCount[u8PollClassIdx];

        /* Process all entries from the RxOut FIFO corresponding to a polling class. Their order number starts with 16 (LLCE_CAN_CONFIG_MAXCTRL_COUNT) */
        while ((LLCE_FIFO_FEMTYD_U32 != (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS((LLCE_CAN_CONFIG_MAXCTRL_COUNT + u8PollClassIdx)))) & (uint32)(LLCE_FIFO_FEMTYD_U32))) && \
               (u16SafetyLoopEscapeCnt > 0U ) )
        {
            u16SafetyLoopEscapeCnt--;
            /* Read data from the fifo. */
            u16RxMbDescIdx = (uint16)Reg_Read32( LLCE_FIFO_POP0(LLCE_FIFO_RXOUT_BASE_ADDRESS((LLCE_CAN_CONFIG_MAXCTRL_COUNT + u8PollClassIdx))));
            u16HohIndex = Can_SharedMemory.Can_Rx_aMbDesc[u16RxMbDescIdx].u16FilterId;

            u8ControllerId = pxConfig->aHohList[u16HohIndex].u8ControllerId;
            
            /* Get the hardware offset for this controller. */
            u8HwCtrl = pxConfig->aControllerDescriptors[u8ControllerId].u8HwCtrl;

#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            if(Can_43_LLCE_GetCoreID() == pxConfig->aControllerDescriptors[u8ControllerId].u32CoreId)
            {
#endif
                /* Filter outdated frames gathered as a consequence of bus-off event or STOP command. */
                if (CAN_CS_STARTED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState)
                {
                    /*
                    (CAN108) The function Can_43_LLCE_MainFunction_Read shall perform the polling of RX indications when CanRxProcessing is set to POLLING or Mixed.
                    In case of MIXED processing only the hardware objects for which CanHardwareObjectUsesPolling is set to TRUE shall be polled
                    */
                    if (LLCE_CAN_REFERENCE_NOT_USED != pxConfig->aHohList[u16HohIndex].u8CanMainFuncRWPeriodRef)
                    {
                        Can_Llce_ProcessRxMb(u16RxMbDescIdx);
                    }
                }

                u32timeStart = OsIf_GetCounter(CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
                u32TicksDelayDuration = OsIf_MicrosToTicks(CAN_43_LLCE_TIMEOUT_DURATION, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
                u32timeElapsed = 0U;

                /* Wait for LLCE to consume the tokens before next token is pushed */
                while ( (0U == (uint32)(Reg_Read32( LLCE_FIFO_STATUS1(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif))) & (uint32)(LLCE_FIFO_FEMTYD_U32)) ) && (u32timeElapsed < u32TicksDelayDuration))
                {
                    u32timeElapsed += OsIf_GetElapsed(&u32timeStart, CAN_43_LLCE_SERVICE_TIMEOUT_TYPE);
                }

                /* Write address of RX message buffer back to the LLCE */
                Reg_Write32( LLCE_FIFO_PUSH0(LLCE_FIFO_RXIN_BASE_ADDRESS(pxConfig->u8ActiveHif)), (uint32)u16RxMbDescIdx);
#if CAN_43_LLCE_MULTICORE_ENABLED == (STD_ON)
            }
#endif
        }
    }
#endif

#if (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON)
    #ifdef CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE
       #if (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE == STD_OFF)
            /*================================================================================================*/
            /**
            * @brief          Service to perform the polling of TX confirmation and TX cancellation confirmation
            * @details        This routine is called by:
            *               - Can_43_LLCE_MainFunction_Write() from Can_43_LLCE.c file.
            *
            * @pre            The controller must be configured for transmit in polling mode and at least one MB is configured for Tx.
            * @post           Process the transmission data in case of availability.
            *
            *
            */
            void Can_Llce_MainFunctionWrite(void)
            {   
                uint8  u8PollClassIdx;

                const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

                if ( NULL_PTR != pxConfig )
                {   
                    for ( u8PollClassIdx = 0U; u8PollClassIdx < LLCE_CAN_MAX_POLLING_CLASSES; u8PollClassIdx++)
                    {   
                        /* Check only the polling classes which have been configured */
                        if (0U != pxConfig->pPlatfInitConfig->au16MaxPollTxAckCount[u8PollClassIdx])
                        {
                            Can_Llce_ProcessTxPollingClass(u8PollClassIdx);
                        }
                    }
                }
            }
        #else
            /*================================================================================================*/
            /**
            * @brief          Function called at fixed cyclic time, with polling of all the MessageBuffer referenced to writepoll
            * @details        Service for performs the polling of TX confirmation and TX cancellation confirmation when CAN_TX_PROCESSING is set to POLLING.
            *                 This routine is called by:
            *                 - CanIf or an upper layer according to Autosar requirements.
            *
            * @api
            *
            * @pre            Driver must be initialized.
            * @post           Send the data from that MB that is configured for Tx.
            */
            void Can_Llce_MainFunctionMultipleWritePoll(uint8 writepoll)
            {

                const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

                if ( NULL_PTR != pxConfig )
                {   
                    Can_Llce_ProcessTxPollingClass(writepoll);
                }
            }
            #endif /* End CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE */
    #endif /*ifdef (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE)*/
#endif /* (CAN_43_LLCE_TXPOLL_SUPPORTED == STD_ON) */



#if (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON)
    #ifdef CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ
        #if (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ == STD_OFF)
            /*================================================================================================*/
            /**
            * @brief          Service to perform the polling of RX indications.
            * @details        Processes Rx interrupt flags.
            *                 This routine is called by:
            *                    - Can_43_LLCE_MainFunction_Read() from Can_43_LLCE.c file.
            *
            * @pre            The controller must be configured for receive in polling mode and at least one MB is configured for Rx.
            * @post           Process the reception data in case of availability.
            *
            *
            */
            void Can_Llce_MainFunctionRead(void)
            {   
                uint8  u8PollClassIdx;

                const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

                if ( NULL_PTR != pxConfig )
                {   
                    for ( u8PollClassIdx = 0U; u8PollClassIdx < LLCE_CAN_MAX_POLLING_CLASSES; u8PollClassIdx++)
                    {   
                        /* Check only the polling classes which have been configured */
                        if (0U != pxConfig->pPlatfInitConfig->au16MaxPollMbCount[u8PollClassIdx])
                        {
                            Can_Llce_ProcessRxPollingClass(u8PollClassIdx);
                        }
                    }
                }
            }
        #else
            /*================================================================================================*/
            /**
            * @brief          Function called at fixed cyclic time, with polling of all the MessageBuffer referenced to .readpoll
            * @details        Service for performs the polling of RX indications when CAN_RX_PROCESSING is set to POLLING.
            *                 This routine is called by:
            *                 - CanIf or an upper layer according to Autosar requirements.
            *
            * @api
            * @pre            Driver must be initialized.
            * @post           Receive the data from that MB that is configured for Rx.
            *
            */
            void Can_Llce_MainFunctionMultipleReadPoll(uint8 readpoll)
            {
                const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();


                if ( NULL_PTR != pxConfig )
                {   
                    Can_Llce_ProcessRxPollingClass(readpoll);
                }
            }
        #endif  /* (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ == STD_OFF) */   
    #endif /* ifdef (CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ)*/
#endif /* (CAN_43_LLCE_RXPOLL_SUPPORTED == STD_ON) */


/*================================================================================================*/
/**
* @brief          Service to perform the polling of CAN status register flags to detect transition of CAN Controller state
* @details        The function Can_43_LLCE_MainFunction_Mode shall implement the polling of CAN status register flags to detect transition of CAN Controller state
*
* @param[in]      u8HwCtrl    CAN controller for which the polling shall be done.
*
* @pre
* @post
*
*/

void Can_Llce_MainFunctionMode(uint8 u8HwCtrl)
{
    /* Variable for updated mode */
    Can_ControllerStateType crtControllerMode = CAN_CS_UNINIT;
    
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
    /* Update mode indicator */
    (void)Can_Llce_GetControllerMode(u8HwCtrl, &crtControllerMode);

    /* Check for state changes */
    if(crtControllerMode != Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState) 
    {
        switch(crtControllerMode)
        {
            case CAN_CS_UNINIT:
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_UNINIT;
                Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_UNINIT);
                break;

            case CAN_CS_SLEEP:
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_SLEEP;
                Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_SLEEP);
                break;

            case CAN_CS_STARTED:
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_STARTED;
                Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_STARTED);
                /*
                (CAN425)   Enabling of CAN interrupts shall not be executed, when CAN interrupts have been disabled by function CAN_DisableControllerInterrupts.
                */
                if ( CAN_INTERRUPT_ENABLED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eInterruptMode )
                {
                    Can_Llce_EnableInterrupts(u8HwCtrl);
                }
                break;

            case CAN_CS_STOPPED:
                /* Check if interrupts are enabled */
                if ( CAN_INTERRUPT_ENABLED == Can_43_LLCE_ControllerStatuses[u8HwCtrl].eInterruptMode )
                {
                    Can_Llce_DisableInterrupts(u8HwCtrl);
                }
                Can_43_LLCE_ControllerStatuses[u8HwCtrl].eCachedControllerState = CAN_CS_STOPPED;
                Can_43_LLCE_ControllerModeIndication(u8HwCtrl, CAN_CS_STOPPED);
                break;

            default:
                /* Switch must handle all states. No action, just appease MISRA */
                break;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_03();
}

/*================================================================================================*/
/**
* @brief          Service disables all interrupts for the given CAN controller.
* @details        This routine is called by:
*                 - Can_43_LLCE_DisableControllerInterrupts() from Can_43_LLCE.c file.
*
* @param[in]      Controller CAN controller for which the init shall be done.
*
* @pre            Disable interrupts must be called prior to enable interrupts.
* @post           Clear all flags/bits that are needed for disabling the interrupts.
*
*
*/
void Can_Llce_DisableControllerInterrupts(uint8 u8HwCtrl)
{
    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_00();
    /*
       (CAN202) When Can_43_LLCE_DisableControllerInterrupts has been called several times, Can_43_LLCE_EnableControllerInterrupts must be called
                as many times before the interrupts are re-enabled.
    */
    Can_43_LLCE_ControllerStatuses[u8HwCtrl].u8IntDisableLevel++;

    /*
       (CAN049) The function Can_43_LLCE_DisableControllerInterrupts shall disable all interrupts for this CAN controller only at the first call of this function.
    */
    if ( (uint8)1 == Can_43_LLCE_ControllerStatuses[u8HwCtrl].u8IntDisableLevel )
    {
        /* Switch to disabled mode. */
        Can_43_LLCE_ControllerStatuses[u8HwCtrl].eInterruptMode = CAN_INTERRUPT_DISABLED;
        Can_Llce_DisableInterrupts(u8HwCtrl);
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_00();
}


/*================================================================================================*/
/**
* @brief          Service enables all interrupts that shall be enabled according the current software status.
* @details        This routine is called by:
*                  - Can_43_LLCE_EnableControllerInterrupts() from Can_43_LLCE.c file.
*
* @param[in]      Controller CAN controller for which the init shall be done.
*
* @pre            Can be executed only if disable interrupts was called before.
* @post           Enable all interrupts that must be enabled according the current sw status.
*
*
*/
void Can_Llce_EnableControllerInterrupts(uint8 u8HwCtrl )
{
    /* Variable that tells if disable ints was called at least once before. */
    uint8   u8DisCalledBefore = 0U;

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_01();
    /*
       (CAN202) When Can_43_LLCE_DisableControllerInterrupts has been called several times, Can_43_LLCE_EnableControllerInterrupts must be called as many
               times before the interrupts are re-enabled.
    */

    if ( Can_43_LLCE_ControllerStatuses[u8HwCtrl].u8IntDisableLevel > (uint8)0 )
    {
        /* When u8IntDisableLevel is greater than 0  means Can_43_LLCE_DisableControllerInterrupts was called at least once before this call of current function. */

        /* Decrement the nesting level. */
        Can_43_LLCE_ControllerStatuses[u8HwCtrl].u8IntDisableLevel--;

        u8DisCalledBefore = (uint8)0x1U;
    }

    /* Can_43_LLCE_DisableControllerInterrupts and Can_43_LLCE_EnableControllerInterrupts do not modify the software flags. */

    /*
       (CAN208) The function Can_43_LLCE_EnableControllerInterrupts shall perform no action when Can_43_LLCE_DisableControllerInterrupts has not been called before.
    */
    if ( ((uint8)0 == Can_43_LLCE_ControllerStatuses[u8HwCtrl].u8IntDisableLevel) && ((uint8)0x1U == u8DisCalledBefore) )
    {

        /* Switch to enabled mode. */
        Can_43_LLCE_ControllerStatuses[u8HwCtrl].eInterruptMode = CAN_INTERRUPT_ENABLED;
        Can_Llce_EnableInterrupts(u8HwCtrl);
    }

    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_01();
}


Std_ReturnType Can_Llce_GetControllerErrorState(uint8 u8HwCtrl, Can_ErrorStateType * ErrorStatePtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue;
    /* The value Error State of Controller */
    uint32  u32ErrorState = 0U;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_GETSTATUS;

        /* Send the command prepared above to the LLCE in order to be executed */
        eCommandReturnValue = Can_Llce_ExecuteIfCommand(u8HwCtrl);
        /* Read the BCAN error state */
        u32ErrorState =  Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.GetStatus.u32SR & LLCE_BCAN_SR_FLTCONF_MASK_U32;

        if (LLCE_FW_SUCCESS == eCommandReturnValue)
        {            
            switch(u32ErrorState)
            {
                case (LLCE_BCAN_SR_FLTCONF_ERROR_ACTIVE_U32):
                    *ErrorStatePtr = CAN_ERRORSTATE_ACTIVE;
                    eReturnValue = E_OK;
                    break;
                case (LLCE_BCAN_SR_FLTCONF_ERROR_PASSIVE_U32):
                    *ErrorStatePtr = CAN_ERRORSTATE_PASSIVE;
                    eReturnValue = E_OK;
                    break;
                case (LLCE_BCAN_SR_FLTCONF_BUSOFF10_U32):
                    *ErrorStatePtr = CAN_ERRORSTATE_BUSOFF;
                    eReturnValue = E_OK;
                    break;
                case (LLCE_BCAN_SR_FLTCONF_BUSOFF11_U32):
                    *ErrorStatePtr = CAN_ERRORSTATE_BUSOFF;
                    eReturnValue = E_OK;
                    break;
                default:
                    eReturnValue = E_NOT_OK;
                    break;
            }
        }
    }
    
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    
    return eReturnValue;
}

/**
*   @brief      Get Controller Rx Error Counter
*/
Std_ReturnType Can_Llce_GetControllerRxErrorCounter(uint8 u8HwCtrl, uint8 * RxErrorCounterPtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_GETSTATUS;

         /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand(u8HwCtrl) )
        {
            /* Read the BCAN Rx Error Counter */
            *RxErrorCounterPtr = (uint8)((Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.GetStatus.u32ECR & LLCE_BCAN_ECR_REC_MASK_U32) >> LLCE_BCAN_ECR_REC_SHIFT_U8);
            eReturnValue = E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

/**
*   @brief      Get Controller Tx Error Counter
*/
Std_ReturnType Can_Llce_GetControllerTxErrorCounter(uint8 u8HwCtrl, uint8 * TxErrorCounterPtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_GETSTATUS;

         /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand(u8HwCtrl) )
        {
            /* Read the BCAN Tx Error Counter */
            *TxErrorCounterPtr = (uint8)((Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.GetStatus.u32ECR & LLCE_BCAN_ECR_TEC_MASK_U32) >> LLCE_BCAN_ECR_TEC_SHIFT_U8);
            eReturnValue = E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

Std_ReturnType Can_Llce_GetControllerStatus(uint8 u8HwCtrl, Llce_Can_GetStatusCmdType * StatusPtr)
{
    /* Variable for return status. */
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_GETSTATUS;

         /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand(u8HwCtrl) )
        {
            *StatusPtr = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.GetStatus;
            eReturnValue = E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}

Std_ReturnType Can_Llce_GetFwVersion(const uint8 ** pVersionString, uint8 * pStringLength)
{
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue;

    uint8 u8Idx = 0;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    if(0U == u8VersionLength)
    {
        SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
        /* Read version from LLCE */
        if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
        {
            /* Configure the command id. */
            Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_GETFWVERSION;

            /* Send the command prepared above to the LLCE in order to be executed */
            eCommandReturnValue = Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController);

            u8VersionLength = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.GetFwVersion.stringLength;

            for(u8Idx = 0; u8Idx < u8VersionLength; u8Idx++)
            {
                au8VersionStringBuf[u8Idx] = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.GetFwVersion.versionString[u8Idx];
            }

            if (LLCE_FW_SUCCESS == eCommandReturnValue)
            {
                eReturnValue = E_OK;
            }
        }
       
        SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    }
    else 
    {
        eReturnValue = E_OK;
    }
        
    *pVersionString = au8VersionStringBuf;
    *pStringLength = u8VersionLength;

    return eReturnValue;
   
}

Std_ReturnType Can_Llce_ExecuteCustomCommand(const void* const argument)
{
    Std_ReturnType  eReturnValue = (Std_ReturnType)E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_CUSTOM;
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.pCustomCmdArg= (uint32)argument;

         /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand(pxConfig->u8DefaultController) )
        {
            eReturnValue = E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    
    return eReturnValue;
}


#if (CAN_43_LLCE_API_ENABLE_ABORT_MB == STD_ON)
/*================================================================================================*/
/**
* @brief          This service requests LLCE to abort lowest priority pending transmission
* @details        This service requests LLCE to abort lowest priority pending transmission
*                 belonging to a specific HTH. The MB will be released if the command succeeds.
*
* @param[in]      Hth - HW-transmit handler
*
* @return         Std_ReturnType
* @retval         E_OK MB has been aborted
* @retval         E_NOT_OK MB could not be aborted
*/
Std_ReturnType Can_Llce_AbortMb( Can_HwHandleType Hth)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;
    Llce_Fw_ReturnType eCommandReturnValue = LLCE_FW_NOTRUN;
    uint8 u8HwCtrl = 0U;
    uint8 u8CtrlId = 0U;
    uint8 u8AbortedFrameCnt = 0U;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    u8CtrlId = pxConfig->aHohList[Hth].u8ControllerId;

    /* Get the hardware offset for this controller. */
    u8HwCtrl = pxConfig->aControllerDescriptors[u8CtrlId].u8HwCtrl;

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_ABORT_MB;

        /* Configure the MB tag in order for the LLCE firmware to find the MB. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.AbortMb.u16FrameTag = Hth;

#if (CAN_43_LLCE_ABORT_ONLY_ONE_MB == STD_ON)
        /* Configure the MB tag in order for the LLCE firmware to find the MB. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.AbortMb.eAbortMbType = ABORT_ONLY_ONE_MB;
#else
        /* Configure the MB tag in order for the LLCE firmware to find the MB. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.AbortMb.eAbortMbType = ABORT_ALL_MB;
#endif 
         /* Send the command prepared above to LLCE in order to be executed */
        eCommandReturnValue =  Can_Llce_ExecuteIfCommand(u8HwCtrl);
        
        u8AbortedFrameCnt = Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].CmdList.AbortMb.u8AbortedFrameCnt;
    }
    
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    if (LLCE_FW_SUCCESS == eCommandReturnValue)
    {
        eReturnValue = E_OK;

        Can_Hth_FreeTxObject(Hth, u8AbortedFrameCnt);
    }

    return eReturnValue;
}
#endif


#if (CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY == STD_ON)
/*================================================================================================*/
/**
* @brief          This service requests LLCE to recover the given controller from bus-off state.
* @details        This synchronous service requests bus-off recovery when the controller is configured
*                 in manual bus-off recovery mode. No outstanding TX or RX frames are discarded.
*
* @param[in]      u8HwCtrl - hw controller
*
* @return         Std_ReturnType
* @retval         E_OK command acknowledged by LLCE
* @retval         E_NOT_OK command not acknowledged by LLCE
*/
Std_ReturnType Can_Llce_ManualBusOffRecovery(uint8 u8HwCtrl)
{
    /* Variable for return status. */
    Std_ReturnType eReturnValue = (Std_ReturnType)E_NOT_OK;

    const Can_43_LLCE_ConfigType* const pxConfig = Can_Llce_GetCurrentConfig();

    SchM_Enter_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();
    if((Std_ReturnType)E_OK == Can_Llce_CheckCommandAvailable())
    {
        /* Configure the command id. */
        Can_SharedMemory.aCanCmd[pxConfig->u8ActiveHif].eCmdId = LLCE_CAN_CMD_MANUAL_BUSOFF_RECOVERY;

         /* Send the command prepared above to the LLCE in order to be executed */
        if (LLCE_FW_SUCCESS == Can_Llce_ExecuteIfCommand(u8HwCtrl) )
        {
            eReturnValue = E_OK;
        }
    }
    SchM_Exit_Can_43_LLCE_CAN_EXCLUSIVE_AREA_04();

    return eReturnValue;
}
#endif


#define CAN_43_LLCE_STOP_SEC_CODE
#include "Can_43_LLCE_MemMap.h"


#ifdef __cplusplus
}
#endif

/** @} */


===== 文件 [111/112]: src\Llce_InterfaceCanConfig.c =====
/**
*   @file    Llce_InterfaceConfig.c
*
*   @version 1.0.0
*   @brief   LLCE defines used to configure the LLCE firmware and interface regarding FIFO usage.
*   @details LLCE  defines used to configure the LLCE firmware and interface regarding FIFOs. Those configuration parameters are used both by LLCE firmware and host software.
*
*
*   @addtogroup Llce_interface_configuration Configuration of FIFOs used as host interface.
*   @{
*/
/*==================================================================================================
*
* Copyright 2018-2023 NXP 
* 
* NXP Confidential. This software is owned or controlled by NXP and may only be used strictly in 
* accordance with the applicable license terms.
* By expressly accepting such terms or by downloading, installing, activating and/or otherwise using
* the software, you are agreeing that you have read, and that you agree to comply with and are bound
* by, such license terms.  If you do not agree to be bound by the applicable license terms, then you
* may not retain, install, activate or otherwise use the software.
==================================================================================================*/


#ifdef __cplusplus
extern "C"
{
#endif
#ifndef __DOXYGEN__
/**
* @page misra_violations MISRA-C:2004 violations
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.1, Identifiers (internal and external) shall not rely 
* on the significance of more than 31 characters. 
* The used compilers use more than 31 chars for identifiers.
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.4, Macro identifiers shall be distinct.
* This violation is due to the AUTOSAR requirement [SWS_BSW_00036] (perform inter module checks).
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.2, Identifiers declared in the same scope and name space shall be distinct.
* This rule does not apply if either identifier is a macro identifier, because this case is covered
* by Rule 5.4 and Rule 5.5.
*
* @section [global]
* Violates MISRA 2012 Required Rule 5.5, Identifiers shall be distinct from macro names.
* The identifier clash is between macro identifiers. Therefore, this rule is incorrectly reported by the tool.
* 
*@section [global]
* Violates MISRA 2012 Advisory Rule 8.9, Objects shall be defined at block scope if they are only accessed from within a single function
* Some macros are used either in FW or driver, or provided as API
*
* @section [global]
* Violates MISRA 2012 Advisory Rule 8.7, Functions and objects should not be defined with external linkage if they are referenced in only one translation unit.
* Some macros are used either in FW or driver, or provided as API
*
*/
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Llce_InterfaceCanConfig.h"
#include "Llce_InterfaceFifo.h"
#include "Llce_InterfaceMemLayoutCheck.h"
#include "Llce_InterfaceCanTypes.h"
#include "Llce_InterfaceCanUtils.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/

/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/
/** @brief    Configuration of FIFOs used for BLRIN role. 
 *  @details  It is used to configure which FIFOs are used to send indexes to full tx mb descriptors from host to LLCE.
 **/ 

const uint32 Llce_Can_u32BlrinBaseAddress[LLCE_CAN_CONFIG_MAXCTRL_COUNT] = {
    LLCE_FIFO_42_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO0*/
    LLCE_FIFO_43_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO1*/
    LLCE_FIFO_44_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO2*/
    LLCE_FIFO_45_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO3*/
    LLCE_FIFO_46_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO4*/
    LLCE_FIFO_47_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO5*/
    LLCE_FIFO_48_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO6*/
    LLCE_FIFO_49_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO7*/
    LLCE_FIFO_50_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO8*/
    LLCE_FIFO_51_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO9*/
    LLCE_FIFO_52_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO10*/
    LLCE_FIFO_53_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO11*/
    LLCE_FIFO_54_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO12*/
    LLCE_FIFO_55_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO13*/
    LLCE_FIFO_56_BASE_ADDRESS,  /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO14*/
    LLCE_FIFO_57_BASE_ADDRESS   /**< @brief   Base address of the hardware FIFO having the role of BLRINx FIFO15*/
    };
   

 /** @brief    Configuration of FIFOs used for RXOUT role. 
 *   @details  It is used to configure which FIFOs are used to send indexes to full rx mb descriptors from LLCE to host.
 **/  
const uint32 Llce_Can_u32RxoutBaseAddress[LLCE_CAN_CONFIG_MAXCTRL_COUNT + LLCE_CAN_MAX_POLLING_CLASSES] = {
    LLCE_FIFO_21_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO0*/
    LLCE_FIFO_22_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO1*/
    LLCE_FIFO_23_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO2*/
    LLCE_FIFO_24_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO3*/
    LLCE_FIFO_25_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO4*/
    LLCE_FIFO_26_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO5*/
    LLCE_FIFO_27_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO6*/
    LLCE_FIFO_28_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO7*/
    LLCE_FIFO_29_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO8*/
    LLCE_FIFO_30_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO9*/
    LLCE_FIFO_31_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO10*/
    LLCE_FIFO_32_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO11*/
    LLCE_FIFO_33_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO12*/
    LLCE_FIFO_34_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO13*/
    LLCE_FIFO_35_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO14*/
    LLCE_FIFO_36_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO15*/
    LLCE_FIFO_2_BASE_ADDRESS,    /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO16*/
    LLCE_FIFO_3_BASE_ADDRESS,    /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO17*/
    LLCE_FIFO_4_BASE_ADDRESS,    /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO18*/
    LLCE_FIFO_5_BASE_ADDRESS,    /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO19*/
    LLCE_FIFO_6_BASE_ADDRESS,    /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO20*/
    LLCE_FIFO_7_BASE_ADDRESS     /**< @brief   Base address of the hardware FIFO having the role of RXOUTx FIFO21*/
    };

/** @brief    Configuration of FIFOs used for either NOTIF_INTR or NOTIF_POLL role. 
 *  @details  It is used to configure for each host which FIFOs are used to send notifications from LLCE to host in interrupt mode.
 **/ 
const uint32 Llce_Can_u32NotifFifo0BaseAddress[LLCE_CAN_CONFIG_HIF_COUNT] = {
    LLCE_FIFO_0_BASE_ADDRESS,     /**< @brief   Base address of the hardware FIFO having the role of NOTIF_INTR FIFO for HIF0 */
    LLCE_FIFO_8_BASE_ADDRESS      /**< @brief   Base address of the hardware FIFO having the role of NOTIF_INTR FIFO for HIF1 */
    };

 /** @brief    Configuration of FIFOs used for either NOTIF_INTR or NOTIF_POLL role. 
 *   @details  It is used to configure for each host which FIFOs are used to send notifications from LLCE to host in polling mode.
 **/    
const uint32 Llce_Can_u32NotifFifo1BaseAddress[LLCE_CAN_CONFIG_HIF_COUNT] = {
    LLCE_FIFO_1_BASE_ADDRESS,     /**< @brief   Base address of the hardware FIFO having the role of NOTIF_POLL FIFO for HIF0 */
    LLCE_FIFO_9_BASE_ADDRESS,     /**< @brief   Base address of the hardware FIFO having the role of NOTIF_POLL FIFO for HIF1 */
    };    

/** @brief    Configuration of FIFOs used for TXACK role. 
 *  @details  It is used to configure which FIFOs are used to send tx confirmations from LLCE to host.
 **/ 
const uint32 Llce_Can_u32TxackBaseAddress[LLCE_CAN_RX_TX_INTERFACES] = {
    LLCE_FIFO_84_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK0 FIFO*/
    LLCE_FIFO_85_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK1 FIFO*/
    LLCE_FIFO_86_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK2 FIFO*/
    LLCE_FIFO_87_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK3 FIFO*/
    LLCE_FIFO_88_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK4 FIFO*/
    LLCE_FIFO_89_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK5 FIFO*/
    LLCE_FIFO_90_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK6 FIFO*/
    LLCE_FIFO_91_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK7 FIFO*/
    LLCE_FIFO_92_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK8 FIFO*/
    LLCE_FIFO_93_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK9 FIFO*/
    LLCE_FIFO_94_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK10 FIFO*/
    LLCE_FIFO_95_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK11 FIFO*/
    LLCE_FIFO_96_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK12 FIFO*/
    LLCE_FIFO_97_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK13 FIFO*/
    LLCE_FIFO_98_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK14 FIFO*/
    LLCE_FIFO_99_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK15 FIFO*/
    LLCE_FIFO_10_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK16 FIFO*/
    LLCE_FIFO_11_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK17 FIFO*/
    LLCE_FIFO_12_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK18 FIFO*/
    LLCE_FIFO_13_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK19 FIFO*/
    LLCE_FIFO_14_BASE_ADDRESS,   /**< @brief   Base address of the hardware FIFO having the role of TXACK20 FIFO*/
    LLCE_FIFO_15_BASE_ADDRESS    /**< @brief   Base address of the hardware FIFO having the role of TXACK21 FIFO*/
    };


/** @brief    Configuration of FIFOs used for BLROUT role. 
 *  @details  It is used to configure which FIFOs are used to send indexes to empty tx mb descriptors from LLCE to host.
 **/ 
const uint32 Llce_Can_u32BlroutBaseAddress[LLCE_CAN_CONFIG_MAXCTRL_COUNT] = {
    LLCE_FIFO_63_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT0 FIFO*/
    LLCE_FIFO_64_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT1 FIFO*/
    LLCE_FIFO_65_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT2 FIFO*/
    LLCE_FIFO_66_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT3 FIFO*/
    LLCE_FIFO_67_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT4 FIFO*/
    LLCE_FIFO_68_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT5 FIFO*/
    LLCE_FIFO_69_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT6 FIFO*/
    LLCE_FIFO_70_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT7 FIFO*/
    LLCE_FIFO_71_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT8 FIFO*/
    LLCE_FIFO_72_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT9 FIFO*/
    LLCE_FIFO_73_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT10 FIFO*/
    LLCE_FIFO_74_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT11 FIFO*/
    LLCE_FIFO_75_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT12 FIFO*/
    LLCE_FIFO_76_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT13 FIFO*/
    LLCE_FIFO_77_BASE_ADDRESS,      /**< @brief   Base address of the hardware FIFO having the role of BLROUT14 FIFO*/
    LLCE_FIFO_78_BASE_ADDRESS       /**< @brief   Base address of the hardware FIFO having the role of BLROUT15 FIFO*/
    };

/** @brief    Configuration of FIFOs used for RXIN role. 
 *  @details  It is used to configure for each host  which FIFOs are used to send indexes to empty rx mb descriptors from host to LLCE.
 **/   
const uint32 Llce_Can_u32RxinBaseAddress[LLCE_CAN_CONFIG_HIF_COUNT] = {
    LLCE_FIFO_16_BASE_ADDRESS,/**< @brief   Base address of the FIFO having the role of RXIN FIFO for HIF0*/
    LLCE_FIFO_18_BASE_ADDRESS /**< @brief   Base address of the FIFO having the role of RXIN FIFO for HIF1*/
    };

/** @brief    Configuration of FIFOs used for commands. 
 *  @details  It is used to configure which FIFOs are used to send commands from host to LLCE.
 **/ 
const uint32 Llce_Can_u32CmdBaseAddress[LLCE_CAN_CONFIG_HIF_COUNT] = {
    LLCE_FIFO_101_BASE_ADDRESS, /**< @brief   Base address of the CMD FIFO for HIF0   */
    LLCE_FIFO_102_BASE_ADDRESS  /**< @brief   Base address of the CMD FIFO for HIF1   */
    };



/** @brief    Configuration of FIFO used for logging interface. 
 *  @details  It is used to configure which FIFO is used to send indexes to full rx mb descriptors from logging host core  back to LLCE.
 **/ 
const uint32 Llce_Can_u32RxinLogBaseAddress[1] = {
    LLCE_FIFO_37_BASE_ADDRESS  /**< @brief   Base address of the RXINLOG FIFO. */
    }; 

    
/** @brief    Configuration of FIFO used for logging interface. 
 *  @details  It is used to configure which FIFO is used to send indexes to  full rx mb descriptors from LLCE to logging host core.
 **/  
const uint32 Llce_Can_u32RxoutLogBaseAddress[1] = {
    LLCE_FIFO_38_BASE_ADDRESS  /**< @brief   Base address of the RXOUTLOG FIFO. */
    };

/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

/*=================================================================================================
*                                       LOCAL FUNCTIONS PROTOTYPES
==================================================================================================*/

/*=================================================================================================
*                                            LOCAL FUNCTIONS 
==================================================================================================*/

/*=================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/

/*================================================================================================*/


/**
* @brief          Disable FNEMPTY interrupt for TXACK and RXOUT fifos, thus disabling ACK and RX frames to be processed on interrupt.
* @details        Recommended API to disable FIFO interrupt for host processing
*
* @param[in]      u8FifoInterface Fifo interface mapped to the hw controller (1 to 1 default mapping).
* @param[in]      u8Hif Host Interface
*
* @return         void
*
*/
void DisableFifoInterrupts (uint8 u8FifoInterface, uint8 u8Hif)
{
    Llce_Sema42_Lock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, u8Hif), LLCE_HOST_CORE_SEMA42_DOMAIN);
    /* Disable RXOUT interrupt. */
    Reg_Bit_Clear32( LLCE_FIFO_IER(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);
    Llce_Sema42_Unlock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, u8Hif));


    Llce_Sema42_Lock( Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, u8Hif), LLCE_HOST_CORE_SEMA42_DOMAIN);
    /* Disable TXACK interrupt. */
    Reg_Bit_Clear32( LLCE_FIFO_IER(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);
    Llce_Sema42_Unlock( Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, u8Hif));

}


/**
* @brief          Enable FNEMPTY interrupt for TXACK and RXOUT fifos, thus enabling ACK and RX frames to be processed on interrupt.
* @details        Recommended API to enable FIFO interrupt for host processing
*
* @param[in]      u8FifoInterface Fifo interface mapped to the hw controller (1 to 1 default mapping).
* @param[in]      u8Hif Host Interface
*
* @return         void
*
*/
void EnableFifoInterrupts (uint8 u8FifoInterface, uint8 u8Hif)
{
    /* Clear all interrupt status flags. */
    Reg_Write32(LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface)), Reg_Read32(LLCE_FIFO_STATUS1(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface))));

    Llce_Sema42_Lock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, u8Hif), LLCE_HOST_CORE_SEMA42_DOMAIN);
    /* Enable needed interrupt. */
    Reg_Bit_Set32( LLCE_FIFO_IER(LLCE_FIFO_RXOUT_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);
    Llce_Sema42_Unlock( Llce_GetSema42Gate(LLCE_FIFO_RXOUT_INDEX, u8Hif));

    /* Clear all interrupt status flags. */
    Reg_Write32(LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface)),Reg_Read32(LLCE_FIFO_STATUS1(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface))));

    Llce_Sema42_Lock( Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, u8Hif), LLCE_HOST_CORE_SEMA42_DOMAIN);
    /* Enable needed interrupt. */
    Reg_Bit_Set32( LLCE_FIFO_IER(LLCE_FIFO_TXACK_BASE_ADDRESS(u8FifoInterface)), LLCE_FIFO_FNEMTY_U32);
    Llce_Sema42_Unlock( Llce_GetSema42Gate(LLCE_FIFO_TXACK_INDEX, u8Hif));

}



#ifdef __cplusplus
}
#endif

/** @} */


===== 文件 [112/112]: src\Llce_SwFifo.c =====
/**
*   
*   @brief   LLCE Generic Software Fifo functions
*   @details This file contains the LLCE Generic Software Fifo function definitions.
*
*   @addtogroup LLCE_SwFifo
*   @{
*/
/*==================================================================================================
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

#include "Llce_SwFifo.h"

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/

/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

/*=================================================================================================
*                                       LOCAL FUNCTIONS PROTOTYPES
==================================================================================================*/

/*=================================================================================================
*                                            LOCAL FUNCTIONS 
==================================================================================================*/        

/*=================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
#if (CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED == STD_ON)
/**
    * @brief          Initialize the Software Fifo structure with needed fields.
    * @details        Receives the size of the elements stored in the FIFO, the number of elements
    *                 able to be stored in the FIFO, the base address and the structure itself needed
    *                 to be initialized and updates the fields: u16MaxNElements, u16WrByteIdx, u16RdByteIdx,
    *                 pu8BaseAddr, u8ElemSize, eFifoStatus
    *  
    * @param          pu8BaseAddr - pointer to the base address of the buffer used by the FIFO
    * @param          u8ElemSize - the size of the elements stored in the FIFO
    * @param          u16MaxNElements - the maximum number of elements stored in the FIFO
    * @param          pLlce_SwFifo - pointer to the Software Fifo structure used
    *
    * @retval         Llce_Fw_ReturnType
    *
    * @pre            A buffer should be declared in order to be passed to the FIFO 
    *
    */
Llce_Fw_ReturnType Llce_SwFifo_Init(void *pu8BaseAddr, uint8 u8ElemSize, uint16 u16MaxNElements, Llce_SwFifo_Type *pLlce_SwFifo)
{   
    pLlce_SwFifo->u16MaxNElements = u16MaxNElements;
    pLlce_SwFifo->u16WrByteIdx = 0;
    pLlce_SwFifo->u16RdByteIdx = 0;
    pLlce_SwFifo->pu8BaseAddr = (uint8*)pu8BaseAddr;
    pLlce_SwFifo->u8ElemSize = u8ElemSize;
    pLlce_SwFifo->eFifoStatus = LLCE_SWFIFO_EMPTY;
    return LLCE_FW_SUCCESS;
}

/**
    * @brief          Stores a new element in the FIFO
    * @details        Receives the element to be stored and the Software FIFO and writes the
    *                 information, byte by byte into the FIFO buffer
    *  
    * @param          pGenericElem - pointer to the element which needs to be pushed into FIFO
    * @param          pLlce_SwFifo - pointer the Software FIFO structure used
    *
    * @retval         Llce_Fw_ReturnType
    *
    * @pre            The FIFO should be initialized before applying any operation on it
    *
    */
Llce_Fw_ReturnType Llce_SwFifo_Push(const void *pGenericElem, Llce_SwFifo_Type *pLlce_SwFifo)
{
    /* Index used to iterate each byte into the elements of struct type */
    uint8 u8CopyIdx;
    /* Variable for return status. */
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_SUCCESS;
    /* Pointer to the element which needs to be pushed. Used for elements of struct type */
    const uint8 *pElem;

    /* Check FIFO STATUS */
    if (pLlce_SwFifo->eFifoStatus == LLCE_SWFIFO_FULL)
    {
        eReturnValue = LLCE_FW_ERROR;
    }
    else /* Fifo not full */
    {   
        switch (pLlce_SwFifo->u8ElemSize)
        {
        case ((uint8)sizeof(uint32)):
            *(uint32*)(&(pLlce_SwFifo->pu8BaseAddr[pLlce_SwFifo->u16WrByteIdx])) = *(const uint32*)pGenericElem;
            
            break;
        case ((uint8)sizeof(uint16)):
            *(uint16*)(&(pLlce_SwFifo->pu8BaseAddr[pLlce_SwFifo->u16WrByteIdx])) = *(const uint16*)pGenericElem;

            break;
        case ((uint8)sizeof(uint8)):
            *(uint8*)(&(pLlce_SwFifo->pu8BaseAddr[pLlce_SwFifo->u16WrByteIdx])) = *(const uint8*)pGenericElem;

            break;
        default: /* used for elements of struct type */
            pElem = (const uint8*)pGenericElem;
            /* Copy each byte from source to destination */
            for (u8CopyIdx = 0; u8CopyIdx < pLlce_SwFifo->u8ElemSize; u8CopyIdx++)
            {
                pLlce_SwFifo ->pu8BaseAddr[pLlce_SwFifo->u16WrByteIdx + u8CopyIdx] = pElem[u8CopyIdx];
            }

            break;
        }

        /* Update the position of the writing index */
        pLlce_SwFifo->u16WrByteIdx += pLlce_SwFifo->u8ElemSize;

        /* Check writing index position and reset if needed */
        if (pLlce_SwFifo->u16WrByteIdx >= (pLlce_SwFifo->u8ElemSize * pLlce_SwFifo->u16MaxNElements))
        {
            pLlce_SwFifo->u16WrByteIdx = 0;
        }

        /* Update FIFO status after push operation */
        if (pLlce_SwFifo->u16WrByteIdx == pLlce_SwFifo->u16RdByteIdx)
        {
            pLlce_SwFifo->eFifoStatus = LLCE_SWFIFO_FULL;
        }
        else
        {
            pLlce_SwFifo->eFifoStatus = LLCE_SWFIFO_OPERATIONAL;
        }
    }

    return eReturnValue;
}

/**
    * @brief          Removes an element in the FIFO
    * @details        Receives a pointer to the location where the element will be stored
    *                 and the Software FIFO and writes the information, byte by byte from
    *                 the FIFO buffer to the destination location
    *  
    * @param          pGenericElem - pointer location where the extracted element will be stored
    * @param          pLlce_SwFifo - pointer the Software Fifo structure used
    *
    * @retval         Llce_Fw_ReturnType
    *
    * @pre            The FIFO should be initialized before applying any operation on it
    *
    */
Llce_Fw_ReturnType Llce_SwFifo_Pop(void *pGenericElem, Llce_SwFifo_Type *pLlce_SwFifo)
{
    /* Index used to iterate each byte into the elements of struct type */
    uint8 u8CopyIdx;
    /* Variable for return status. */
    Llce_Fw_ReturnType eReturnValue = LLCE_FW_SUCCESS;
    /* Pointer to the element which needs to be popped.Used for elements of struct type  */
    uint8 *pElem;
    
    /* Check FIFO STATUS */
    if (pLlce_SwFifo->eFifoStatus == LLCE_SWFIFO_EMPTY)
    {
        eReturnValue = LLCE_FW_ERROR;
    }
    else /* Fifo not empty */
    {   
        switch (pLlce_SwFifo->u8ElemSize)
        {
        case ((uint8)sizeof(uint32)):
            *(uint32*)pGenericElem = *(uint32*)(&(pLlce_SwFifo->pu8BaseAddr[pLlce_SwFifo->u16RdByteIdx]));

            break;
        case ((uint8)sizeof(uint16)):
            *(uint16*)pGenericElem = *(uint16*)(&(pLlce_SwFifo->pu8BaseAddr[pLlce_SwFifo->u16RdByteIdx]));

            break;
        case ((uint8)sizeof(uint8)):
            *(uint8*)pGenericElem = *(uint8*)(&(pLlce_SwFifo->pu8BaseAddr[pLlce_SwFifo->u16RdByteIdx]));

            break;
        default: /* used for elements of struct type */
            pElem = (uint8*)pGenericElem;
            /* Copy each byte from source to destination */
            for (u8CopyIdx = 0; u8CopyIdx < pLlce_SwFifo->u8ElemSize; u8CopyIdx++)
            {
                pElem[u8CopyIdx] = pLlce_SwFifo ->pu8BaseAddr[pLlce_SwFifo->u16RdByteIdx + u8CopyIdx];
            }

            break;
        }

        /* Update the position of the reading index */
        pLlce_SwFifo->u16RdByteIdx += pLlce_SwFifo->u8ElemSize;

        /* Check reading index position and reset if needed */
        if (pLlce_SwFifo->u16RdByteIdx >= (pLlce_SwFifo->u8ElemSize * pLlce_SwFifo->u16MaxNElements))
        {
            pLlce_SwFifo->u16RdByteIdx = 0;
        }
        /* Update FIFO status after pop operation */
        if (pLlce_SwFifo->u16WrByteIdx == pLlce_SwFifo->u16RdByteIdx)
        {
            pLlce_SwFifo->eFifoStatus = LLCE_SWFIFO_EMPTY;
        }
        else
        {
            pLlce_SwFifo->eFifoStatus = LLCE_SWFIFO_OPERATIONAL;
        }
    }

    return eReturnValue;
}
#endif

#ifdef __cplusplus
}
#endif

/** @} */


