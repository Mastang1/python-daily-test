
==============================================================================
[CONTEXT FOR AI ASSISTANT]
You are processing a packed codebase containing 13 source files.
Project Root: template_NXP
Packed Date: 2026-01-13 10:18:03

[INSTRUCTIONS]
1. The code below contains multiple files packed into a single text block.
2. Each file is demarcated by a START header and an END footer.
3. The format is:
   ========== START FILE: <relative_path> ==========
   <file_content>
   ========== END FILE: <relative_path> ==========
4. When analyzing, strictly distinguish between separate files based on these markers.
5. If asked to modify, please reference the specific file path provided in the header.

[FILE LIST]
- generate_PB\Can_43_LLCE_Can_BaudRate_Inference.m
- generate_PB\Can_43_LLCE_Macros.m
- generate_PB\Can_43_LLCE_VersionCheck_Src_PB.m
- generate_PB\include\Can_43_LLCE_AFcfg.h
- generate_PB\include\Can_43_LLCE_PBcfg.h
- generate_PB\src\Can_43_LLCE_AFcfg.c
- generate_PB\src\Can_43_LLCE_Headless_Ip_PBcfg.c
- generate_PB\src\Can_43_LLCE_PBcfg.c
- generate_PC\Can_43_LLCE_VersionCheck_Inc.m
- generate_PC\Can_43_LLCE_VersionCheck_Src.m
- generate_PC\include\Can_43_LLCE_Cfg.h
- generate_PC\include\Can_43_LLCE_Externals.h
- generate_PC\src\Can_43_LLCE_Cfg.c
==============================================================================

========== START FILE: generate_PB\Can_43_LLCE_Can_BaudRate_Inference.m ==========
[!/**
*   @file    Can_BaudRate_Inference.m
*   @version 1.0.10
*
*   @brief   Compute CAN Baud Rate segments.
*   @details Compute segments starting from desired baud rate and physical setup parameters.
*  
*   Project RTD AUTOSAR 4.4
*   Platform CORTEXM
*   Peripheral LLCE
*   Dependencies 
*  
*   ARVersion 4.4.0
*   ARRevision ASR_REL_4_4_REV_0000
*   ARConfVariant
*   SWVersion 1.0.10
*   BuildVersion S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/!]

[!/***********************Can Baud Inference Macro ****************************************/!]
[!NOCODE!]
[!MACRO "Can_BaudRate_Inference",
        "CanPhysBusLength" = "40",
        "PropDelayTransceiver" = "150",
        "PhaseSegment1_Max" = "256",
        "PhaseSegment2_Max" = "128", 
        "NumOfTQ" = "1"!]
[!NOCODE!]
    [!/* Initiates the inference of the CAN bit timing values from the CanControllerBaudRate parameter. */!]
    [!VAR "PhaseSegment1_Min" ="num:i(2)"!]
    [!VAR "PhaseSegment2_Min" ="num:i(2)"!]
    [!VAR "BusPropagationDelay" ="5 div 1000000000"!][!/* Hard coded to 5ns/m. */!]
    [!VAR "PhysicalDelayOfBus"="$CanPhysBusLength * $BusPropagationDelay"!]
    [!/* Tprop_seg=TpropAB + TpropBA = 2 * (Tbus + Trx + Ttx). Usually Trx=Ttx. */!]
    [!VAR "TpropagationSegment"="2*($PhysicalDelayOfBus + 2 * $PropDelayTransceiver)"!]
    [!VAR "PropagationSegment"="1+round($TpropagationSegment div $NumOfTQ )"!]
    [!IF "($PropagationSegment >= 0) and ($PropagationSegment <= 256)"!]
        [!VAR "PhaseSegments" = "($NumOfTQ - $PropagationSegment - $Tsyncsegment)"!]
        [!IF "$PhaseSegments >= 2"!]
            [!VAR "Modulo" = "$PhaseSegments mod 2"!]
            [!IF "$Modulo = 0"!]
                [!VAR "PhaseSeg1" = "num:i($PhaseSegments div 2)"!]
                [!VAR "PhaseSeg2" = "num:i($PhaseSeg1)"!]
            [!ELSE!]
                [!VAR "PhaseSeg1" = "num:i(($PhaseSegments - 1) div 2)"!]
                [!VAR "PhaseSeg2" = "num:i($PhaseSeg1 + 1)"!]
            [!ENDIF!]
            [!IF "($PhaseSeg1 < $PhaseSegment1_Min) or ($PhaseSeg1 > $PhaseSegment1_Max)"!]
                [!ERROR!]
                    For [!"node:name(.)"!] of CanController [!"../../CanHwChannel"!],
                    PhaseSegment1 is out of range [!"num:i($PhaseSegment1_Min)"!]:[!"num:i($PhaseSegment1_Max)"!]]. Current value is [!"num:i($PhaseSeg1)"!].
                    The bit length has [!"num:i($NumOfTQ)"!] Time Quantas.
                    Propagation Segment based bus length and transceiver delay has [!"num:i($PropagationSegment)"!] Time Quantas.
                    Need to increase PropagationSegment or to decrease the number of Time Quantas per bit.
                [!ENDERROR!]
            [!ENDIF!]
            [!IF "($PhaseSeg2 < $PhaseSegment2_Min) or ($PhaseSeg2 > $PhaseSegment2_Max)"!]
                [!ERROR!]
                    For [!"node:name(.)"!] of CanController [!"../../CanHwChannel"!],
                    PhaseSegment2 is out of range [!"num:i($PhaseSegment2_Min)"!]:[!"num:i($PhaseSegment2_Max)"!]]. Current value is [!"num:i($PhaseSeg2)"!]
                    The bit length has [!"num:i($NumOfTQ)"!] Time Quantas.
                    Propagation Segment based bus length and transceiver delay has [!"num:i($PropagationSegment)"!] Time Quantas.
                    Need to increase PropagationSegment or to decrease the number of Time Quantas per bit.
                [!ENDERROR!]
            [!ENDIF!]
            [!IF "$PhaseSeg1 < 5"!]
                [!VAR "RJWidth" = "num:i($PhaseSeg1)"!]
            [!ELSE!]
                [!VAR "RJWidth" = "4"!]
            [!ENDIF!]
        [!ELSE!]
            [!ERROR!] For [!"node:name(.)"!] of CanController [!"../../CanHwChannel"!], (Phase Segment1+Phase Segment2) must be >= 8. Increase no of NumOfTQ ([!"num:i($NumOfTQ)"!]) per bit or decrease PropSegment ([!"num:i($PropagationSegment)"!])(based CanBusLength and CanPropDelayTranceiver).[!ENDERROR!]
        [!ENDIF!]
    [!ELSE!]
        [!ERROR!]
        For [!"node:name(.)"!] of CanController [!"../../CanHwChannel"!],
        Delay A_to_B >= node output delay(A) + bus line delay(A+B) + node input delay(B)
        Prop_Seg >= Delay A_to_B + Delay B_to_A
        Prop_Seg >= 2 * [max(node output delay+ bus line delay + node input delay)]

        The formulas used:
        BusPropagationDelay =5 div 1000000000 /* Hard coded to 5ns/m. */
        PhysicalDelayOfBus = CanBusLength * BusPropagationDelay
        TpropagationSegment = 2*(PhysicalDelayOfBus + 2 * CanPropDelayTranceiver)
        PropagationSegment = 1+round(TpropagationSegment div NumOfTQ )
        [!ENDERROR!]
    [!ENDIF!]
    [!VAR "NoTimeQuantas"= "num:i($Tsyncsegment + $PropagationSegment + $PhaseSeg1 + $PhaseSeg2)"!]
    [!IF "CanAdvancedSetting = 'true'"!]
        [!/* Ensure a minimum of 8 time quanta for basic CAN bit time */!]
        [!IF "num:i($NoTimeQuantas) < num:i(8)"!]
            [!ERROR!]
            CAN bit time should be at least 8 time quanta. Please increase PropagationSegment, PhaseSegment1 or PhaseSegment2.
            [!ENDERROR!]
        [!ENDIF!]
        [!VAR "PropSeg" = "num:i($PropagationSegment)"!]
        [!VAR "PhaseSegment1" = "num:i($PhaseSeg1)"!]
        [!VAR "PhaseSegment2" = "num:i($PhaseSeg2)"!]
        [!VAR "RJW" = "num:i($RJWidth)"!]
    [!ENDIF!]
    [!/* Check $PropDelayTransceiver because it has a unique value for CanFd*/!]
    [!IF "node:exists((CanControllerFdBaudrateConfig/CanAdvancedSettingFd)) = 'true' and $PropDelayTransceiver=0"!]
        [!IF "(node:exists(CanControllerFdBaudrateConfig/CanControllerSspOffset)) = 'true'"!]
            [!IF "CanControllerFdBaudrateConfig/CanControllerSspOffset > ((3 * num:i($NumOfTQ)) - 2)"!]
                [!WARNING!]
                    The maximum delay which can be compensated by the BCAN transceiver delay compensation during the data phase is 3 CAN bit times â€“ 2 TQ, [!"(3 * num:i($NumOfTQD)) - 2"!].
                    Current CanControllerSspOffset value is [!"CanControllerFdBaudrateConfig/CanControllerSspOffset"!] .
                [!ENDWARNING!]
            [!ENDIF!]
        [!ENDIF!]
        [!VAR "PropSegFd" = "num:i($PropagationSegment)"!]
        [!VAR "PhaseSegment1Fd" = "num:i($PhaseSeg1)"!]
        [!VAR "PhaseSegment2Fd" = "num:i($PhaseSeg2)"!]
        [!VAR "RJW_Fd" = "num:i($RJWidth)"!]
    [!ENDIF!]   
[!ENDNOCODE!]
[!ENDMACRO!]
[!ENDNOCODE!]
========== END FILE: generate_PB\Can_43_LLCE_Can_BaudRate_Inference.m ==========

========== START FILE: generate_PB\Can_43_LLCE_Macros.m ==========
/**
*   @file    Can_43_LLCE_Macros.c
*   @version 1.0.4
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Macros for configuration generation
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.4
*   Build Version        : S32_RTD_1_0_4_D2204_ASR_REL_4_4_REV_0000_20220429
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/
[!VAR "C2PCIE_CNT"  = "num:i(0)"!][!//
[!VAR "C2O_CNT"  = "num:i(0)"!][!//

[!AUTOSPACING!]
[!NOCODE!]
[!// To be called in a CAN Ctrl context
[!MACRO "GetRWDestInterfaceFromCtrl"!][!//
[!IF "not(node:exists(RWDestInterface))"!][!//
[!CODE!][!WS "8"!](uint8)[!"substring-after(CanHwChannel,'BCAN_')"!]U[!ENDCODE!][!//
[!ELSE!][!//
[!CODE!][!WS "8"!](uint8)[!"substring-after(RWDestInterface,'FIFO_INTERFACE_')"!]U[!ENDCODE!][!//
[!ENDIF!][!//
[!ENDMACRO!][!//
[!ENDNOCODE!]

[!NOCODE!][!//
[!// To be called in a HOH context
[!MACRO "GetRWDestInterfaceFromHOH"!][!//
[!AUTOSPACING!][!//
[!IF "not(node:exists(node:ref(CanControllerRef)/RWDestInterface))"!][!//
[!CODE!][!WS "8"!](uint8)[!"substring-after(node:ref(CanControllerRef)/CanHwChannel,'BCAN_')"!]U[!ENDCODE!][!//
[!ELSE!][!//
[!CODE!][!WS "8"!](uint8)[!"substring-after(node:ref(CanControllerRef)/RWDestInterface,'FIFO_INTERFACE_')"!]U[!ENDCODE!][!//
[!ENDIF!][!//
[!ENDMACRO!][!//
[!ENDNOCODE!][!//

[!MACRO "GenerateFilterConfig"!][!//
[!INDENT "6"!][!//
    [!IF "node:exists('RangeFilter')"!][!//
        [!IF "num:i(RangeFilter/RangeEnd) > 2047"!][!//
            (uint32)([!"num:i(RangeFilter/RangeEnd)"!]U | LLCE_CAN_MB_IDE_U32), /* uIdMask = RangeEnd */
        [!ELSE!][!//
            (uint32)[!"num:i(RangeFilter/RangeEnd)"!], /* uIdMask = RangeEnd */
        [!ENDIF!][!//
    [!ELSE!][!//
        [!IF "(CanHandleType = 'FULL')"!][!//
            (uint32)((CAN_43_LLCE_MAX_IDMASK[!//
        [!ELSE!][!//
            (uint32)((([!"num:inttohex(CanHwFilter/CanHwFilterMask)"!]U & CAN_43_LLCE_MAX_IDMASK)[!//
        [!ENDIF!][!//
        | LLCE_CAN_MB_RTR_U32) [!//
        [!IF "CanIdType != 'MIXED'"!] | [!ELSE!] & ~[!ENDIF!] LLCE_CAN_MB_IDE_U32),  /* uIdMask */
    [!ENDIF!][!//
    [!IF "node:exists('RangeFilter')"!][!//
        [!IF "num:i(RangeFilter/RangeStart) > 2047"!][!//
            (uint32)([!"num:i(RangeFilter/RangeStart)"!]U | LLCE_CAN_MB_IDE_U32), /* MessageId = RangeStart*/
        [!ELSE!][!//
            (uint32)[!"num:i(RangeFilter/RangeStart)"!], /* MessageId = RangeStart */
        [!ENDIF!][!//
    [!ELSE!][!//
        (uint32)(([!"num:inttohex(CanHwFilter/CanHwFilterCode)"!]U & CAN_43_LLCE_MAX_IDMASK)[!IF "CanIdType = 'EXTENDED'"!] | LLCE_CAN_MB_IDE_U32[!ENDIF!]),   /* MessageId */
    [!ENDIF!][!//
        (uint16)[!"num:inttohex(CanObjectId)"!]U, /* FilterId */
    [!IF " (node:exists(CanHwObjectCount))"!][!//
        (uint16)[!"num:inttohex(CanHwObjectCount)"!], /* MBCount */
    [!ELSE!][!//
        (uint16)1U, /* MBCount */
    [!ENDIF!][!//
    (uint16)0U, /* Output filter address */
        [!IF "node:refexists(CanMainFunctionRWPeriodRef) and (((node:ref(CanControllerRef)/CanRxProcessing = 'MIXED') and (CanHardwareObjectUsesPolling = 'true')) or (((node:ref(CanControllerRef)/CanRxProcessing = 'POLLING'))))"!][!//
            (uint8)[!"num:i(node:ref(CanMainFunctionRWPeriodRef)/RxInterface)"!]U,   /* Rx is reported through this interface. */
        [!ELSE!][!//
            [!CALL "GetRWDestInterfaceFromHOH"!], /* Rx is reported through this interface . */
        [!ENDIF!][!//
    [!IF "node:exists('RangeFilter')"!][!//
        LLCE_CAN_ENTRY_CFG_RANGED,
    [!ELSEIF "(CanHandleType = 'FULL')"!][!//
        LLCE_CAN_ENTRY_EXACT_MATCH,
    [!ELSE!][!//
        LLCE_CAN_ENTRY_CFG_MASKED,
    [!ENDIF!][!//
    [!IF "node:exists('CanObjectPayloadLength') and (CanObjectPayloadLength='CAN_OBJECT_PL_8')"!][!//
        USE_SHORT_MB /* Use 8B size Hw Object */
    [!ELSE!][!//
        USE_LONG_MB /* Use 64B size Hw Object */
    [!ENDIF!][!//
[!ENDINDENT!][!//
[!ENDMACRO!]!// GenerateFilterConfig

[!MACRO "CheckEthBufferSize"!][!//
    [!VAR "AVTP_NTSCF_BRIEF" = "num:i(26 + 8)"!][!//general header + BRIEF size
    [!VAR "AVTP_NTSCF_FULL" = "num:i(26 + 16)"!][!//general header size + FULL size
    [!VAR "AVTP_TSCF_BRIEF" = "num:i(38 + 8)"!][!//general header size + BRIEF size
    [!VAR "AVTP_TSCF_FULL" = "num:i(38 + 16)"!][!//general header size + FULL size
    [!VAR "UDP" = "num:i(42 + 8)"!][!// header size + CAN metadata
    [!VAR "CAN_PAYLOAD" = "num:i(0)"!][!//
    [!VAR "MIN_BUFFER_SIZE" = "num:i(0)"!][!//

    [!IF "node:exists(node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)/Can2EthRoutingEnable)"!][!//
        [!IF "node:exists(node:ref(node:ref(CanControllerRef)/CanControllerDefaultBaudrate)/CanControllerFdBaudrateConfig)"!][!//
            [!VAR "CAN_PAYLOAD" = "num:i(64)"!][!//
        [!ELSE!]
            [!VAR "CAN_PAYLOAD" = "num:i(8)"!][!//
        [!ENDIF!][!//
        [!IF "node:ref(node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)/Can2EthRoutingEnable/Can2EthRoutingTableRef)/EncapsulationType = 'AVTP_NTSCF_BRIEF'"!][!//
            [!VAR "MIN_BUFFER_SIZE"="num:i($CAN_PAYLOAD) + ($AVTP_NTSCF_BRIEF)"!]
        [!ELSE!]
            [!IF "node:ref(node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)/Can2EthRoutingEnable/Can2EthRoutingTableRef)/EncapsulationType = 'AVTP_NTSCF_FULL'"!][!//
                [!VAR "MIN_BUFFER_SIZE"="num:i($CAN_PAYLOAD) + ($AVTP_NTSCF_FULL)"!]
            [!ELSE!]
                [!IF "node:ref(node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)/Can2EthRoutingEnable/Can2EthRoutingTableRef)/EncapsulationType = 'AVTP_TSCF_BRIEF'"!][!//
                    [!VAR "MIN_BUFFER_SIZE"="num:i($CAN_PAYLOAD) + ($AVTP_TSCF_BRIEF)"!]
                [!ELSE!]
                        [!IF "node:ref(node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)/Can2EthRoutingEnable/Can2EthRoutingTableRef)/EncapsulationType = 'AVTP_TSCF_FULL'"!][!//
                            [!VAR "MIN_BUFFER_SIZE"="num:i($CAN_PAYLOAD) + ($AVTP_TSCF_FULL)"!]
                        [!ELSE!]
                            [!IF "(node:ref(node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)/Can2EthRoutingEnable/Can2EthRoutingTableRef)/EncapsulationType = 'UDP') or
                                  (node:ref(node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)/Can2EthRoutingEnable/Can2EthRoutingTableRef)/EncapsulationType = 'UDP_B')"!][!//
                                [!VAR "MIN_BUFFER_SIZE"="num:i($CAN_PAYLOAD) + ($UDP)"!]
                            [!ENDIF!][!//
                        [!ENDIF!][!//
                [!ENDIF!][!//
            [!ENDIF!][!//
        [!ENDIF!][!//
        [!IF "node:ref(node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)/Can2EthRoutingEnable/Can2EthRoutingTableRef)/Can2EthBufferSize < num:i($CAN_PAYLOAD)"!][!//
            [!WARNING!]Configured buffer size is not large enough to hold a CAN frame for controller CanController_[!"node:ref(CanControllerRef)/CanControllerId"!] ! Configured buffer size is [!"node:ref(node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)/Can2EthRoutingEnable/Can2EthRoutingTableRef)/Can2EthBufferSize"!] and minimum size is [!"num:i($MIN_BUFFER_SIZE)"!].[!ENDWARNING!][!//
        [!ENDIF!][!//
    [!ENDIF!][!//
[!ENDMACRO!][!// CheckEthBufferSize

[!MACRO "CountFilters"!][!//
[!NOCODE!]
[!VAR "GLOBAL_RX_FILTERCOUNT_LIST" = "''"!][!// Array-like variable holding per-channel number of regular filters
[!VAR "GLOBAL_RXAF_FILTERCOUNT_LIST" = "''"!][!// Array-like variable holding per-channel number of advanced filters
[!VAR "GLOBAL_AUX_RX_FILTERCOUNT_LIST" = "''"!][!// Array-like variable holding per-channel number of auxilliary filters
[!SELECT "CanConfigSet"!]
    [!VAR "MAX_CTRL_RX_FILTERS_COUNT" = "num:i(0)"!][!// Number of Filters per hardware controller
    [!VAR "MAX_CTRL_RXAF_FILTERS_COUNT" = "num:i(0)"!][!// Number of Advanced Filters per hardware controller
[!//
    [!FOR "i" = "0" TO "15"!] 
        [!VAR "MAX_CTRL_RX_FILTERS_COUNT" = "num:i(0)"!]
        [!VAR "MAX_CTRL_RXAF_FILTERS_COUNT" = "num:i(0)"!]
        [!VAR "MAX_CTRL_AUX_RX_FILTERS_COUNT" = "num:i(0)"!]
        [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
            [!IF "node:ref(CanControllerRef)/CanControllerActivation = 'true' and CanObjectType = 'RECEIVE'"!]
                [!IF "substring-after(node:ref(CanControllerRef)/CanHwChannel,'BCAN_') = $i"!]
                    [!IF "node:exists(CanAdvancedFeature)"!]
                        [!CALL "CheckEthBufferSize"!]
                        [!VAR "MAX_CTRL_RXAF_FILTERS_COUNT"="num:i($MAX_CTRL_RXAF_FILTERS_COUNT) + 1"!]
                    [!ELSE!]
                        [!VAR "MAX_CTRL_RX_FILTERS_COUNT"="num:i($MAX_CTRL_RX_FILTERS_COUNT) + 1"!]
                    [!ENDIF!]
                [!ENDIF!]
            [!ENDIF!]
        [!ENDLOOP!]
        [!IF "node:exists(../CanGeneral/CanAuxFilterEnable)"!]
            [!LOOP "CanAuxFilter/*"!]
                [!IF "node:ref(./CanControllerRef)/CanControllerActivation = 'true'"!]
                    [!IF "substring-after(node:ref(./CanControllerRef)/CanHwChannel,'BCAN_') = $i"!]
                        [!VAR "MAX_CTRL_AUX_RX_FILTERS_COUNT"="num:i($MAX_CTRL_AUX_RX_FILTERS_COUNT) + 1"!]
                    [!ENDIF!]
                [!ENDIF!]
            [!ENDLOOP!]
        [!ENDIF!]
        [!VAR "GLOBAL_RX_FILTERCOUNT_LIST"   = "concat($GLOBAL_RX_FILTERCOUNT_LIST,   ' ', num:i($MAX_CTRL_RX_FILTERS_COUNT))"!]
        [!VAR "GLOBAL_RXAF_FILTERCOUNT_LIST" = "concat($GLOBAL_RXAF_FILTERCOUNT_LIST, ' ', num:i($MAX_CTRL_RXAF_FILTERS_COUNT))"!]
        [!VAR "GLOBAL_AUX_RX_FILTERCOUNT_LIST"   = "concat($GLOBAL_AUX_RX_FILTERCOUNT_LIST,   ' ', num:i($MAX_CTRL_AUX_RX_FILTERS_COUNT))"!]
    [!ENDFOR!]
[!ENDSELECT!]
[!ENDNOCODE!][!//
[!ENDMACRO!]

[!MACRO "GeneratePlatformInit", "CanEcuCPartitionPath" = " 'none' "!][!//
[!AUTOSPACING!][!//
[!SELECT "CanConfigSet"!][!//
[!NOCODE!]
    [!VAR "MAX_IF_RXMB_COUNT" = "num:i(0)"!] [!// Number of MBs per fifo-interface.
    [!VAR "GLOBAL_IF_RXMB_COUNT_LIST" ="''"!] [!// Array-like variable holding per-fifo-interface number of RXMB
    [!VAR "MAX_IF_ACK_COUNT" = "num:i(0)"!] [!// Number of reserved tx confirmation buffers per fifo-interface
    [!VAR "GLOBAL_IF_ACK_COUNT_LIST" ="''"!] [!// Array-like variable holding per-fifo-interface number of ACK buffers
    [!VAR "MAX_POOL_RXMB_COUNT" = "num:i(0)"!][!// Number of MBs of all HRHs reported through  a pooling class
    [!VAR "MAX_POOL_ACK_COUNT" = "num:i(0)"!][!// Number of reserved tx confirmation buffers reported through  a pooling class
[!ENDNOCODE!][!//
[!INDENT "4"!][!//
        /*  Array containing the initialization status of the controllers */
        { [!//
        [!FOR "i" = "0" TO "15"!][!//
            [!VAR "CTRL_CONFIGURED"="num:i(0)"!][!//
            [!LOOP "node:order(CanController/*,'node:value(CanControllerId)')"!][!//
                [!IF "substring-after(./CanHwChannel,'BCAN_') = $i and (CanControllerActivation = 'true') "!][!//
                    [!IF "$CanEcuCPartitionPath = 'none' or (node:exists(./CanControllerEcucPartitionRef) and (node:value(./CanControllerEcucPartitionRef) = $CanEcuCPartitionPath))"!][!//
                        [!VAR "CTRL_CONFIGURED"="num:i(1)"!][!//
                    [!ENDIF!][!//
                [!ENDIF!][!//
            [!ENDLOOP!][!//
            [!IF "$CTRL_CONFIGURED = 1"!][!//
                [!WS "0"!]INITIALIZED[!//
            [!ELSE!][!//
                [!WS "0"!]UNINITIALIZED[!//
            [!ENDIF!][!//
            [!IF "$i < 15"!][!//
                [!WS "0"!], [!//
            [!ENDIF!][!//
        [!ENDFOR!][!//
        },

        /* Array containing maximum number of regular filters per hardware controller */
        {[!//
        [!FOR "i" = "0" TO "15"!][!//
            [!VAR "CTRL_CONFIGURED"="num:i(0)"!][!//
            [!LOOP "node:order(CanController/*,'node:value(CanControllerId)')"!][!//
                [!IF "substring-after(./CanHwChannel,'BCAN_') = $i and (CanControllerActivation = 'true') "!][!//
                    [!IF "$CanEcuCPartitionPath = 'none' or (node:exists(./CanControllerEcucPartitionRef) and (node:value(./CanControllerEcucPartitionRef) = $CanEcuCPartitionPath))"!][!//
                        [!VAR "CTRL_CONFIGURED"="num:i(1)"!][!//
                    [!ENDIF!][!//
                [!ENDIF!][!//
            [!ENDLOOP!][!//
            [!IF "$CTRL_CONFIGURED = 1"!][!//
                [!WS "4"!](uint16)[!"text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($i+1)]"!]U[!//
            [!ELSE!][!//
                [!WS "4"!](uint16)0U[!//
            [!ENDIF!][!//
            [!IF "$i < 15"!], [!ENDIF!][!//
        [!ENDFOR!][!//
        [!WS "0"!] },

        /* Array containing maximum number of advanced filters per hardware controller */
        {[!//
        [!FOR "i" = "0" TO "15"!][!//
            [!VAR "CTRL_CONFIGURED"="num:i(0)"!][!//
            [!LOOP "node:order(CanController/*,'node:value(CanControllerId)')"!][!//
                [!IF "substring-after(./CanHwChannel,'BCAN_') = $i and (CanControllerActivation = 'true') "!][!//
                    [!IF "$CanEcuCPartitionPath = 'none' or (node:exists(./CanControllerEcucPartitionRef) and (node:value(./CanControllerEcucPartitionRef) = $CanEcuCPartitionPath))"!][!//
                        [!VAR "CTRL_CONFIGURED"="num:i(1)"!][!//
                    [!ENDIF!][!//
                [!ENDIF!][!//
            [!ENDLOOP!][!//
            [!IF "$CTRL_CONFIGURED = 1"!][!//
                  [!WS "4"!](uint16)[!"text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($i+1)]"!]U[!//
            [!ELSE!][!//
                  [!WS "4"!](uint16)0U[!//
            [!ENDIF!][!//
            [!IF "$i < 15"!], [!ENDIF!][!//
        [!ENDFOR!][!//
        [!WS "0"!] },

        /* Array containing maximum number of INTERRUPT driven receive Message Buffers per FIFO interface. */
        {   [!NOCODE!][!FOR "i" = "0" TO "15"!]
            [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
                [!IF "node:ref(CanControllerRef)/CanControllerActivation = 'true' and CanObjectType = 'RECEIVE'"!]
                    [!IF "$CanEcuCPartitionPath = 'none' or [!//
                        (node:exists(node:ref(CanControllerRef)/CanControllerEcucPartitionRef) and (node:value(node:ref(CanControllerRef)/CanControllerEcucPartitionRef) = $CanEcuCPartitionPath))"!][!//
                        [!IF "( ((substring-after(node:ref(CanControllerRef)/CanHwChannel,'BCAN_') = $i) and not(node:exists(node:ref(CanControllerRef)/RWDestInterface)) ) [!// Default mapping is 1 to 1 (channel-FIFO_IF)
                            or (node:exists(node:ref(CanControllerRef)/RWDestInterface) and (substring-after(node:ref(CanControllerRef)/RWDestInterface,'FIFO_INTERFACE_') = $i))) [!// Custom FIFO_IF selection per HRH
                          and (((node:ref(CanControllerRef)/CanRxProcessing = 'MIXED') and CanHardwareObjectUsesPolling = 'false') or node:ref(CanControllerRef)/CanRxProcessing = 'INTERRUPT')"!]
                        [!VAR "MAX_IF_RXMB_COUNT"="num:i($MAX_IF_RXMB_COUNT) +  num:i(CanHwObjectCount)"!]
                        [!ENDIF!]
                    [!ENDIF!]
                [!ENDIF!]
            [!ENDLOOP!]
                [!VAR "GLOBAL_IF_RXMB_COUNT_LIST" = "concat($GLOBAL_IF_RXMB_COUNT_LIST,   ' ', num:i($MAX_IF_RXMB_COUNT))"!]
                [!VAR "MAX_IF_RXMB_COUNT" = "num:i(0)"!]
            [!ENDFOR!]
        [!FOR "i" = "0" TO "15"!]
            [!CODE!](uint16)[!"text:split($GLOBAL_IF_RXMB_COUNT_LIST)[num:i($i+1)]"!]U[!//
            [!IF "$i < 15"!], [!ENDIF!][!ENDCODE!]
        [!ENDFOR!][!//
        [!ENDNOCODE!][!//
        [!WS "0"!] },

        [!VAR "MAX_CTRL_COUNT" = "num:i(16)"!][!//
        [!VAR "POLLING_CLASSES_CNT" = "num:i(6)"!][!//
        [!VAR "FIRST_POLLING_CLASS" = "$MAX_CTRL_COUNT"!][!//
        [!VAR "LAST_POLLING_CLASS" = "$FIRST_POLLING_CLASS + $POLLING_CLASSES_CNT - 1"!][!//
        /* Array containing maximum number of RX Message Buffers per POLLING class. There are [!"num:i($POLLING_CLASSES_CNT)"!] of them available */
        {   [!FOR "i" = "$FIRST_POLLING_CLASS" TO "$LAST_POLLING_CLASS"!][!//
            [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!][!//
                [!IF "node:ref(CanControllerRef)/CanControllerActivation = 'true' and CanObjectType = 'RECEIVE'"!][!//
                    [!IF "$CanEcuCPartitionPath = 'none' or [!//
                        (node:exists(node:ref(CanControllerRef)/CanControllerEcucPartitionRef) and (node:value(node:ref(CanControllerRef)/CanControllerEcucPartitionRef) = $CanEcuCPartitionPath))"!][!//
                        [!IF "(((node:ref(CanControllerRef)/CanRxProcessing = 'MIXED') and (CanHardwareObjectUsesPolling = 'true')) or (node:ref(CanControllerRef)/CanRxProcessing = 'POLLING'))"!][!//
                            [!IF "node:ref(CanMainFunctionRWPeriodRef)/RxInterface = $i"!][!//
                                [!VAR "MAX_POOL_RXMB_COUNT"="num:i($MAX_POOL_RXMB_COUNT) + num:i(CanHwObjectCount)"!][!//
                            [!ENDIF!][!//
                        [!ENDIF!][!//
                    [!ENDIF!][!//
                [!ENDIF!][!//
            [!ENDLOOP!][!//
        [!WS "0"!](uint16)[!"num:i($MAX_POOL_RXMB_COUNT)"!]U[!//
        [!VAR "MAX_POOL_RXMB_COUNT" = "num:i(0)"!][!//
        [!IF "$i < $LAST_POLLING_CLASS"!][!//
        [!WS "0"!], [!//
        [!ENDIF!][!//
        [!ENDFOR!][!//
        [!WS "0"!] },

        /* Array containing maximum number of INTERRUPT driven TX confirmation buffers per FIFO interface. */
        {   [!NOCODE!][!FOR "i" = "0" TO "15"!][!//
            [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
                [!IF "node:ref(CanControllerRef)/CanControllerActivation = 'true' and CanObjectType = 'TRANSMIT'"!]
                    [!IF "$CanEcuCPartitionPath = 'none' or [!//
                        (node:exists(node:ref(CanControllerRef)/CanControllerEcucPartitionRef) and (node:value(node:ref(CanControllerRef)/CanControllerEcucPartitionRef) = $CanEcuCPartitionPath))"!][!//
                        [!IF "( ((substring-after(node:ref(CanControllerRef)/CanHwChannel,'BCAN_') = $i) and not(node:exists(node:ref(CanControllerRef)/RWDestInterface)) )  [!// Default mapping is 1 to 1 (channel-FIFO_IF)
                            or (node:exists(node:ref(CanControllerRef)/RWDestInterface) and (substring-after(node:ref(CanControllerRef)/RWDestInterface,'FIFO_INTERFACE_') = $i))) [!// Custom FIFO_IF selection per HTH
                             and  (((node:ref(CanControllerRef)/CanTxProcessing = 'MIXED') and CanHardwareObjectUsesPolling = 'false') or node:ref(CanControllerRef)/CanTxProcessing = 'INTERRUPT')"!]
                        [!VAR "MAX_IF_ACK_COUNT"="num:i($MAX_IF_ACK_COUNT) +  num:i(CanHwObjectCount)"!]
                        [!ENDIF!]
                    [!ENDIF!]
                [!ENDIF!]
            [!ENDLOOP!]
                [!VAR "GLOBAL_IF_ACK_COUNT_LIST" = "concat($GLOBAL_IF_ACK_COUNT_LIST,   ' ', num:i($MAX_IF_ACK_COUNT))"!]
                [!VAR "MAX_IF_ACK_COUNT" = "num:i(0)"!]
            [!ENDFOR!]
            [!WS "0"!]
        [!FOR "i" = "0" TO "15"!] 
            [!CODE!](uint16)[!"text:split($GLOBAL_IF_ACK_COUNT_LIST)[num:i($i+1)]"!]U[!//
            [!IF "$i < 15"!], [!ENDIF!][!ENDCODE!]
        [!ENDFOR!][!//
        [!ENDNOCODE!][!//
        [!WS "0"!] },

        /* Array containing maximum number of TX confirmation buffers per POLLING class. There are 6 of them available */
        {   [!FOR "i" = "$FIRST_POLLING_CLASS" TO "$LAST_POLLING_CLASS"!][!//
            [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!][!//
                [!IF "node:ref(CanControllerRef)/CanControllerActivation = 'true' and CanObjectType = 'TRANSMIT'"!][!//
                    [!IF "$CanEcuCPartitionPath = 'none' or [!//
                        (node:exists(node:ref(CanControllerRef)/CanControllerEcucPartitionRef) and (node:value(node:ref(CanControllerRef)/CanControllerEcucPartitionRef) = $CanEcuCPartitionPath))"!][!//
                        [!IF "(((node:ref(CanControllerRef)/CanTxProcessing = 'MIXED') and (CanHardwareObjectUsesPolling = 'true')) or (node:ref(CanControllerRef)/CanTxProcessing = 'POLLING'))"!][!//
                            [!IF "node:ref(CanMainFunctionRWPeriodRef)/AckInterface = $i"!][!//
                                [!VAR "MAX_POOL_ACK_COUNT"="num:i($MAX_POOL_ACK_COUNT) + num:i(CanHwObjectCount)"!][!//
                            [!ENDIF!][!//
                        [!ENDIF!][!//
                    [!ENDIF!][!//
                [!ENDIF!][!//
            [!ENDLOOP!][!//
        [!WS "0"!](uint16)[!"num:i($MAX_POOL_ACK_COUNT)"!]U[!//
            [!VAR "MAX_POOL_ACK_COUNT" = "num:i(0)"!][!//
            [!IF "$i < $LAST_POLLING_CLASS"!][!//
            [!WS "0"!], [!//
            [!ENDIF!][!//
        [!ENDFOR!][!//
        [!WS "0"!] },

        /* Structure describing the way of processing each errors category. This can be: INTERRUPT, POLLING or IGNORE. */
    [!SELECT "CanErrorReporting"!][!//
        {
            [!IF "CAN_PROTOCOL_ERR = 'INTERRUPT'"!][!//
                    [!WS "4"!]NOTIF_FIFO0, /*CAN_PROTOCOL_ERR*/
            [!ELSE!][!//
                [!IF "CAN_PROTOCOL_ERR = 'POLLING'"!][!//
                    [!WS "4"!]NOTIF_FIFO1, /*CAN_PROTOCOL_ERR*/
                [!ELSE!][!//
                    [!WS "4"!]IGNORE, /*CAN_PROTOCOL_ERR*/
                [!ENDIF!][!//
            [!ENDIF!][!//
            [!IF "DATALOST_ERR = 'INTERRUPT'"!][!//
                [!WS "4"!]NOTIF_FIFO0, /*DATALOST_ERR*/
            [!ELSE!][!//
                [!IF "DATALOST_ERR = 'POLLING'"!][!//
                    [!WS "4"!]NOTIF_FIFO1, /*DATALOST_ERR*/
                [!ELSE!][!//
                    [!WS "4"!]IGNORE, /*DATALOST_ERR*/
                [!ENDIF!][!//
            [!ENDIF!][!//
            [!IF "CONFIGURATION_ERR = 'INTERRUPT'"!][!//
                [!WS "4"!]NOTIF_FIFO0, /*CONFIGURATION_ERR*/
            [!ELSE!][!//
                [!IF "CONFIGURATION_ERR = 'POLLING'"!][!//
                    [!WS "4"!]NOTIF_FIFO1, /*CONFIGURATION_ERR*/
                [!ELSE!][!//
                    [!WS "4"!]IGNORE, /*CONFIGURATION_ERR*/
                [!ENDIF!][!//
            [!ENDIF!][!//
            [!IF "INTERNAL_ERR = 'INTERRUPT'"!][!//
                [!WS "4"!]NOTIF_FIFO0, /*INTERNAL_ERR*/
            [!ELSE!][!//
                [!IF "INTERNAL_ERR = 'POLLING'"!][!//
                    [!WS "4"!]NOTIF_FIFO1, /*INTERNAL_ERR*/
                [!ELSE!][!//
                    [!WS "4"!]IGNORE, /*INTERNAL_ERR*/
                [!ENDIF!][!//
            [!ENDIF!][!//
    [!ENDSELECT!][!//
            [!WS "4"!]{
            [!FOR "i" = "0" TO "15"!][!//
                [!VAR "CTRL_ENABLED"="num:i(0)"!][!//
                [!LOOP "node:order(CanController/*,'node:value(CanControllerId)')"!][!//
                    [!IF "substring-after(./CanHwChannel,'BCAN_') = $i"!][!//
                        [!IF "(CanControllerActivation = 'true') "!][!//
                            [!IF "$CanEcuCPartitionPath = 'none' or (node:exists(CanControllerEcucPartitionRef) and (node:value(CanControllerEcucPartitionRef) = $CanEcuCPartitionPath))"!][!//
                                [!IF "CanBusoffProcessing = 'INTERRUPT'"!][!//
                                    [!WS "4"!]NOTIF_FIFO0[!//
                                [!ELSE!][!//
                                    [!WS "4"!]NOTIF_FIFO1[!//
                                [!ENDIF!][!//
                                [!VAR "CTRL_ENABLED"="num:i(1)"!][!//
                            [!ENDIF!][!//
                        [!ENDIF!][!//
                    [!ENDIF!][!//
                [!ENDLOOP!][!//
                [!IF "$CTRL_ENABLED = 0"!][!//
                    [!WS "4"!] IGNORE[!//
                [!ENDIF!][!//
                [!IF "$i < 15"!][!//
                    [!WS "0"!],
                [!ENDIF!][!//
            [!ENDFOR!]
            [!WS "4"!]}, /* BusOff processing type for each channel */
    [!SELECT "CanErrorReporting"!][!//
            [!IF "CAN_PROTOCOL_WRN = 'INTERRUPT'"!][!//
                [!WS "4"!]NOTIF_FIFO0, /*CAN_PROTOCOL_WRN*/
            [!ELSE!][!//
                [!IF "CAN_PROTOCOL_WRN = 'POLLING'"!][!//
                    [!WS "4"!]NOTIF_FIFO1, /*CAN_PROTOCOL_WRN*/
                [!ELSE!][!//
                    [!WS "4"!]IGNORE, /*CAN_PROTOCOL_WRN*/
                [!ENDIF!][!//
            [!ENDIF!][!//
    [!ENDSELECT!][!//
        }
[!ENDINDENT!][!//
[!ENDSELECT!][!//
[!ENDMACRO!][!// GeneratePlatformInit

[!MACRO "GenerateChannelInit", "SkipGenerateEmpty" = "0", "CanEcuCPartitionPath" = " 'none' "!][!//
[!INDENT "4"!][!//
[!SELECT "CanConfigSet"!][!//
[!FOR "crtCtrl" = "0" TO "15"!][!//
    [!VAR "ctrlFound" = "0"!][!//
    [!VAR "MAX_TXMB" = "num:i(0)"!][!//
    [!LOOP "node:order(CanController/*,'node:value(CanControllerId)')"!][!//
        [!IF "(CanControllerActivation = 'true') and (substring-after(CanHwChannel,'BCAN_') = num:i($crtCtrl))"!][!//
            [!IF "$CanEcuCPartitionPath = 'none' or (node:exists(./CanControllerEcucPartitionRef) and (node:value(./CanControllerEcucPartitionRef) = $CanEcuCPartitionPath))"!][!//
        { /* Options for BCAN_[!"$crtCtrl"!] */
            [!INDENT "8"!][!//
            /* ===== Controller Options for firmware ===== */
            (uint32)(
            [!IF "CanTimeStampEnable = 'END_OF_FRAME'"!][!//
                LLCE_CAN_CONTROLLERCONFIG_TST_END_U32 |/* Timestamp capture point END */
            [!ELSEIF "CanTimeStampEnable = 'START_OF_FRAME'"!][!//
                LLCE_CAN_CONTROLLERCONFIG_TST_START_U32 |/* Timestamp capture point START */
            [!ELSEIF "CanTimeStampEnable = 'CAN_START_OF_FRAME_CANFD_RES'"!][!//
                LLCE_CAN_CONTROLLERCONFIG_TST_FD_U32 |/* Timestamp capture point START or RES bit */
            [!ELSE!][!//
                /* TimeStamp disabled */ 
            [!ENDIF!][!//
            [!IF "CanListenOnlyMode = 'true'"!][!//
                LLCE_CAN_CONTROLLERCONFIG_LOM_EN_U32 | /* Listen-only mode enabled */
            [!ELSE!][!//
                /* Listen-only mode disabled */                
            [!ENDIF!][!//
            [!IF "CanLoopBackMode = 'true'"!][!//
                LLCE_CAN_CONTROLLERCONFIG_LPB_EN_U32 | /* LoopBack mode enabled */
            [!ELSE!][!//
                /* LoopBack mode disabled */                
            [!ENDIF!][!//
            [!IF "SelfReceptionEnable = 'true'"!][!//
                LLCE_CAN_CONTROLLERCONFIG_SRX_EN_U32 | /* Self reception mode enabled */
            [!ELSE!][!//
                /* Self reception mode disabled */                
            [!ENDIF!][!//
            [!IF "CanProtocolException = 'true'"!][!//
                LLCE_CAN_CONTROLLERCONFIG_PE_EN_U32 | /* Protocol exception feature enabled */
            [!ELSE!][!//
                /* Protocol Exception feature disabled */                
            [!ENDIF!][!//
            [!IF "CanTxFifoMode = 'true'"!][!//
                LLCE_CAN_CONTROLLERCONFIG_TXFIFO_EN_U32 | /* Can TX FIFO Mode enabled */
            [!ELSE!][!//
                /* Can TX FIFO Mode disabled */                
            [!ENDIF!][!//
            [!IF "AutomaticBusOffRecovery = 'true'"!][!//
                LLCE_CAN_CONTROLLERCONFIG_ABR_EN_U32 | /* Automatic Bus Off Recovery enabled */
            [!ELSE!][!//
                /* Automatic Bus Off Recovery disabled */                
            [!ENDIF!][!//
            [!IF "ManualBusOffRecovery = 'true'"!][!//
                LLCE_CAN_CONTROLLERCONFIG_MBR_EN_U32 | /* Manual Bus Off Recovery enabled */
            [!ELSE!][!//
                /* Manual Bus Off Recovery disabled */                
            [!ENDIF!][!//
            
            LLCE_CAN_CONTROLLERCONFIG_CTRL_EN_U32
            ),
            [!LOOP "node:order(../../CanHardwareObject/*,'node:value(CanObjectId)')"!][!//
                [!IF "(substring-after(node:ref(CanControllerRef)/CanHwChannel,'BCAN_') = num:i($crtCtrl)) and (CanObjectType = 'TRANSMIT')"!][!//
                    [!VAR "MAX_TXMB"="num:i($MAX_TXMB) + num:i(CanHwObjectCount)"!][!//
                [!ENDIF!][!//
            [!ENDLOOP!][!//
            [!IF "$MAX_TXMB > 16"!][!//
                [!ERROR!]The hardware platform does not include enough message buffers in order to service all configured HTHs for BCAN_[!"$crtCtrl"!] [!ENDERROR!][!//
            [!ENDIF!][!//
            /* Number of configured HTHs for this controller */
            (uint8)[!"num:i($MAX_TXMB)"!]U
            [!VAR "ctrlFound" = "1"!][!//
            [!ENDINDENT!][!//
            },
            [!ENDIF!][!//
        [!ENDIF!][!//
    [!ENDLOOP!][!//
    [!//
    [!IF "($ctrlFound = 0) and ($SkipGenerateEmpty = 0)"!][!//
        { /* Options for BCAN_[!"$crtCtrl"!] */
            [!INDENT "8"!][!//
            /* BCAN_[!"$crtCtrl"!] not enabled */
            (uint32)(0U),
            /* Number of configured HTHs for this controller */
            (uint8)0U
            [!ENDINDENT!][!//
        },
    [!ENDIF!][!//
[!ENDFOR!][!//
[!ENDSELECT!][!//
[!ENDINDENT!][!//
[!ENDMACRO!][!// GenerateChannelInit

[!MACRO "GenerateAdvancedFilterConfig"!][!//
[!INDENT "4"!][!//
  { /* Advanced filter [!"num:i($crtFilter)"!] for BCAN_[!"num:i($crtCtrl)"!] */
    [!INDENT "6"!][!//
    { /* RxFilter */
      [!CALL "GenerateFilterConfig"!][!//
    },
    { /* AdvancedFeature */
        [!SELECT "node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)"!][!//
        [!IF "node:value(AuthenticationFrameEnable) = 'true'"!][!//
            LLCE_AF_AUTHENTICATION_ENABLED,  /* Option for frame authentication feature */
        [!ELSE!][!//
            LLCE_AF_AUTHENTICATION_DISABLED, /* Option for frame authentication feature */
        [!ENDIF!][!//
        [!IF "node:value(HostReceiveEnable) = 'true'"!][!//
            LLCE_AF_HOSTRECEIVE_ENABLED,  /* Option for host receive feature */
        [!ELSE!][!//
            LLCE_AF_HOSTRECEIVE_DISABLED, /* Option for host receive feature */
        [!ENDIF!][!//
        [!IF "node:value(LoggingFeatureEnable) = 'true'"!][!//
            LLCE_AF_LOGGING_ENABLED,  /* Option for logging feature */
        [!ELSE!][!//
            LLCE_AF_LOGGING_DISABLED, /* Option for logging feature */
        [!ENDIF!][!//
        [!IF "node:value(CustomProcessingEnable) = 'true'"!][!//
            LLCE_AF_CUSTOMPROCESSING_ENABLED,  /* Option for custom processing in FDK */
        [!ELSE!][!//
            LLCE_AF_CUSTOMPROCESSING_DISABLED, /* Option for custom processing in FDK */
        [!ENDIF!][!//
        [!IF "node:exists(Can2CanRoutingEnable)"!][!//
            (uint8)[!"node:ref(Can2CanRoutingEnable/Can2CanRoutingTableRef)/@index"!]U, /* Reference to Can2Can routing entry */
        [!ELSE!][!//
            (uint8)LLCE_CAN_ADVANCED_FILTER_NOT_USED, /* Can2Can not used */
        [!ENDIF!][!//
        [!IF "node:exists(Can2EthRoutingEnable)"!][!//
            (uint8)[!"node:ref(Can2EthRoutingEnable/Can2EthRoutingTableRef)/@index"!]U + LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT, /* Reference to Can2Eth routing entry */
        [!ELSE!][!//
            (uint8)LLCE_CAN_ADVANCED_FILTER_NOT_USED,  /* Can2Eth not used */
        [!ENDIF!][!//
        [!IF "node:exists(Can2OtherRoutingEnable)"!][!//
            (uint8)[!"node:ref(Can2OtherRoutingEnable/Can2OtherRoutingTableRef)/@index"!]U + LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT /* Reference to Can2Other routing entry */
        [!ELSE!][!//
            (uint8)LLCE_CAN_ADVANCED_FILTER_NOT_USED  /* Can2Other not used */
        [!ENDIF!][!//
        [!ENDSELECT!][!//
    }
    [!ENDINDENT!][!//
  } /* End advanced filter [!"num:i($crtFilter)"!] for BCAN_[!"num:i($crtCtrl)"!] */[!//
[!ENDINDENT!][!//
[!ENDMACRO!][!// GenerateAdvancedFilterConfig

[!MACRO "GenerateAdvancedDestinations"!][!//
    [!LOOP "Can2CanRoutingTable/*"!][!//
        [!VAR "DESTCH_CNT" = "num:i(count(CanDestinationList/*))"!][!//
        [!INDENT "4"!][!//
            {
            [!INDENT "8"!][!//
                {.Can2Can = {
                    [!INDENT "12"!][!//
                        /* ======= Routing Rule ======= */
                        (uint32)(
                        [!IF "(CanFd2Can = 'false') and (Can2CanFd = 'false')"!][!//
                            [!WS "10"!]LLCE_CAN_ROUTING_NOCHANGE |
                        [!ELSE!][!//
                            [!IF "(CanFd2Can = 'false') and (Can2CanFd = 'true')"!][!//
                                [!WS "10"!]LLCE_CAN_ROUTING_CANFD |
                            [!ELSE!][!//
                                [!IF "(CanFd2Can = 'true') and (Can2CanFd = 'false')"!][!//
                                    [!WS "10"!]LLCE_CAN_ROUTING_CAN |
                                [!ENDIF!][!//
                            [!ENDIF!][!//
                        [!ENDIF!][!//
                        [!IF "node:exists(CanIdRemapping)"!][!//
                            [!WS "10"!]LLCE_CAN_ROUTING_ID_REMAPPING_EN |
                        [!ENDIF!][!//
                        [!WS "10"!]LLCE_CAN_ROUTING_OPTION_DEFAULT_CONFIG
                        [!WS "8"!]),
                        [!IF "node:exists(CanIdRemapping)"!][!//
                            (uint32)[!"num:i(CanIdRemapping)"!]U [!//
                            [!IF "num:i(CanIdRemapping) > 2047"!][!//
                                | LLCE_CAN_MB_IDE_U32,[!// Add IDE bit
                            [!ELSE!][!//
                                [!IF "ForceExtendedID = 'true'"!][!//
                                    | LLCE_CAN_MB_IDE_U32,[!// Add IDE bit
                                [!ELSE!][!//
                                    << LLCE_CAN_MB_IDSTD_SHIFT_U32,[!// Shift for standard ID
                                [!ENDIF!][!//
                            [!ENDIF!][!//
                        [!ELSE!][!//
                            (uint32)0U,
                        [!ENDIF!][!//
                        {
                            [!VAR "END_COMMA2"="0"!][!//
                            [!LOOP "CanDestinationList/*"!][!//
                                [!VAR "END_COMMA2"="$END_COMMA2 + 1"!][!//
                                [!INDENT "16"!][!//
                                    [!SELECT "node:ref(Can2CanControllerRef)"!][!//
                                        (uint8)[!"substring-after(CanHwChannel,'BCAN_')"!][!//
                                        [!IF "$END_COMMA2 < $DESTCH_CNT"!][!//
                                            ,
                                        [!ELSE!][!//
                                            [!FOR "i" = "$DESTCH_CNT" TO "15"!][!/* Initialize remaining elements in array in order to comply with misra rule 9.3 */!][!//
                                            ,
                                                    (uint8)0[!//
                                            [!ENDFOR!][!//
                                        [!ENDIF!][!//
                                        [!VAR "CanFdEnabled" = "'true'"!][!//
                                        [!LOOP "CanControllerBaudrateConfig/*"!][!//
                                            [!VAR "CanFdEnabled"="$CanFdEnabled and (node:exists(CanControllerFdBaudrateConfig))"!][!//
                                        [!ENDLOOP!][!//
                                    [!ENDSELECT!][!//
                                    [!IF "(node:value(../../Can2CanFd) = 'true') and $CanFdEnabled = 'false'"!][!//
                                        [!WARNING!]Controllers from destination list has non CAN-FD baudrates configurations, even if converting option is to CAN-FD. The received frames will be dropped.[!ENDWARNING!][!//
                                    [!ENDIF!][!//
                                [!ENDINDENT!][!//
                            [!ENDLOOP!][!//
                            [!CR!][!//
                        },
                        (uint8)[!"$DESTCH_CNT"!]U
                    [!ENDINDENT!][!//
                }},
                /* ======= Destination rule type ======= */
                CAN_AF_CAN2CAN
            [!ENDINDENT!][!//
            },
        [!ENDINDENT!][!//
    [!ENDLOOP!][!//
    [!VAR "crtIdx" = "0"!][!//
    [!LOOP "Can2EthRoutingTable/*"!][!//
        [!VAR "DestMacArray" = "text:replaceAll(EthDestAddress, ':', ', (uint8)0x')"!][!//
        [!VAR "DestMacArray" = "text:concat('(uint8)0x', $DestMacArray)"!][!//
        [!VAR "DestMacArray" = "text:replace($DestMacArray, '\[', '\{ ')"!][!//
        [!VAR "DestMacArray" = "text:replace($DestMacArray, '\]', ' \}')"!][!//
        [!VAR "SrcMacArray" = "text:replaceAll(EthSrcAddress, ':', ', (uint8)0x')"!][!//
        [!VAR "SrcMacArray" = "text:concat('(uint8)0x', $SrcMacArray)"!][!//
        [!VAR "SrcMacArray" = "text:replace($SrcMacArray, '\[', '\{ ')"!][!//
        [!VAR "SrcMacArray" = "text:replace($SrcMacArray, '\]', ' \}')"!][!//
        [!INDENT "4"!][!//
            {
            [!INDENT "8"!][!//
                {.Can2Eth = {
                    /* ======= Routing Rule ======= */
                    [!INDENT "12"!][!//
                        (uint32)0U,
                        (uint16)sizeof(Llce_Can2Eth_Buffer[!"num:i($crtIdx)"!][0]),
                        [!"Can2EthBufferCount"!],
                        LLCE_AF_CAN2[!"EncapsulationType"!],
                        [!"$DestMacArray"!],
                        [!"$SrcMacArray"!],
                        [!IF "(EncapsulationType = 'UDP') or (EncapsulationType = 'UDP_B')"!][!//
                            {[!LOOP "text:split(IpDestAddress,'.')"!][!//
                              [!IF "num:i(.) > 255"!][!//
                                    [!ERROR!]Invalid IP address[!ENDERROR!][!//
                              [!ELSE!][!//
                                    [!"num:i(.)"!],[!//
                              [!ENDIF!][!//
                            [!ENDLOOP!]},
                            {[!LOOP "text:split(IpSrcAddress,'.')"!][!//
                              [!IF "num:i(.) > 255"!][!//
                                    [!ERROR!]Invalid IP address[!ENDERROR!][!//
                              [!ELSE!][!//
                                    [!"num:i(.)"!],[!//
                              [!ENDIF!][!//
                            [!ENDLOOP!]},
                            [!"UdpDestPort"!],
                            [!"UdpSrcPort"!],
                        [!ELSE!][!//
                        {0U, 0U, 0U, 0U},
                        {0U, 0U, 0U, 0U},
                        0U,
                        0U,
                        [!ENDIF!][!//
                        [!LOOP "EthPhyIf/*"!][!//
                            LLCE_CAN2ETH_[!"."!][!IF "not(node:islast(.))"!] | [!ENDIF!][!//
                        [!ENDLOOP!]
                    }
                    [!ENDINDENT!][!//
                },
                /* ======= Destination rule type ======= */
                CAN_AF_CAN2ETH
            [!ENDINDENT!][!//
            },
        [!VAR "crtIdx" = "$crtIdx+1"!][!//
        [!ENDINDENT!][!//
    [!ENDLOOP!][!//
    [!VAR "pcieIdx" = "0"!][!//
    [!LOOP "Can2OtherRoutingTable/*"!][!//
      [!IF "RoutingType = 'PCIe'"!]
          [!INDENT "4"!][!//
          {
          [!INDENT "8"!][!//
            {.Can2Pcie = {
            /* ======= Routing Rule ======= */
            [!INDENT "12"!][!//
                (uint64)[!"num:inttohex(PcieRcBuffAddr)"!],
                (uint32)0U,
                (uint16)sizeof(Llce_Can2Pcie_Buffer[!"num:i($pcieIdx)"!][0]),
                [!"BufferCount"!],
                [!"num:i(PcieController)"!],
                [!"num:i(DmaChannel)"!],
              [!IF "node:exists(MsiId)"!][!//
                [!"num:i(MsiId)"!]
              [!ELSE!][!//
                0xFF
              [!ENDIF!][!//
            }
            [!ENDINDENT!][!//
            },
            /* ======= Destination rule type ======= */
            CAN_AF_CAN2PCIE
          [!ENDINDENT!][!//
          },
          [!VAR "pcieIdx" = "$pcieIdx+1"!][!//
          [!ENDINDENT!][!//
      [!ENDIF!]
      [!IF "RoutingType = 'HSE'"!]
          [!INDENT "4"!][!//
          {
          [!INDENT "8"!][!//
            {.Can2Hse = {
            /* ======= Routing Rule ======= */
            [!INDENT "12"!][!//
                (uint32)[!"CanKeyHandle"!]
            }
            [!ENDINDENT!][!//
            },
            /* ======= Destination rule type ======= */
            CAN_AF_CAN2HSE
          [!ENDINDENT!][!//
          },
          [!ENDINDENT!][!//
      [!ENDIF!]
    [!ENDLOOP!][!//
[!ENDMACRO!][!// GenerateAdvancedDestinations

[!MACRO "GenerateBaudrate"!][!//
[!INDENT "0"!][!//
    [!NOCODE!][!//
    [!/*
    Sync-seg = is the segment that is used to synchronise the nodes on the bus. A bit edge (if there is a data change) is expected during this segment.
    Prop-Seg = is a period of time that is used to compensate for physical delay times within the network.
    Phase-seg1 = is a buffer segment that may be lengthened during resynchronisation to compensate for oscillator drift and positive phase differences between the oscillators of the transmitting and receiving node(s).
    Phase-seg2 = is a buffer segment that may be shortened during resynchronisation (described below) to compensate for negative phase errors and oscillator drift.

    The Sample point is always at the end of Phase-seg1 and is the time at which the bus level is read and interpreted as the value of the current bit.
    Whether transmitting or receiving, all nodes on a single CAN bus must have the same nominal bit time. Bit time is programmable at each node on a CAN Bus and is a function
        of the period of the oscillator local to each node, the value that is user-programmed into a Baud Rate Prescaler (BRP) register in the controller at each node, and the programmed number of time quanta per bit.

    When any node receives a data frame or a remote frame, it is necessary for the receiver to synchronise with the transmitter.
        1. The first is hard synchronisation and occurs at Start-of-Frame (SOF).
        2. For subsequent bits in any received frame, if a bit edge does not occur in the Sync-seg segment of bit time, resynchronisation is automatically invoked and will shorten or lengthen the current bit time depending
            on where the edge occurs. The maximum amount by which the bit time is lengthened or shortened is determined by a user-programmable number of time quanta known as the Synchronisation Jump Width (SJW).
    */!][!//
    [!ENDNOCODE!][!//
    [!IF "../../CanControllerActivation = 'true'"!][!//
        [!WS "8"!]/* Configuration [!"@index"!] for CanController ID[!"../../CanControllerId"!] == [!"../../CanHwChannel"!] */
        [!WS "8"!]{
        [!WS "12"!]/* ===== Nominal Bit Timing Register - NCBT ===== */
        [!VAR "TimeQuantum" = "num:i(./CanControllerPrescaller) div $CanClockSrc"!][!//
        [!VAR "NumOfTQN" = "num:i(round(1 div (./CanControllerBaudRate * 1000 * $TimeQuantum)))"!][!/* Number of Tq in nominal bit time = (1 div ((desired_baudrate(kbps) * 1000) * TQ )) */!][!//
        [!VAR "Tsyncsegment" = "1"!][!/* Sync_seg has 1 Tq length */!][!//
        [!IF "node:exists(CanAdvancedSetting) and (CanAdvancedSetting  = 'true')"!][!//
            [!/* Initiates the derivation of the CAN bit timing values from the CanControllerBaudRate parameter. */!][!//
            [!VAR "PropSeg" = "num:i(1)"!][!//
            [!VAR "PhaseSegment1" = "num:i(2)"!][!//
            [!VAR "PhaseSegment2" = "num:i(2)"!][!//
            [!VAR "RJW" = "num:i(1)"!][!//
            [!CALL "Can_BaudRate_Inference",
                    "CanPhysBusLength" = "num:i(./CanBusLength)",
                    "PropDelayTransceiver" = "num:i(./CanPropDelayTranceiver)",
                    "PhaseSegment1_Max" = "256",
                    "PhaseSegment2_Max" = "128",
                    "NumOfTQ" = "$NumOfTQN"!][!//
        [!ELSE!][!//
            [!IF "CanControllerCheckCanStandard"!][!/* Nominal Baudrate checking */!][!//
                [!VAR "TqNSeg1" = "num:i(./CanControllerPropSeg + ./CanControllerSeg1 + ./CanControllerSyncSeg)"!][!//
                [!VAR "TqNSeg2" = "num:i(./CanControllerSeg2)"!][!//
                [!VAR "UserNoTimeQuantas" = "num:i($TqNSeg1 + $TqNSeg2)"!][!/* Number of given Tq  */!][!//
                [!IF "$NumOfTQN != $UserNoTimeQuantas"!][!//
                    [!VAR "CorrespondingBaudrate" = "num:i(round(1 div ($UserNoTimeQuantas * $TimeQuantum * 1000)))"!][!/* Baudrate(kbps) corresponding to given Tq */!][!//
                    [!VAR "CorrespondingSamplePoint" = "num:f($TqNSeg1 div $UserNoTimeQuantas) * 100"!][!/* Sample point corresponding to given Tq */!][!//
                    [!WARNING!][!//
                        The total time quanta configured ([!"$UserNoTimeQuantas"!]) corresponds to a baudrate of [!"$CorrespondingBaudrate"!] kbps for nominal phase which
                        is different from the one given [!"./CanControllerBaudRate"!] kbps and computed from [!"$NumOfTQN"!] time quantas using the Can Clock 
                        (default is considered 40Mhz if no MCU clock source provided) and Prescaler. The corresponding sample point is [!"$CorrespondingSamplePoint"!]%.
                    [!ENDWARNING!][!//
                [!ENDIF!][!//
            [!ENDIF!] [!/* End of nominal baudrate checking  */!][!//
        [!ENDIF!][!//
        [!WS "12"!](uint32)( ((uint32)[!"num:i(num:i(CanControllerPrescaller) - 1)"!] << LLCE_NCBT_NPRESDIV_SHIFT_U8) |    /* Clock Prescaler */
        [!IF "node:exists(CanAdvancedSetting) and (CanAdvancedSetting  = 'true')"!][!//
                 [!WS "22"!]((uint32)[!"num:i(num:i($RJW) - 1)"!]U << LLCE_NCBT_NRJW_SHIFT_U8) |     /* Resynchronization Jump Width */
                 [!WS "22"!]((uint32)[!"num:i(num:i($PhaseSegment1) + num:i($PropSeg) - 1)"!]U) |      /*Segment 1 */
                 [!WS "22"!]((uint32)[!"num:i(num:i($PhaseSegment2) - 1)"!]U << LLCE_NCBT_NTSEG2_SHIFT_U8)    /* Segment 2 */
        [!ELSE!][!//
                 [!WS "22"!]((uint32)[!"num:i(num:i(CanControllerSyncJumpWidth) - 1)"!] << LLCE_NCBT_NRJW_SHIFT_U8) |     /* Resynchronization Jump Width */
                 [!WS "22"!]((uint32)[!"num:i(num:i(CanControllerSeg1) + num:i(CanControllerPropSeg) - 1)"!]) |      /*Segment 1 */
                 [!WS "22"!]((uint32)[!"num:i(num:i(CanControllerSeg2) - 1)"!] << LLCE_NCBT_NTSEG2_SHIFT_U8)    /* Segment 2 */
        [!ENDIF!][!//
            [!WS "20"!]),
        [!/* For further adding of CanControllerBaudRate number in configuration structure*/!][!//
        [!WS "12"!]{ /* Llce_Can_ControllerFdConfig */
        [!IF "node:exists(CanControllerFdBaudrateConfig/CanAdvancedSettingFd) and (CanControllerFdBaudrateConfig/CanAdvancedSettingFd = 'true')"!][!//
            [!VAR "TimeQuantumFD" = "num:i(CanControllerFdBaudrateConfig/CanControllerFDPrescaller) div $CanClockSrc"!][!//
            [!VAR "NumOfTQD" = "num:i(round(1 div (CanControllerFdBaudrateConfig/CanControllerFdBaudRate * 1000 * $TimeQuantumFD))"!][!/* Number of Tq in Data bit time = (1 div ((desired_baudrate(kbps) * 1000) * TQ )) */!][!//
            [!VAR "PhaseSegment1Fd" = "num:i(2)"!][!//
            [!VAR "PhaseSegment2Fd" = "num:i(2)"!][!//
            [!VAR "PropSegFd" = "num:i(1)"!][!//
            [!VAR "RJW_Fd" = "num:i(1)"!][!//
            [!CALL "Can_BaudRate_Inference",
                    "CanPhysBusLength" = "num:i(./CanControllerFdBaudrateConfig/CanBusLengthFd)",
                    "PropDelayTranceiver" = "num:i(0)",[!//CAN Fd provides an optional tranceiver delay mechanism
                    "PhaseSegment1_Max" = "32",
                    "PhaseSegment2_Max" = "16",
                    "NumOfTQ" = "$NumOfTQD"!][!//
        [!ELSE!][!//
            [!IF "CanControllerCheckCanStandard"!][!/* Data Baudrate checking  */!][!//
                [!IF "(node:exists(CanControllerFdBaudrateConfig) = 'true') and ((node:value(CanControllerFdBaudrateConfig/CanControllerTxBitRateSwitch)) = 'true')"!][!//
                 [!IF "node:value(CanControllerFdBaudrateConfig/CanControllerFdBaudRate) > num:i(text:split('8000 8000 8000 8000 8000 8000 7400 7400 6600 6600 5700 5700 5700 5700 5000 5000')[num:i($CONFIGURED_CONTROLLERS_COUNT)])"!][!//
                    [!WARNING!][!//
                        Maximum baudrate for a number of [!"num:i($CONFIGURED_CONTROLLERS_COUNT)"!] started controllers is [!//
                            [!"num:i(text:split('8000 8000 8000 8000 8000 8000 7400 7400 6600 6600 5700 5700 5700 5700 5000 5000')[num:i($CONFIGURED_CONTROLLERS_COUNT)])"!] kbps.
                    [!ENDWARNING!][!//
                    [!/* For further adding of CanControllerFdBaudRate number in configuration structure*/!][!//
                    [!ENDIF!][!//
                    [!VAR "TimeQuantumFD" = "num:i(CanControllerFdBaudrateConfig/CanControllerFDPrescaller) div $CanClockSrc"!][!//
                    [!VAR "NumOfTQD" = "num:i(round(1 div (CanControllerFdBaudrateConfig/CanControllerFdBaudRate * 1000 * $TimeQuantumFD)))"!][!/* Number of Tq in Data bit time = (1 div ((desired_baudrate(kbps) * 1000) * TQ )) */!][!//
                    [!VAR "TqDSeg1" = "num:i(CanControllerFdBaudrateConfig/CanControllerFdSyncSeg + CanControllerFdBaudrateConfig/CanControllerPropSeg + CanControllerFdBaudrateConfig/CanControllerSeg1)"!][!//
                    [!VAR "TqDSeg2" = "num:i(CanControllerFdBaudrateConfig/CanControllerSeg2)"!][!//
                    [!VAR "UserNoTimeQuantasFd" = "num:i($TqDSeg1 + $TqDSeg2)"!][!//
                    [!IF "$NumOfTQD != $UserNoTimeQuantasFd"!][!//
                        [!VAR "CorrespondingBaudrate" = "num:i(round(1 div ($UserNoTimeQuantasFd * $TimeQuantumFD * 1000)))"!][!/* Baudrate(kbps) corresponding to given Tq */!][!//
                        [!VAR "CorrespondingSamplePoint" = "num:f($TqDSeg1 div $UserNoTimeQuantasFd) * 100"!][!/* Sample point corresponding to given Tq */!][!//
                    [!WARNING!][!//
                        Maximum baudrate for a number of [!"num:i($CONFIGURED_CONTROLLERS_COUNT)"!] started controllers is [!//
                            [!"num:i(text:split('8000 8000 8000 8000 8000 8000 7400 7400 6600 6600 5700 5700 5700 5700 5000 5000')[num:i($CONFIGURED_CONTROLLERS_COUNT)])"!] kbps.
                    [!ENDWARNING!][!//
                    [!/* For further adding of CanControllerFdBaudRate number in configuration structure*/!][!//
                    [!ENDIF!][!//
                    [!VAR "TqDSeg1" = "num:i(CanControllerFdBaudrateConfig/CanControllerFdSyncSeg + CanControllerFdBaudrateConfig/CanControllerPropSeg + CanControllerFdBaudrateConfig/CanControllerSeg1)"!][!//
                    [!VAR "TqDSeg2" = "num:i(CanControllerFdBaudrateConfig/CanControllerSeg2)"!][!//
                    [!VAR "UserNoTimeQuantasFd" = "num:i($TqDSeg1 + $TqDSeg2)"!][!//
                    [!IF "$NumOfTQD != $UserNoTimeQuantasFd"!][!//
                        [!VAR "CorrespondingBaudrate" = "num:i(round(1 div ($UserNoTimeQuantasFd * $TimeQuantumFD * 1000)))"!][!/* Baudrate(kbps) corresponding to given Tq */!][!//
                        [!VAR "CorrespondingSamplePoint" = "num:f($TqDSeg1 div $UserNoTimeQuantasFd) * 100"!][!/* Sample point corresponding to given Tq */!][!//
                        [!WARNING!][!//
                            The total time quanta configured ([!"$UserNoTimeQuantasFd"!]) corresponds to a baudrate of [!"$CorrespondingBaudrate"!] kbps for data phase which 
                            is different from the one given [!"./CanControllerFdBaudrateConfig/CanControllerFdBaudRate"!] kbps and computed from [!"$NumOfTQD"!] time quantas using the Can Clock 
                            (default is considered 40Mhz if no MCU clock source provided) and Prescaler. The corresponding sample point is [!"$CorrespondingSamplePoint"!]%.
                        [!ENDWARNING!][!//
                    [!ENDIF!][!//
                    [!IF "(node:exists(CanControllerFdBaudrateConfig/CanControllerSspOffset)) = 'true'"!][!//
                        [!IF "CanControllerFdBaudrateConfig/CanControllerSspOffset > ((3 * num:i($NumOfTQD)) - 2)"!][!//
                            [!WARNING!][!//
                                The maximum delay which can be compensated by the BCAN transceiver delay compensation during the data phase is 3 CAN bit times â€“ 2 TQ, [!"(3 * num:i($NumOfTQD)) - 2"!].
                                Current CanControllerSspOffset value is [!"CanControllerFdBaudrateConfig/CanControllerSspOffset"!] .
                            [!ENDWARNING!][!//
                        [!ENDIF!][!//
                    [!ENDIF!][!//
                [!ENDIF!][!//
            [!ENDIF!][!/* End of data baudrate checking  */!][!//
        [!ENDIF!][!//
        [!IF "(node:exists(CanControllerFdBaudrateConfig)) = 'true'"!][!//
            [!WS "12"!](uint32)(((uint32)[!"num:i((CanControllerFdBaudrateConfig/CanControllerFDPrescaller) - 1)"!]U << LLCE_DCBT_DPRESDIV_SHIFT_U8) |   /* CAN FD prescaler */
            [!IF "node:exists(CanControllerFdBaudrateConfig/CanAdvancedSettingFd) and (CanControllerFdBaudrateConfig/CanAdvancedSettingFd = 'true')"!][!//
                    [!WS "21"!]((uint32)[!"num:i(num:i($RJW_Fd) - 1)"!]U << LLCE_DCBT_DRJW_SHIFT_U8) | /*Sync jump width*/
                    [!WS "21"!]((uint32)[!"num:i(num:i($PhaseSegment1Fd) + num:i($PropSegFd) - 1)"!]U) |   /* Time segment 1 */
                    [!WS "21"!]((uint32)[!"num:i(num:i($PhaseSegment2Fd) - 1)"!]U<<LLCE_DCBT_DTSEG2_SHIFT_U8)),   /*Time segment 2  */
            [!ELSE!][!//
                    [!WS "21"!]((uint32)[!"num:i((CanControllerFdBaudrateConfig/CanControllerSyncJumpWidth - 1))"!]U << LLCE_DCBT_DRJW_SHIFT_U8) | /*Sync jump width*/
                    [!WS "21"!]((uint32)[!"num:i(num:i(CanControllerFdBaudrateConfig/CanControllerSeg1) + num:i(CanControllerFdBaudrateConfig/CanControllerPropSeg) - 1)"!]U) |   /* Time segment 1 */
                    [!WS "21"!]((uint32)[!"num:i((CanControllerFdBaudrateConfig/CanControllerSeg2) - 1)"!]U<<LLCE_DCBT_DTSEG2_SHIFT_U8)),   /*Time segment 2  */
            [!ENDIF!][!//
            [!WS "12"!](uint8)LLCE_TRUE,  /* CAN FD enabled */
            [!IF "((node:value(CanControllerFdBaudrateConfig/CanControllerTxBitRateSwitch)) = 'true')"!][!//
                [!WS "12"!](uint8)LLCE_TRUE,  /* BRS activated*/
            [!ELSE!][!//
                [!WS "12"!](uint8)LLCE_FALSE, /* BRS deactivated*/
            [!ENDIF!][!//
            [!IF "(node:exists(CanControllerFdBaudrateConfig/CanControllerSspOffset)) = 'true'"!][!//
                [!WS "12"!](uint8)LLCE_TRUE, /* CanTrcvDelayCompEnable*/
                [!WS "12"!](uint8)LLCE_TRUE, /* CanTrcvDelayMeasEnable */
                [!WS "12"!](uint8)[!"CanControllerFdBaudrateConfig/CanControllerSspOffset"!]U, /*Trcv Delay*/
            [!ELSE!][!//
                [!WS "12"!](uint8)LLCE_FALSE, /* CanTrcvDelayCompEnable*/
                [!WS "12"!](uint8)LLCE_FALSE, /* CanTrcvDelayMeasEnable */
                [!WS "12"!](uint8)0U, /*Trcv Delay*/
            [!ENDIF!][!//
        [!ELSE!][!//
            [!WS "12"!](uint32)(0U |  /* CAN FD prescaler */
                    [!WS "21"!]0U | /*Sync jump width*/
                    [!WS "21"!]0U | /* Time segment 1 */
                    [!WS "21"!]0U),  /*Time segment 2  */
            [!WS "12"!](uint8)LLCE_FALSE, /*CAN FD Deactivated*/
            [!WS "12"!](uint8)LLCE_FALSE, /* BRS deactivated*/
            [!WS "12"!](uint8)LLCE_TRUE, /* CanTrcvDelayCompEnable*/
            [!WS "12"!](uint8)LLCE_TRUE, /* CanTrcvDelayMeasEnable */
            [!WS "12"!]0U,   /*Trcv Delay*/
        [!ENDIF!][!//
        [!WS "12"!]},
        [!WS "8"!]},
    [!ELSE!][!//
        [!WS "8"!]{
        [!WS "12"!]/* [!"../../CanHwChannel"!] ControlRegister Default Configuration: 125kb/s */
        [!WS "12"!]/* ===== Nominal Bit Timing Register - NCBT ===== */
        [!WS "12"!](uint32)( ((uint32)7 << LLCE_NCBT_NPRESDIV_SHIFT_U8) |    /* Clock Prescaler */
        [!WS "22"!]((uint32)0 << LLCE_NCBT_NRJW_SHIFT_U8) |     /* Resynchronization Jump Width */
        [!WS "22"!]((uint32)21) |      /*Segment 1 */
        [!WS "22"!]((uint32)16 << LLCE_NCBT_NTSEG2_SHIFT_U8)    /* Segment 2 */
        [!WS "20"!]),
        [!WS "12"!]{
        [!WS "7"!](uint32)(0U |
                [!WS "16"!]0U | /*Sync jump width*/
                [!WS "16"!]0U |
                [!WS "16"!]0U),
        [!WS "16"!](uint8)LLCE_FALSE, /*CAN FD Deactivated*/
        [!WS "16"!](uint8)LLCE_FALSE, /*false -> BRS deactivated*/
        [!WS "16"!](uint8)LLCE_FALSE, /* CanTrcvDelayCompEnable*/
        [!WS "16"!](uint8)LLCE_FALSE, /* CanTrcvDelayMeasEnable */
        [!WS "16"!]0U,   /*Trcv Delay*/
        [!WS "12"!]},
        [!WS "8"!]},
    [!ENDIF!][!//
[!ENDINDENT!][!//
[!ENDMACRO!][!// GenerateBaudrate

[!MACRO "CountDestinations"!][!//

    [!VAR "AF_CNT"  = "num:i(count(CanAdvancedFeature/*))"!][!//
    [!VAR "C2C_CNT" = "num:i(count(Can2CanRoutingTable/*))"!][!//
    [!VAR "C2E_CNT" = "num:i(count(Can2EthRoutingTable/*))"!][!//
    [!LOOP "node:order(Can2OtherRoutingTable/*)"!][!//
        [!IF "RoutingType = 'PCIe'"!][!//
        [!VAR "C2PCIE_CNT"="$C2PCIE_CNT + num:i(1)"!][!//
        [!ENDIF!][!//
    [!ENDLOOP!][!//
    [!VAR "C2O_CNT" = "num:i(count(Can2OtherRoutingTable/*))"!][!//

[!ENDMACRO!][!// CountDestinations

[!MACRO "PrintCrtDestOwnerPartition", "DestType"!][!//
[!NOCODE!][!//
    [!VAR "CrtDest" = "node:path(.)"!][!//
    [!VAR "CrtDestUsed" = "0"!][!//
    [!VAR "nodeEnable" = "concat($DestType, 'RoutingEnable')"!][!//
    [!VAR "nodeRef" = "concat($nodeEnable, '/', $DestType, 'RoutingTableRef')"!][!//
    [!/* Find advanced features using current destination */!][!//
    [!LOOP "../../CanAdvancedFeature/*"!][!//
      [!IF "node:exists($nodeEnable) and ($CrtDest = node:path(node:value($nodeRef)))"!][!//
        [!VAR "DestNode" = "node:path(.)"!][!//
        [!/* Find HRH using this feature and check their controller's owner */!][!//
        [!LOOP "as:modconf('Can')[CommonPublishedInformation/VendorApiInfix = 'LLCE']/CanConfigSet/CanHardwareObject/*"!][!//
       [!IF "(node:ref(CanControllerRef)/CanControllerActivation = 'true') and (CanObjectType = 'RECEIVE') and node:exists(CanAdvancedFeature) and node:refvalid(CanAdvancedFeature/CanAdvancedFeatureRef) and node:refvalid(node:ref(CanControllerRef)/CanControllerEcucPartitionRef)"!][!//
            [!IF "$DestNode = node:path(node:value(CanAdvancedFeature/CanAdvancedFeatureRef))"!][!//
              [!VAR "CrtDestUsed" = "1"!][!//
              [!VAR "CrtDestOwner" = "node:pos(node:ref(node:ref(CanControllerRef)/CanControllerEcucPartitionRef))"!][!//
              [!VAR "CrtDestOwnerCore" = "text:split($GLOBAL_ECUCPARTITION_COREID)[$CrtDestOwner+1]"!]
              [!BREAK!][!//
            [!ENDIF!][!//
          [!ENDIF!][!//
        [!ENDLOOP!][!//
      [!ENDIF!][!//
    [!ENDLOOP!][!//
[!ENDNOCODE!][!//
  [!INDENT "4"!][!//
      [!IF "$CrtDestUsed = 1"!][!//
        (uint32)[!"$CrtDestOwnerCore"!]U,
      [!ELSE!][!//
        (uint32)0xFFFFFFFFU,
      [!ENDIF!][!//
  [!ENDINDENT!][!//
[!ENDMACRO!][!//

========== END FILE: generate_PB\Can_43_LLCE_Macros.m ==========

========== START FILE: generate_PB\Can_43_LLCE_VersionCheck_Src_PB.m ==========
[!NOCODE!][!//
/**
*   @file    Can_VersionCheck_Src_PB.m
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - version check macro.
*   @details Version checks.
*  
*   Project RTD AUTOSAR 4.4
*   Platform CORTEXM
*   Peripheral LLCE
*   Dependencies 
*  
*   ARVersion 4.4.0
*   ARRevision ASR_REL_4_4_REV_0000
*   ARConfVariant
*   SWVersion 1.0.10
*   BuildVersion S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
==================================================================================================*/

[!/* avoid multiple inclusion */!]
[!IF "not(var:defined('CAN_VERSION_CHECK_INC_M'))"!]
[!VAR "CAN_VERSION_CHECK_INC_M"="'true'"!]

[!VAR "CAN_AR_RELEASE_MAJOR_VERSION_TEMPLATE"="4"!][!// 
[!VAR "CAN_AR_RELEASE_MINOR_VERSION_TEMPLATE"="4"!][!// 
[!VAR "CAN_AR_RELEASE_REVISION_VERSION_TEMPLATE"="0"!][!// 
[!VAR "CAN_SW_MAJOR_VERSION_TEMPLATE"="1"!][!//      
[!VAR "CAN_SW_MINOR_VERSION_TEMPLATE"="0"!][!//
[!VAR "CAN_SW_PATCH_VERSION_TEMPLATE"="10"!][!//      

[!SELECT "CommonPublishedInformation"!][!//
[!IF "not(num:i(ArReleaseMajorVersion) = num:i($CAN_AR_RELEASE_MAJOR_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "AUTOSAR major version number of the Basic Software Module Description file (Can.epd version [!"ArReleaseMajorVersion"!]) and the Code template file (Can_PBcfg.c version [!"num:i($CAN_AR_RELEASE_MAJOR_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(ArReleaseMinorVersion) = num:i($CAN_AR_RELEASE_MINOR_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "AUTOSAR minor version number of the Basic Software Module Description file (Can.epd version [!"ArReleaseMinorVersion"!]) and the Code template file (Can_PBcfg.c version [!"num:i($CAN_AR_RELEASE_MINOR_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(ArReleaseRevisionVersion) = num:i($CAN_AR_RELEASE_REVISION_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "AUTOSAR patch version number of the Basic Software Module Description file (Can.epd version [!"ArReleaseRevisionVersion"!]) and the Code template file (Can_PBcfg.c version [!"num:i($CAN_AR_RELEASE_REVISION_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(SwMajorVersion) = num:i($CAN_SW_MAJOR_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "The software major number of the Basic Software Module Description file (Can.epd version [!"SwMajorVersion"!]) and the Code template file (Can_PBcfg.c version [!"num:i($CAN_SW_MAJOR_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(SwMinorVersion) = num:i($CAN_SW_MINOR_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "The software minor number of the Basic Software Module Description file (Can.epd version [!"SwMinorVersion"!]) and the Code template file (Can_PBcfg.c version [!"num:i($CAN_SW_MINOR_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(SwPatchVersion) = num:i($CAN_SW_PATCH_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "The software patch number of the Basic Software Module Description file (Can.epd version [!"SwPatchVersion"!]) and the Code template file (Can_PBcfg.c version [!"num:i($CAN_SW_PATCH_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!ENDSELECT!][!//

[!ENDIF!][!// avoid multiple inclusion ENDIF

[!ENDNOCODE!][!//
========== END FILE: generate_PB\Can_43_LLCE_VersionCheck_Src_PB.m ==========

========== START FILE: generate_PB\include\Can_43_LLCE_AFcfg.h ==========
/**
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/
#ifndef CAN_AFCFG_H
#define CAN_AFCFG_H

#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Can_43_LLCE_Cfg.h"
[!NOCODE!]
[!INCLUDE "Can_43_LLCE_Macros.m"!][!//
[!ENDNOCODE!]
/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/
[!AUTOSPACING!][!//
[!VAR "AF_CNT"  = "num:i(0)"!][!//
[!VAR "C2C_CNT" = "num:i(0)"!][!//
[!VAR "C2E_CNT" = "num:i(0)"!][!//
[!VAR "ETH2CAN_BUF_CNT" = "num:i(0)"!][!//
[!VAR "ETH2CAN_BUF_SIZE" = "num:i(0)"!][!//
[!VAR "ETH2CAN_FORMAT_CNT" = "num:i(0)"!][!//
[!VAR "ETH2CAN_ENABLED" = "'STD_OFF'"!][!//
[!INDENT "0"!][!//
[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!][!//
    [!CALL "CountDestinations"!]
[!ENDSELECT!]
    [!WS "0"!]#define LLCE_CAN_ADVANCED_FEATURE_AF_CNT          [!"$AF_CNT"!]U
    [!WS "0"!]#define LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT     [!"$C2C_CNT"!]U
    [!WS "0"!]#define LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT     [!"$C2E_CNT"!]U
    [!WS "0"!]#define LLCE_CAN_ADVANCED_FEATURE_CAN2PCIE_CNT    [!"num:i($C2PCIE_CNT)"!]U
    [!WS "0"!]#define LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT   [!"num:i($C2O_CNT)"!]U

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral/Eth2Can"!]
    [!IF "Eth2CanEnable"!]
        [!VAR "ETH2CAN_ENABLED" = "'STD_ON'"!]
        [!VAR "ETH2CAN_BUF_CNT" = "num:i(Eth2CanBufferCount)"!]
        [!VAR "ETH2CAN_BUF_SIZE" = "num:i(Eth2CanBufferSize + (Eth2CanBufferSize mod 2))"!]
        [!VAR "ETH2CAN_FORMAT_CNT" = "num:i(count(Eth2CanEnabledFormats/*))"!]

        #define LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_CNT       [!"$ETH2CAN_BUF_CNT"!]U
        #define LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_SIZE      [!"$ETH2CAN_BUF_SIZE"!]U
        #define LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_FORMAT_CNT    [!"$ETH2CAN_FORMAT_CNT"!]U
    [!ENDIF!]
[!ENDSELECT!]
#define LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_ENABLED       [!"$ETH2CAN_ENABLED"!]

#if(LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT > 0)
/*
* @brief          CAN2ETH with external buffer
* @details        User shall use the external rings instead of internal ones.
*
*/
[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!]
[!IF "node:exists(CAN2ETHWithExternalRingBuffer) and (CAN2ETHWithExternalRingBuffer = 'true')"!]
#define LLCE_USE_EXTERNAL_RING_BUF (STD_ON)

#define LLCE_PFE_HIF_RING_CFG_LENGTH         128U /*number of BD*/

#define LLCE_PFE_BD_SIZE                     16U /*bytes*/
#define LLCE_PFE_BD_RING_SIZE                (LLCE_PFE_BD_SIZE * LLCE_PFE_HIF_RING_CFG_LENGTH)

#define LLCE_PFE_BD_WB_SIZE                  8U /*bytes*/
#define LLCE_PFE_BD_WB_RING_SIZE             (LLCE_PFE_BD_WB_SIZE * LLCE_PFE_HIF_RING_CFG_LENGTH)

#define LLCE_PFE_TX_HDR_EACH_SIZE            16U /*bytes*/
#define LLCE_PFE_TX_HDR_COUNT                LLCE_PFE_HIF_RING_CFG_LENGTH /*required by LLCE driver*/
#define LLCE_PFE_TX_HDR_SIZE                 (LLCE_PFE_TX_HDR_EACH_SIZE * LLCE_PFE_TX_HDR_COUNT)

#define LLCEIF_MIN_NUM_RX_BUF                72U
[!ELSE!]
    #define LLCE_USE_EXTERNAL_RING_BUF (STD_OFF)
[!ENDIF!]
[!ENDSELECT!]
#endif
/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/
[!IF "$AF_CNT > 0"!]
/* Configuration for advanced features */
extern const Llce_Can_AdvancedFeatureType Can_Llce_AdvancedFeature[LLCE_CAN_ADVANCED_FEATURE_AF_CNT];
[!ENDIF!]


[!IF "num:i($C2E_CNT + $C2PCIE_CNT) > 0"!]
/* Array with ETH and PCIE buffer addresses */
extern const uint8* pLlce_Can_AfBuffer[LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT];
[!ENDIF!]
[!IF "num:i($C2C_CNT + $C2E_CNT + $C2O_CNT) > 0"!]
/* Configuration for Routing Rules (CAN2CAN, CAN2ETH, CAN2OTHER)  */
extern const Can_Af_DestRulesType Llce_Can_AfRoutingTable[LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT];
    [!IF "num:i(count(as:modconf('Can')[CommonPublishedInformation/VendorApiInfix = 'LLCE']/CanGeneral/CanEcucPartitionRef/*)) != 0"!][!// Multicore
extern const uint32 Llce_Can_AfDestOwnerCoreId[LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT];
    [!ENDIF!][!// CanGeneral/CanEcucPartitionRef/* != 0"
[!ENDIF!]
    
[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral/Eth2Can"!]
    [!IF "Eth2CanEnable"!]
        VAR_ALIGN(extern uint8 Llce_Eth2Can_Buffer[LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_CNT][LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_SIZE], 2U)
        extern Llce_Can_EthEncapsulationFormat Llce_Eth2Can_EnabledFormats[LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_FORMAT_CNT];
    [!ENDIF!]
[!ENDSELECT!]

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!]
[!IF "node:exists(CAN2ETHWithExternalRingBuffer) and (CAN2ETHWithExternalRingBuffer = 'true')"!]
    extern volatile uint8 Llce_PfeIf_RxRing  [LLCE_PFE_BD_RING_SIZE];
    extern volatile uint8 Llce_PfeIf_RxWbRing[LLCE_PFE_BD_WB_RING_SIZE];
    extern volatile uint8 Llce_PfeIf_TxRing  [LLCE_PFE_BD_RING_SIZE];
    extern volatile uint8 Llce_PfeIf_TxWbRing[LLCE_PFE_BD_WB_RING_SIZE];
    extern volatile uint8 Llce_PfeIf_Hdr     [LLCE_PFE_TX_HDR_SIZE];
[!ENDIF!]
[!ENDSELECT!]
/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/

[!ENDINDENT!]
#ifdef __cplusplus
}
#endif

#endif /* CAN_AFCFG_H */

/** @} */
========== END FILE: generate_PB\include\Can_43_LLCE_AFcfg.h ==========

========== START FILE: generate_PB\include\Can_43_LLCE_PBcfg.h ==========
/**
*   @file    Can_43_LLCE_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBcfg.h
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Configuration settings generated by user settings.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifndef CAN_43_LLCE_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H
#define CAN_43_LLCE_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H

#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/*
* @file           Can_43_LLCE_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBcfg.h
*/
#define CAN_43_LLCE_VENDOR_ID_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H                  43
#define CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H           4
#define CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H           4
#define CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H        0
#define CAN_43_LLCE_SW_MAJOR_VERSION_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H           1
#define CAN_43_LLCE_SW_MINOR_VERSION_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H           0
#define CAN_43_LLCE_SW_PATCH_VERSION_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H           10

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/
[!NOCODE!]
[!IF "var:defined('postBuildVariant')"!]
    [!VAR "postBuildVariantNameUnderscore" = "concat('_',$postBuildVariant)"!]
    [!CODE!]#define CAN_43_LLCE_CONFIG_[!"$postBuildVariant"!]_PB \[!CR!][!ENDCODE!]
[!ELSE!]
    [!VAR "postBuildVariantNameUnderscore" = "string(null)"!]
    [!CODE!]#define CAN_43_LLCE_CONFIG_PB \[!CR!][!ENDCODE!]
[!ENDIF!]
[!VAR "CanConfiguredPartitions" = "num:i((count(CanGeneral/CanEcucPartitionRef/*)))"!]
[!INDENT "4"!]
[!IF "((IMPLEMENTATION_CONFIG_VARIANT != 'VariantPostBuild') and (variant:size()>1)) or (IMPLEMENTATION_CONFIG_VARIANT = 'VariantPostBuild')"!]
    [!IF "$CanConfiguredPartitions > 0"!]
        [!VAR "CanPartitionIdx" = "0"!]
        [!LOOP "CanGeneral/CanEcucPartitionRef/*"!]
            [!VAR "CanPartitionIdx" = "$CanPartitionIdx + 1"!]
            [!VAR "currentPartition" = "substring-after(substring-after(., 'EcuC/EcuC/'), '/')"!]
            [!CODE!]extern const Can_43_LLCE_ConfigType[!WS!]Can_43_LLCE_Config[!"$postBuildVariantNameUnderscore"!]_[!"$currentPartition"!]; [!IF "$CanPartitionIdx < $CanConfiguredPartitions"!]\[!ENDIF!][!CR!][!ENDCODE!]
        [!ENDLOOP!]
    [!ELSE!]
        [!CODE!]extern const Can_43_LLCE_ConfigType[!WS!]Can_43_LLCE_Config[!"$postBuildVariantNameUnderscore"!];[!ENDCODE!]
    [!ENDIF!]
[!ELSE!]
    [!IF "$CanConfiguredPartitions > 0"!]
        [!VAR "maxCoreDefConfig" = "num:i(1)"!]
        [!IF "CanGeneral/CanMulticoreSupport = 'true'"!]
            [!IF "node:exists(as:modconf('EcuC')[1]/EcucHardware/*/EcucCoreDefinition)"!]
                [!VAR "maxCoreDefConfig" = "num:i(count(as:modconf('EcuC')[1]/EcucHardware/*/EcucCoreDefinition/*))"!]
             [!ENDIF!]
        [!ENDIF!]
        [!VAR "CanPartitionIdx" = "0"!]
        [!LOOP "CanGeneral/CanEcucPartitionRef/*"!]
            [!VAR "CanPartitionIdx" = "$CanPartitionIdx + 1"!]
            [!VAR "currentPartition" = "substring-after(substring-after(., 'EcuC/EcuC/'), '/')"!]
            [!IF "var:defined('postBuildVariant')"!]
                [!CODE!]extern const Can_43_LLCE_ConfigType[!WS!]Can_43_LLCE_Config_[!"$currentPartition"!]; \[!CR!][!ENDCODE!]
            [!ELSE!]
                [!CODE!]extern const Can_43_LLCE_ConfigType[!WS!]Can_43_LLCE_Config[!"$postBuildVariantNameUnderscore"!]_[!"$currentPartition"!]; \[!CR!][!ENDCODE!]
            [!ENDIF!]
        [!ENDLOOP!]
        [!CODE!]extern const Can_43_LLCE_ConfigType* const Can_43_LLCE_Config[[!"$maxCoreDefConfig"!]];[!ENDCODE!]
    [!ELSE!]
        [!CODE!]extern const Can_43_LLCE_ConfigType Can_43_LLCE_Config;[!ENDCODE!]
    [!ENDIF!]

[!ENDIF!]
[!ENDINDENT!]
[!ENDNOCODE!]
#ifdef __cplusplus
}
#endif

#endif /* _CAN_43_LLCE_[!IF "var:defined('postBuildVariant')"!][!"$postBuildVariant"!]_[!ENDIF!]PBCFG_H_ */

/** @} */
========== END FILE: generate_PB\include\Can_43_LLCE_PBcfg.h ==========

========== START FILE: generate_PB\src\Can_43_LLCE_AFcfg.c ==========
/**
*   @file    Can_43_LLCE_AFcfg.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Configuration Structures for PostBuild.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifdef __cplusplus
extern "C"{
#endif

/**
* @file           Can_43_LLCE_AFcfg.c
*/

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Llce_InterfaceCanTypes.h"
#include "Mcal.h"
#include "Can_43_LLCE_AFcfg.h"

[!AUTOSPACING!]
[!INDENT "0"!]
[!NOCODE!]
[!INCLUDE "Can_43_LLCE_Macros.m"!][!//
[!ENDNOCODE!]
/*==================================================================================================
*                                   GLOBAL FUNCTION PROTOTYPES
==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_VAR_CLEARED_16_NO_CACHEABLE
#include "Can_43_LLCE_MemMap.h"

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!]
[!IF "node:exists(CAN2ETHWithExternalRingBuffer) and (CAN2ETHWithExternalRingBuffer = 'true')"!]

VAR_ALIGN(volatile uint8 Llce_PfeIf_RxRing  [LLCE_PFE_BD_RING_SIZE]     , 16U)
VAR_ALIGN(volatile uint8 Llce_PfeIf_RxWbRing[LLCE_PFE_BD_WB_RING_SIZE]  , 16U)
VAR_ALIGN(volatile uint8 Llce_PfeIf_TxRing  [LLCE_PFE_BD_RING_SIZE]     , 16U)
VAR_ALIGN(volatile uint8 Llce_PfeIf_TxWbRing[LLCE_PFE_BD_WB_RING_SIZE]  , 16U)
VAR_ALIGN(volatile uint8 Llce_PfeIf_Hdr     [LLCE_PFE_TX_HDR_SIZE]      , 16U)

[!ENDIF!]
[!ENDSELECT!]

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!]
    [!VAR "C2E_CNT" = "num:i(count(Can2EthRoutingTable/*))"!]
    [!IF "$C2E_CNT > 0"!]
        /**
        * @brief Can2Eth buffers
        * @details Memory space to be used by the LLCE Can2Eth feature. All buffers must be 16-bit aligned.
        *
        */
        [!VAR "crtIdx" = "0"!]
        [!LOOP "Can2EthRoutingTable/*"!]
            VAR_ALIGN(static uint8 Llce_Can2Eth_Buffer[!"num:i($crtIdx)"!][[!"Can2EthBufferCount"!]][[!"num:i(Can2EthBufferSize + (Can2EthBufferSize mod 2))"!]] , 2U)
            [!VAR "crtIdx" = "$crtIdx+1"!]
        [!ENDLOOP!]
    [!ENDIF!]
[!ENDSELECT!]

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!]
    [!VAR "crtIdx" = "0"!]
    [!LOOP "Can2OtherRoutingTable/*"!]
      [!IF "RoutingType = 'PCIe'"!]
        VAR_ALIGN(static uint8 Llce_Can2Pcie_Buffer[!"num:i($crtIdx)"!][[!"BufferCount"!]][[!"num:i(BufferSize + (BufferSize mod 2))"!]] , 2U)
        [!VAR "crtIdx" = "$crtIdx+1"!]
      [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!]

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!][!//
[!VAR "C2C_CNT" = "num:i(count(Can2CanRoutingTable/*))"!][!//
[!VAR "C2E_CNT" = "num:i(count(Can2EthRoutingTable/*))"!][!//
[!//
[!CALL "CountDestinations"!][!//
[!IF "num:i($C2E_CNT + $C2PCIE_CNT) > 0"!][!//
const uint8* pLlce_Can_AfBuffer[LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT] = {
    [!LOOP "Can2CanRoutingTable/*"!][!//
        [!WS "4"!]NULL_PTR,
    [!ENDLOOP!][!//
    [!VAR "Idx" = "0"!][!//
    [!LOOP "Can2EthRoutingTable/*"!][!//
        [!WS "4"!]&Llce_Can2Eth_Buffer[!"num:i($Idx)"!][0][0],
        [!VAR "Idx" = "$Idx+1"!][!//
    [!ENDLOOP!][!//
    [!VAR "Idx" = "0"!][!//
    [!LOOP "Can2OtherRoutingTable/*"!][!//
        [!IF "RoutingType = 'PCIe'"!]
            [!WS "4"!]&Llce_Can2Pcie_Buffer[!"num:i($Idx)"!][0][0],
            [!VAR "Idx" = "$Idx+1"!][!//
        [!ENDIF!]
    [!ENDLOOP!][!//
};
[!ENDIF!][!//
[!ENDSELECT!]           

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral/Eth2Can"!]
    [!IF "Eth2CanEnable"!]
        /**
        * @brief Eth2Can RX buffers
        * @details Memory space to be used by PFE to store incoming Eth2Can frames. All buffers must be 16-bit aligned.
        */
        VAR_ALIGN( uint8 Llce_Eth2Can_Buffer[LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_CNT][LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_BUF_SIZE] , 2U)

        Llce_Can_EthEncapsulationFormat Llce_Eth2Can_EnabledFormats[LLCE_CAN_ADVANCED_FEATURE_ETH2CAN_FORMAT_CNT] =
        {
            [!INDENT "4"!]
            [!LOOP "Eth2CanEnabledFormats/*"!]
                LLCE_AF_CAN2[!"."!][!IF "not(node:islast(.))"!], [!ENDIF!][!CR!]
            [!ENDLOOP!]
            [!ENDINDENT!]
        };
    [!ENDIF!]
[!ENDSELECT!]

#define CAN_43_LLCE_STOP_SEC_VAR_CLEARED_16_NO_CACHEABLE
#include "Can_43_LLCE_MemMap.h"
[!ENDINDENT!]

/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_CONFIG_DATA_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

[!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!][!//
[!IF "num:i($C2C_CNT + $C2E_CNT + $C2O_CNT) > 0"!][!//
/* Configuration for Can2Can and Can2Eth and Can2Other routing */
const Can_Af_DestRulesType Llce_Can_AfRoutingTable[LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT] =
{
    [!CALL "GenerateAdvancedDestinations"!]    
};
[!//
    [!IF "num:i(count(as:modconf('Can')[CommonPublishedInformation/VendorApiInfix = 'LLCE']/CanGeneral/CanEcucPartitionRef/*)) != 0"!][!// Multicore
        [!/* Fantastic speed optimization: preload list of cores associated with each CanEcucPartitionRef. Then each destination can just look it up */!]
        [!VAR "GLOBAL_ECUCPARTITION_COREID" = "''"!]
        [!LOOP "as:modconf('EcuC')[1]/EcucPartitionCollection/*[1]/EcucPartition/*"!]
            [!VAR "EcucPartitionName" = "node:name(.)"!]
            [!VAR "CoreID" = "'0xFFFFFFFF'"!]
            [!LOOP "as:modconf('Os')[1]/OsApplication/*"!]
                [!IF "contains(node:value(./OsAppEcucPartitionRef), $EcucPartitionName)"!]
                    [!VAR "CoreID" = "node:value(node:ref(./OsApplicationCoreRef)/EcucCoreId)"!]
                    [!BREAK!]
                [!ENDIF!]
            [!ENDLOOP!]
            [!VAR "GLOBAL_ECUCPARTITION_COREID"   = "concat($GLOBAL_ECUCPARTITION_COREID,' ', num:i($CoreID))"!]
        [!ENDLOOP!]
[!// Generate array of destination - owner core mappings
const uint32 Llce_Can_AfDestOwnerCoreId[LLCE_CAN_ADVANCED_FEATURE_CAN2CAN_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2ETH_CNT + LLCE_CAN_ADVANCED_FEATURE_CAN2OTHER_CNT] = {
        [!LOOP "Can2CanRoutingTable/*"!][!//
          [!CALL "PrintCrtDestOwnerPartition", "DestType" = "'Can2Can'"!][!//
        [!ENDLOOP!][!//
        [!LOOP "Can2EthRoutingTable/*"!][!//
          [!CALL "PrintCrtDestOwnerPartition", "DestType" = "'Can2Eth'"!][!//
        [!ENDLOOP!][!//
        [!LOOP "Can2OtherRoutingTable/*"!][!//
          [!CALL "PrintCrtDestOwnerPartition", "DestType" = "'Can2Other'"!][!//
        [!ENDLOOP!]
};
    [!ENDIF!][!// CanGeneral/CanEcucPartitionRef/* != 0"
[!ENDIF!][!// num:i($C2C_CNT + $C2E_CNT + $C2O_CNT) > 0
[!ENDSELECT!][!// as:modconf('Llce_Af')/LlceAfGeneral

#define CAN_43_LLCE_STOP_SEC_CONFIG_DATA_UNSPECIFIED
#include "Can_43_LLCE_MemMap.h"

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/

/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/

#ifdef __cplusplus
}
#endif

/** @} */
========== END FILE: generate_PB\src\Can_43_LLCE_AFcfg.c ==========

========== START FILE: generate_PB\src\Can_43_LLCE_Headless_Ip_PBcfg.c ==========
/**
*   @file    Can_43_LLCE_HeadlessCfg.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Configuration Structures for PostBuild.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/
[!IF "not((node:exists(CanGeneral/CanLlceHeadlessModeUsed)) and (CanGeneral/CanLlceHeadlessModeUsed ='true'))"!]
    [!SKIPFILE!]
    /* Headless option not activated in driver. This file is not used */
[!ELSE!]
#ifdef __cplusplus
extern "C"{
#endif

#include "Llce_InterfaceCanTypes.h"
#include "Llce_Headless.h"

[!AUTOSPACING!]
[!INDENT "0"!]
[!NOCODE!]
[!INCLUDE "Can_43_LLCE_Macros.m"!][!//
[!ENDNOCODE!]

#define CAN_43_LLCE_MAX_IDMASK    (uint32)0x1FFFFFFFU
[!NOCODE!]
[!CALL "CountFilters"!]
[!VAR "AdvancedDestinationCount" = "count(as:modconf('Llce_Af')/LlceAfGeneral/CanAdvancedFeature/*)"!],
[!SELECT "CanConfigSet"!]
[!VAR "RegularFilterCount" = "0"!]
[!VAR "AdvancedFilterCount" = "0"!]
[!FOR "i" = "0" TO "15"!] 
    [!VAR "RegularFilterCount" = "num:i($RegularFilterCount) + num:i(text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($i+1)])"!]
    [!VAR "AdvancedFilterCount" = "num:i($AdvancedFilterCount) + num:i(text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($i+1)])"!]
[!ENDFOR!]
[!VAR "CONFIGURED_CONTROLLERS_COUNT" = "num:i(0)"!]
[!LOOP "CanController/*"!]
    [!IF "CanControllerActivation = 'true'"!]
        [!VAR "CONFIGURED_CONTROLLERS_COUNT"="num:i($CONFIGURED_CONTROLLERS_COUNT) + 1"!]
    [!ENDIF!]
[!ENDLOOP!]
[!ENDSELECT!]
[!ENDNOCODE!]

__attribute__((section(".llce_headlessconfig")))
volatile struct {
[!INDENT "2"!]
    Llce_Headless_Descriptor descriptor;
    Llce_Can_InitPlatformCmdType initPlatform;
    Llce_Can_InitCmdType initChannels[[!"num:i($CONFIGURED_CONTROLLERS_COUNT)"!]];
    Llce_Can_SetBaudrateCmdType baudrates[[!"num:i($CONFIGURED_CONTROLLERS_COUNT)"!]];
    [!IF "num:i($AdvancedDestinationCount) > 0"!]
    Can_Af_DestRulesType advancedDestinations[[!"num:i($AdvancedDestinationCount)"!]];
    [!ENDIF!]
    [!IF "num:i($RegularFilterCount) > 0"!]
    Llce_Can_ReceiveFilterType regularFilters[[!"num:i($RegularFilterCount)"!]];
    [!ENDIF!]
    [!IF "num:i($AdvancedFilterCount) > 0"!]
    Llce_Can_AdvancedFilterType advancedFilters[[!"num:i($AdvancedFilterCount)"!]];
    [!ENDIF!]
[!ENDINDENT!]
} LLCE__ALIGNED__PACKED Can_43_LLCE_HeadlessCfg = {
[!INDENT "2"!]
    /* Headless config descriptor */
    {
        [!INDENT "4"!]
        /** "Magic number" used to detect headless mode */
        LLCE_HEADLESSMODE_MAGICVALUE,
        /** Number of channels used */
        [!"num:i($CONFIGURED_CONTROLLERS_COUNT)"!]U, 
        /** Number of routing destinations used. Used for advanced filters */
        [!"num:i($AdvancedDestinationCount)"!]U, 
        /** Number of regular filters used */
        {[!//
        [!FOR "i" = "0" TO "15"!] 
            [!"num:i(text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($i+1)])"!]U, [!//
        [!ENDFOR!]
        },
        /** Number of advanced filters used */
        {[!//
        [!FOR "i" = "0" TO "15"!] 
            [!"num:i(text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($i+1)])"!]U, [!//
        [!ENDFOR!]
        }
        [!ENDINDENT!]
    },
    /* Platform init */
    {
        [!CALL "GeneratePlatformInit"!]
    },
    /* Channel init */
    {
        [!CALL "GenerateChannelInit", "SkipGenerateEmpty" = "1"!]
    },
    /* Default Baudrates */
    {
        [!FOR "crtBcan"="0" TO "15"!]
            [!LOOP "node:order(CanConfigSet/CanController/*,'node:value(CanControllerId)')"!][!//
                [!IF "substring-after(./CanHwChannel,'BCAN_') = $crtBcan "!]
                    [!VAR "CanClockSrc"="0"!]
                    [!IF "(node:exists(./CanCpuClockRef)) = 'true'"!]
                        [!VAR "CanClockSrc" = "node:ref(./CanCpuClockRef)/McuClockReferencePointFrequency"!]
                    [!ELSE!]
                        [!VAR "CanClockSrc" = "num:i(40000000)"!] [!/* Default Can Clock value 40 Mhz */!]
                    [!ENDIF!]
                    [!SELECT "node:ref(CanControllerDefaultBaudrate)"!]
                        [!CALL "GenerateBaudrate"!]
                    [!ENDSELECT!]
                [!ENDIF!]
            [!ENDLOOP!]
        [!ENDFOR!]
    },
    [!IF "num:i($AdvancedDestinationCount) > 0"!]
    /* Advanced destinations */
    {
        [!SELECT "as:modconf('Llce_Af')/LlceAfGeneral"!][!//
        [!CALL "GenerateAdvancedDestinations"!]    
        [!ENDSELECT!][!//
    },    
    [!ENDIF!]
    [!IF "num:i($RegularFilterCount) > 0"!]
    /* Regular filters */
    {
        [!FOR "crtCtrl" = "0" TO "15"!] 
        [!IF "text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
            [!VAR "crtFilter" = "0"!]
            [!INDENT "4"!]     
                [!LOOP "node:order(CanConfigSet/CanHardwareObject/*,'node:value(CanObjectId)')"!]
                    [!IF "(node:ref(CanControllerRef)/CanControllerActivation = 'true') and (CanObjectType = 'RECEIVE') and (substring-after(node:ref(CanControllerRef)/CanHwChannel,'BCAN_') = num:i($crtCtrl)) and not(node:exists(CanAdvancedFeature))"!]
                        { /* Regular filter [!"num:i($crtFilter)"!] for BCAN_[!"num:i($crtCtrl)"!] */
                        [!CALL "GenerateFilterConfig"!]
                        },
                        [!VAR "crtFilter" = "$crtFilter+1"!]
                    [!ENDIF!]
                [!ENDLOOP!]
            [!ENDINDENT!]
        [!ENDIF!]
        [!ENDFOR!]
    },
    [!ENDIF!]
    [!IF "num:i($AdvancedFilterCount) > 0"!]  
    /* Advanced filters */
    {
        [!FOR "crtCtrl" = "0" TO "15"!] 
        [!IF "text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
            [!VAR "crtFilter" = "0"!]
            [!INDENT "4"!]     
                [!LOOP "node:order(CanConfigSet/CanHardwareObject/*,'node:value(CanObjectId)')"!]
                    [!IF "(node:ref(CanControllerRef)/CanControllerActivation = 'true') and (CanObjectType = 'RECEIVE') and (substring-after(node:ref(CanControllerRef)/CanHwChannel,'BCAN_') = num:i($crtCtrl)) and node:exists(CanAdvancedFeature)"!]
                        [!CALL "GenerateAdvancedFilterConfig"!],
                        [!VAR "crtFilter" = "$crtFilter+1"!]
                    [!ENDIF!]
                [!ENDLOOP!]
            [!ENDINDENT!]
        [!ENDIF!]
        [!ENDFOR!]
    }
    [!ENDIF!]
[!ENDINDENT!]
};

[!ENDINDENT!]
#ifdef __cplusplus
}
#endif
[!ENDIF!]
========== END FILE: generate_PB\src\Can_43_LLCE_Headless_Ip_PBcfg.c ==========

========== START FILE: generate_PB\src\Can_43_LLCE_PBcfg.c ==========
/**
*   @file    Can_43_LLCE_PBcfg.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Configuration Structures for PostBuild.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifdef __cplusplus
extern "C"{
#endif

/*
   (CAN078) The code file structure shall not be defined within this specification completely.
            At this point it shall be pointed out that the code-file structure shall include the following file named: Can_43_LLCE_PBcfg.c.
            This file shall contain all post-build time configurable parameters.
   (CAN221) VariantPB: (Mix of precompile and Post Build multiple selectable configurable configurations.
*/
/**
* @file           Can_43_LLCE_PBcfg.c
*/

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Can_43_LLCE.h"
#include "Can_43_LLCE_IPW.h"

[!AUTOSPACING!]
[!//
[!NOCODE!][!//
[!INCLUDE "Can_43_LLCE_VersionCheck_Src_PB.m"!][!//
[!INCLUDE "Can_43_LLCE_Can_BaudRate_Inference.m"!][!//
[!INCLUDE "Can_43_LLCE_Macros.m"!][!//
[!ENDNOCODE!][!//
[!//
/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/*
* @file           Can_43_LLCE_PBcfg.c
*/
#define CAN_43_LLCE_VENDOR_ID_PBCFG_C                   43
#define CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_PBCFG_C     4
#define CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_PBCFG_C     4
#define CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_PBCFG_C  0
#define CAN_SW_MAJOR_VERSION_PBCFG_C             1
#define CAN_SW_MINOR_VERSION_PBCFG_C             0
#define CAN_SW_PATCH_VERSION_PBCFG_C             10

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/* Check if current file and Can configuration header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID_PBCFG_C != CAN_43_LLCE_VENDOR_ID)
#error "Can_43_LLCE.h and Can_43_LLCE_Cfg.h have different vendor ids"
#endif
/* Check if current file and CAN header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_PBCFG_C != CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_PBCFG_C != CAN_43_LLCE_AR_RELEASE_MINOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_PBCFG_C != CAN_43_LLCE_AR_RELEASE_REVISION_VERSION))
  #error "AutoSar Version Numbers of Can_43_LLCE_PBcfg.c and Can_43_LLCE.h are different"
#endif
/* Check if current file and CAN header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_PBCFG_C != CAN_43_LLCE_SW_MAJOR_VERSION) || \
     (CAN_SW_MINOR_VERSION_PBCFG_C != CAN_43_LLCE_SW_MINOR_VERSION) || \
     (CAN_SW_PATCH_VERSION_PBCFG_C != CAN_43_LLCE_SW_PATCH_VERSION))
       #error "Software Version Numbers of Can_43_LLCE_PBcfg.c and Can_43_LLCE.h are different"
#endif

/* Check if current file and Can_IPW configuration header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID_PBCFG_C  != CAN_IPW_VENDOR_ID_H)
#error "Can_43_LLCE.h and Can_43_LLCE_Cfg.h have different vendor ids"
#endif
/* Check if current file and CAN_IPW header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_PBCFG_C != CAN_IPW_AR_RELEASE_MAJOR_VERSION_H) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_PBCFG_C != CAN_IPW_AR_RELEASE_MINOR_VERSION_H) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_PBCFG_C != CAN_IPW_AR_RELEASE_REVISION_VERSION_H))
  #error "AutoSar Version Numbers of Can_43_LLCE_PBcfg.c and Can_43_LLCE_IPW.h are different"
#endif
/* Check if current file and CAN_IPW header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_PBCFG_C != CAN_IPW_SW_MAJOR_VERSION_H) || \
     (CAN_SW_MINOR_VERSION_PBCFG_C != CAN_IPW_SW_MINOR_VERSION_H) || \
     (CAN_SW_PATCH_VERSION_PBCFG_C != CAN_IPW_SW_PATCH_VERSION_H))
       #error "Software Version Numbers of Can_43_LLCE_PBcfg.c and Can_43_LLCE_IPW.h are different"
#endif

/*==================================================================================================
*                                   GLOBAL FUNCTION PROTOTYPES
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_CONFIG_DATA_UNSPECIFIED

#include "Can_43_LLCE_MemMap.h"


/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/
[!NOCODE!]
[!SELECT "CanConfigSet"!]
    [!VAR "CanEcucPartitionRefCount" = "num:i(count(./CanGeneral/CanEcucPartitionRef/*))"!]
    [!VAR "HOHCount" = "num:i(count(CanHardwareObject/*))"!]
    [!VAR "CustomProcessingFlag"="'false'"!]
    [!VAR "HRHcount" = "0"!]
    [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
            [!IF "(CanObjectType = 'RECEIVE')"!]
                [!VAR "HRHcount" = "$HRHcount + 1"!]
                [!IF "node:exists(CanAdvancedFeature)"!]
                    [!SELECT "node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)"!]
                        [!IF "CustomProcessingEnable = 'true'"!]
                            [!VAR "CustomProcessingFlag"="'true'"!]
                        [!ENDIF!]
                    [!ENDSELECT!]
                [!ENDIF!]
            [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!]

[!MACRO "GetCoreIdOfEcucPartition"!][!// Call with an CanEcucPartitionRef selected
    [!VAR "PartitionMatch" = "num:i(0)"!]
    [!VAR "CanEcucPartitionPath" = "node:value(.)"!]
    [!VAR "CanEcucPartitionName" = "substring-after(substring-after($CanEcucPartitionPath, 'EcuC/EcuC/'), '/')"!]
    [!LOOP "as:modconf('Os')[1]/OsApplication/*"!]
        [!IF "contains(node:value(./OsAppEcucPartitionRef), $CanEcucPartitionName)"!]
            [!VAR "CoreID" = "node:value(node:ref(./OsApplicationCoreRef)/EcucCoreId)"!]
            [!VAR "PartitionMatch" = "num:i(1)"!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$PartitionMatch = 1"!]    
        [!CODE!][!WS "4"!](uint32)[!"$CoreID"!]U /* Core ID */[!ENDCODE!]
    [!ELSE!]
        [!CODE!][!WS "4"!](uint32)0xFFFFFFFFU /* No core defined for selected partition */[!ENDCODE!]
    [!ENDIF!]        
[!ENDMACRO!]    
[!ENDNOCODE!]

[!CALL "CountFilters"!]
[!FOR "i" = "0" TO "15"!] 
    [!IF "text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($i+1)] > 0"!]
        [!WS "0"!]#define LLCE_CTRL_[!"num:i($i)"!]_MAX_RX_FILTERS      [!"num:i(text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($i+1)])"!]
    [!ENDIF!]
    [!IF "text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($i+1)] > 0"!]
        [!WS "0"!]#define LLCE_CTRL_[!"num:i($i)"!]_MAX_RXAF_FILTERS    [!"num:i(text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($i+1)])"!]
    [!ENDIF!]
[!ENDFOR!]

/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/
[!IF "$CustomProcessingFlag='true'"!]
VAR_ALIGN( static const uint32 CanFilterId2CustomIdx[[!"num:i($HRHcount)"!]], 32U)
[!ENDIF!]

/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/
/*==================================================================================================*/
/**
* @brief        Configuration parameters of the entire platform.
* @details      Config parameters needed for init platform command. E.g:
*               Maximum number of filters requested to be supported by filtering hardware. It is used to generate the data structures used for tracking used hardware filters.
*               Maximum number of RX hardware objects (for interrupt mode) of each channel needed to be reserved for RX buffering mechanism.
*               Maximum number of RX hardware objects of each polling class needed to be reserved for RX buffering mechanism.
*               Maximum number of TX confirmation buffers (for interrupt mode) of each channel needed to be reserved for TX confirmations buffering mechanism.
*               Maximum number of TX confirmation buffers of each polling class needed to be reserved for TX confirmations buffering mechanism.
*
*/
/*==================================================================================================*/
[!VAR "CanEcucPartitionRefCount" = "num:i(count(CanGeneral/CanEcucPartitionRef/*))"!]
[!IF "$CanEcucPartitionRefCount = 0"!][!// No CAN EcucPartition References
static const Llce_Can_InitPlatformCmdType PlatformInitConfig[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!] =
{   
[!CALL "GeneratePlatformInit"!]
};
[!ELSE!][!//
    [!LOOP "CanGeneral/CanEcucPartitionRef/*"!]
        [!VAR "crtEcucPartitionPath" = "node:value(.)"!]
        [!VAR "CanEcucPartitionName" = "substring-after(substring-after($crtEcucPartitionPath, 'EcuC/EcuC/'), '/')"!]
static const Llce_Can_InitPlatformCmdType PlatformInitConfig_[!"$CanEcucPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!] =
{   
        [!SELECT "../../.."!]
[!CALL "GeneratePlatformInit", "CanEcuCPartitionPath" = "$crtEcucPartitionPath"!]
};
        [!ENDSELECT!]

    [!ENDLOOP!]
[!ENDIF!]

/*==================================================================================================*/
/**
* @brief          Arrays of filters for LLCE
* @details        Lists of regular and advanced reception filters to be sent to LLCE, grouped by controller
*
*/
/*==================================================================================================*/
[!SELECT "CanConfigSet"!]
[!FOR "crtCtrl" = "0" TO "15"!] 
[!IF "text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
 [!WS "0"!]static Llce_Can_ReceiveFilterType Llce_Rx_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!] [ LLCE_CTRL_[!"num:i($crtCtrl)"!]_MAX_RX_FILTERS ] =
 [!VAR "crtFilter" = "0"!]
{   
[!INDENT "2"!]     
    [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
        [!IF "(node:ref(CanControllerRef)/CanControllerActivation = 'true') and (CanObjectType = 'RECEIVE') and (substring-after(node:ref(CanControllerRef)/CanHwChannel,'BCAN_') = num:i($crtCtrl)) and not(node:exists(CanAdvancedFeature))"!]
            [!IF "$crtFilter > 0"!],
            [!ENDIF!]
            { /* Regular filter [!"num:i($crtFilter)"!] for BCAN_[!"num:i($crtCtrl)"!] */
            [!CALL "GenerateFilterConfig"!]
            }[!//
            [!VAR "crtFilter" = "$crtFilter+1"!]
         [!ENDIF!]
    [!ENDLOOP!]
[!ENDINDENT!]

};
[!ENDIF!]
[!ENDFOR!]

/* List of regular filter arrays */
[!IF "$CanEcucPartitionRefCount = 0"!][!// No CAN EcucPartition References - dump filter count list
static Llce_Can_ReceiveFilterType * Llce_Rx_Filters_List[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][] =
{ 
    [!FOR "crtCtrl" = "0" TO "15"!] 
        [!IF "$crtCtrl > 0"!],
        [!ENDIF!]
        [!IF "text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
    Llce_Rx_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][!//
        [!ELSE!][!//
    NULL_PTR /* No regular filters for channel [!"$crtCtrl"!] */[!//
        [!ENDIF!]
    [!ENDFOR!]

};
[!ELSE!][!//
    [!LOOP "../CanGeneral/CanEcucPartitionRef/*"!]
        [!VAR "crtEcucPartitionPath" = "node:value(.)"!]
        [!VAR "CanEcucPartitionName" = "substring-after(substring-after($crtEcucPartitionPath, 'EcuC/EcuC/'), '/')"!]
static Llce_Can_ReceiveFilterType * Llce_Rx_Filters_List_[!"$CanEcucPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][] =
{ 
        [!FOR "crtCtrl" = "0" TO "15"!][!//
            [!IF "$crtCtrl > 0"!],
            [!ENDIF!][!//
                [!IF "text:split($GLOBAL_RX_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!][!//
                        [!LOOP "node:order(../../../CanConfigSet/CanController/*,'node:value(CanControllerId)')"!][!//
                            [!IF "substring-after(./CanHwChannel,'BCAN_') = $crtCtrl"!][!//
                                [!IF "node:exists(./CanControllerEcucPartitionRef) and (node:value(./CanControllerEcucPartitionRef) = $crtEcucPartitionPath)"!][!//
    Llce_Rx_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][!//
                                [!ELSE!][!//
    NULL_PTR /* Channel [!"$crtCtrl"!] not in current partition*/[!//
                                [!ENDIF!]
                            [!ENDIF!]
                        [!ENDLOOP!]
                [!ELSE!][!//
    NULL_PTR /* No regular filters for channel [!"$crtCtrl"!] */[!//
                [!ENDIF!]
        [!ENDFOR!]

};

    [!ENDLOOP!]
[!ENDIF!]
   
[!FOR "crtCtrl" = "0" TO "15"!] 
[!IF "text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
 [!WS "0"!]static Llce_Can_AdvancedFilterType Llce_RxAf_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!] [ LLCE_CTRL_[!"num:i($crtCtrl)"!]_MAX_RXAF_FILTERS ] =
 [!VAR "crtFilter" = "0"!]
 {   
        [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
            [!IF "(node:ref(CanControllerRef)/CanControllerActivation = 'true') and (CanObjectType = 'RECEIVE') and (substring-after(node:ref(CanControllerRef)/CanHwChannel,'BCAN_') = num:i($crtCtrl)) and node:exists(CanAdvancedFeature)"!]
              [!IF "$crtFilter > 0"!],
              [!ENDIF!]
              [!CALL "GenerateAdvancedFilterConfig"!]
              [!VAR "crtFilter" = "$crtFilter+1"!]
            [!ENDIF!]
        [!ENDLOOP!]

 };

[!ENDIF!]
[!ENDFOR!]

[!IF "$CanEcucPartitionRefCount = 0"!][!// No CAN EcucPartition References - dump filter count list
static Llce_Can_AdvancedFilterType * Llce_RxAf_Filters_List[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][] =
{ 
    [!FOR "crtCtrl" = "0" TO "15"!] 
        [!IF "$crtCtrl > 0"!],
        [!ENDIF!]
        [!IF "text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
    Llce_RxAf_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][!//
        [!ELSE!][!//
    NULL_PTR /* No advanced filters for channel [!"$crtCtrl"!] */[!//
        [!ENDIF!]
    [!ENDFOR!]

};
[!ELSE!][!//
    [!LOOP "../CanGeneral/CanEcucPartitionRef/*"!]
        [!VAR "crtEcucPartitionPath" = "node:value(.)"!]
        [!VAR "CanEcucPartitionName" = "substring-after(substring-after($crtEcucPartitionPath, 'EcuC/EcuC/'), '/')"!]
static Llce_Can_AdvancedFilterType * Llce_RxAf_Filters_List_[!"$CanEcucPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][] =
{ 
        [!FOR "crtCtrl" = "0" TO "15"!][!//
            [!IF "$crtCtrl > 0"!],
            [!ENDIF!][!//
                [!IF "text:split($GLOBAL_RXAF_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!][!//
                        [!LOOP "node:order(../../../CanConfigSet/CanController/*,'node:value(CanControllerId)')"!][!//
                            [!IF "substring-after(./CanHwChannel,'BCAN_') = $crtCtrl"!][!//
                                [!IF "node:exists(./CanControllerEcucPartitionRef) and (node:value(./CanControllerEcucPartitionRef) = $crtEcucPartitionPath)"!][!//
    Llce_RxAf_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][!//
                                [!ELSE!][!//
    NULL_PTR /* Channel [!"$crtCtrl"!] not in current partition*/[!//
                                [!ENDIF!]
                            [!ENDIF!]
                        [!ENDLOOP!]
                [!ELSE!][!//
    NULL_PTR /* No advanced filters for channel [!"$crtCtrl"!] */[!//
                [!ENDIF!]
        [!ENDFOR!]

};

    [!ENDLOOP!]
[!ENDIF!]

[!ENDSELECT!]    
/*==================================================================================================*/
/**
* @brief          Information about hardware objects.
* @details        (CAN100)Several TX hardware objects with unique HTHs may be configured. The CanIf module provides the HTH as parameter of the TX request. See Figure 7-2 for a possible configuration.
*
*/
/*==================================================================================================*/

[!SELECT "CanConfigSet"!]
    [!VAR "MAX_RX_LONGMB_COUNT" = "num:i(0)"!]
    [!VAR "MAX_RX_SHORTMB_COUNT" = "num:i(0)"!]
    [!VAR "MAX_TXMB_COUNT" = "num:i(0)"!]
    [!WS "0"!]static const Can_43_LLCE_HOHType MessageBufferConfigs_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][CAN_43_LLCE_MAXHOH_CONFIGURED] =
    [!WS "0"!]{
    [!VAR "END_COMMA"="0"!]
    [!VAR "MASK_COUNT"="num:i(count(CanHardwareObject/*))"!]
    [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
        [!VAR "END_COMMA"="$END_COMMA + 1"!]
                [!WS "4"!]/* [!"@name"!] Message Buffer [!"@index"!] on Can Controller [!"num:i(node:ref(CanControllerRef)/CanControllerId)"!] */
                [!WS "4"!]{
                [!INDENT "8"!]
                [!IF "CanObjectType = 'RECEIVE'"!]
                    [!IF "node:exists(CanAdvancedFeature/CanAdvancedFeatureRef)"!]
                        CAN_43_LLCE_RECEIVE_AF, /* Object Type */
                    [!ELSE!]        
                        CAN_43_LLCE_RECEIVE,  /* Object Type */
                    [!ENDIF!]
                    [!IF "node:exists('CanObjectPayloadLength') and (CanObjectPayloadLength='CAN_OBJECT_PL_8')"!]
                        [!VAR "MAX_RX_SHORTMB_COUNT"="num:i($MAX_RX_SHORTMB_COUNT) + num:i(CanHwObjectCount)"!]
                    [!ELSE!]
                        [!VAR "MAX_RX_LONGMB_COUNT"="num:i($MAX_RX_LONGMB_COUNT) + num:i(CanHwObjectCount)"!]
                    [!ENDIF!]

                [!ELSE!]
                        CAN_43_LLCE_TRANSMIT,  /* Object Type */
                    [!VAR "MAX_TXMB_COUNT"="num:i($MAX_TXMB_COUNT) + num:i(CanHwObjectCount)"!]
                [!ENDIF!]
                [!IF " (node:exists(CanHwObjectCount))"!]
                    (uint16)[!"num:inttohex(CanHwObjectCount)"!], /* MBCount */
                [!ELSE!]
                    (uint16)1U, /* MBCount */
                [!ENDIF!]
                    (uint8)[!"num:i(node:ref(CanControllerRef)/CanControllerId)"!]U, /* ControllerId  - based on the order from CanController list */
                [!IF " (node:exists(CanFdPaddingValue)) and (node:exists(../../../CanConfigSet/CanController/*/CanControllerBaudrateConfig/*/CanControllerFdBaudrateConfig)) and (node:fallback(CanObjectType,'TRANSMIT') = 'TRANSMIT')"!]
                    (uint8)[!"num:inttohex(CanFdPaddingValue)"!], /**< @brief Padding value for MB > 8 bytes */
                [!ELSE!]
                    (uint8)0U, /**< @brief Padding value for MB > 8 bytes */
                [!ENDIF!]
                [!IF "CanObjectType = 'TRANSMIT'"!]
                    /* Read/Write period reference used when polling mode is selected for this HTH */
                    [!IF "node:refexists(CanMainFunctionRWPeriodRef) and (((node:ref(CanControllerRef)/CanTxProcessing = 'MIXED') and (CanHardwareObjectUsesPolling = 'true')) or (((node:ref(CanControllerRef)/CanTxProcessing = 'POLLING'))))"!]
                        [!SELECT "node:ref(CanMainFunctionRWPeriodRef)"!]
                            (uint8)[!"@index"!]U,    /* HTH reference is from [!"node:name(.)"!]. */
                            (uint8)[!"num:i(AckInterface)"!],   /* Ack reported through this interface . */
                        [!ENDSELECT!]
                    [!ELSE!]
                        LLCE_CAN_REFERENCE_NOT_USED,   /* HTH configured for interrupt mode, reference not used.*/
                        [!WS "8"!][!CALL "GetRWDestInterfaceFromHOH"!], /* Ack is reported through this interface . */
                    [!ENDIF!][!//
                    [!IF "CanTxAddFrameMac = 'true'"!]
                        TRUE, /* Add MAC code and Key Handle for all frames transmitted using this HTH. */
                        (uint32)[!"num:inttohex(CanLlceKeyHandle)"!],
                    [!ELSE!]
                        FALSE, /* Add no MAC code for frames transmitted using this HTH. */
                        0u,    /* No key handler required if no MAC code is requested */
                    [!ENDIF!][!//
                [!ELSE!] [!// Receive object
                    [!IF "node:refexists(CanMainFunctionRWPeriodRef) and (((node:ref(CanControllerRef)/CanRxProcessing = 'MIXED') and (CanHardwareObjectUsesPolling = 'true')) or (((node:ref(CanControllerRef)/CanRxProcessing = 'POLLING'))))"!]
                        [!SELECT "node:ref(CanMainFunctionRWPeriodRef)"!]
                            (uint8)[!"@index"!]U,    /* HRH reference is from [!"node:name(.)"!] */
                            (uint8)[!"num:i(RxInterface)"!],   /* Rx is reported through this interface. */
                        [!ENDSELECT!]
                    [!ELSE!]
                        LLCE_CAN_REFERENCE_NOT_USED,   /* HRH configured for interrupt mode, reference not used. */
                        [!WS "2"!][!CALL "GetRWDestInterfaceFromHOH"!], /* Rx is reported through this interface . */
                    [!ENDIF!][!//
                    FALSE, /* Adding MAC code and key handler do not apply for receiving HRH. */
                    0u,
                [!ENDIF!][!//
                [!IF "(node:exists(CanTriggerTransmitEnable)) and (node:value(CanTriggerTransmitEnable) ='true')"!]
                    #if (CAN_43_LLCE_TRIGGER_TRANSMIT_EN == STD_ON)
                    (boolean)TRUE, /* Trigger Transmit enabled */
                    #endif
                [!ELSE!]
                    #if (CAN_43_LLCE_TRIGGER_TRANSMIT_EN == STD_ON)
                    (boolean)FALSE, /* Trigger Transmit disabled */
                    #endif
                [!ENDIF!]
                [!IF "(node:exists(Dummy_HRH)) and (node:value(Dummy_HRH) ='true')"!]
                    #if (CAN_43_LLCE_DUMMY_HRH_EN == STD_ON)
                    (boolean)TRUE /* Dummy HRH enabled */
                    #endif
                [!ELSE!]
                    #if (CAN_43_LLCE_DUMMY_HRH_EN == STD_ON)
                    (boolean)FALSE /* Dummy HRH disabled */
                    #endif
                [!ENDIF!]
                [!ENDINDENT!]
                [!WS "4"!]}[!CR!]
        [!IF "$END_COMMA < $MASK_COUNT"!][!//
            [!WS "0"!],
        [!ENDIF!]
        [!CR!]
    [!ENDLOOP!]
    [!WS "0"!]};
    [!IF "num:i($MAX_TXMB_COUNT) > 256"!][!//
        [!ERROR!]The hardware platform does not include enough message buffers in order to service all configured HTHs. Please decrease the number of HTHs and/or the number of MB used by each HTHs.[!ENDERROR!]
    [!ENDIF!]
    [!IF "num:i($MAX_RX_LONGMB_COUNT) > 1700"!][!//
        [!ERROR!]The hardware platform does not include enough long (64B) message buffers in order to service all configured HRHs. Please decrease the number of HRHs and/or the number of long MB used by each HRHs.[!ENDERROR!]
    [!ENDIF!]
    [!IF "num:i($MAX_RX_SHORTMB_COUNT) > 2396"!][!//
        [!ERROR!]The hardware platform does not include enough short (8B) message buffers in order to service all configured HRHs. Please decrease the number of HRHs and/or the number of short MB used by each HRHs.[!ENDERROR!]
    [!ENDIF!]
[!ENDSELECT!]

/*==================================================================================================*/
/**
* @brief          Configuration of Bcan controller
* @details        Configuration of Bcan controller
*
*/
[!SELECT "CanConfigSet"!]
    [!INDENT "0"!]
    [!VAR "CONFIGURED_CONTROLLERS_COUNT" = "num:i(0)"!]
    [!LOOP "CanController/*"!]
        [!IF "CanControllerActivation = 'true'"!]
            [!VAR "CONFIGURED_CONTROLLERS_COUNT"="num:i($CONFIGURED_CONTROLLERS_COUNT) + 1"!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!LOOP "CanController/*"!]
        [!VAR "CanClockSrc"="0"!]
        [!IF "(node:exists(./CanCpuClockRef)) = 'true'"!]
            [!VAR "CanClockSrc" = "node:ref(./CanCpuClockRef)/McuClockReferencePointFrequency"!]
        [!ELSE!]
            [!VAR "CanClockSrc" = "num:i(40000000)"!] [!/* Default Can Clock value 40 Mhz */!]
        [!ENDIF!]
        [!VAR "MASK_COUNT2"="num:i(count(CanControllerBaudrateConfig/*))"!]
        [!VAR "END_COMMA2"="0"!]
        static const Can_43_LLCE_ControllerBaudrateConfigType ControllerBaudrateCfgSet_PB_[!"CanControllerId"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][CAN_43_LLCE_MAX_BAUDRATE_FC_[!"substring-after(CanHwChannel,'BCAN_')"!]_[!"@index"!]] =
        {
        [!LOOP "CanControllerBaudrateConfig/*"!]
            [!WS "4"!]{
            [!CALL "GenerateBaudrate"!]
            #if (CAN_43_LLCE_SET_BAUDRATE_API == STD_ON)
            [!WS "8"!](uint16)[!"CanControllerBaudRateConfigID"!]
            #endif
            [!WS "4"!]}
            [!VAR "END_COMMA2"="$END_COMMA2 + 1"!]
            [!IF "$END_COMMA2 < $MASK_COUNT2"!]
                ,
            [!ENDIF!]
            [!CR!]
        [!ENDLOOP!]
        };
    [!ENDLOOP!]
    [!ENDINDENT!]
[!ENDSELECT!]

/*==================================================================================================*/
/**
* @brief          LLCE Per-channel Init 
* @details        Information needed to initialize each LLCE channel
*
*/

[!IF "$CanEcucPartitionRefCount = 0"!][!// No CAN EcucPartition References
static const Llce_Can_InitCmdType ControllerInit[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][LLCE_CAN_CONFIG_MAXCTRL_COUNT] =
{
[!CALL "GenerateChannelInit"!]
};
[!ELSE!][!//
    [!LOOP "CanGeneral/CanEcucPartitionRef/*"!]
        [!VAR "crtEcucPartitionPath" = "node:value(.)"!]
        [!VAR "CanEcucPartitionName" = "substring-after(substring-after($crtEcucPartitionPath, 'EcuC/EcuC/'), '/')"!]
static const Llce_Can_InitCmdType ControllerInit_[!"$CanEcucPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][LLCE_CAN_CONFIG_MAXCTRL_COUNT] =
{   
        [!SELECT "../../.."!]
[!CALL "GenerateChannelInit", "CanEcuCPartitionPath" = "$crtEcucPartitionPath"!]
};
        [!ENDSELECT!]

    [!ENDLOOP!]
[!ENDIF!]

/*==================================================================================================*/
/**
* @brief          Description of individual Bcan controllers on chip
* @details        Description of individual Bcan controllers on chip
*
*/

[!SELECT "CanConfigSet"!]
    [!WS "0"!]static const Can_43_LLCE_ControllerDescriptorType ControllerDescriptors_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][CAN_43_LLCE_MAXCTRL_CONFIGURED] =
    [!WS "0"!]{
    [!VAR "MASK_COUNT4"="num:i(count(CanController/*))"!]
    [!VAR "END_COMMA4"="0"!]
    [!VAR "CanGeneralPath" = "as:path(../CanGeneral, true())"!]
    [!LOOP "node:order(CanController/*,'node:value(CanControllerId)')"!]
        [!WS "4"!]/* ControllerDescriptor of CanController_[!"node:value(CanControllerId)"!]*/
        [!WS "4"!]{
                    [!INDENT "8"!]
                    [!IF "CanControllerActivation = 'true'"!]
                        /* No. of BaudRate configured for current controller - u8MaxBaudRateCount */
                        (uint8)[!"num:i(count(CanControllerBaudrateConfig/*))"!]U,
                        [!IF "not(contains(node:path(node:ref(CanControllerDefaultBaudrate)),node:path(CanControllerBaudrateConfig)))"!]
                            [!ERROR!]
                                Please select CanControllerDefaultBaudrate from the "[!"substring-after(node:path(CanControllerBaudrateConfig),'ELEMENTS/')"!]" container.
                            [!ENDERROR!]
                        [!ENDIF!]
                        /* Default BaudRate configured for current controller - u8DefaultBaudRateIndex */
                        (uint8)[!"num:i(node:ref(CanControllerDefaultBaudrate)/@index)"!]U,
                        /* pControllerBaudrateConfigsPtr - pControllerBaudrateConfigsPtr*/
                        ControllerBaudrateCfgSet_PB_[!"CanControllerId"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
                        /* u32CoreId */ 
                        [!IF "node:exists(./CanControllerEcucPartitionRef)"!]
                            [!SELECT "./CanControllerEcucPartitionRef"!]
                            [!CALL "GetCoreIdOfEcucPartition"!],[!CR!]
                            [!ENDSELECT!] 
                        [!ELSE!]        
                            0xFFFFFFFFU, /* No partition selected */
                        [!ENDIF!]
                        /* Can Controller Offset on chip: Can_A=offset 0, Can_B=offset 1, .. -u8ControllerOffset */
                        (uint8)[!"substring-after(CanHwChannel,'BCAN_')"!]
                    [!ELSE!]
                        /* No. of BaudRate configured for current controller - u8MaxBaudRateCount */
                        (uint8)0U,
                        /* Default BaudRate configured for current controller */
                        (uint8)0U,
                        /* pControllerBaudrateConfigsPtr */
                        ControllerBaudrateCfgSet_PB_[!"CanControllerId"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
                        /* u32CoreId */ 
                        [!IF "node:exists(./CanControllerEcucPartitionRef)"!]
                            [!SELECT "./CanControllerEcucPartitionRef"!]
                            [!CALL "GetCoreIdOfEcucPartition"!],[!CR!]
                            [!ENDSELECT!] 
                        [!ELSE!]        
                            0xFFFFFFFFU, /* No partition selected */
                        [!ENDIF!]
                        /* Can Controller Offset on chip: Can_A=offset 0, Can_B=offset 1, .. -u8ControllerOffset */
                        (uint8)LLCE_NULL_OFFSET_U8
                    [!ENDIF!]
                   [!ENDINDENT!]
        [!WS "4"!]}[!//
        [!VAR "END_COMMA4"="$END_COMMA4 + 1"!][!//
        [!IF "$END_COMMA4 < $MASK_COUNT4"!][!//
            [!WS "0"!], /* ControllerDescriptors CanController_[!"node:value(CanControllerId)"!] end */
        [!ENDIF!]
        [!CR!]
    [!ENDLOOP!]
    [!WS "0"!]};
[!ENDSELECT!]


[!SELECT "CanConfigSet"!]
    [!WS "0"!]static const Can_43_LLCE_HwControllerDescriptorType HwControllerDescriptors_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][LLCE_CAN_CONFIG_MAXCTRL_COUNT] =
    [!WS "0"!]{
    [!VAR "MASK_COUNT4"="15"!]
    [!VAR "END_COMMA4"="0"!]
    [!VAR "CanGeneralPath" = "as:path(../CanGeneral, true())"!]
    [!FOR "i" = "0" TO "$MASK_COUNT4"!][!//
        [!VAR "HwObjFound"="'false'"!]
        [!WS "4"!]/* ControllerDescriptor of HwCanController_[!"$i"!]*/
        [!WS "4"!]{
        [!LOOP "node:order(CanController/*,'node:value(CanControllerId)')"!][!//
            [!IF "substring-after(./CanHwChannel,'BCAN_') = $i "!]
                            [!INDENT "8"!]
                            [!IF "CanControllerActivation = 'true'"!]
                                /* ===== Controller Options for the driver ===== */
                                (uint32)(
                                [!IF "CanRxProcessing = 'INTERRUPT' or CanRxProcessing = 'MIXED'"!]
                                    LLCE_CAN_CONTROLLERCONFIG_RXINT_EN_U32 | /* Rx select by interrupt */
                                [!ELSE!]
                                    /* RxPoll Enabled */
                                [!ENDIF!]
                                [!IF "CanTxProcessing = 'INTERRUPT' or CanTxProcessing = 'MIXED'"!]
                                    LLCE_CAN_CONTROLLERCONFIG_TXINT_EN_U32 | /* Tx select by interrupt */
                                [!ELSE!]
                                    /* TxPoll Enabled */
                                [!ENDIF!]
                                [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                                    LLCE_CAN_CONTROLLERCONFIG_BOINT_EN_U32 | /* BusOff select by interrupt */
                                [!ELSE!]
                                    /* BusOffPoll Enabled */
                                [!ENDIF!]
                                    0U [!/*dummy value, to avoid checks for '|' on each macro definition*/!]
                                ),
                                /* Can Controller ID in CanIf */
                                [!VAR "CanControllerPath" = "as:path(., true())"!]
                                [!VAR "AbstCanIfControllerID" = "0"!]
                                [!SELECT "as:modconf('CanIf')[1]"!]
                                    [!VAR "CanCanIfMatchCounter" = "0"!]
                                    [!LOOP "./CanIfCtrlDrvCfg/*"!]
                                        [!IF "node:value(./CanIfCtrlDrvNameRef) = $CanGeneralPath"!]
                                            [!VAR "CanCanIfMatchCounter" = "$CanCanIfMatchCounter + 1"!]
                                        [!ENDIF!]
                                        [!IF "$CanCanIfMatchCounter = 1"!]
                                            [!LOOP "./CanIfCtrlCfg/*"!]
                                                [!IF "node:value(./CanIfCtrlCanCtrlRef) = $CanControllerPath"!]
                                                    [!VAR "AbstCanIfControllerID" = "node:value(./CanIfCtrlId)"!]
                                                [!ENDIF!]
                                            [!ENDLOOP!]
                                        [!ENDIF!]
                                    [!ENDLOOP!]
                                [!ENDSELECT!]
                                    (uint8)[!"num:i($AbstCanIfControllerID)"!]U,
                                    [!CALL "GetRWDestInterfaceFromCtrl"!] /**< LLCE FIFO Interface used for interrupt processing */
                            [!ELSE!]
                                /* ===== Controller Options for the driver ===== */
                                (uint32)(0U),
                                /* Can Controller ID in CanIf */
                                (uint8)LLCE_NULL_OFFSET_U8,
                                /**< LLCE FIFO Interface ID used for interrupt processing of RX/ACK events. */
                                (uint8)LLCE_NULL_OFFSET_U8
                            [!ENDIF!]
                            [!VAR "HwObjFound"="'true'"!]
                            [!BREAK!]
                        [!ENDINDENT!]
            [!ENDIF!]
        [!ENDLOOP!]
        [!IF "$HwObjFound = 'false'"!][!//
            /* ===== Controller Options for the driver ===== */
            (uint32)(0U),
            /* Can Controller ID in CanIf */
            (uint8)LLCE_NULL_OFFSET_U8,
            /**< LLCE FIFO Interface ID used for interrupt processing of RX/ACK events. */
            (uint8)LLCE_NULL_OFFSET_U8
        [!ENDIF!]
        [!WS "4"!]}[!//
        [!IF "$i < $MASK_COUNT4"!][!//
            [!WS "0"!], /* ControllerDescriptors HwCanController_[!"$i"!] end */
        [!ENDIF!]
        [!CR!]
    [!ENDFOR!]
    [!WS "0"!]};
[!ENDSELECT!]


[!SELECT "CanConfigSet"!]
[!IF "$CustomProcessingFlag='true'"!]
static const uint32 CanFilterId2CustomIdx[[!"num:i($HRHcount)"!]] =
{
    [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
        [!IF "(CanObjectType = 'RECEIVE')"!]
            [!IF "node:exists(CanAdvancedFeature)"!]
                [!SELECT "node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)"!]
                    [!IF "CustomProcessingEnable = 'true'"!]
                        [!WS "4"!](uint32)[!"num:i(CustomProcessingIndex)"!]U,
                    [!ELSE!]
                        [!WS "4"!](uint32)0U, /* No custom index attached */
                    [!ENDIF!]
                [!ENDSELECT!]
            [!ELSE!]
                [!WS "4"!](uint32)0U, /* No custom index attached */
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
};
[!ENDIF!]
[!//
[!//
[!IF "node:exists(../CanGeneral/CanAuxFilterEnable)"!]
[!IF "node:value(../CanGeneral/CanAuxFilterEnable) = 'true'"!]
[!FOR "ctrl" = "0" TO "15"!] 
    [!IF "text:split($GLOBAL_AUX_RX_FILTERCOUNT_LIST)[num:i($ctrl+1)] > 0"!]
        [!VAR "comma_count" = "text:split($GLOBAL_AUX_RX_FILTERCOUNT_LIST)[num:i($ctrl+1)]"!]
        [!VAR "filter_count" = "num:i(0)"!]
        [!WS "0"!]static Llce_Can_AuxFilterType Llce_AuxRx_Filters_Ctrl[!"$ctrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!] [[!"text:split($GLOBAL_AUX_RX_FILTERCOUNT_LIST)[num:i($ctrl+1)]"!]] =
        [!WS "0"!]{
        [!LOOP "CanAuxFilter/*"!]
            [!IF "substring-after(node:ref(./CanControllerRef)/CanHwChannel,'BCAN_') = $ctrl"!]
                [!WS "2"!]{ /* Auxilliary filter [!"num:i($filter_count)"!] for BCAN_[!"$ctrl"!] */
                    [!INDENT "4"!] 
                    [!VAR "filter_count" = "$filter_count + num:i(1)"!]
                    [!IF "Filter_Type = 'RANGE'"!]
                        [!IF "num:i(./RangeEnd) > 2047"!]
                            (Can_IdType)([!"num:i(./RangeEnd)"!]U | LLCE_CAN_MB_IDE_U32), /* uIdMask = RangeEnd */
                        [!ELSE!]
                            (Can_IdType)[!"num:i(./RangeEnd)"!], /* uIdMask = RangeEnd */
                        [!ENDIF!]
                        [!IF "num:i(./RangeStart) > 2047"!]
                            (Can_IdType)([!"num:i(./RangeStart)"!]U | LLCE_CAN_MB_IDE_U32), /* MessageId = RangeStart*/
                        [!ELSE!]
                            (Can_IdType)[!"num:i(./RangeStart)"!], /* MessageId = RangeStart */
                        [!ENDIF!]                
                    [!ELSE!]
                        [!IF "(Filter_Type = 'EXACT_MATCH')"!]
                            (Can_IdType)((CAN_43_LLCE_MAX_IDMASK 
                        [!ELSE!]
                            (Can_IdType)((([!"num:inttohex(./CanHwFilterMask)"!]U & CAN_43_LLCE_MAX_IDMASK) [!//
                        [!ENDIF!][!//
                        | LLCE_CAN_MB_RTR_U32)[!//
                        [!IF "CanIdType != 'MIXED'"!] |[!WS "1"!] [!ELSE!] & ~[!ENDIF!] LLCE_CAN_MB_IDE_U32),  /* uIdMask */
                            (Can_IdType)(([!"num:inttohex(./CanHwFilterCode)"!]U & CAN_43_LLCE_MAX_IDMASK)[!IF "CanIdType = 'EXTENDED'"!] | LLCE_CAN_MB_IDE_U32[!ENDIF!]),   /* MessageId */
                    [!ENDIF!]
                    (uint16_t)[!"num:inttohex(./AuxSearchResult)"!], /* Auxilliary Search Result */
                    [!IF "Filter_Type = 'RANGE'"!]
                        LLCE_CAN_ENTRY_CFG_RANGED  /* Filter type */
                    [!ELSE!] 
                        [!IF "Filter_Type = 'MASK'"!]
                            LLCE_CAN_ENTRY_CFG_MASKED  /* Filter type */
                        [!ELSE!]
                            LLCE_CAN_ENTRY_EXACT_MATCH  /* Filter type */
                        [!ENDIF!] 
                    [!ENDIF!]
                    [!ENDINDENT!]
                    [!WS "2"!]}[!//
                    [!IF "num:i($comma_count) > 1"!],
                    [!ELSE!]

                    [!ENDIF!] 
                    [!VAR "comma_count" = "$comma_count - num:i(1)"!]
            [!ENDIF!]
        [!ENDLOOP!]
        [!WS "0"!]};

    [!ENDIF!]
[!ENDFOR!]

[!VAR "AUX_FILTERS_COUNT" = "num:i(count(CanAuxFilter/*))"!]
[!IF "$AUX_FILTERS_COUNT != num:i(0)"!]
/* Array containing maximum number of auxilliary filters per hardware controller */
static uint16 Llce_MaxAuxilliaryFilterCount[LLCE_CAN_CONFIG_MAXCTRL_COUNT] =
{[!//
[!FOR "i" = "0" TO "15"!] 
    [!WS "4"!](uint16)[!"text:split($GLOBAL_AUX_RX_FILTERCOUNT_LIST)[num:i($i+1)]"!]U[!//
    [!IF "$i < 15"!],
    [!ENDIF!]
[!ENDFOR!]
};

/* List of auxilliary filter arrays */
[!IF "$CanEcucPartitionRefCount = 0"!][!// No CAN EcucPartition References - dump filter count list
static Llce_Can_AuxFilterType * Llce_AuxRx_Filters_List[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][LLCE_CAN_CONFIG_MAXCTRL_COUNT] =
{ 
    [!FOR "crtCtrl" = "0" TO "15"!] 
        [!IF "$crtCtrl > 0"!],
        [!ENDIF!]
        [!IF "text:split($GLOBAL_AUX_RX_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
    Llce_AuxRx_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][!//
        [!ELSE!][!//
    NULL_PTR /* No filters for channel [!"$crtCtrl"!] */[!//
        [!ENDIF!]
    [!ENDFOR!]

};
[!ELSE!][!//
    [!LOOP "../CanGeneral/CanEcucPartitionRef/*"!]
        [!VAR "crtEcucPartitionPath" = "node:value(.)"!]
        [!VAR "CanEcucPartitionName" = "substring-after(substring-after($crtEcucPartitionPath, 'EcuC/EcuC/'), '/')"!]
static Llce_Can_AuxFilterType * Llce_AuxRx_Filters_List_[!"$CanEcucPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][LLCE_CAN_CONFIG_MAXCTRL_COUNT] =
{ 
    [!FOR "crtCtrl" = "0" TO "15"!][!//
        [!IF "$crtCtrl > 0"!],
        [!ENDIF!][!//
        [!IF "text:split($GLOBAL_AUX_RX_FILTERCOUNT_LIST)[num:i($crtCtrl+1)] > 0"!]
            [!LOOP "node:order(../../../CanConfigSet/CanController/*,'node:value(CanControllerId)')"!][!//
                [!IF "substring-after(./CanHwChannel,'BCAN_') = $crtCtrl"!][!//
                    [!IF "node:exists(./CanControllerEcucPartitionRef) and (node:value(./CanControllerEcucPartitionRef) = $crtEcucPartitionPath)"!][!//
Llce_AuxRx_Filters_Ctrl[!"$crtCtrl"!]_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!][!//
                    [!ELSE!][!//
NULL_PTR /* Channel [!"$crtCtrl"!] not in current partition*/[!//
                    [!ENDIF!]
                [!ENDIF!]
            [!ENDLOOP!]
        [!ELSE!][!//
NULL_PTR /* No aux filters for channel [!"$crtCtrl"!] */[!//
        [!ENDIF!]
    [!ENDFOR!]

};

    [!ENDLOOP!]
[!ENDIF!][!// $CanEcucPartitionRefCount = 0
[!ENDIF!][!// $AUX_FILTERS_COUNT != num:i(0)
[!ENDIF!][!// node:exists(../CanGeneral/CanAuxFilterEnable)
[!ENDIF!][!// node:value(../CanGeneral/CanAuxFilterEnable) = 'true'
[!ENDSELECT!]
/*==================================================================================================*/
/**
* @brief          Top level structure containing all Can driver configurations
* @details        Top level structure containing all Can driver configurations
*
*/[!//
[!// To be called with CanEcucPartitionRef selected for multicore
[!MACRO "GenerateTopConfig", "crtEcuCPartitionName", "pbVariantName", "defaultController"!]
const Can_43_LLCE_ConfigType Can_43_LLCE_Config[!"$pbVariantName"!][!"$crtEcuCPartitionName"!] =
[!WS "0"!]{
[!INDENT "4"!]
[!SELECT "as:modconf('Can')[CommonPublishedInformation/VendorApiInfix = 'LLCE']/CanGeneral"!][!// select CanGeneral even in multicore
[!IF "$crtEcuCPartitionName = ''"!][!VAR "hostInterface" = "node:value(HostInterface)"!][!ENDIF!][!// save this value for outside the select
    &PlatformInitConfig[!"$crtEcuCPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    ControllerInit[!"$crtEcuCPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    Llce_Rx_Filters_List[!"$crtEcuCPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    Llce_RxAf_Filters_List[!"$crtEcuCPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    [!IF "node:exists(CanAuxFilterEnable) and ($AUX_FILTERS_COUNT != num:i(0)) and (CanAuxFilterEnable = 'true')"!]
    Llce_AuxRx_Filters_List[!"$crtEcuCPartitionName"!][!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    Llce_MaxAuxilliaryFilterCount,
    [!ELSE!]
    NULL_PTR, /* There are no filters configured for the second rxlut */ 
    NULL_PTR,
    [!ENDIF!]
    MessageBufferConfigs_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    ControllerDescriptors_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    HwControllerDescriptors_PB[!IF "var:defined('postBuildVariant')"!]_[!"$postBuildVariant"!][!ENDIF!],
    [!IF "$CustomProcessingFlag = 'true'"!]
    CanFilterId2CustomIdx,
    [!ELSE!]
    NULL_PTR, /* No custom processing defined for any HRH */
    [!ENDIF!]
    [!IF "node:exists(CanLlceHeadlessModeUsed) and (node:value(CanLlceHeadlessModeUsed) = 'true')"!]
        [!IF "not(node:exists(CanLlceEnableHeadlessMode) and (node:value(CanLlceEnableHeadlessMode) = 'true'))"!]
            [!ERROR "To enable headless mode for this variant, also enable the global option"!]
        [!ENDIF!]
    (boolean)TRUE, /* LLCE started in Headless Mode */
    [!ELSE!]
    (boolean)FALSE, /* LLCE started normally */
    [!ENDIF!]
[!ENDSELECT!]
    [!IF "$crtEcuCPartitionName != ''"!][!CALL "GetCoreIdOfEcucPartition"!],[!ELSE!]0xFFFFFFFFU, /* No partition selected */[!ENDIF!][!CR!] 
    [!IF "$crtEcuCPartitionName != ''"!]LLCE_CAN_HIF[!"@index"!],[!ELSE!][!"$hostInterface"!],[!ENDIF!] /* LLCE HIF */ 
    [!"num:i($defaultController)"!]U /* Default controller */    
[!ENDINDENT!]
};
[!ENDMACRO!]

[!SELECT "CanConfigSet"!]
[!VAR "PBname" = "''"!]
[!VAR "crtDefaultController" = "0"!]
[!IF "((../IMPLEMENTATION_CONFIG_VARIANT = 'VariantPostBuild') or (variant:size() > 1))"!][!// VariantPostBuild or more than 1 configured variant
    [!IF "var:defined('postBuildVariant')"!]
        [!VAR "PBname" = "concat('_', $postBuildVariant)"!]
    [!ENDIF!]
[!ENDIF!]
[!//
[!IF "$CanEcucPartitionRefCount = 0"!][!// No CAN EcucPartition References
    [!LOOP "node:order(CanController/*,'node:value(CanControllerId)')"!][!//
        [!IF "CanControllerActivation = 'true'"!]
        [!VAR "crtDefaultController" = "node:value(CanControllerId)"!]
            [!BREAK!]
        [!ENDIF!]
    [!ENDLOOP!]    
    [!CALL "GenerateTopConfig", "pbVariantName" = "$PBname", "defaultController" = "$crtDefaultController"!]
[!ELSE!][!//
    [!LOOP "../CanGeneral/CanEcucPartitionRef/*"!]
        [!VAR "CanEcucPartitionName" = "concat('_', substring-after(substring-after(., 'EcuC/EcuC/'), '/'))"!]
        [!VAR "crtEcucPartitionPath" = "node:value(.)"!]
        [!LOOP "node:order(../../../CanConfigSet/CanController/*,'node:value(CanControllerId)')"!][!//
            [!IF "CanControllerActivation = 'true' and node:exists(./CanControllerEcucPartitionRef) and (node:value(./CanControllerEcucPartitionRef) = $crtEcucPartitionPath)"!][!//
                [!VAR "crtDefaultController" = "node:value(CanControllerId)"!]
                [!BREAK!]
            [!ENDIF!]
        [!ENDLOOP!]    
        [!CALL "GenerateTopConfig", "pbVariantName" = "$PBname", "crtEcuCPartitionName" = "$CanEcucPartitionName", "defaultController" = "$crtDefaultController"!]
    [!ENDLOOP!]
[!ENDIF!]
[!ENDSELECT!]

[!// Special case for PreCompile with multiple partitions
[!IF "(./IMPLEMENTATION_CONFIG_VARIANT != 'VariantPostBuild') and (variant:size() <= 1)"!]
    [!IF "$CanEcucPartitionRefCount != 0"!][!// Existing CAN EcucPartition References
        [!SELECT "as:modconf('EcuC')[1]"!]
            [!VAR "MaxCoreIdConfig" = "num:i(count(./EcucHardware/*[1]/EcucCoreDefinition/*))"!]
        [!ENDSELECT!]
    [!INDENT "0"!]        
    const Can_43_LLCE_ConfigType * const [!WS!]Can_43_LLCE_Config[[!"$MaxCoreIdConfig"!]U] =
    {
        [!VAR "coreIdx" = "0"!]
        [!LOOP "node:order(as:modconf('EcuC')[1]/EcucHardware/*[1]/EcucCoreDefinition/*, './EcucCoreId')"!]
            [!VAR "OsAppPart" = "''"!]
            [!VAR "coreIdx" = "$coreIdx + 1"!]
            [!VAR "CoreId" = "node:value(./EcucCoreId)"!]
            [!VAR "CanPartShortName" = "''"!]
            [!VAR "CanPartMatchCounter" = "0"!]
            [!LOOP "as:modconf('Os')[1]/OsApplication/*"!]
                [!IF "$CoreId = node:value(node:ref(./OsApplicationCoreRef)/EcucCoreId)"!]
                    [!VAR "OsAppPart" = "node:value(./OsAppEcucPartitionRef)"!]
                [!ENDIF!]
            [!ENDLOOP!]
            [!LOOP "as:modconf('Can')[CommonPublishedInformation/VendorApiInfix = 'LLCE']/CanGeneral/CanEcucPartitionRef/*"!]
                [!IF "$OsAppPart = node:value(.)"!]
                    [!VAR "CanPartMatchCounter" = "$CanPartMatchCounter + 1"!]
                    [!VAR "CanPartShortName" = "substring-after(substring-after(., 'EcuC/EcuC/'), '/')"!]
                [!ENDIF!]
            [!ENDLOOP!]
            [!WS "4"!][!IF "$CanPartMatchCounter = 1"!]&Can_43_LLCE_Config_[!"$CanPartShortName"!] [!ELSE!] NULL_PTR[!ENDIF!][!IF "$coreIdx < $MaxCoreIdConfig"!],[!ENDIF!][!CR!]
        [!ENDLOOP!]
    };
    [!ENDINDENT!]        
    [!ENDIF!]
[!ENDIF!]


/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/

#define CAN_43_LLCE_STOP_SEC_CONFIG_DATA_UNSPECIFIED

#include "Can_43_LLCE_MemMap.h"

#ifdef __cplusplus
}
#endif

/** @} */
========== END FILE: generate_PB\src\Can_43_LLCE_PBcfg.c ==========

========== START FILE: generate_PC\Can_43_LLCE_VersionCheck_Inc.m ==========
[!NOCODE!][!//
/**
*   @file    Can_VersionCheck_Inc.m
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - version check macro.
*   @details Version checks.
*  
*   Project RTD AUTOSAR 4.4
*   Platform CORTEXM
*   Peripheral LLCE
*   Dependencies 
*
*   ARVersion 4.4.0
*   ARRevision ASR_REL_4_4_REV_0000
*   ARConfVariant
*   SWVersion 1.0.10
*   BuildVersion S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
==================================================================================================*/

[!/* avoid multiple inclusion */!]
[!IF "not(var:defined('CAN_VERSION_CHECK_INC_M'))"!]
[!VAR "CAN_VERSION_CHECK_INC_M"="'true'"!]

[!VAR "CAN_AR_RELEASE_MAJOR_VERSION_TEMPLATE"="4"!][!// 
[!VAR "CAN_AR_RELEASE_MINOR_VERSION_TEMPLATE"="4"!][!// 
[!VAR "CAN_AR_RELEASE_REVISION_VERSION_TEMPLATE"="0"!][!// 
[!VAR "CAN_SW_MAJOR_VERSION_TEMPLATE"="1"!][!//      
[!VAR "CAN_SW_MINOR_VERSION_TEMPLATE"="0"!][!//
[!VAR "CAN_SW_PATCH_VERSION_TEMPLATE"="10"!][!//      

[!SELECT "CommonPublishedInformation"!][!//
[!IF "not(num:i(ArReleaseMajorVersion) = num:i($CAN_AR_RELEASE_MAJOR_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "AUTOSAR major version number of the Basic Software Module Description file (Can.epd version [!"ArReleaseMajorVersion"!]) and the Code template file (Can_Cfg.h version [!"num:i($CAN_AR_RELEASE_MAJOR_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(ArReleaseMinorVersion) = num:i($CAN_AR_RELEASE_MINOR_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "AUTOSAR minor version number of the Basic Software Module Description file (Can.epd version [!"ArReleaseMinorVersion"!]) and the Code template file (Can_Cfg.h version [!"num:i($CAN_AR_RELEASE_MINOR_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(ArReleaseRevisionVersion) = num:i($CAN_AR_RELEASE_REVISION_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "AUTOSAR patch version number of the Basic Software Module Description file (Can.epd version [!"ArReleaseRevisionVersion"!]) and the Code template file (Can_Cfg.h version [!"num:i($CAN_AR_RELEASE_REVISION_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(SwMajorVersion) = num:i($CAN_SW_MAJOR_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "The software major number of the Basic Software Module Description file (Can.epd version [!"SwMajorVersion"!]) and the Code template file (Can_Cfg.h version [!"num:i($CAN_SW_MAJOR_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(SwMinorVersion) = num:i($CAN_SW_MINOR_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "The software minor number of the Basic Software Module Description file (Can.epd version [!"SwMinorVersion"!]) and the Code template file (Can_Cfg.h version [!"num:i($CAN_SW_MINOR_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(SwPatchVersion) = num:i($CAN_SW_PATCH_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "The software patch number of the Basic Software Module Description file (Can.epd version [!"SwPatchVersion"!]) and the Code template file (Can_Cfg.h version [!"num:i($CAN_SW_PATCH_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!ENDSELECT!][!//

[!ENDIF!][!// avoid multiple inclusion ENDIF

[!ENDNOCODE!][!//
========== END FILE: generate_PC\Can_43_LLCE_VersionCheck_Inc.m ==========

========== START FILE: generate_PC\Can_43_LLCE_VersionCheck_Src.m ==========
[!NOCODE!][!//
/**
*   @file    Can_VersionCheck_Src.m
*   @version 1.0.10
*    
*   @brief   AUTOSAR Can_43_LLCE - version check macro.
*   @details Version checks.
*  
*   Project RTD AUTOSAR 4.4
*   Platform CORTEXM
*   Peripheral LLCE
*   Dependencies 
*  
*   ARVersion 4.4.0
*   ARRevision ASR_REL_4_4_REV_0000
*   ARConfVariant
*   SWVersion 1.0.10
*   BuildVersion S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
*/
/*==================================================================================================
==================================================================================================*/

[!/* avoid multiple inclusion */!]
[!IF "not(var:defined('CAN_VERSION_CHECK_INC_M'))"!]
[!VAR "CAN_VERSION_CHECK_INC_M"="'true'"!]

[!VAR "CAN_AR_RELEASE_MAJOR_VERSION_TEMPLATE"="4"!][!// 
[!VAR "CAN_AR_RELEASE_MINOR_VERSION_TEMPLATE"="4"!][!// 
[!VAR "CAN_AR_RELEASE_REVISION_VERSION_TEMPLATE"="0"!][!// 
[!VAR "CAN_SW_MAJOR_VERSION_TEMPLATE"="1"!][!//      
[!VAR "CAN_SW_MINOR_VERSION_TEMPLATE"="0"!][!//
[!VAR "CAN_SW_PATCH_VERSION_TEMPLATE"="10"!][!//      

[!SELECT "CommonPublishedInformation"!][!//
[!IF "not(num:i(ArReleaseMajorVersion) = num:i($CAN_AR_RELEASE_MAJOR_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "AUTOSAR major version number of the Basic Software Module Description file (Can.epd version [!"ArReleaseMajorVersion"!]) and the Code template file (Can_Cfg.c version [!"num:i($CAN_AR_RELEASE_MAJOR_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(ArReleaseMinorVersion) = num:i($CAN_AR_RELEASE_MINOR_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "AUTOSAR minor version number of the Basic Software Module Description file (Can.epd version [!"ArReleaseMinorVersion"!]) and the Code template file (Can_Cfg.c version [!"num:i($CAN_AR_RELEASE_MINOR_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(ArReleaseRevisionVersion) = num:i($CAN_AR_RELEASE_REVISION_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "AUTOSAR patch version number of the Basic Software Module Description file (Can.epd version [!"ArReleaseRevisionVersion"!]) and the Code template file (Can_Cfg.c version [!"num:i($CAN_AR_RELEASE_REVISION_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(SwMajorVersion) = num:i($CAN_SW_MAJOR_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "The software major number of the Basic Software Module Description file (Can.epd version [!"SwMajorVersion"!]) and the Code template file (Can_Cfg.c version [!"num:i($CAN_SW_MAJOR_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(SwMinorVersion) = num:i($CAN_SW_MINOR_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "The software minor number of the Basic Software Module Description file (Can.epd version [!"SwMinorVersion"!]) and the Code template file (Can_Cfg.c version [!"num:i($CAN_SW_MINOR_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!IF "not(num:i(SwPatchVersion) = num:i($CAN_SW_PATCH_VERSION_TEMPLATE))"!]
    [!ERROR!]
        "The software patch number of the Basic Software Module Description file (Can.epd version [!"SwPatchVersion"!]) and the Code template file (Can_Cfg.c version [!"num:i($CAN_SW_PATCH_VERSION_TEMPLATE)"!]) are different"
    [!ENDERROR!]
[!ENDIF!]
[!ENDSELECT!][!//

[!ENDIF!][!// avoid multiple inclusion ENDIF

[!ENDNOCODE!][!//
========== END FILE: generate_PC\Can_43_LLCE_VersionCheck_Src.m ==========

========== START FILE: generate_PC\include\Can_43_LLCE_Cfg.h ==========
/**
*   @file    Can_43_LLCE_Cfg.h
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Configuration settings generated by user settings.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/
/*
@brief   (CAN023) The consistency of the configuration must be checked by the configuration tool(s).
@brief   (CAN022) The code configurator of the Can module is CAN controller specific.
         If the CAN controller is sited on-chip, the code generation tool for the Can module is Controller specific.
         If the CAN controller is an external device the generation tool must not be Controller specific.
@brief   (CAN024) The valid values that can be configured are hardware dependent.
         Therefore the rules and constraints can't be given in the standard.
         The configuration tool is responsible to do a static configuration checking, also regarding dependencies between modules (i.e. Port driver, MCU driver etc.)
*/
/*
* @file    Can_43_LLCE_Cfg.h
*/

#ifndef CAN_43_LLCE_CFG_H
#define CAN_43_LLCE_CFG_H

#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Std_Types.h"
#include "Soc_Ips.h"
#include "OsIf.h"

[!AUTOSPACING!]
[!INDENT "0"!]
[!IF "var:defined('postBuildVariant')"!]
    [!LOOP "variant:all()"!]
        #include "Can_43_LLCE_[!"."!]_PBcfg.h"
    [!ENDLOOP!]
[!ELSE!]
    #include "Can_43_LLCE_PBcfg.h"
[!ENDIF!]

[!NOCODE!][!//
[!INCLUDE "Can_43_LLCE_VersionCheck_Inc.m"!][!//
[!ENDNOCODE!][!//

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/*
* @file           Can_43_LLCE_Cfg.h
*/
#define CAN_43_LLCE_VENDOR_ID_CFG_H                     43
#define CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_CFG_H      4
#define CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_CFG_H      4
#define CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_CFG_H   0
#define CAN_43_LLCE_SW_MAJOR_VERSION_CFG_H              1
#define CAN_43_LLCE_SW_MINOR_VERSION_CFG_H              0
#define CAN_43_LLCE_SW_PATCH_VERSION_CFG_H              10

#ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
    /* Check if header file and Std_Types.h file are of the same Autosar version */
    #if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_CFG_H != STD_AR_RELEASE_MAJOR_VERSION) || \
         (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_CFG_H != STD_AR_RELEASE_MINOR_VERSION)    \
        )
        #error "AutoSar Version Numbers of Can_43_LLCE_Cfg.h and Std_Types.h are different"
    #endif

#endif

[!IF "var:defined('postBuildVariant')"!]
    [!LOOP "variant:all()"!]
        /* Check if source file and CAN_43_LLCE_.h configuration header file are of the same vendor */
        #if (CAN_43_LLCE_VENDOR_ID_[!"."!]_PBCFG_H != CAN_43_LLCE_VENDOR_ID_CFG_H)
            #error "CAN_43_LLCE_[!"."!]_PBcfg.h and CAN_43_LLCE_Cfg.h have different vendor IDs"
        #endif
         /* Check if header file and CAN_43_LLCE_.h configuration header file are of the same Autosar version */
        #if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_[!"."!]_PBCFG_H != CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_CFG_H) || \
         (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_[!"."!]_PBCFG_H != CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_CFG_H) || \
         (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_[!"."!]_PBCFG_H != CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_CFG_H))
        #error "AutoSar Version Numbers of CAN_43_LLCE_[!"."!]_PBcfg.h and CAN_43_LLCE_Cfg.h are different"
        #endif
        /* Check if header file and CAN_43_LLCE_.h configuration header file are of the same software version */
        #if ((CAN_43_LLCE_SW_MAJOR_VERSION_[!"."!]_PBCFG_H != CAN_43_LLCE_SW_MAJOR_VERSION_CFG_H) || \
         (CAN_43_LLCE_SW_MINOR_VERSION_[!"."!]_PBCFG_H != CAN_43_LLCE_SW_MINOR_VERSION_CFG_H) || \
         (CAN_43_LLCE_SW_PATCH_VERSION_[!"."!]_PBCFG_H != CAN_43_LLCE_SW_PATCH_VERSION_CFG_H))
        #error "Software Version Numbers of CAN_43_LLCE_[!"."!]_PBcfg.h and CAN_43_LLCE_Cfg.h are different"
        #endif
    [!ENDLOOP!]
[!ELSE!]
    /* Check if source file and CAN_43_LLCE_.h configuration header file are of the same vendor */
    #if (CAN_43_LLCE_VENDOR_ID_PBCFG_H != CAN_43_LLCE_VENDOR_ID_CFG_H)
     #error "CAN_43_LLCE_PBcfg.h and CAN_43_LLCE_Cfg.h have different vendor IDs"
    #endif
     /* Check if header file and CAN_43_LLCE_.h configuration header file are of the same Autosar version */
    #if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_PBCFG_H != CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_PBCFG_H != CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_PBCFG_H != CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_CFG_H))
    #error "AutoSar Version Numbers of CAN_43_LLCE_PBcfg.h and CAN_43_LLCE_Cfg.h are different"
    #endif
    /* Check if header file and CAN_43_LLCE_.h configuration header file are of the same software version */
    #if ((CAN_43_LLCE_SW_MAJOR_VERSION_PBCFG_H != CAN_43_LLCE_SW_MAJOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_SW_MINOR_VERSION_PBCFG_H != CAN_43_LLCE_SW_MINOR_VERSION_CFG_H) || \
     (CAN_43_LLCE_SW_PATCH_VERSION_PBCFG_H != CAN_43_LLCE_SW_PATCH_VERSION_CFG_H))
    #error "Software Version Numbers of CAN_43_LLCE_PBcfg.h and CAN_43_LLCE_Cfg.h are different"
    #endif
[!ENDIF!]


/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/
/**
* @brief          Enable support for MAC generation and verification.
* @details        Enable support for MAC generation and verification.
*
*/
[!// Loop on all Configuration Sets
[!SELECT "CanConfigSet"!][!//
    [!VAR "MAC_SUPPORT" = "num:i(0)"!][!//
    [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!][!//
    [!IF "CanObjectType = 'TRANSMIT'"!][!//
        [!IF "CanTxAddFrameMac = 'true'"!][!//
            [!VAR "MAC_SUPPORT"="$MAC_SUPPORT + 1"!][!//
        [!ENDIF!][!//
    [!ELSE!] [!// Receive object
        [!IF "node:exists(CanAdvancedFeature/CanAdvancedFeatureRef) and node:ref(CanAdvancedFeature/CanAdvancedFeatureRef)/AuthenticationFrameEnable = 'true'"!][!//
        [!VAR "MAC_SUPPORT"="$MAC_SUPPORT + 1"!]
        [!ENDIF!][!//
    [!ENDIF!][!//
    [!ENDLOOP!][!//
[!IF "num:i($MAC_SUPPORT) > 0"!][!//
#define CAN_43_LLCE_HSE_SUPPORT_ENABLE    (STD_ON)
[!ELSE!]
#define CAN_43_LLCE_HSE_SUPPORT_ENABLE    (STD_OFF)
[!ENDIF!]


[!VAR "AUX_FILTERS_COUNT" = "num:i(count(CanAuxFilter/*))"!]
[!VAR "GenerateCanAuxFilter" = "'false'"!]
[!IF "node:exists(../CanGeneral/CanAuxFilterEnable)"!]
    [!IF "($AUX_FILTERS_COUNT != num:i(0)) and (node:value(../CanGeneral/CanAuxFilterEnable) = 'true')"!]
        [!VAR "GenerateCanAuxFilter"="'true'"!]
    [!ENDIF!]
[!ENDIF!]

[!IF "$GenerateCanAuxFilter = 'true'"!]
#define RXLUT2_ENABLE  (STD_ON)
[!ELSE!]
#define RXLUT2_ENABLE  (STD_OFF) 
[!ENDIF!]
[!ENDSELECT!]




/**
* @brief          Implicit index value used by Full can hardware objects.
* @details        Implicit index value used by Full can hardware objects.
*
*/
#define CAN_43_LLCE_MAX_IDMASK    (Can_IdType)0x1FFFFFFFU

[!NOCODE!]
[!// Loop on all Configuration Sets
[!SELECT "CanConfigSet"!][!//
    [!VAR "ConfigSetIndex" = "0"!][!//
    [!LOOP "CanController/*"!][!//
    [!// Loop on all channels inside the same Configuration Set
        [!VAR "SavedIndex" = "CanControllerId"!][!//
        [!VAR "Name" = "@name"!][!//
        [!// Loop on all other Configuration Sets
        [!LOOP "../../../*[@index>$ConfigSetIndex]/CanController/*"!][!//
            [!IF "($Name = node:name(.))"!][!//
                [!IF "($SavedIndex != CanControllerId)"!][!//
                    [!// Error
                    [!ERROR!][!//
                        [!"$Name"!][!"'- Symbolic name for controller Ids can be repeated only if they have the same CanControllerId in each of the config set.'"!][!//
                    [!ENDERROR!][!//
                [!ENDIF!][!//
            [!ENDIF!][!//
        [!ENDLOOP!][!//     
    [!ENDLOOP!][!//
[!ENDSELECT!]
[!/* Check status of CanHwFilter and CanMainFunctionRWPeriodRef */!]
[!SELECT "CanConfigSet"!]
    [!LOOP "CanHardwareObject/*"!]
        [!IF "((((CanObjectType = 'TRANSMIT') and ((node:ref(CanControllerRef))/CanTxProcessing) = 'POLLING')  or
                ((CanObjectType = 'RECEIVE' ) and ((node:ref(CanControllerRef))/CanRxProcessing) = 'POLLING'))
                   and (not(node:refexists(CanMainFunctionRWPeriodRef))))"!]
            [!ERROR!]
            The "CanMainFunctionRWPeriodRef" must be enabled when user configure the Can controller operate in the Polling mode (both to transmission and reception)
            [!ENDERROR!]
        [!ENDIF!]
        [!IF "((CanObjectType = 'RECEIVE')) and (not(node:exists(CanHwFilter)))"!]
            [!ERROR!]
            The "CanHwFilter" of each HOH must be enabled when user configure HOH is receive.
            [!ENDERROR!]
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!]
[!ENDNOCODE!]
[!/* Check if two controllers have the same name in any ConfigSet */!]
[!VAR "OuterLoopCounter" = "0"!][!VAR "InnerLoopCounter" = "0"!]
[!LOOP "CanConfigSet/CanController/*"!]
    [!VAR "OuterLoopCounter" = "$OuterLoopCounter + 1"!]
    [!VAR "InnerLoopCounter" = "0"!]
    [!VAR "Matchcounter" = "0"!]
    [!VAR "Name" = "node:name(.)"!]
    [!LOOP "../../CanController/*"!]
        [!VAR "InnerLoopCounter" = "$InnerLoopCounter + 1"!]
        [!IF "$OuterLoopCounter >= $InnerLoopCounter"!]
            [!IF "($Name = node:name(.))"!]
                [!VAR "Matchcounter" = "$Matchcounter + 1"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$Matchcounter != 1"!]
        [!WARNING!] Some controllers have identical name. Should avoid this because of multiple generated DEFINEs with the same name![!ENDWARNING!]
    [!ENDIF!]
[!ENDLOOP!]

[!NOCODE!][!//
// Loop on all Configuration Sets to check if the symbolic names are duplicated between config sets
[!SELECT "CanConfigSet"!][!//
    [!VAR "ConfigSetIndex" = "0"!][!//
    // Loop on all channels inside the same Configuration Set
    [!LOOP "CanHardwareObject/*"!][!//
    [!VAR "SavedIndex" = "CanObjectId"!][!//
        [!VAR "Name" = "@name"!][!//
        // Loop on all other Configuration Sets
        [!LOOP "../../../*[@index>$ConfigSetIndex]/CanHardwareObject/*"!][!//
            [!IF "($Name = node:name(.))"!][!//
                [!IF "($SavedIndex != CanObjectId)"!][!//
                    // Error
                    [!ERROR!][!//
                        [!"$Name"!][!"'- Symbolic name for hardware object Ids can be repeated only if they have the same value for CanObjectId in each of the config set.'"!][!//
                    [!ENDERROR!][!//
                [!ENDIF!][!//
            [!ENDIF!][!//
        [!ENDLOOP!][!//     
    [!ENDLOOP!][!//
[!ENDSELECT!]
 
[!VAR "OuterLoopCounter" = "0"!][!VAR "InnerLoopCounter" = "0"!]
[!LOOP "CanConfigSet/CanHardwareObject/*"!]
    [!VAR "OuterLoopCounter" = "$OuterLoopCounter + 1"!]
    [!VAR "InnerLoopCounter" = "0"!]
    [!VAR "Matchcounter" = "0"!]
    [!VAR "Name" = "node:name(.)"!]
    [!LOOP "../../CanHardwareObject/*"!]
        [!VAR "InnerLoopCounter" = "$InnerLoopCounter + 1"!]
        [!IF "$OuterLoopCounter >= $InnerLoopCounter"!]
            [!IF "($Name = node:name(.))"!]
                [!VAR "Matchcounter" = "$Matchcounter + 1"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$Matchcounter != 1"!]
        [!WARNING!] Some MBs have identical name. Should avoid this because of multiple generated DEFINEs with the same name![!ENDWARNING!]
    [!ENDIF!]
[!ENDLOOP!]

[!SELECT "CanConfigSet"!]
    [!VAR "MaxObjectIdForReceiveHO" = "-1"!]
    [!LOOP "CanHardwareObject/*"!]
        [!IF "CanObjectType = 'RECEIVE'"!]
            [!IF "$MaxObjectIdForReceiveHO < CanObjectId"!]
                [!VAR "MaxObjectIdForReceiveHO" = "CanObjectId"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!LOOP "CanHardwareObject/*"!]
        [!IF "CanObjectType = 'TRANSMIT'"!]
            [!IF "$MaxObjectIdForReceiveHO >= CanObjectId"!]
                [!ERROR!]
                The HRH and HTH Ids are defined under two different name-spaces (Refer to CAN326).
                Example: HRH0-0, HRH1-1, HTH0-2, HTH1-3.
                The HRHs of all controllers are grouped before the HTHs of all controllers
                    (there must not be any HTH of any controller with an object ID lower than
                    that of any HRH configured for this driver).
                [!ENDERROR!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!]
[!ENDNOCODE!]


/*
* @brief          Symbolic names for CanObjectId
* @details        Symbolic names for CanObjectId maintained for compatibility with old testcases/applications 
*
*/
[!SELECT "CanConfigSet"!][!//
 [!LOOP "CanHardwareObject/*"!]
    [!IF "CanObjectType = 'RECEIVE'"!]
        #define [!WS "1"!][!"@name"!] [!WS "1"!][!"num:i(CanObjectId)"!]U /* RECEIVE object of Can Controller ID = [!"num:i(node:ref(CanControllerRef)/CanControllerId)"!] */
    [!ENDIF!]
[!ENDLOOP!]
[!ENDSELECT!]
[!SELECT "CanConfigSet"!][!//
[!LOOP "CanHardwareObject/*"!]
    [!IF "CanObjectType = 'TRANSMIT'"!]
        #define [!WS "1"!][!"@name"!] [!WS "1"!][!"num:i(CanObjectId)"!]U /* TRANSMIT object of Can Controller ID = [!"num:i(node:ref(CanControllerRef)/CanControllerId)"!] */
    [!ENDIF!]
[!ENDLOOP!]
[!ENDSELECT!]

/*
* @brief          Lpdu callout name
* @details        (CAN357_Conf) CanLPduReceiveCalloutFunction - This parameter sets the name of the LPDU callout.
*
*/
[!IF "node:exists(CanGeneral/CanLPduReceiveCalloutFunction) and (normalize-space(CanGeneral/CanLPduReceiveCalloutFunction) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_LPDU_NOTIFICATION_ENABLE  (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_LPDU_NOTIFICATION_ENABLE  (STD_OFF)
[!ENDIF!]

#define CAN_43_LLCE_LPDU_CALLOUT_EXTENSION [!WS "1"!][!IF "((node:exists(CanGeneral/LPDUCalloutExtension)) and (CanGeneral/LPDUCalloutExtension ='true'))"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

/*
* @brief          Callout function name for timestamp of received frames
*
*/
[!IF "node:exists(CanGeneral/RxTimestampNotification) and (normalize-space(CanGeneral/RxTimestampNotification) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_RX_TIMESTAMP  (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_RX_TIMESTAMP  (STD_OFF)
[!ENDIF!]

/*
* @brief          Callout function name for timestamp of frame confirmations
*
*/
[!IF "node:exists(CanGeneral/TxTimestampNotification) and (normalize-space(CanGeneral/TxTimestampNotification) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_ACK_TIMESTAMP  (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_ACK_TIMESTAMP  (STD_OFF)
[!ENDIF!]

/*
* @brief          Callback for frames received through customization filters
*
*/
[!IF "node:exists(CanGeneral/CanCustomRxFunction) and (normalize-space(CanGeneral/CanCustomRxFunction) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED  (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_CUSTOM_RX_CALLBACK_USED  (STD_OFF)
[!ENDIF!]

/*
* @brief          Callback for each frame sent to LLCE firmware through Can_Write
*
*/
[!IF "node:exists(CanGeneral/CanWriteCustomCallback) and (normalize-space(CanGeneral/CanWriteCustomCallback) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_CUSTOM_WRITE_CALLBACK_USED  (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_CUSTOM_WRITE_CALLBACK_USED  (STD_OFF)
[!ENDIF!]

/*
* @brief          Callback for each TX Confirmation received from LLCE firmware.
*
*/
[!IF "node:exists(CanGeneral/CanTxConfirmationCustomCallback) and (normalize-space(CanGeneral/CanTxConfirmationCustomCallback) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_CUSTOM_CONFIRMATION_CALLBACK  (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_CUSTOM_CONFIRMATION_CALLBACK  (STD_OFF)
[!ENDIF!]


/*
* @brief          Callout function name for reporting errors.
*
*/
[!IF "node:exists(CanConfigSet/CanErrorReporting/CanErrorNotif) and (normalize-space(CanConfigSet/CanErrorReporting/CanErrorNotif) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_ERROR_NOTIF_ENABLE  (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_ERROR_NOTIF_ENABLE  (STD_OFF)
[!ENDIF!]

/*
* @brief          Extended identifiers.
* @details        Extended identifiers.
                   - (STD_ON)  - if at least one extended identifier is used.
                   - (STD_OFF) - if no extended identifiers are used at all
                  If no extended identifiers are used then the IDs and MASKs can be stored in uint16 rather than uint32.
*
*/

#define CAN_43_LLCE_SET_BAUDRATE_API [!WS "1"!][!IF "((node:exists(CanGeneral/CanSetBaudrateApi)) and (CanGeneral/CanSetBaudrateApi ='true'))"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

#define CAN_LLCE_USE_HEADLESSMODE [!WS "1"!][!IF "((node:exists(CanGeneral/CanLlceEnableHeadlessMode)) and (CanGeneral/CanLlceEnableHeadlessMode ='true'))"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

/** Report controllers started without waiting to synchronise on bus */
#define CAN_43_LLCE_CONTROLLER_START_NOSYNC [!WS "1"!][!IF "((node:exists(CanGeneral/CanLlceControllerStartNoSync)) and (CanGeneral/CanLlceControllerStartNoSync ='true'))"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

/*
* @brief          Switches the Development Error Detection and Notification ON or OFF.
* @details        (CAN028) Call the Development Error Tracer when DET is switched on and the Can module detects an error.
                  (CAN082) The detection of development errors is configurable (ON / OFF) at pre- compile time.
                  The switch CanDevErrorDetect (see chapter 10) shall activate or deactivate the detection of all development errors.
*
*/
#define CAN_43_LLCE_DEV_ERROR_DETECT [!WS "1"!][!IF "CanGeneral/CanDevErrorDetect = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

/*
* @brief          Switches between user mode and supervisor mode.
* @details        Switches between user mode and supervisor mode. Some peripherals, eg. sema42 require supervisor mode.
*
*/

[!IF "CanGeneral/CanEnableUserModeSupport = 'true'"!]
#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
#error MCAL_ENABLE_USER_MODE_SUPPORT must be defined when driver is configured in user mode
#endif
#define CAN_LLCE_ENABLE_USER_MODE_SUPPORT
[!ENDIF!]

/*
* @brief          Support for version info API
* @details        Switches the Can_43_LLCE_GetVersionInfo() API ON or OFF.
*
*/
#define CAN_43_LLCE_VERSION_INFO_API [!WS "1"!][!IF "CanGeneral/CanVersionInfoApi = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

/*
* @brief          Instance # of the driver - used for Det_ReportError().
* @details        Instance # of the driver - used for Det_ReportError().
*
*/
#define CAN_43_LLCE_INSTANCE [!WS "1"!][!"num:i(CanGeneral/CanIndex)"!]U

/*
* @brief          Enables the reporting to AUTOSAR modules. (e.g. CanIf, Det)
* @details        It's used for compatibility with DS, which can operate in non-ASR mode. 
*
*/
#ifndef AUTOSAR_COMPATIBLE_MODE
#define AUTOSAR_COMPATIBLE_MODE   (STD_ON)
#endif


    
/**
*   @brief      The definition used for guarding GetCoreID/Multicore
*/
#define CAN_43_LLCE_MULTICORE_ENABLED[!WS "4"!][!IF "num:i(count(CanGeneral/CanEcucPartitionRef/*)) > 0"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/**
*   @brief      The definition represent for number of ECUC partition configured.
*/
[!NOCODE!]
    [!VAR "maxCoreDefConfig" = "num:i(1)"!]
    [!IF "CanGeneral/CanMulticoreSupport = 'true'"!]
        [!IF "node:exists(as:modconf('EcuC')[1]/EcucHardware/*/EcucCoreDefinition)"!]
            [!VAR "maxCoreDefConfig" = "num:i(count(as:modconf('EcuC')[1]/EcucHardware/*/EcucCoreDefinition/*))"!]
        [!ENDIF!]
    [!ENDIF!]
[!ENDNOCODE!]
#define CAN_43_LLCE_MAX_PARTITIONS[!WS "4"!][!"$maxCoreDefConfig"!]U

/*
* @brief          The define in order to check the trigger transmit feature is enabled or disabled.
* @details        The define in order to check the trigger transmit feature is enabled or disabled.
*
*/
[!IF "num:i(count(CanConfigSet/CanHardwareObject/*[CanTriggerTransmitEnable = 'true'])) > 0"!]
    #define CAN_43_LLCE_TRIGGER_TRANSMIT_EN (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_TRIGGER_TRANSMIT_EN (STD_OFF)
[!ENDIF!]

/*
* @brief          The define in order to check the dummy hrh feature is enabled or disabled.
* @details        The define in order to check the dummy hrh transmit feature is enabled or disabled.
*
*/
[!IF "num:i(count(CanConfigSet/CanHardwareObject/*[Dummy_HRH = 'true'])) > 0"!]
    #define CAN_43_LLCE_DUMMY_HRH_EN (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_DUMMY_HRH_EN (STD_OFF)
[!ENDIF!]

/*123 Calculate the maximum number of HRH and HTH amd MBs from all config sets */
[!SELECT "CanConfigSet"!]
    [!VAR "HrhCount"="0"!]
    [!VAR "HthCount"="0"!]
    [!VAR "RxMbCount"="0"!]
    [!VAR "TxMbCount"="0"!]
    [!VAR "Can_First_HTH_Index" = "0"!]
    [!VAR "Can_Check_ExistHTH" = "0"!]
    [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]  
        [!IF "CanObjectType = 'RECEIVE'"!]
            [!VAR "HrhCount"="$HrhCount + 1"!]  
            [!IF "node:exists(CanHwObjectCount)"!]
                [!VAR "RxMbCount"="$RxMbCount + node:value(CanHwObjectCount)"!] 
            [!ELSE!]
                [!VAR "RxMbCount"="$RxMbCount + 1"!] 
            [!ENDIF!]                
        [!ELSE!]
            [!VAR "HthCount"="$HthCount + 1"!] 
            [!IF "node:exists(CanHwObjectCount)"!]
                [!VAR "TxMbCount"="$TxMbCount + node:value(CanHwObjectCount)"!] 
            [!ELSE!]
                [!VAR "TxMbCount"="$TxMbCount + 1"!] 
            [!ENDIF!] 
            [!IF "$Can_Check_ExistHTH = 0"!]
                [!VAR "Can_First_HTH_Index" = "CanObjectId"!]
                [!VAR "Can_Check_ExistHTH" = "1"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]

/*
* @brief          Maximum number of HRHs configured.
*
*/
#define CAN_43_LLCE_MAXHRH_CONFIGURED [!WS "1"!]
        [!IF "num:i($HrhCount) > 0"!]
             [!"num:i($HrhCount)"!]U
        [!ELSE!]
             1U
        [!ENDIF!] 

 /*
* @brief          Maximum number of HTHs configured.
*
*/       
#define CAN_43_LLCE_MAXHTH_CONFIGURED [!WS "1"!]
        [!IF "num:i($HthCount) > 0"!]
             [!"num:i($HthCount)"!]U
        [!ELSE!]
             1U
        [!ENDIF!] 

 /*
* @brief          Maximum number of HOHs configured.
*
*/       
#define CAN_43_LLCE_MAXHOH_CONFIGURED [!WS "1"!]
        (CAN_43_LLCE_MAXHRH_CONFIGURED [!WS "1"!] + CAN_43_LLCE_MAXHTH_CONFIGURED [!WS "1"!])

/*
* @brief          The index of the first HTH configured
*
*/  
#define CAN_43_LLCE_FIRST_HTH_CONFIGURED [!WS "1"!]
        [!IF "$Can_Check_ExistHTH = 0"!][!/* Unless it has any HTH, Can_First_HTH_Index will be equal Max MB count  */!]
            [!"num:i($HrhCount + $HthCount)"!]U
        [!ELSE!]
            [!"num:i($Can_First_HTH_Index)"!]U
        [!ENDIF!]

/*
* @brief          Maximum number of RXMBs configured.
*
*/  
#define CAN_43_LLCE_MAXRXMB_CONFIGURED [!WS "1"!]
    [!IF "num:i($RxMbCount) > 0"!]
        [!"num:i($RxMbCount)"!]U
    [!ELSE!]
        1U
    [!ENDIF!]

/*
* @brief          Maximum number of TXMBs configured.
*
*/ 
#define CAN_43_LLCE_MAXTXMB_CONFIGURED [!WS "1"!]
    [!IF "num:i($TxMbCount) > 0"!]
        [!"num:i($TxMbCount)"!]U
    [!ELSE!]
        1U
    [!ENDIF!] 
[!ENDSELECT!]


/*
* @brief          Maximum No. of controllers Configured
* @details      Maximum No. of controllers Configured
*
*/
[!NOCODE!]
[!VAR "ctrl_no" = "0"!]
[!SELECT "CanConfigSet"!]
    [!VAR "ctrl_no" = "num:i(count(CanController/*))"!] 
[!ENDSELECT!]
[!ENDNOCODE!]
#define CAN_43_LLCE_MAXCTRL_CONFIGURED [!WS "1"!][!"$ctrl_no"!]U

/**
* @brief          Hardware events detected by an interrupt or by polling
* @details        (CAN099) The hardware events may be detected by an interrupt or by polling status flags of the hardware objects.
*                 The configuration possibilities regarding polling is hardware dependent (i.e. which events can be polled, which events need to be polled), and not restricted by this standard.
*                 (CAN007)It shall be possible to configure the driver such that no interrupts at all are used (complete polling).
*
*/
[!NOCODE!]
[!VAR "tx_pol_en"="0"!]
[!SELECT "CanConfigSet"!]
    [!LOOP "CanController/*"!]
        [!IF "CanTxProcessing = 'POLLING'"!]
            [!VAR "tx_pol_en" = "1"!]
            [!BREAK!]  
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$tx_pol_en = 0"!]
        [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
            [!IF "CanObjectType = 'TRANSMIT' and node:ref(CanControllerRef)/CanTxProcessing = 'MIXED' and CanHardwareObjectUsesPolling = 'true'"!]
                [!VAR "tx_pol_en" = "1"!]
                [!BREAK!]  
            [!ENDIF!]
        [!ENDLOOP!]
    [!ENDIF!]
[!ENDSELECT!]
[!ENDNOCODE!]

/*
* @brief          This macro enables Can_43_LLCE_MainFunction_Write() if at least one controller is set to process Tx in Polling Mode.
* @details        This macro enables Can_43_LLCE_MainFunction_Write() if at least one controller is set to process Tx in Polling Mode.
*
*/
#define CAN_43_LLCE_TXPOLL_SUPPORTED   [!IF "$tx_pol_en = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!]

[!NOCODE!]
[!VAR "rx_pol_en"="0"!]
[!SELECT "CanConfigSet"!]
    [!LOOP "CanController/*"!]
        [!IF "CanRxProcessing = 'POLLING'"!]
            [!VAR "rx_pol_en" = "1"!]
            [!BREAK!]  
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$rx_pol_en = 0"!]
        [!LOOP "node:order(CanHardwareObject/*,'node:value(CanObjectId)')"!]
            [!IF "CanObjectType = 'RECEIVE' and node:ref(CanControllerRef)/CanRxProcessing = 'MIXED' and CanHardwareObjectUsesPolling = 'true'"!]
                [!VAR "rx_pol_en" = "1"!]
                [!BREAK!]  
            [!ENDIF!]
        [!ENDLOOP!]
    [!ENDIF!]
[!ENDSELECT!]
[!ENDNOCODE!]

/*
* @brief          This macro enables Can_43_LLCE_MainFunction_Read() if at least one controller is set to process Rx in Polling Mode.
* @details        This macro enables Can_43_LLCE_MainFunction_Read() if at least one controller is set to process Rx in Polling Mode.
*
*/
#define CAN_43_LLCE_RXPOLL_SUPPORTED   [!IF "$rx_pol_en = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]


[!NOCODE!]
[!VAR "bo_pol_en"="0"!]
[!SELECT "CanConfigSet"!][!//
    [!LOOP "CanController/*"!]
        [!IF "CanBusoffProcessing = 'POLLING'"!]
            [!VAR "bo_pol_en" = "1"!]
            [!BREAK!]  
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!]
[!ENDNOCODE!]


/*
* @brief          This macro enables Can_43_LLCE_MainFunction_BusOff() if at least one controller is set to process BusOff in Polling Mode.
* @details        This macro enables Can_43_LLCE_MainFunction_BusOff() if at least one controller is set to process BusOff in Polling Mode.
*
*/
#define CAN_43_LLCE_BUSOFFPOLL_SUPPORTED   [!IF "$bo_pol_en = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]


/*
* @brief          This macro enables Can_43_LLCE_MainFunction_ErrorNotification() and is used for reporting errors configured in Polling Mode.
*
*/
[!SELECT "CanConfigSet"!]
[!SELECT "CanErrorReporting"!]
#define CAN_43_LLCE_ERRORNOTIFPOLL_SUPPORTED   [!IF "CanMainFunctionErrorEn = 'true'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]
[!ENDSELECT!]
[!ENDSELECT!]


/**
* @brief          Maximum number of baudrate configured.
* @details        Maximum number of baudrate configured.
*                 Controller Baudrates configured are in kbps
*
*/
[!SELECT "CanConfigSet"!][!//
    [!LOOP "CanController/*"!]
        [!VAR "HWChannel" = "CanHwChannel"!]
        #define CAN_43_LLCE_MAX_BAUDRATE_FC_[!"substring-after($HWChannel,'BCAN_')"!]_[!"@index"!]   [!WS "1"!][!"num:i(count(CanControllerBaudrateConfig/*))"!]U[!CR!]
    [!ENDLOOP!]
[!ENDSELECT!]

/* CAN FD INIT*/
[!NOCODE!]
[!VAR "CNT_FD" = "0"!]
[!SELECT "CanConfigSet"!][!//
    [!IF "node:exists(CanController/*/CanControllerBaudrateConfig/*/CanControllerFdBaudrateConfig)"!]
        [!VAR "CNT_FD" = "$CNT_FD+1"!] 
    [!ENDIF!]
[!ENDSELECT!]
[!ENDNOCODE!]
[!IF "$CNT_FD > 0"!]
    #define CAN_43_LLCE_FD_MODE_ENABLE (STD_ON)
    [!VAR "CNT_FD" = "0"!]
[!ELSE!]
    #define CAN_43_LLCE_FD_MODE_ENABLE (STD_OFF)
[!ENDIF!]

[!SELECT "CanGeneral"!]
/*
* @brief          (CAN113_Conf) Specifies the maximum time for blocking function until a timeout is detected. Unit in loops.
* @details        (CAN281) The Can module shall use the free running timer provided by the system service for timeout detection in case the hardware does not react
*                  in the expected time (hardware malfunction) to prevent endless loops.
*
*/
/* Time out value in uS */
#define CAN_43_LLCE_TIMEOUT_DURATION    [!"num:i(./CanTimeoutDuration * 1000000)"!]U

/* This will set the timer source for osif that will be used for timeout */
#define CAN_43_LLCE_SERVICE_TIMEOUT_TYPE    [!"CanTimeoutMethod"!]

[!ENDSELECT!]


/*
* @brief          Precompile Support.
* @details        (CAN220)VARIANT-PRE-COMPILE: Only pre-compile configuration parameters
*
*/
[!IF "IMPLEMENTATION_CONFIG_VARIANT = 'VariantPreCompile' and (variant:size()<=1)"!]
    #define CAN_43_LLCE_PRECOMPILE_SUPPORT (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_PRECOMPILE_SUPPORT (STD_OFF)
[!ENDIF!]

[!IF "node:exists(CanGeneral/CanMainFunctionBusoffPeriod)"!]
    /*
    * @brief          Periods for cyclic call of Main function
    * @details        (CAN355_Conf) CanMainFunctionBusoffPeriod - This parameter describes the period for cyclic call to Can_MainFunction_Busoff. Unit is seconds.
    *
    */
    #define CAN_43_LLCE_MAINFUNCTION_PERIOD_BUSOFF  [!WS "1"!][!SELECT "CanGeneral"!]([!"./CanMainFunctionBusoffPeriod"!]F)[!ENDSELECT!][!CR!]
[!ENDIF!]


/*
* @brief          Periods for cyclic call of Main function
* @details        (ECUC_Can_00484) This parameter describes the period for cyclic call to Can_43_LLCE_MainFunction_Read or Can_43_LLCE_MainFunction_Write depending on the referring item. Unit is seconds. 
*                 Different poll-cycles will be configurable if more than one CanMainFunctionPeriod is configured. 
*                 In this case multiple Can_43_LLCE_MainFunction_Read() or Can_43_LLCE_MainFunction_Write() will be provided by the CAN Driver module..
*
*/
[!VAR "MainFuncPeriodCount" = "num:i(count(CanGeneral/CanMainFunctionRWPeriods/*))"!]

[!IF "$MainFuncPeriodCount = 0 or $MainFuncPeriodCount = 1"!]
    #define CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ  (STD_OFF)
    #define CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE (STD_OFF)
[!ELSE!]
    [!VAR "MAX_CTRL_COUNT"="16"!]
    [!IF "$rx_pol_en = 1"!]
        #define CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ   (STD_ON)
    [!ELSE!]
        #define CAN_43_LLCE_MAINFUNCTION_MULTIPLE_READ  (STD_OFF)
    [!ENDIF!]
    [!IF "$tx_pol_en = 1"!]
        #define CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE   (STD_ON)
    [!ELSE!]
        #define CAN_43_LLCE_MAINFUNCTION_MULTIPLE_WRITE  (STD_OFF)
    [!ENDIF!]
    [!LOOP "CanGeneral/CanMainFunctionRWPeriods/*"!]
        [!VAR "rx_hoh_pol_en"="0"!]
        [!VAR "tx_hoh_pol_en"="0"!]
        [!VAR "CanMainFunctionPeriodName" = "@name"!]
        [!LOOP "../../../CanConfigSet/CanHardwareObject/*"!]
            [!IF "($rx_hoh_pol_en = 0) and ((node:ref(CanControllerRef)/CanRxProcessing = 'POLLING' or (node:ref(CanControllerRef)/CanRxProcessing = 'MIXED' and CanHardwareObjectUsesPolling = 'true')) and (CanObjectType = 'RECEIVE')) and ($CanMainFunctionPeriodName = node:ref(CanMainFunctionRWPeriodRef)/@name)"!]
                [!VAR "rx_hoh_pol_en" = "1"!]
            [!ENDIF!]
            [!IF "($tx_hoh_pol_en = 0) and ((node:ref(CanControllerRef)/CanTxProcessing = 'POLLING' or (node:ref(CanControllerRef)/CanTxProcessing = 'MIXED' and CanHardwareObjectUsesPolling = 'true')) and (CanObjectType = 'TRANSMIT')) and ($CanMainFunctionPeriodName = node:ref(CanMainFunctionRWPeriodRef)/@name)"!]
                [!VAR "tx_hoh_pol_en" = "1"!]    
            [!ENDIF!]
            [!IF "($rx_hoh_pol_en = 1) and ($tx_hoh_pol_en = 1)"!]
                [!BREAK!]    
            [!ENDIF!]
        [!ENDLOOP!]
        [!IF "$rx_hoh_pol_en = 1"!]
            #define Can_43_LLCE_MainFunction_Read_[!"@name"!]()       Can_43_LLCE_MainFunction_Multiple_Read([!"num:i(RxInterface - $MAX_CTRL_COUNT)"!]) [!// RxInterface translates into polling class by subtracting 16
        [!ENDIF!]
        [!IF "$tx_hoh_pol_en = 1"!]
            #define Can_43_LLCE_MainFunction_Write_[!"@name"!]()       Can_43_LLCE_MainFunction_Multiple_Write([!"num:i(AckInterface - $MAX_CTRL_COUNT)"!]) [!// AckInterface translates into polling class by subtracting 16
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDIF!]


/*
* @brief          Periods for cyclic call of Main function Mode
* @details        (CAN376_Conf) This parameter describes the period for cyclic call to Can_43_LLCE_MainFunction_Mode. Unit is seconds.
*
*/
#define CAN_43_LLCE_MAINFUNCTION_MODE_PERIOD   [!WS "1"!][!SELECT "CanGeneral"!]([!"./CanMainFunctionModePeriod"!]F)[!ENDSELECT!]


/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/
#define CAN_43_LLCE_CONFIG_EXT \
    [!INDENT "4"!]
    [!IF "var:defined('postBuildVariant') or (variant:size() > 1)"!]
        [!VAR "variantIndex"="0"!]
        [!VAR "variantNumber"="variant:size()"!]
        [!LOOP "variant:all()"!]
            [!VAR "variantIndex"="$variantIndex + 1"!]
            CAN_43_LLCE_CONFIG_[!"."!]_PB [!IF "$variantIndex < $variantNumber"!]\[!ENDIF!][!CR!]
        [!ENDLOOP!]
    [!ELSE!]
        CAN_43_LLCE_CONFIG_PB
    [!ENDIF!]
    [!ENDINDENT!]

/*
* @brief          Support for Special MB Abort API
* @details        Enables an additional API which adds support for aborting a message transmission.
*/
#define CAN_43_LLCE_API_ENABLE_ABORT_MB [!WS "1"!][!IF "(CanGeneral/CanApiEnableMbAbort = 'true')"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Support for single MB Abort  API
* @details        Extra information for AbortMB API which selects between single MB abort and aborting all the MBs corresponding to a specific HTH.
*/
#define CAN_43_LLCE_ABORT_ONLY_ONE_MB [!WS "1"!][!IF "(CanGeneral/CanAbortOnlyOneMB = 'true') and (CanGeneral/CanApiEnableMbAbort = 'true')"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Support for Manual BusOff recovery request API
* @details        Enables an additional API for requesting recovery from BusOff confinement state. 
*                 It is enabled when at least one controller configuration handles the recovery from bus-off manually.
*                 Not Autosar required.
*/
#define CAN_43_LLCE_API_MANUAL_BUSOFF_RECOVERY [!WS "1"!][!VAR "ManualBusOffRec" = "CanConfigSet/CanController/*/ManualBusOffRecovery = 'true'"!] [!// At least one controller has ManualBusOffRecovery enabled
[!IF "$ManualBusOffRec = 'true'"!] (STD_ON)[!ELSE!] (STD_OFF)[!ENDIF!]

/*
* @brief          Checks whether the BUSOFF_RECOVERY mode is ENABLED.
* @details        BUSOFF_RECOVERY is ENABLED when Manual or Auto Bus-off Recovery is set for any controller.
*                 Not Autosar required.
*/
[!SELECT "CanGeneral"!][!IF "node:exists(./BusOffNotification) and (normalize-space(./BusOffNotification) != 'NULL_PTR')"!]
    #define CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED     (STD_ON)
[!ELSE!]
    #define CAN_43_LLCE_BUSOFF_RECOVERY_ENABLED     (STD_OFF)
[!ENDIF!][!ENDSELECT!]

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/

/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/

[!ENDINDENT!]

#ifdef __cplusplus
}
#endif

#endif /* CAN_43_LLCE_CFG_H */

/** @} */
========== END FILE: generate_PC\include\Can_43_LLCE_Cfg.h ==========

========== START FILE: generate_PC\include\Can_43_LLCE_Externals.h ==========
/**
*   @file    Can_43_LLCE_Externals.h
*   @implements Can_Externals.h_Artifact
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface.
*   @details API header for CAN driver.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/
#ifndef CAN_43_LLCE_EXTERNALS_H
#define CAN_43_LLCE_EXTERNALS_H

#ifdef __cplusplus
extern "C"{
#endif

/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/

#define CAN_43_LLCE_EXTERNALS_VENDOR_ID_H                       43
#define CAN_43_LLCE_EXTERNALS_MODULE_ID_H                       80
#define CAN_43_LLCE_EXTERNALS_AR_RELEASE_MAJOR_VERSION_H        4
#define CAN_43_LLCE_EXTERNALS_AR_RELEASE_MINOR_VERSION_H        4
#define CAN_43_LLCE_EXTERNALS_AR_RELEASE_REVISION_VERSION_H     0
#define CAN_43_LLCE_EXTERNALS_SW_MAJOR_VERSION_H                1
#define CAN_43_LLCE_EXTERNALS_SW_MINOR_VERSION_H                0
#define CAN_43_LLCE_EXTERNALS_SW_PATCH_VERSION_H                10

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_CODE
#include "Can_43_LLCE_MemMap.h"
[!NOCODE!][!INDENT "0"!]
[!SELECT "CanGeneral"!]
    [!IF "node:exists(./CanLPduReceiveCalloutFunction)"!]
        [!IF "(normalize-space(./CanLPduReceiveCalloutFunction) != 'NULL_PTR')"!]
            [!CODE!]
            [!IF "((node:exists(./LPDUCalloutExtension)) and (./LPDUCalloutExtension ='true'))"!]
                boolean [!"normalize-space(./CanLPduReceiveCalloutFunction)"!](uint16 Hrh, Can_IdType CanId, uint8 CanDataLength, const uint8* CanSduPtr);[!CR!]
            [!ELSE!]
                boolean [!"normalize-space(./CanLPduReceiveCalloutFunction)"!](uint8 Hrh, Can_IdType CanId, uint8 CanDataLength, const uint8* CanSduPtr);[!CR!]
            [!ENDIF!]            
            #define Can_43_LLCE_LPduReceiveCalloutFunction     ([!"normalize-space(CanLPduReceiveCalloutFunction)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

    [!IF "node:exists(./RxTimestampNotification)"!]
        [!IF "(normalize-space(./RxTimestampNotification) != 'NULL_PTR')"!]
            [!CODE!]
            void [!"normalize-space(./RxTimestampNotification)"!](Can_HwHandleType Hoh, uint32 u32TimestampVal);[!CR!]
            #define Can_43_LLCE_RxTimestampNotification     ([!"normalize-space(RxTimestampNotification)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

    [!IF "node:exists(./TxTimestampNotification)"!]
        [!IF "(normalize-space(./TxTimestampNotification) != 'NULL_PTR')"!]
            [!CODE!]
            void [!"normalize-space(./TxTimestampNotification)"!](Can_HwHandleType Hoh, PduIdType CanTxPduId, uint32 u32TimestampVal);[!CR!]
            #define Can_43_LLCE_TxTimestampNotification     ([!"normalize-space(TxTimestampNotification)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

    [!IF "node:exists(./CanCustomRxFunction)"!]
        [!IF "(normalize-space(./CanCustomRxFunction) != 'NULL_PTR')"!]
            [!CODE!]
            boolean [!"normalize-space(./CanCustomRxFunction)"!](uint8 Hrh, Can_IdType CanId, uint8 CanDataLength, uint8* CanSduPtr, uint16 u16RxMbDescIdx);[!CR!]
            #define Can_43_LLCE_CustomRxCallback        ([!"normalize-space(CanCustomRxFunction)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

    [!IF "node:exists(./CanWriteCustomCallback)"!]
        [!IF "(normalize-space(./CanWriteCustomCallback) != 'NULL_PTR')"!]
            [!CODE!]
            void [!"normalize-space(./CanWriteCustomCallback)"!](Can_HwHandleType Hoh, PduIdType CanTxPduId, uint16 u16TxMbDescIdx);[!CR!]
            #define Can_43_LLCE_CustomWriteCallback        ([!"normalize-space(CanWriteCustomCallback)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

    [!IF "node:exists(./CanTxConfirmationCustomCallback)"!]
        [!IF "(normalize-space(./CanTxConfirmationCustomCallback) != 'NULL_PTR')"!]
            [!CODE!]
            void [!"normalize-space(./CanTxConfirmationCustomCallback)"!](Can_HwHandleType Hoh, PduIdType CanTxPduId);[!CR!]
            #define Can_43_LLCE_CustomTxConfirmationCallback        ([!"normalize-space(CanTxConfirmationCustomCallback)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

    [!IF "node:exists(./CanAuxFilterCallback)"!]
        [!IF "(normalize-space(./CanAuxFilterCallback) != 'NULL_PTR')"!]
            [!CODE!]
            void [!"normalize-space(./CanAuxFilterCallback)"!](uint16 u16FilterId, uint16 u16AuxSearchResult);[!CR!]
            #define Can_43_LLCE_CanAuxFilterCallback        ([!"normalize-space(CanAuxFilterCallback)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

    [!IF "node:exists(./BusOffNotification)"!]
        [!IF "(normalize-space(./BusOffNotification) != 'NULL_PTR')"!]
            [!CODE!]
            void [!"normalize-space(./BusOffNotification)"!](uint8 u8CanIfCtrlId);[!CR!]
            #define Can_43_LLCE_ControllerBusOffCallback        ([!"normalize-space(BusOffNotification)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]

[!ENDSELECT!]

[!SELECT "CanConfigSet/CanErrorReporting"!]
    [!IF "node:exists(./CanErrorNotif)"!]
        [!IF "(normalize-space(./CanErrorNotif) != 'NULL_PTR')"!]
            [!CODE!]
            void [!"normalize-space(./CanErrorNotif)"!](CanErrorNotificationType* error);[!CR!]
            #define Can_43_LLCE_ErrorNotificationCallback     ([!"normalize-space(CanErrorNotif)"!])
            [!ENDCODE!]
        [!ENDIF!]
    [!ENDIF!]
[!ENDSELECT!]


[!ENDINDENT!][!ENDNOCODE!]
#define CAN_43_LLCE_STOP_SEC_CODE
#include "Can_43_LLCE_MemMap.h"
#ifdef __cplusplus
}
#endif
#endif /* CAN_43_LLCE_EXTERNALS_H */
/** @} */
========== END FILE: generate_PC\include\Can_43_LLCE_Externals.h ==========

========== START FILE: generate_PC\src\Can_43_LLCE_Cfg.c ==========
/**
*   @file    Can_43_LLCE_Cfg.c
*   @version 1.0.10
*
*   @brief   AUTOSAR Can_43_LLCE - module interface
*   @details Configuration Structures for PreCompile.
*
*   @addtogroup CAN_LLCE
*   @{
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : LLCE
*   Dependencies         : 
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.10
*   Build Version        : S32_RTD_1_0_10_D2505_ASR_REL_4_4_REV_0000_20250516
*
*   Copyright 2020-2025 NXP
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
#include "Can_43_LLCE.h"
#include "Can_43_LLCE_IPW.h"

/**
* @file           Can_43_LLCE_Cfg.c
*/

[!AUTOSPACING!]

[!NOCODE!][!//
[!INCLUDE "Can_43_LLCE_VersionCheck_Src.m"!][!//
[!ENDNOCODE!][!//

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
#define CAN_43_LLCE_VENDOR_ID_PCCFG_C                   43
#define CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_PCCFG_C     4
#define CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_PCCFG_C     4
#define CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_PCCFG_C  0
#define CAN_SW_MAJOR_VERSION_PCCFG_C             1
#define CAN_SW_MINOR_VERSION_PCCFG_C             0
#define CAN_SW_PATCH_VERSION_PCCFG_C             10

/*==================================================================================================
*                                     FILE VERSION CHECKS
==================================================================================================*/

/* Check if current file and Can configuration header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID_PCCFG_C != CAN_43_LLCE_VENDOR_ID)
#error "Can_43_LLCE.h and Can_43_LLCE_Cfg.h have different vendor ids"
#endif
/* Check if current file and CAN header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_PCCFG_C != CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_PCCFG_C != CAN_43_LLCE_AR_RELEASE_MINOR_VERSION) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_PCCFG_C != CAN_43_LLCE_AR_RELEASE_REVISION_VERSION))
  #error "AutoSar Version Numbers of Can_43_LLCE_Cfg.c and Can_43_LLCE.h are different"
#endif
/* Check if current file and CAN header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_PCCFG_C != CAN_43_LLCE_SW_MAJOR_VERSION) || \
     (CAN_SW_MINOR_VERSION_PCCFG_C != CAN_43_LLCE_SW_MINOR_VERSION) || \
     (CAN_SW_PATCH_VERSION_PCCFG_C != CAN_43_LLCE_SW_PATCH_VERSION))
       #error "Software Version Numbers of Can_43_LLCE_Cfg.c and Can_43_LLCE.h are different"
#endif

/* Check if current file and Can_IPW configuration header file are of the same vendor */
#if (CAN_43_LLCE_VENDOR_ID_PCCFG_C  != CAN_IPW_VENDOR_ID_H)
#error "Can_43_LLCE.h and Can_43_LLCE_Cfg.h have different vendor ids"
#endif
/* Check if current file and CAN_IPW header file are of the same Autosar version */
#if ((CAN_43_LLCE_AR_RELEASE_MAJOR_VERSION_PCCFG_C != CAN_IPW_AR_RELEASE_MAJOR_VERSION_H) || \
     (CAN_43_LLCE_AR_RELEASE_MINOR_VERSION_PCCFG_C != CAN_IPW_AR_RELEASE_MINOR_VERSION_H) || \
     (CAN_43_LLCE_AR_RELEASE_REVISION_VERSION_PCCFG_C != CAN_IPW_AR_RELEASE_REVISION_VERSION_H))
  #error "AutoSar Version Numbers of Can_43_LLCE_Cfg.c and Can_43_LLCE.h are different"
#endif
/* Check if current file and CAN_IPW header file are of the same Software version */
#if ((CAN_SW_MAJOR_VERSION_PCCFG_C != CAN_IPW_SW_MAJOR_VERSION_H) || \
     (CAN_SW_MINOR_VERSION_PCCFG_C != CAN_IPW_SW_MINOR_VERSION_H) || \
     (CAN_SW_PATCH_VERSION_PCCFG_C != CAN_IPW_SW_PATCH_VERSION_H))
       #error "Software Version Numbers of Can_43_LLCE_Cfg.c and Can_43_LLCE.h are different"
#endif


/*==================================================================================================
*                                   GLOBAL FUNCTION PROTOTYPES
==================================================================================================*/
#define CAN_43_LLCE_START_SEC_CONFIG_DATA_UNSPECIFIED

#include "Can_43_LLCE_MemMap.h"


/*==================================================================================================
*                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL MACROS
==================================================================================================*/


/*==================================================================================================
*                                      LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      LOCAL VARIABLES
==================================================================================================*/
[!NOCODE!] [!/* This section is for global variables, local to this file */!]
    [!/*
    Sync-seg = is the segment that is used to synchronise the nodes on the bus. A bit edge (if there is a data change) is expected during this segment.
    Prop-Seg = is a period of time that is used to compensate for physical delay times within the network.
    Phase-seg1 = is a buffer segment that may be lengthened during resynchronisation to compensate for oscillator drift and positive phase differences between the oscillators of the transmitting and receiving node(s).
    Phase-seg2 = is a buffer segment that may be shortened during resynchronisation (described below) to compensate for negative phase errors and oscillator drift.

    The Sample point is always at the end of Phase-seg1 and is the time at which the bus level is read and interpreted as the value of the current bit.
    Whether transmitting or receiving, all nodes on a single CAN bus must have the same nominal bit time. Bit time is programmable at each node on a CAN Bus and is a function
        of the period of the oscillator local to each node, the value that is user-programmed into a Baud Rate Prescaler (BRP) register in the controller at each node, and the programmed number of time quanta per bit.
    When any node receives a data frame or a remote frame, it is necessary for the receiver to synchronise with the transmitter.
        1. The first is hard synchronisation and occurs at Start-of-Frame (SOF).
        2. For subsequent bits in any received frame, if a bit edge does not occur in the Sync-seg segment of bit time, resynchronisation is automatically invoked and will shorten or lengthen the current bit time depending
            on where the edge occurs. The maximum amount by which the bit time is lengthened or shortened is determined by a user-programmable number of time quanta known as the Synchronisation Jump Width (SJW).
    */!]
[!ENDNOCODE!]

/*==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                      GLOBAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                   LOCAL FUNCTION PROTOTYPES
==================================================================================================*/


/*==================================================================================================
*                                       LOCAL FUNCTIONS
==================================================================================================*/

/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/

#define CAN_43_LLCE_STOP_SEC_CONFIG_DATA_UNSPECIFIED

#include "Can_43_LLCE_MemMap.h"

#ifdef __cplusplus
}
#endif

/** @} */
========== END FILE: generate_PC\src\Can_43_LLCE_Cfg.c ==========

